<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Python中yield from的用法 · David's Blog</title><meta name="description" content="Python中yield from的用法 - David"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/imgs/favicon.ico"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/bootstrap-theme.css"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="/css/david.css"><link rel="search" type="application/opensearchdescription+xml" href="http://youchen.me/atom.xml" title="David's Blog"><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><script async type="text/javascript" src="//cdnjs.cloudflare.com/ajax//libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/typeahead.js"></script><script src="/js/search.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-89945048-1",'auto');ga('send','pageview');</script><script>(function(){var bp = document.createElement('script');var curProtocol = window.location.protocol.split(':')[0];if (curProtocol === 'https') {bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';}else {bp.src = 'http://push.zhanzhang.baidu.com/push.js';}var s = document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp, s);})();</script></head><body><div id="search"><div id="search-panel" class="search-panel"><div class="search-input"><input id="search-keywords" type="text" placeholder="搜索范围: 文章标题 日期 标签" class="form-control"><ul role="list" class="typeahead dropdown-menu"></ul></div><div class="search-close"><a id="search-close" href="#"><img src="/imgs/close-white.png"></a></div></div><div class="search-button"><a id="search-open" title="双击Ctrl快速打开搜索框"><img src="/imgs/search-black.png"></a></div></div><div class="apollo-wrap"><header class="apollo"><a href="/" class="logo-link"><img src="/imgs/favicon.png" alt="logo"></a><ul class="apollo-nav apollo-nav-list"><li class="apollo-nav-list-item"><a href="/" target="_self" class="apollo-nav-list-link">博客</a></li><li class="apollo-nav-list-item"><a href="/archives" target="_self" class="apollo-nav-list-link">归档</a></li><li class="apollo-nav-list-item"><a href="/categories" target="_self" class="apollo-nav-list-link">分类</a></li><li class="apollo-nav-list-item"><a href="https://github.com/Time1ess" target="_blank" class="apollo-nav-list-link">GITHUB</a></li><li class="apollo-nav-list-item"><a href="/atom.xml" target="_self" class="apollo-nav-list-link">RSS</a></li><li class="apollo-nav-list-item"><a href="/about" target="_self" class="apollo-nav-list-link">关于</a></li></ul></header><main class="apollo-container"><div class="post"><article class="post-block"><h1 class="post-title">Python中yield from的用法</h1><div class="post-info">时间: 2017年2月10日 13:22<a href="http://stackoverflow.com/a/26109157/331785" target="_blank" title="http://stackoverflow.com/a/26109157/331785" class="post-from">翻译 · 原文地址</a> 标签: <a class="tags" href="/tags/Python/">#Python</a>,<a class="tags" href="/tags/生成器/">#生成器</a>,<a class="tags" href="/tags/迭代器/">#迭代器</a></div><div class="post-content"><p>上一篇中谈到了迭代器、生成器以及<code>yield</code>的相关内容，而Python 3.3中，引入了在<a href="https://www.python.org/dev/peps/pep-0380/" target="_blank" rel="noopener">PEP 380 – Syntax for Delegating to a Subgenerator</a>中提出的<code>yield from</code>关键字，大幅简化了Python程序员在使用协程的时候的编程过程。</p>
<div class="tip"><br>本文内容除特殊说明外均基于Python 3.3以上版本。<br></div>

<p>首先需要声明的是，<code>yield from g</code>并不完全等于<code>for v in g: yield v</code>。而是应该将<code>yield from</code>看成为<strong>调用者(caller)</strong>和<strong>子生成器(sub-generator)</strong>之间提供了一种<strong>透明地双向通道</strong>。这包括了从子生成器中获取数据并向子生成器发送数据。</p>
<a id="more"></a>
<h4 id="使用yield-from从生成器中获得数据"><a href="#使用yield-from从生成器中获得数据" class="headerlink" title="使用yield from从生成器中获得数据"></a>使用<code>yield from</code>从生成器中获得数据</h4><p>考虑以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""A generator that fakes a read from a file, socket, etc."""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'&lt;&lt; %s'</span> % i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader_wrapper</span><span class="params">(g)</span>:</span></span><br><span class="line">    <span class="comment"># Manually iterate over data produced by reader</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> g:</span><br><span class="line">        <span class="keyword">yield</span> v</span><br><span class="line"></span><br><span class="line">wrap = reader_wrapper(reader())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> wrap:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Result</span></span><br><span class="line">&lt;&lt; <span class="number">0</span></span><br><span class="line">&lt;&lt; <span class="number">1</span></span><br><span class="line">&lt;&lt; <span class="number">2</span></span><br><span class="line">&lt;&lt; <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>我们其实可以使用<code>yield from</code>来代替亲自迭代<code>reader()</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader_wrapper</span><span class="params">(g)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> g</span><br></pre></td></tr></table></figure>
<p>这可以很好的工作而且减少了一行代码，而且可能使得我们的意图更加明确。</p>
<h4 id="使用yield-from向生成器发送数据"><a href="#使用yield-from向生成器发送数据" class="headerlink" title="使用yield from向生成器发送数据"></a>使用<code>yield from</code>向生成器发送数据</h4><p>现在让我们做些更有趣的。首先创建一个名叫<code>writer</code>的协程，它可以接收发送给它的数据并写给套接字、文件描述符等等:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""A coroutine that writes data *sent* to it to fd, socket, etc."""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        w = (<span class="keyword">yield</span>)</span><br><span class="line">        print(<span class="string">'&gt;&gt; '</span>, w)</span><br></pre></td></tr></table></figure>
<p>现在的问题是，包装函数<code>wrapper</code>如何处理将数据发送给<code>writer</code>，使得发送给包装函数的数据能够透明地发送给<code>writer()</code>？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer_wrapper</span><span class="params">(coro)</span>:</span></span><br><span class="line">    <span class="comment"># TBD</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">w = writer()</span><br><span class="line">wrap = writer_wrapper(w)</span><br><span class="line">wrap.send(<span class="keyword">None</span>)  <span class="comment"># "prime" the coroutine</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    wrap.send(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected result</span></span><br><span class="line">&gt;&gt;  <span class="number">0</span></span><br><span class="line">&gt;&gt;  <span class="number">1</span></span><br><span class="line">&gt;&gt;  <span class="number">2</span></span><br><span class="line">&gt;&gt;  <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>包装函数需要接受发送给它的数据(显而易见地)而且应该在循环结束的时候处理<code>StopIteration</code>异常。很明显只是完成<code>for x in coro: yield x</code>的话不能胜任这项工作。下面是一个能够工作的版本:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer_wrapper</span><span class="params">(coro)</span>:</span></span><br><span class="line">    coro.send(<span class="keyword">None</span>)  <span class="comment"># prime the coro</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            x = (<span class="keyword">yield</span>)  <span class="comment"># Capture the value that's sent</span></span><br><span class="line">            coro.send(x)  <span class="comment"># and pass it to the writer</span></span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>或者，我们可以这样做:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer_wrapper</span><span class="params">(coro)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> coro</span><br></pre></td></tr></table></figure>
<p>这节省了6行代码，而且使得代码更加清晰易读，最关键的是，它可行！</p>
<h4 id="使用yield-from向生成器发送数据——异常处理"><a href="#使用yield-from向生成器发送数据——异常处理" class="headerlink" title="使用yield from向生成器发送数据——异常处理"></a>使用<code>yield from</code>向生成器发送数据——异常处理</h4><p>让我们使这个例子更复杂点，假设我们的<code>writer</code>需要处理异常呢？比如<code>writer</code>捕获<code>SpamException</code>异常并且在遇到这个的时候打印<code>***</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpamException</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            w = (<span class="keyword">yield</span>)</span><br><span class="line">        <span class="keyword">except</span> SpamException:</span><br><span class="line">            print(<span class="string">'***'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'&gt;&gt; '</span>, w)</span><br></pre></td></tr></table></figure>
<p>如果我们使用原始版本的<code>writer_wrapper</code>，会怎样？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># writer_wrapper same as above</span></span><br><span class="line"></span><br><span class="line">w = writer()</span><br><span class="line">wrap = writer_wrapper(w)</span><br><span class="line">wrap.send(<span class="keyword">None</span>)  <span class="comment"># "prime" the coroutine</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'spam'</span>, <span class="number">4</span>]:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="string">'spam'</span>:</span><br><span class="line">        wrap.throw(SpamException)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        wrap.send(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected Result</span></span><br><span class="line">&gt;&gt;  <span class="number">0</span></span><br><span class="line">&gt;&gt;  <span class="number">1</span></span><br><span class="line">&gt;&gt;  <span class="number">2</span></span><br><span class="line">***</span><br><span class="line">&gt;&gt;  <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Actual Result</span></span><br><span class="line">&gt;&gt;  <span class="number">0</span></span><br><span class="line">&gt;&gt;  <span class="number">1</span></span><br><span class="line">&gt;&gt;  <span class="number">2</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ... redacted ...</span><br><span class="line">  File ... <span class="keyword">in</span> writer_wrapper</span><br><span class="line">    x = (<span class="keyword">yield</span>)</span><br><span class="line">__main__.SpamException</span><br></pre></td></tr></table></figure>
<p>不能正常工作的原因是因为<code>x = (yield)</code>抛出了这个异常所以导致了程序崩溃。要使得其正常工作的话，我们需要亲自捕获异常并将它传递给子生成器(<code>writer</code>)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer_wrapper</span><span class="params">(coro)</span>:</span></span><br><span class="line">    <span class="string">"""Works. Manually catches exceptions and throws them"""</span></span><br><span class="line">    coro.send(<span class="keyword">None</span>)  <span class="comment"># prime the coro</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                x = (<span class="keyword">yield</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:   <span class="comment"># This catches the SpamException</span></span><br><span class="line">                coro.throw(e)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                coro.send(x)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment"># Result</span></span><br><span class="line">&gt;&gt;  <span class="number">0</span></span><br><span class="line">&gt;&gt;  <span class="number">1</span></span><br><span class="line">&gt;&gt;  <span class="number">2</span></span><br><span class="line">***</span><br><span class="line">&gt;&gt;  <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>这可以正常工作，但是假设我们这样呢:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer_wrapper</span><span class="params">(coro)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> coro</span><br></pre></td></tr></table></figure>
<p><code>yield from</code>语句透明地将数据或者异常发送给子生成器。</p>
<p>以上仍然没有覆盖所有的特殊情况。如果外部生成器关闭了会怎样？子生成器返回了一个值会怎样(Python 3里生成器可以返回值)？返回值会怎样被处理？而<code>yield from</code>很好的处理了以上所有情况。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="tip"><br><code>yield from</code>是<strong>调用者</strong>和<strong>子生成器</strong>之间的一个<strong>双向透明通道</strong>。<br></div>

<p>更多关于<code>yield from</code>的内容可以阅读<a href="https://www.python.org/dev/peps/pep-0380/" target="_blank" rel="noopener">PEP 380 – Syntax for Delegating to a Subgenerator</a>。</p>
</div></article></div><script src="/js/comments.js"></script></main><footer class="apollo"><div class="paginator"><a href="/2017/03/12/Python-A-JD-spider-based-on-scrapy/" class="prev">上一篇</a><a href="/2017/02/10/Python-What-does-yield-do/" class="next">下一篇</a></div><div class="copyright"><p>© 2016 - 2018 <a href="http://youchen.me">David</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div></body></html>