{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/README.md","path":"README.md","modified":1,"renderable":0},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":1,"renderable":1},{"_id":"themes/apollo/source/css/bootstrap-theme.css","path":"css/bootstrap-theme.css","modified":1,"renderable":1},{"_id":"themes/apollo/source/css/bootstrap-theme.css.map","path":"css/bootstrap-theme.css.map","modified":1,"renderable":1},{"_id":"themes/apollo/source/css/david.css","path":"css/david.css","modified":1,"renderable":1},{"_id":"themes/apollo/source/font/glyphicons-halflings-regular.eot","path":"font/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/apollo/source/font/glyphicons-halflings-regular.svg","path":"font/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/apollo/source/font/glyphicons-halflings-regular.ttf","path":"font/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/apollo/source/font/glyphicons-halflings-regular.woff","path":"font/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":1,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":1,"renderable":1},{"_id":"themes/apollo/source/imgs/apple-touch-icon-precomposed.png","path":"imgs/apple-touch-icon-precomposed.png","modified":1,"renderable":1},{"_id":"themes/apollo/source/imgs/close-grey.png","path":"imgs/close-grey.png","modified":1,"renderable":1},{"_id":"themes/apollo/source/imgs/close-white.png","path":"imgs/close-white.png","modified":1,"renderable":1},{"_id":"themes/apollo/source/imgs/favicon.ico","path":"imgs/favicon.ico","modified":1,"renderable":1},{"_id":"themes/apollo/source/imgs/favicon.png","path":"imgs/favicon.png","modified":1,"renderable":1},{"_id":"themes/apollo/source/imgs/favicon@48x48.ico","path":"imgs/favicon@48x48.ico","modified":1,"renderable":1},{"_id":"themes/apollo/source/imgs/favicon@64x64.ico","path":"imgs/favicon@64x64.ico","modified":1,"renderable":1},{"_id":"themes/apollo/source/imgs/search-black.png","path":"imgs/search-black.png","modified":1,"renderable":1},{"_id":"themes/apollo/source/imgs/search.png","path":"imgs/search.png","modified":1,"renderable":1},{"_id":"themes/apollo/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/apollo/source/js/npm.js","path":"js/npm.js","modified":1,"renderable":1},{"_id":"themes/apollo/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/apollo/source/js/typeahead.js","path":"js/typeahead.js","modified":1,"renderable":1},{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":1,"renderable":1},{"_id":"themes/apollo/source/imgs/favicon@128x128.ico","path":"imgs/favicon@128x128.ico","modified":1,"renderable":1},{"_id":"themes/apollo/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/apollo/source/js/jquery-3.1.1.min.js","path":"js/jquery-3.1.1.min.js","modified":1,"renderable":1},{"_id":"themes/apollo/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"themes/apollo/source/css/bootstrap.css.map","path":"css/bootstrap.css.map","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"70b9cd04bc2854ceb4af0748f3cbd5ee7ff4aca9","modified":1525661932539},{"_id":"source/CNAME","hash":"2e5fe553c049c1b17e3f02f8a5dc1bffe42f2ec3","modified":1515804639839},{"_id":"source/README.md","hash":"616939b068d590a50a6f41ae97c85fe9176239a0","modified":1515804639839},{"_id":"themes/apollo/.DS_Store","hash":"d64f7cccad87a2aac2c94ef18f930b831b71e312","modified":1515333409761},{"_id":"themes/apollo/.gitignore","hash":"a006beea0877a0aa3610ee00e73f62cb1d45125b","modified":1483709573000},{"_id":"themes/apollo/LICENSE","hash":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1483709573000},{"_id":"themes/apollo/README.md","hash":"201c76d030a98578ed5a6ad5c766a7bde91c32d3","modified":1483709573000},{"_id":"themes/apollo/_config.yml","hash":"02bea8f29cd148cadab5498ed77789db656c377d","modified":1515372358488},{"_id":"themes/apollo/gulpfile.js","hash":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1483709573000},{"_id":"themes/apollo/package.json","hash":"eb1e76ec0b7ed6c6c7b2bd32b4f1e1bbe15800ca","modified":1483709573000},{"_id":"source/404/index.md","hash":"5c4912c4476a9ef7e4bef2828e3882312cb9a7aa","modified":1515804639839},{"_id":"source/_drafts/.DS_Store","hash":"d89aaf8e7b481d9777f070fe9f5c52561bcd8157","modified":1525656499480},{"_id":"source/_drafts/DDIA读书笔记3.md","hash":"fc70efaa16f6cb8067bef8a066b4f9af344111a4","modified":1519617473765},{"_id":"source/_drafts/DDIA读书笔记4.md","hash":"1e626db4102e3b66b4b2aa8759027aa4ea7ccad1","modified":1519617477733},{"_id":"source/_drafts/DDIA读书笔记5.md","hash":"bd035d02d48f7d7cb19720a3d46cad1cc47268fd","modified":1519617481462},{"_id":"source/_posts/.DS_Store","hash":"66dfde4013a6c84ccdffcb09c685509ef2cc3393","modified":1524363975429},{"_id":"source/_posts/Backslashes-in-Python-Regular-Expressions.md","hash":"fe55249e340f083cf0a443a7a2efb719c055acfd","modified":1515979113385},{"_id":"source/_posts/Bloom-Filter.md","hash":"319a8867231ec383c546b49adbd0d2424aa7d1ec","modified":1525661933473},{"_id":"source/_posts/CPP-Access-n-d-array-with-1-d-index-array.md","hash":"e226b5cf1dcb479784d9e334b5be91be98d993f3","modified":1515804639840},{"_id":"source/_posts/Consistent-Hashing.md","hash":"266282bec67f3d734114e94de43d36dc67aace5b","modified":1524366248119},{"_id":"source/_posts/DDIA读书笔记1.md","hash":"c8ae3a7cbdc131fdb47c25e11241569f4e2b9e23","modified":1519617296730},{"_id":"source/_posts/DDIA读书笔记2.md","hash":"91315783314de2dde00f3a0118412e9951049428","modified":1519617325665},{"_id":"source/_posts/Django中的select-related与prefetch-related.md","hash":"1265ea8e3c8426a16e49ef154ccab877dbdc896a","modified":1515808567312},{"_id":"source/_posts/New-to-asyncio.md","hash":"8d081dc4def9c5363b83cc9fe104df1e0ad04d30","modified":1515979095816},{"_id":"source/_posts/Python-A-JD-spider-based-on-scrapy.md","hash":"317a73c97962adf5da069fa081f6ba710c2474b4","modified":1515979084489},{"_id":"source/_posts/Python-Method Resolution Order.md","hash":"060b24baf8e2659105e3f335e97e932491bbabb3","modified":1515979065671},{"_id":"source/_posts/Python-What-does-yield-do.md","hash":"c9b4c9b0da0fb617bc6756f2b861aa7b7488850a","modified":1515804639866},{"_id":"source/_posts/Python-main-use-for-yield-from.md","hash":"d5b020a1b272c6f8145bd9d2e05e8f01ca57f800","modified":1515979043609},{"_id":"source/_posts/Python-metaclass.md","hash":"0d6834b7c26090de214254904d9ee9bbe6c9a19f","modified":1515979032817},{"_id":"source/_posts/Python-multiprocessing pool.md","hash":"c27cce968ab59dee4daaf3ebe95ec02b22a5db11","modified":1515804639867},{"_id":"source/_posts/Python-property access.md","hash":"b3ebfc823836b2eade515dc7a6507ec04ad8dd68","modified":1515804639868},{"_id":"source/_posts/Python-property and descriptor.md","hash":"f28ab89def4fdf3271b4c42462a2dc15be0a0e49","modified":1515804639868},{"_id":"source/_posts/Python-unit-testing-with-Mock.md","hash":"c83d914c511ddac0ddb80643cd8992fddae5e544","modified":1516005357832},{"_id":"source/_posts/kNN.md","hash":"a657a8bc7fa6876ab1223d397cba98739bea096c","modified":1515978998647},{"_id":"source/_posts/welcome.md","hash":"9e1e9b763c1890ff797df02e4f06d01418c8e488","modified":1515804639868},{"_id":"source/about/index.md","hash":"91e1766f955ac9cf142c1281f7b430531a3d7bf7","modified":1515804639876},{"_id":"source/_posts/论文笔记-全卷积神经网络-FCN.md","hash":"92e18a0ad5766e6e101bcb417e4524dff6150791","modified":1515978570882},{"_id":"source/categories/index.md","hash":"aea4ae4ecb3965ca422a93144c5b1dadbac22cb2","modified":1515804639876},{"_id":"themes/apollo/doc/doc-en.md","hash":"d6d9756b2085cdd8ee51eb5594427e2abf170e94","modified":1483709573000},{"_id":"themes/apollo/doc/doc-zh.md","hash":"d43c1f6bff66426744a2c6f031d19ff09cdeb2d1","modified":1483709573000},{"_id":"themes/apollo/languages/en.yml","hash":"40292f2a48e4e6361132033a47c516cb33127b6c","modified":1483709573000},{"_id":"themes/apollo/languages/zh-cn.yml","hash":"508f10c5fd97b72b254f697372e98f8b1c4aa1c7","modified":1483750932000},{"_id":"themes/apollo/layout/about.jade","hash":"c692300fae5e13c3c131abf2792d69750822132e","modified":1483757678000},{"_id":"themes/apollo/layout/.DS_Store","hash":"7ac4d19bb246057c593d1565c19e3c122d0d1a60","modified":1483777217000},{"_id":"themes/apollo/layout/archive.jade","hash":"62797414355bf4474092bc3a32726c8340820ffb","modified":1483709573000},{"_id":"themes/apollo/layout/blank.jade","hash":"8adc73039d0ea4c71e197b73dcfe3963921f74e1","modified":1483774316000},{"_id":"themes/apollo/layout/category.jade","hash":"c2c91ed81f8c18e14804b1602e2b85938cd7fcf0","modified":1483766228000},{"_id":"themes/apollo/layout/index.jade","hash":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1483709573000},{"_id":"themes/apollo/layout/post.jade","hash":"fb3cacd4269fbba180a2167a5b7bf5a1a7da7b5e","modified":1524362733359},{"_id":"themes/apollo/source/.DS_Store","hash":"62eb7a9759564fc5ab84b89d480ac50d9047965a","modified":1515333421500},{"_id":"source/_posts/Bloom-Filter/bloom_filter.png","hash":"32520b974af2f82a744fbbe0fc313024caa3f6a8","modified":1525661827235},{"_id":"source/_posts/Bloom-Filter/bloom_filter_error.png","hash":"025262666f1f9091452ad7a685ed79773d7f939b","modified":1525661827235},{"_id":"source/_posts/Bloom-Filter/bloom_filter_lookup.png","hash":"32515eafb6087405e4edb0e57293e98a744ce385","modified":1525661827236},{"_id":"source/_posts/CPP-Access-n-d-array-with-1-d-index-array/c_1d_array.png","hash":"d42f3ffbc14aeebc58a2946d476347ab3f12d717","modified":1515804639840},{"_id":"source/_posts/CPP-Access-n-d-array-with-1-d-index-array/c_2d_array.png","hash":"ab192451efa9d2081cf970b4d60d0e3318bfc4c6","modified":1515804639840},{"_id":"source/_posts/Consistent-Hashing/bias_on_hash_ring.png","hash":"a3ae295d658875eb6c0d5287352f56b816592601","modified":1524365386284},{"_id":"source/_posts/Consistent-Hashing/hash_ring.png","hash":"9c4125b120b6a47fc93fcd55a65ef65d5230c580","modified":1524363948150},{"_id":"source/_posts/Consistent-Hashing/pic_belong.png","hash":"cf7e258c80a2f2639e2822e57116c70778404c49","modified":1524364980772},{"_id":"source/_posts/Consistent-Hashing/pic_on_hash_ring.png","hash":"c128277c0beef9d6983c5c14cbb2bfa802b865f9","modified":1524364547029},{"_id":"source/_posts/Consistent-Hashing/pics_on_hash_ring.png","hash":"17aa6e2a39d0d63637d849feccfbb47fe88c19ae","modified":1524365266930},{"_id":"source/_posts/Consistent-Hashing/servers_on_hash_ring.png","hash":"5d12cf4dbe00441a630461215746d11f1917336b","modified":1524364269512},{"_id":"source/_posts/Consistent-Hashing/virtual_nodes_on_hash_ring.png","hash":"621e458de44b9592824609ab9abe2e4f4ae20201","modified":1524365623017},{"_id":"source/_posts/DDIA读书笔记1/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1519369312660},{"_id":"source/_posts/DDIA读书笔记2/twitter_sql.png","hash":"2c6dde6aebac615311b7474eaf4d67a1532b202e","modified":1519457257121},{"_id":"source/_posts/Django中的select-related与prefetch-related/.DS_Store","hash":"ea6b449ff7227da39e87e4ea17a2ae1fc79518c7","modified":1515761444451},{"_id":"source/_posts/Django中的select-related与prefetch-related/complex_raw_sel_pre_avg.png","hash":"c4499eac19b84557bb5b1dc35f27d5a3c8325eeb","modified":1515804639841},{"_id":"source/_posts/Django中的select-related与prefetch-related/complex_raw_sel_pre_tot.png","hash":"94b7a374b5c51383528d7833ba10717a175dda92","modified":1515804639841},{"_id":"source/_posts/Django中的select-related与prefetch-related/complex_sel_pre_avg.png","hash":"50e4e01888a9a47aa501a7ec5a66fdba43f48d90","modified":1515804639841},{"_id":"source/_posts/Django中的select-related与prefetch-related/complex_sel_pre_tot.png","hash":"3bcb2b5d4badcff080b77fda4b1e8ab55cb3f493","modified":1515804639841},{"_id":"source/_posts/Django中的select-related与prefetch-related/simple_raw_sel_pre_avg.png","hash":"a7e3f5864fa0f06d9a1c2d94146649dd6bf6403b","modified":1515804639846},{"_id":"source/_posts/Django中的select-related与prefetch-related/simple_raw_sel_pre_tot.png","hash":"17f2925c7e8c838ae1d5f27aeaa42ff670ea3b05","modified":1515804639846},{"_id":"source/_posts/Django中的select-related与prefetch-related/simple_sel_pre_avg.png","hash":"0c67dbf04c47585aa42e8777a1d3cba1b6ce403b","modified":1515804639846},{"_id":"source/_posts/Django中的select-related与prefetch-related/simple_sel_pre_tot.png","hash":"9f4236672e8f2f721df9f656c0194142d311af99","modified":1515804639847},{"_id":"source/_posts/New-to-asyncio/.DS_Store","hash":"2a04a346d45a4b18d56da82494a938ea5f4b80bd","modified":1494401428000},{"_id":"source/_posts/New-to-asyncio/async.png","hash":"32253d25f75a5e2ef5a7ae5884f8d41c00d6eb7c","modified":1515804639847},{"_id":"source/_posts/New-to-asyncio/block.png","hash":"080c6bf14666e63247fae14bf0ec94783c0c09cb","modified":1515804639847},{"_id":"source/_posts/New-to-asyncio/reactor-1.png","hash":"c999d400652a9138253b2ccf8d6d388e6bdbaed0","modified":1515804639847},{"_id":"source/_posts/New-to-asyncio/sync.png","hash":"f49c05a97e967fa6c40d28486022785a1522e99a","modified":1515804639848},{"_id":"source/_posts/New-to-asyncio/threaded.png","hash":"fb84bf6f4727fa978f6799ceebdbdf6c8bdb192c","modified":1515804639848},{"_id":"source/_posts/Python-A-JD-spider-based-on-scrapy/.DS_Store","hash":"252c422c75dce2b828aa28a0bb2aa1e24c92cfb6","modified":1489382506000},{"_id":"source/_posts/Python-Method Resolution Order/python_inheritance2.png","hash":"474a8f9951419ae361f6d8032a0990a2246af9b2","modified":1515804639865},{"_id":"source/_posts/Python-Method Resolution Order/python_inheritance.png","hash":"7c372a0e1aa11d6c94ca298ee51912d16df95e94","modified":1515804639865},{"_id":"source/_posts/Python-Method Resolution Order/python_inheritance3.png","hash":"7127882ee1c299ee84eff52e72543d2391197d70","modified":1515804639866},{"_id":"source/_posts/Python-Method Resolution Order/python_inheritance4.png","hash":"31ec1846b8f94a8d2304bb2d4e01c259994dc9e1","modified":1515804639866},{"_id":"source/_posts/论文笔记-全卷积神经网络-FCN/.DS_Store","hash":"983581fd2e6c337a5dddfa0b0d0a876d5a29ca15","modified":1500968919000},{"_id":"source/_posts/论文笔记-全卷积神经网络-FCN/fcns-validation.png","hash":"8c364ffa400bf74c946b0f227e55e2bed85686f6","modified":1515804639869},{"_id":"source/_posts/论文笔记-全卷积神经网络-FCN/ss-cat.png","hash":"79346138a3a35d8e5450b5d2e89fe2c57e895f41","modified":1515804639875},{"_id":"themes/apollo/layout/mixins/paginator.jade","hash":"f4ee2fb61a32e199b48cf93771749edc8a007391","modified":1483709573000},{"_id":"themes/apollo/layout/mixins/post.jade","hash":"8d1d851fceabae9bf3dae1a9cf3a0e890ff83575","modified":1483777411000},{"_id":"themes/apollo/layout/partial/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1483774293000},{"_id":"themes/apollo/layout/partial/comment.jade","hash":"3ab1cbe5edda8287bbec65f316da398334b8e905","modified":1515372364927},{"_id":"themes/apollo/layout/partial/copyright.jade","hash":"217f8b17054e5079f2d30bb7e2e4e36c0f2161b7","modified":1483709573000},{"_id":"themes/apollo/layout/partial/head.jade","hash":"f7242d3883bdbededfe07862e9cefb409a61da60","modified":1486629840000},{"_id":"themes/apollo/layout/partial/layout.jade","hash":"854679c63395bcfdac35bebc25d475d409aed0d7","modified":1494672170000},{"_id":"themes/apollo/layout/partial/nav.jade","hash":"619c85316952933d5082ef43a3536b7e041fdf56","modified":1483770114000},{"_id":"themes/apollo/layout/partial/scripts.jade","hash":"dfef44f3dc3a319c2e8b1d73172e8369ed63e899","modified":1515372312121},{"_id":"themes/apollo/layout/partial/search.jade","hash":"d385efb023476254eb648de8595ea4f755a817a8","modified":1515748117633},{"_id":"themes/apollo/source/css/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1483769735000},{"_id":"themes/apollo/source/css/apollo.css","hash":"f203a793207c4e386cdff3658ee08ecc5b1bad74","modified":1484614519000},{"_id":"themes/apollo/source/css/bootstrap-theme.css","hash":"537c9e08eb02ca46eb8ad0489ce2b65dcf929593","modified":1414609900000},{"_id":"themes/apollo/source/css/bootstrap-theme.css.map","hash":"65504b036ed1a76a6e25e93091ea4671ba068a10","modified":1414608943000},{"_id":"themes/apollo/source/css/david.css","hash":"3b973097dddc58568527513fd783a85a164ab7fd","modified":1483773958000},{"_id":"themes/apollo/source/font/glyphicons-halflings-regular.eot","hash":"f3a9a3b609133c3d21d6b42abbf7f43bd111df72","modified":1414450784000},{"_id":"themes/apollo/source/font/glyphicons-halflings-regular.svg","hash":"66b1fc67e37d01ee45ca75c4eefb144d2dbe98fa","modified":1414450784000},{"_id":"themes/apollo/source/font/glyphicons-halflings-regular.ttf","hash":"aafafdc09404c4aa4447d7e898a2183def9cc1b1","modified":1414450784000},{"_id":"themes/apollo/source/font/glyphicons-halflings-regular.woff","hash":"22037a3455914e5662fa51a596677bdb329e2c5c","modified":1414450784000},{"_id":"themes/apollo/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1483769154000},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1483769154000},{"_id":"themes/apollo/source/imgs/apple-touch-icon-precomposed.png","hash":"f70a472aea3b1b965498f3fa7660be78ce198a95","modified":1483673293000},{"_id":"themes/apollo/source/imgs/close-grey.png","hash":"43c1ed8203c3e4e5dc8baa0670fc54bf38913eaf","modified":1483618136000},{"_id":"themes/apollo/source/imgs/close-white.png","hash":"f7510651128e7dda22422dc0758101805acc224d","modified":1483767946000},{"_id":"themes/apollo/source/imgs/favicon.ico","hash":"43b7e8b7d40b3cbeb05cd3c429a3a17e0448e9f3","modified":1483673328000},{"_id":"themes/apollo/source/imgs/favicon.png","hash":"57259d995c639742ca12bcd93aa67181d88c057c","modified":1483673234000},{"_id":"themes/apollo/source/imgs/favicon@48x48.ico","hash":"f360dc5b0325884db3fad560019aaf784c85e851","modified":1483673342000},{"_id":"themes/apollo/source/imgs/favicon@64x64.ico","hash":"932255a72625de0bd8591a253866c57d414653bc","modified":1483673347000},{"_id":"themes/apollo/source/imgs/search-black.png","hash":"8d823d4f5b98d923292e3aee39f40ded6d7ea1f6","modified":1483767858000},{"_id":"themes/apollo/source/imgs/search.png","hash":"c090fcfd95c6fa91396c2c3cd51d409dacd60ea5","modified":1483625771000},{"_id":"themes/apollo/source/js/bootstrap.min.js","hash":"dfb8410ffc10a57d69b81620087c5a0b6027765a","modified":1414609900000},{"_id":"themes/apollo/source/js/npm.js","hash":"e2b7590d6ec1fdac66b01fdf66ae0879f53b1262","modified":1414608945000},{"_id":"themes/apollo/source/js/search.js","hash":"271c3a0d6b6959771d304e75f268c707ae2e4778","modified":1483773029000},{"_id":"themes/apollo/source/js/typeahead.js","hash":"dcfd0937db2981b0b01dec29afe354f6439e4afe","modified":1483769286000},{"_id":"themes/apollo/source/scss/apollo.scss","hash":"e0092f469264b55b25e0d441274f1c812147e7d1","modified":1483709573000},{"_id":"source/_posts/DDIA读书笔记2/requests.png","hash":"5ad90db9f0afe2c5961ca4e513fd00cd5f99fbfa","modified":1519457257121},{"_id":"source/_posts/Django中的select-related与prefetch-related/filter_id_lte_5.png","hash":"4eb14fbddffc3fc942c08d7a8cb848083ce8d2e3","modified":1515804639842},{"_id":"source/_posts/Django中的select-related与prefetch-related/get_with_prefetch_related.png","hash":"0071050e6115bffb98789abeafd2f620af40cc64","modified":1515804639844},{"_id":"source/_posts/Django中的select-related与prefetch-related/get_with_select_related.png","hash":"e4ee7721c23789c1057e182d10b648a9eff2f77c","modified":1515804639845},{"_id":"source/_posts/Django中的select-related与prefetch-related/get_without_select_related.png","hash":"9a3285c34e61873075977a866694e5f10f1230e5","modified":1515804639845},{"_id":"source/_posts/Python-A-JD-spider-based-on-scrapy/console_item_list_2.png","hash":"7a874996e471945f4a0de248ea9e0161ef12f03d","modified":1515804639860},{"_id":"source/_posts/Python-A-JD-spider-based-on-scrapy/item_detail_no_js.png","hash":"9d8fa7a236fbc67014bbb61afc8033078b83bcbb","modified":1515804639863},{"_id":"source/_posts/Python-multiprocessing pool/python_multiprocessing_pool.png","hash":"e0c9fbf97fa2462b8a72bd56dbcfdcaa5b67d390","modified":1515804639868},{"_id":"source/_posts/论文笔记-全卷积神经网络-FCN/fine-coarse.png","hash":"559dc259f5cedf6f8b1f9fa236e1e16c3c1e3f3f","modified":1515804639870},{"_id":"source/_posts/论文笔记-全卷积神经网络-FCN/finer-fcns.png","hash":"c06c0d7de241052ec389953f21b20e5bb745c792","modified":1515804639871},{"_id":"source/_posts/论文笔记-全卷积神经网络-FCN/padding_strides.gif","hash":"25bb19212056fe26e3f73e246a323768c1881fbf","modified":1515804639874},{"_id":"themes/apollo/source/imgs/favicon@128x128.ico","hash":"54e84931fef4b6d7522340ab395afb6e4ce5f9ff","modified":1483673355000},{"_id":"themes/apollo/source/js/bootstrap.js","hash":"1dadc506590e60b7869bc86d72fc11bd2ec7e47c","modified":1414609900000},{"_id":"themes/apollo/source/js/jquery-3.1.1.min.js","hash":"f647a6d37dc4ca055ced3cf64bbc1f490070acba","modified":1483769236000},{"_id":"source/_posts/Bloom-Filter/error_rate_fig.png","hash":"578d936b3b7f43de9a49c119492ee8b71646cc3b","modified":1525661827237},{"_id":"source/_posts/DDIA读书笔记1/Data_system_architecture_combining_several_components.png","hash":"3a2fd0b5746cdcf5c5fab44929b114c11dc1d99c","modified":1519355667629},{"_id":"source/_posts/Django中的select-related与prefetch-related/filter_id_lte_5_with_prefetch_related.png","hash":"f1bb53ea3b76bb70920234ebff8e9661f07fd644","modified":1515804639843},{"_id":"source/_posts/Python-A-JD-spider-based-on-scrapy/comments_json_2.png","hash":"dcacd48cccc9b98647cf5219202f588a8a579957","modified":1515804639854},{"_id":"source/_posts/论文笔记-全卷积神经网络-FCN/cat.png","hash":"2e3cac5bc69e3a24eaefe3387b3836c18b30064d","modified":1515804639869},{"_id":"themes/apollo/source/css/bootstrap.css","hash":"1ecb6e4f5cd6c55d900aab1a7ab8167888c44993","modified":1484614557000},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","hash":"d2f740a7d48349b7536777c795f82ab740836d0f","modified":1483709573000},{"_id":"themes/apollo/source/scss/_partial/base.scss","hash":"ae967b2049ecb9b8c4e139ecce32fd9fb5358ac5","modified":1483709573000},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","hash":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1483709573000},{"_id":"themes/apollo/source/scss/_partial/footer.scss","hash":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1483709573000},{"_id":"themes/apollo/source/scss/_partial/header.scss","hash":"153bde88bf8ffeae4ffd813d8cc694dd83d33d94","modified":1483709573000},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","hash":"6b5c59f3d2295944f934aee2c1156012a3306d5d","modified":1483709573000},{"_id":"themes/apollo/source/scss/_partial/mq.scss","hash":"fc5dda52cfbb10e27e2471e03f4606fb3d588225","modified":1483709573000},{"_id":"themes/apollo/source/scss/_partial/post.scss","hash":"912776a0eb7ad5a387b9aa929c857b6edd0c113e","modified":1483709573000},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1483709573000},{"_id":"source/_posts/Python-A-JD-spider-based-on-scrapy/console_network_after.png","hash":"a6259460d98d711bfa255eaf87f39459d959aea7","modified":1515804639861},{"_id":"source/_posts/Python-A-JD-spider-based-on-scrapy/console_network_before.png","hash":"4f1af0a03396c97859c89c50091ec1b40b7e3090","modified":1515804639862},{"_id":"source/_posts/Python-A-JD-spider-based-on-scrapy/item_shoe_comments_tab.png","hash":"566b000fdf7c95cb78b9c9ba6fc8c371e1002c8e","modified":1515804639865},{"_id":"source/_posts/论文笔记-全卷积神经网络-FCN/heatmap-cat.png","hash":"0f1b4fb24dbfb2baac50c6f38c185945007382f4","modified":1515804639873},{"_id":"themes/apollo/source/css/bootstrap.css.map","hash":"2b3cc170bdd62b736b8741b036cadba2c62952f8","modified":1414608943000},{"_id":"source/_posts/论文笔记-全卷积神经网络-FCN/results.png","hash":"e51b1ada1b2b5179c358ccfe678882f3fc3be337","modified":1515804639875},{"_id":"source/_posts/Python-A-JD-spider-based-on-scrapy/console_item_list.png","hash":"0ae425bc921e2f30704543ce004612868d48af51","modified":1515804639859},{"_id":"source/_posts/Python-A-JD-spider-based-on-scrapy/comments_json_1.png","hash":"7cf5a7280a484140703b1d978622115e216102a2","modified":1515804639853}],"Category":[{"name":"系统架构","_id":"cjgvnqmkb0004w628wndorn43"},{"name":"Python","_id":"cjgvnqmkw000iw628q5zkksbf"},{"name":"系统设计","_id":"cjgvnqml3000pw628hi2a7upl"},{"name":"CPP","_id":"cjgvnqml6000ww628o43pkuw6"},{"name":"Django","_id":"cjgvnqml90014w628seyno2av"},{"name":"机器学习","_id":"cjgvnqmlh001pw628yfeu44wx"},{"name":"其他","_id":"cjgvnqmlj001uw628ghr30xs2"}],"Data":[],"Page":[{"title":"404 Not Found: 该页面无法显示","toc":false,"comments":0,"layout":"blank","_content":"<div style=\"text-align:center\"><h1>404 Not Found: 该页面无法显示</h1></div>","source":"404/index.md","raw":"---\ntitle: \"404 Not Found: 该页面无法显示\"\ntoc: false\ncomments: false\npermalink: /404.html\nlayout: blank\n---\n<div style=\"text-align:center\"><h1>404 Not Found: 该页面无法显示</h1></div>","date":"2018-01-13T00:50:39.839Z","updated":"2018-01-13T00:50:39.839Z","path":"/404.html","_id":"cjgvnqmk70001w628g9nz6eww","content":"<div style=\"text-align:center\"><h1>404 Not Found: 该页面无法显示</h1></div>","site":{"data":{}},"excerpt":"","more":"<div style=\"text-align:center\"><h1>404 Not Found: 该页面无法显示</h1></div>"},{"title":"about","date":"2017-01-07T02:41:40.000Z","layout":"about","_content":"<h2>关于</h2>\n\n欢迎来到我的博客，我是一名计算机科学与技术方向的在读研究生，我会不定期分享一些自己在学习工作中遇到的问题的解决方法以及记录下我学习过程中的一些收获，Have fun!\n\n\n联系邮箱: youchen.du(at)gmail.com","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-01-07 10:41:40\nlayout: about\n---\n<h2>关于</h2>\n\n欢迎来到我的博客，我是一名计算机科学与技术方向的在读研究生，我会不定期分享一些自己在学习工作中遇到的问题的解决方法以及记录下我学习过程中的一些收获，Have fun!\n\n\n联系邮箱: youchen.du(at)gmail.com","updated":"2018-01-13T00:50:39.876Z","path":"about/index.html","comments":1,"_id":"cjgvnqmka0003w628repbfn31","content":"<h2>关于</h2>\n\n<p>欢迎来到我的博客，我是一名计算机科学与技术方向的在读研究生，我会不定期分享一些自己在学习工作中遇到的问题的解决方法以及记录下我学习过程中的一些收获，Have fun!</p>\n<p>联系邮箱: youchen.du(at)gmail.com</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>关于</h2>\n\n<p>欢迎来到我的博客，我是一名计算机科学与技术方向的在读研究生，我会不定期分享一些自己在学习工作中遇到的问题的解决方法以及记录下我学习过程中的一些收获，Have fun!</p>\n<p>联系邮箱: youchen.du(at)gmail.com</p>\n"},{"title":"类别","date":"2017-01-07T02:28:46.000Z","layout":"category","_content":"","source":"categories/index.md","raw":"---\ntitle: 类别\ndate: 2017-01-07 10:28:46\nlayout: category\n---","updated":"2018-01-13T00:50:39.876Z","path":"categories/index.html","comments":1,"_id":"cjgvnqmkd0006w6282p5yzv7w","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"DDIA读书笔记3-关系型模型与文档模型","_content":"","source":"_drafts/DDIA读书笔记3.md","raw":"---\ntitle: DDIA读书笔记3-关系型模型与文档模型\ntags: \ncategories: 系统架构\n---\n","slug":"DDIA读书笔记3","published":0,"date":"2018-02-26T03:54:11.317Z","updated":"2018-02-26T03:57:53.765Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgvnqmk30000w6280px2lyg5","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"DDIA读书笔记4-数据库查询语言","_content":"","source":"_drafts/DDIA读书笔记4.md","raw":"---\ntitle: DDIA读书笔记4-数据库查询语言\ntags: \ncategories: 系统架构\n---\n","slug":"DDIA读书笔记4","published":0,"date":"2018-02-26T03:54:14.406Z","updated":"2018-02-26T03:57:57.733Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgvnqmk90002w628hequnrxl","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"DDIA读书笔记5-图数据模型","_content":"","source":"_drafts/DDIA读书笔记5.md","raw":"---\ntitle: DDIA读书笔记5-图数据模型\ntags: \ncategories: 系统架构\n---\n","slug":"DDIA读书笔记5","published":0,"date":"2018-02-26T03:54:18.049Z","updated":"2018-02-26T03:58:01.462Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgvnqmkc0005w628y22s6xpj","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Python正则表达式中的反斜线","date":"2017-04-24T02:13:12.000Z","_content":"\n正则表达式是一个十分强大的工具，可以完成对字符串的模式匹配以及提取工作，在很多工程中都被广泛使用，但是我之前对于Python正则表达式模块`re`的使用都没有进行一些深入学习，对**原始字符串**之类的了解也比较浅显，之前有个同学问到我关于反斜线`\\`在正则中的一些表现的时候我也迷惑了，跟周围人讨论后上[StackOverflow](http://stackoverflow.com)问了一番，对这方面又多了一些了解，今天跟大家分享。\n\n<!-- more -->\n\n# 字符串中的反斜线`\\`\n\n我们知道，反斜线`\\`在字符串以及正则表达式中都是完成转义的工作，比如我有一个字符串s1:\n\n```Python\n>>> s1 = '123'\n```\n\n现在这个字符串s1内容为`123`，如果我想在字符串中保留一个单引号`'`，那么我可能的一种做法是使用双引号来包含内容，字符串s2:\n\n```Python\n>>> s2 = \"12'3\"\n```\n\nPython中的单引号`'`和双引号`'`其实都可以用来指示字符串，我们在此处使用双引号而不是单引号，原因是因为如果使用单引号Python解释器将会无法对这条语句进行正常解释，因为紧跟2之后的`'`被用来指示字符串结束，然而后面还剩下`3`这个字符，所以会引发`Syntax Error`:\n\n```Python\n>>> s = '12'3'\n  File \"<stdin>\", line 1\n    s = '12'3'\n            ^\nSyntaxError: invalid syntax\n```\n\n但是，只是使用语句中不包含的那种引号来指示字符串有时候是行不通的，因为有时候一个字符串可能同时包含单引号和双引号，比如字符串`1\"2'3`，所以这时候我们需要使用反斜线`\\`来对内容进行转义，因此对于字符串`1\"2'3`，我们可以采用如下表示:\n\n```Python\n>>> s = '1\"2\\'3'\n>>> s\n'1\"2\\'3'\n```\n\n注意我们并没有对字符串内容中的双引号`\"`进行转义，原因同上，字符串使用单引号指示的，因此双引号只会被认为是一个普通的字符。对于字符串内部的单引号`'`，为了让解释器得知它是一个普通字符，我们在其前面增加了一个反斜线`\\`，`\\'`组合起来的意思是对反斜线后面的字符`'`进行转义，可以这样理解，通过添加一个反斜线`\\`，对于`\\'`，你告诉了解释器:`不要按照普通的方式去解释这个字符'`，这样解释器就能正确地完成对该字符串的解释。\n\n有编程基础的读者应该会知道***转义***这一概念广泛存在于很多编程语言中，对`\\n`、`\\r`等字符应该有一定了解，类比前面的解释，`\\n`表示:`不要按照普通的方式去解释这个字符n`。\n\n进一步理解，假设我们从键盘输入了字符串:`abc\\nde`，一共输入了7个字符，这7个字符经过Python解释器解释，两个字符`\\`和`n`将会被转义成一个字符`\\n`，请特别注意这一点，虽然从表面上看是两个字符，但其实`\\n`是一个特殊的字符，这一点我们可以从以下代码看出:\n\n```Python\n>>> s = 'abc\\nde'\n>>> len(s)\n6\n>>> s[0]\n'a'\n>>> s[1]\n'b'\n>>> s[2]\n'c'\n>>> s[3]\n'\\n'\n>>> s[4]\n'd'\n>>> s[5]\n'e'\n>>> s[6]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: string index out of range\n```\n\n有了这些基础，下面我们进入到正则的部分。\n\n# 正则表达式中的反斜线`\\`\n\n因为有了Python解释器首先对字符串的转义，所以正则表达式模块`re`看到的和你输入的可能有所不同，比如，`\\n`在字符串层被转义成一个换行字符，然后`re`看到的是字符`\\n`而不是`\\`和`n`两个字符，看以下代码:\n\n```Python\n>>> import re\n>>> s = 'abc\\nde'\n>>> re.search('\\n', s)\n<_sre.SRE_Match object; span=(3, 4), match='\\n'>\n```\n\n以上代码首先定义了一个前文提到的字符串`s`，然后使用`re`模块的`search`方法搜索，然后要搜索的字符串是`\\n`，注意我们输入的是字符`\\`和字符`n`，然后经过Python解释器的解释实际在内存中的是一个`\\n`字符，因此`re`模块看到的是只有一个字符的字符串`\\n`，而不是两个字符，最后完成搜索。\n\n如果我们想匹配字符串`\\\\\\n`，应该怎么输入模式呢？，一种方法是:\n\n```Python\n>>> s = '\\\\\\n'\n>>> pat = re.compile('\\\\\\\\\\n')\n>>> pat.pattern\n'\\\\\\\\\\n'\n>>> pat.search(s)\n<_sre.SRE_Match object; span=(0, 2), match='\\\\\\n'>\n```\n\n对于字符串`\\\\\\n`，它的内容其实是一个普通的`\\`字符和一个换行字符`\\n`，对于我们输入的匹配模式`\\\\\\\\\\n`，首先经过Python解释器的字符串解释，变成了两个普通的`\\`字符和一个换行字符`\\n`，然后这些内容通过`re`模块的`compile`方法，`compile`方法发现有两个连续的`\\`符号，因此将在接下来的匹配中匹配一个普通的`\\`字符(请注意理解这一点)，而`\\n`字符将会匹配一个`\\n`字符，因此该模式的匹配内容是字符串中的一个普通`\\`字符和一个`\\n`字符。当然，写这么多反斜线显得十分麻烦，所以Python也提供了一种方便的方式，即***原始字符串***，其格式为在字符串前添加一个`r`字符:`r'content'`，通过这样的书写方式，Python解释器将使用不同的规则来解释转义(原始字符串不能以`\\`符号结尾)。因此上述模式可以简化为:\n\n\n```Python\n>>> s = '\\\\\\n'\n>>> pat = re.compile(r'\\\\\\n')\n>>> pat.pattern\n'\\\\\\\\\\\\n'\n>>> pat.search(s)\n<_sre.SRE_Match object; span=(0, 2), match='\\\\\\n'>\n```\n\n让我们再回到普通字符串，考虑以下代码:\n\n\n```Python\n>>> s = '\\\\\\n'\n>>> pat = re.compile('\\\\\\n')\n>>> pat.pattern\n'\\\\\\n'\n>>> pat.search(s)\n<_sre.SRE_Match object; span=(1, 2), match='\\n'>\n```\n\n对于模式`\\\\\\n`，经过Python解释器的解释将变成一个普通'\\`字符和一个换行字符`\\n`，`re`模块的`compile`方法将会看到以上解释结果，然后该模式组合起来就是:**匹配一个换行字符`\\n`的转义字符**，也就是对换行字符`\\n`进行转义！结果是:\n\n<div class=\"tip\">对一个转义字符进行转义将会得到其本身</div>\n\n相关连接:\n\n* [Regular expression operations](https://docs.python.org/3.6/library/re.html)\n* [Backslashes in Python Regular Expressions](http://stackoverflow.com/questions/33582162/backslashes-in-python-regular-expressions)","source":"_posts/Backslashes-in-Python-Regular-Expressions.md","raw":"---\ntitle: Python正则表达式中的反斜线\ndate: 2017-04-24 10:13:12\ntags: [Python,正则,re模块]\ncategories: Python\n---\n\n正则表达式是一个十分强大的工具，可以完成对字符串的模式匹配以及提取工作，在很多工程中都被广泛使用，但是我之前对于Python正则表达式模块`re`的使用都没有进行一些深入学习，对**原始字符串**之类的了解也比较浅显，之前有个同学问到我关于反斜线`\\`在正则中的一些表现的时候我也迷惑了，跟周围人讨论后上[StackOverflow](http://stackoverflow.com)问了一番，对这方面又多了一些了解，今天跟大家分享。\n\n<!-- more -->\n\n# 字符串中的反斜线`\\`\n\n我们知道，反斜线`\\`在字符串以及正则表达式中都是完成转义的工作，比如我有一个字符串s1:\n\n```Python\n>>> s1 = '123'\n```\n\n现在这个字符串s1内容为`123`，如果我想在字符串中保留一个单引号`'`，那么我可能的一种做法是使用双引号来包含内容，字符串s2:\n\n```Python\n>>> s2 = \"12'3\"\n```\n\nPython中的单引号`'`和双引号`'`其实都可以用来指示字符串，我们在此处使用双引号而不是单引号，原因是因为如果使用单引号Python解释器将会无法对这条语句进行正常解释，因为紧跟2之后的`'`被用来指示字符串结束，然而后面还剩下`3`这个字符，所以会引发`Syntax Error`:\n\n```Python\n>>> s = '12'3'\n  File \"<stdin>\", line 1\n    s = '12'3'\n            ^\nSyntaxError: invalid syntax\n```\n\n但是，只是使用语句中不包含的那种引号来指示字符串有时候是行不通的，因为有时候一个字符串可能同时包含单引号和双引号，比如字符串`1\"2'3`，所以这时候我们需要使用反斜线`\\`来对内容进行转义，因此对于字符串`1\"2'3`，我们可以采用如下表示:\n\n```Python\n>>> s = '1\"2\\'3'\n>>> s\n'1\"2\\'3'\n```\n\n注意我们并没有对字符串内容中的双引号`\"`进行转义，原因同上，字符串使用单引号指示的，因此双引号只会被认为是一个普通的字符。对于字符串内部的单引号`'`，为了让解释器得知它是一个普通字符，我们在其前面增加了一个反斜线`\\`，`\\'`组合起来的意思是对反斜线后面的字符`'`进行转义，可以这样理解，通过添加一个反斜线`\\`，对于`\\'`，你告诉了解释器:`不要按照普通的方式去解释这个字符'`，这样解释器就能正确地完成对该字符串的解释。\n\n有编程基础的读者应该会知道***转义***这一概念广泛存在于很多编程语言中，对`\\n`、`\\r`等字符应该有一定了解，类比前面的解释，`\\n`表示:`不要按照普通的方式去解释这个字符n`。\n\n进一步理解，假设我们从键盘输入了字符串:`abc\\nde`，一共输入了7个字符，这7个字符经过Python解释器解释，两个字符`\\`和`n`将会被转义成一个字符`\\n`，请特别注意这一点，虽然从表面上看是两个字符，但其实`\\n`是一个特殊的字符，这一点我们可以从以下代码看出:\n\n```Python\n>>> s = 'abc\\nde'\n>>> len(s)\n6\n>>> s[0]\n'a'\n>>> s[1]\n'b'\n>>> s[2]\n'c'\n>>> s[3]\n'\\n'\n>>> s[4]\n'd'\n>>> s[5]\n'e'\n>>> s[6]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: string index out of range\n```\n\n有了这些基础，下面我们进入到正则的部分。\n\n# 正则表达式中的反斜线`\\`\n\n因为有了Python解释器首先对字符串的转义，所以正则表达式模块`re`看到的和你输入的可能有所不同，比如，`\\n`在字符串层被转义成一个换行字符，然后`re`看到的是字符`\\n`而不是`\\`和`n`两个字符，看以下代码:\n\n```Python\n>>> import re\n>>> s = 'abc\\nde'\n>>> re.search('\\n', s)\n<_sre.SRE_Match object; span=(3, 4), match='\\n'>\n```\n\n以上代码首先定义了一个前文提到的字符串`s`，然后使用`re`模块的`search`方法搜索，然后要搜索的字符串是`\\n`，注意我们输入的是字符`\\`和字符`n`，然后经过Python解释器的解释实际在内存中的是一个`\\n`字符，因此`re`模块看到的是只有一个字符的字符串`\\n`，而不是两个字符，最后完成搜索。\n\n如果我们想匹配字符串`\\\\\\n`，应该怎么输入模式呢？，一种方法是:\n\n```Python\n>>> s = '\\\\\\n'\n>>> pat = re.compile('\\\\\\\\\\n')\n>>> pat.pattern\n'\\\\\\\\\\n'\n>>> pat.search(s)\n<_sre.SRE_Match object; span=(0, 2), match='\\\\\\n'>\n```\n\n对于字符串`\\\\\\n`，它的内容其实是一个普通的`\\`字符和一个换行字符`\\n`，对于我们输入的匹配模式`\\\\\\\\\\n`，首先经过Python解释器的字符串解释，变成了两个普通的`\\`字符和一个换行字符`\\n`，然后这些内容通过`re`模块的`compile`方法，`compile`方法发现有两个连续的`\\`符号，因此将在接下来的匹配中匹配一个普通的`\\`字符(请注意理解这一点)，而`\\n`字符将会匹配一个`\\n`字符，因此该模式的匹配内容是字符串中的一个普通`\\`字符和一个`\\n`字符。当然，写这么多反斜线显得十分麻烦，所以Python也提供了一种方便的方式，即***原始字符串***，其格式为在字符串前添加一个`r`字符:`r'content'`，通过这样的书写方式，Python解释器将使用不同的规则来解释转义(原始字符串不能以`\\`符号结尾)。因此上述模式可以简化为:\n\n\n```Python\n>>> s = '\\\\\\n'\n>>> pat = re.compile(r'\\\\\\n')\n>>> pat.pattern\n'\\\\\\\\\\\\n'\n>>> pat.search(s)\n<_sre.SRE_Match object; span=(0, 2), match='\\\\\\n'>\n```\n\n让我们再回到普通字符串，考虑以下代码:\n\n\n```Python\n>>> s = '\\\\\\n'\n>>> pat = re.compile('\\\\\\n')\n>>> pat.pattern\n'\\\\\\n'\n>>> pat.search(s)\n<_sre.SRE_Match object; span=(1, 2), match='\\n'>\n```\n\n对于模式`\\\\\\n`，经过Python解释器的解释将变成一个普通'\\`字符和一个换行字符`\\n`，`re`模块的`compile`方法将会看到以上解释结果，然后该模式组合起来就是:**匹配一个换行字符`\\n`的转义字符**，也就是对换行字符`\\n`进行转义！结果是:\n\n<div class=\"tip\">对一个转义字符进行转义将会得到其本身</div>\n\n相关连接:\n\n* [Regular expression operations](https://docs.python.org/3.6/library/re.html)\n* [Backslashes in Python Regular Expressions](http://stackoverflow.com/questions/33582162/backslashes-in-python-regular-expressions)","slug":"Backslashes-in-Python-Regular-Expressions","published":1,"updated":"2018-01-15T01:18:33.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgvnqmke0007w628j9gypif4","content":"<p>正则表达式是一个十分强大的工具，可以完成对字符串的模式匹配以及提取工作，在很多工程中都被广泛使用，但是我之前对于Python正则表达式模块<code>re</code>的使用都没有进行一些深入学习，对<strong>原始字符串</strong>之类的了解也比较浅显，之前有个同学问到我关于反斜线<code>\\</code>在正则中的一些表现的时候我也迷惑了，跟周围人讨论后上<a href=\"http://stackoverflow.com\" target=\"_blank\" rel=\"noopener\">StackOverflow</a>问了一番，对这方面又多了一些了解，今天跟大家分享。</p>\n<a id=\"more\"></a>\n<h1 id=\"字符串中的反斜线\"><a href=\"#字符串中的反斜线\" class=\"headerlink\" title=\"字符串中的反斜线\\\"></a>字符串中的反斜线<code>\\</code></h1><p>我们知道，反斜线<code>\\</code>在字符串以及正则表达式中都是完成转义的工作，比如我有一个字符串s1:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s1 = <span class=\"string\">'123'</span></span><br></pre></td></tr></table></figure>\n<p>现在这个字符串s1内容为<code>123</code>，如果我想在字符串中保留一个单引号<code>&#39;</code>，那么我可能的一种做法是使用双引号来包含内容，字符串s2:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s2 = <span class=\"string\">\"12'3\"</span></span><br></pre></td></tr></table></figure>\n<p>Python中的单引号<code>&#39;</code>和双引号<code>&#39;</code>其实都可以用来指示字符串，我们在此处使用双引号而不是单引号，原因是因为如果使用单引号Python解释器将会无法对这条语句进行正常解释，因为紧跟2之后的<code>&#39;</code>被用来指示字符串结束，然而后面还剩下<code>3</code>这个字符，所以会引发<code>Syntax Error</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = <span class=\"string\">'12'</span><span class=\"number\">3</span><span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">  File \"&lt;stdin&gt;\", line 1</span></span><br><span class=\"line\"><span class=\"string\">    s = '</span><span class=\"number\">12</span><span class=\"string\">'3'</span></span><br><span class=\"line\">            ^</span><br><span class=\"line\">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>\n<p>但是，只是使用语句中不包含的那种引号来指示字符串有时候是行不通的，因为有时候一个字符串可能同时包含单引号和双引号，比如字符串<code>1&quot;2&#39;3</code>，所以这时候我们需要使用反斜线<code>\\</code>来对内容进行转义，因此对于字符串<code>1&quot;2&#39;3</code>，我们可以采用如下表示:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = <span class=\"string\">'1\"2\\'3'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s</span><br><span class=\"line\"><span class=\"string\">'1\"2\\'3'</span></span><br></pre></td></tr></table></figure>\n<p>注意我们并没有对字符串内容中的双引号<code>&quot;</code>进行转义，原因同上，字符串使用单引号指示的，因此双引号只会被认为是一个普通的字符。对于字符串内部的单引号<code>&#39;</code>，为了让解释器得知它是一个普通字符，我们在其前面增加了一个反斜线<code>\\</code>，<code>\\&#39;</code>组合起来的意思是对反斜线后面的字符<code>&#39;</code>进行转义，可以这样理解，通过添加一个反斜线<code>\\</code>，对于<code>\\&#39;</code>，你告诉了解释器:<code>不要按照普通的方式去解释这个字符&#39;</code>，这样解释器就能正确地完成对该字符串的解释。</p>\n<p>有编程基础的读者应该会知道<strong><em>转义</em></strong>这一概念广泛存在于很多编程语言中，对<code>\\n</code>、<code>\\r</code>等字符应该有一定了解，类比前面的解释，<code>\\n</code>表示:<code>不要按照普通的方式去解释这个字符n</code>。</p>\n<p>进一步理解，假设我们从键盘输入了字符串:<code>abc\\nde</code>，一共输入了7个字符，这7个字符经过Python解释器解释，两个字符<code>\\</code>和<code>n</code>将会被转义成一个字符<code>\\n</code>，请特别注意这一点，虽然从表面上看是两个字符，但其实<code>\\n</code>是一个特殊的字符，这一点我们可以从以下代码看出:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = <span class=\"string\">'abc\\nde'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>len(s)</span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"string\">'a'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"string\">'b'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s[<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"string\">'c'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s[<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"string\">'\\n'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s[<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"string\">'d'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s[<span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"string\">'e'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s[<span class=\"number\">6</span>]</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">\"&lt;stdin&gt;\"</span>, line <span class=\"number\">1</span>, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">IndexError: string index out of range</span><br></pre></td></tr></table></figure>\n<p>有了这些基础，下面我们进入到正则的部分。</p>\n<h1 id=\"正则表达式中的反斜线\"><a href=\"#正则表达式中的反斜线\" class=\"headerlink\" title=\"正则表达式中的反斜线\\\"></a>正则表达式中的反斜线<code>\\</code></h1><p>因为有了Python解释器首先对字符串的转义，所以正则表达式模块<code>re</code>看到的和你输入的可能有所不同，比如，<code>\\n</code>在字符串层被转义成一个换行字符，然后<code>re</code>看到的是字符<code>\\n</code>而不是<code>\\</code>和<code>n</code>两个字符，看以下代码:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = <span class=\"string\">'abc\\nde'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.search(<span class=\"string\">'\\n'</span>, s)</span><br><span class=\"line\">&lt;_sre.SRE_Match object; span=(<span class=\"number\">3</span>, <span class=\"number\">4</span>), match=<span class=\"string\">'\\n'</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>以上代码首先定义了一个前文提到的字符串<code>s</code>，然后使用<code>re</code>模块的<code>search</code>方法搜索，然后要搜索的字符串是<code>\\n</code>，注意我们输入的是字符<code>\\</code>和字符<code>n</code>，然后经过Python解释器的解释实际在内存中的是一个<code>\\n</code>字符，因此<code>re</code>模块看到的是只有一个字符的字符串<code>\\n</code>，而不是两个字符，最后完成搜索。</p>\n<p>如果我们想匹配字符串<code>\\\\\\n</code>，应该怎么输入模式呢？，一种方法是:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = <span class=\"string\">'\\\\\\n'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pat = re.compile(<span class=\"string\">'\\\\\\\\\\n'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pat.pattern</span><br><span class=\"line\"><span class=\"string\">'\\\\\\\\\\n'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pat.search(s)</span><br><span class=\"line\">&lt;_sre.SRE_Match object; span=(<span class=\"number\">0</span>, <span class=\"number\">2</span>), match=<span class=\"string\">'\\\\\\n'</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>对于字符串<code>\\\\\\n</code>，它的内容其实是一个普通的<code>\\</code>字符和一个换行字符<code>\\n</code>，对于我们输入的匹配模式<code>\\\\\\\\\\n</code>，首先经过Python解释器的字符串解释，变成了两个普通的<code>\\</code>字符和一个换行字符<code>\\n</code>，然后这些内容通过<code>re</code>模块的<code>compile</code>方法，<code>compile</code>方法发现有两个连续的<code>\\</code>符号，因此将在接下来的匹配中匹配一个普通的<code>\\</code>字符(请注意理解这一点)，而<code>\\n</code>字符将会匹配一个<code>\\n</code>字符，因此该模式的匹配内容是字符串中的一个普通<code>\\</code>字符和一个<code>\\n</code>字符。当然，写这么多反斜线显得十分麻烦，所以Python也提供了一种方便的方式，即<strong><em>原始字符串</em></strong>，其格式为在字符串前添加一个<code>r</code>字符:<code>r&#39;content&#39;</code>，通过这样的书写方式，Python解释器将使用不同的规则来解释转义(原始字符串不能以<code>\\</code>符号结尾)。因此上述模式可以简化为:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = <span class=\"string\">'\\\\\\n'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pat = re.compile(<span class=\"string\">r'\\\\\\n'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pat.pattern</span><br><span class=\"line\"><span class=\"string\">'\\\\\\\\\\\\n'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pat.search(s)</span><br><span class=\"line\">&lt;_sre.SRE_Match object; span=(<span class=\"number\">0</span>, <span class=\"number\">2</span>), match=<span class=\"string\">'\\\\\\n'</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>让我们再回到普通字符串，考虑以下代码:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = <span class=\"string\">'\\\\\\n'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pat = re.compile(<span class=\"string\">'\\\\\\n'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pat.pattern</span><br><span class=\"line\"><span class=\"string\">'\\\\\\n'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pat.search(s)</span><br><span class=\"line\">&lt;_sre.SRE_Match object; span=(<span class=\"number\">1</span>, <span class=\"number\">2</span>), match=<span class=\"string\">'\\n'</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>对于模式<code>\\\\\\n</code>，经过Python解释器的解释将变成一个普通’`字符和一个换行字符<code>\\n</code>，<code>re</code>模块的<code>compile</code>方法将会看到以上解释结果，然后该模式组合起来就是:<strong>匹配一个换行字符<code>\\n</code>的转义字符</strong>，也就是对换行字符<code>\\n</code>进行转义！结果是:</p>\n<div class=\"tip\">对一个转义字符进行转义将会得到其本身</div>\n\n<p>相关连接:</p>\n<ul>\n<li><a href=\"https://docs.python.org/3.6/library/re.html\" target=\"_blank\" rel=\"noopener\">Regular expression operations</a></li>\n<li><a href=\"http://stackoverflow.com/questions/33582162/backslashes-in-python-regular-expressions\" target=\"_blank\" rel=\"noopener\">Backslashes in Python Regular Expressions</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>正则表达式是一个十分强大的工具，可以完成对字符串的模式匹配以及提取工作，在很多工程中都被广泛使用，但是我之前对于Python正则表达式模块<code>re</code>的使用都没有进行一些深入学习，对<strong>原始字符串</strong>之类的了解也比较浅显，之前有个同学问到我关于反斜线<code>\\</code>在正则中的一些表现的时候我也迷惑了，跟周围人讨论后上<a href=\"http://stackoverflow.com\" target=\"_blank\" rel=\"noopener\">StackOverflow</a>问了一番，对这方面又多了一些了解，今天跟大家分享。</p>","more":"<h1 id=\"字符串中的反斜线\"><a href=\"#字符串中的反斜线\" class=\"headerlink\" title=\"字符串中的反斜线\\\"></a>字符串中的反斜线<code>\\</code></h1><p>我们知道，反斜线<code>\\</code>在字符串以及正则表达式中都是完成转义的工作，比如我有一个字符串s1:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s1 = <span class=\"string\">'123'</span></span><br></pre></td></tr></table></figure>\n<p>现在这个字符串s1内容为<code>123</code>，如果我想在字符串中保留一个单引号<code>&#39;</code>，那么我可能的一种做法是使用双引号来包含内容，字符串s2:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s2 = <span class=\"string\">\"12'3\"</span></span><br></pre></td></tr></table></figure>\n<p>Python中的单引号<code>&#39;</code>和双引号<code>&#39;</code>其实都可以用来指示字符串，我们在此处使用双引号而不是单引号，原因是因为如果使用单引号Python解释器将会无法对这条语句进行正常解释，因为紧跟2之后的<code>&#39;</code>被用来指示字符串结束，然而后面还剩下<code>3</code>这个字符，所以会引发<code>Syntax Error</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = <span class=\"string\">'12'</span><span class=\"number\">3</span><span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">  File \"&lt;stdin&gt;\", line 1</span></span><br><span class=\"line\"><span class=\"string\">    s = '</span><span class=\"number\">12</span><span class=\"string\">'3'</span></span><br><span class=\"line\">            ^</span><br><span class=\"line\">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>\n<p>但是，只是使用语句中不包含的那种引号来指示字符串有时候是行不通的，因为有时候一个字符串可能同时包含单引号和双引号，比如字符串<code>1&quot;2&#39;3</code>，所以这时候我们需要使用反斜线<code>\\</code>来对内容进行转义，因此对于字符串<code>1&quot;2&#39;3</code>，我们可以采用如下表示:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = <span class=\"string\">'1\"2\\'3'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s</span><br><span class=\"line\"><span class=\"string\">'1\"2\\'3'</span></span><br></pre></td></tr></table></figure>\n<p>注意我们并没有对字符串内容中的双引号<code>&quot;</code>进行转义，原因同上，字符串使用单引号指示的，因此双引号只会被认为是一个普通的字符。对于字符串内部的单引号<code>&#39;</code>，为了让解释器得知它是一个普通字符，我们在其前面增加了一个反斜线<code>\\</code>，<code>\\&#39;</code>组合起来的意思是对反斜线后面的字符<code>&#39;</code>进行转义，可以这样理解，通过添加一个反斜线<code>\\</code>，对于<code>\\&#39;</code>，你告诉了解释器:<code>不要按照普通的方式去解释这个字符&#39;</code>，这样解释器就能正确地完成对该字符串的解释。</p>\n<p>有编程基础的读者应该会知道<strong><em>转义</em></strong>这一概念广泛存在于很多编程语言中，对<code>\\n</code>、<code>\\r</code>等字符应该有一定了解，类比前面的解释，<code>\\n</code>表示:<code>不要按照普通的方式去解释这个字符n</code>。</p>\n<p>进一步理解，假设我们从键盘输入了字符串:<code>abc\\nde</code>，一共输入了7个字符，这7个字符经过Python解释器解释，两个字符<code>\\</code>和<code>n</code>将会被转义成一个字符<code>\\n</code>，请特别注意这一点，虽然从表面上看是两个字符，但其实<code>\\n</code>是一个特殊的字符，这一点我们可以从以下代码看出:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = <span class=\"string\">'abc\\nde'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>len(s)</span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"string\">'a'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"string\">'b'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s[<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"string\">'c'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s[<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"string\">'\\n'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s[<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"string\">'d'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s[<span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"string\">'e'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s[<span class=\"number\">6</span>]</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">\"&lt;stdin&gt;\"</span>, line <span class=\"number\">1</span>, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">IndexError: string index out of range</span><br></pre></td></tr></table></figure>\n<p>有了这些基础，下面我们进入到正则的部分。</p>\n<h1 id=\"正则表达式中的反斜线\"><a href=\"#正则表达式中的反斜线\" class=\"headerlink\" title=\"正则表达式中的反斜线\\\"></a>正则表达式中的反斜线<code>\\</code></h1><p>因为有了Python解释器首先对字符串的转义，所以正则表达式模块<code>re</code>看到的和你输入的可能有所不同，比如，<code>\\n</code>在字符串层被转义成一个换行字符，然后<code>re</code>看到的是字符<code>\\n</code>而不是<code>\\</code>和<code>n</code>两个字符，看以下代码:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = <span class=\"string\">'abc\\nde'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>re.search(<span class=\"string\">'\\n'</span>, s)</span><br><span class=\"line\">&lt;_sre.SRE_Match object; span=(<span class=\"number\">3</span>, <span class=\"number\">4</span>), match=<span class=\"string\">'\\n'</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>以上代码首先定义了一个前文提到的字符串<code>s</code>，然后使用<code>re</code>模块的<code>search</code>方法搜索，然后要搜索的字符串是<code>\\n</code>，注意我们输入的是字符<code>\\</code>和字符<code>n</code>，然后经过Python解释器的解释实际在内存中的是一个<code>\\n</code>字符，因此<code>re</code>模块看到的是只有一个字符的字符串<code>\\n</code>，而不是两个字符，最后完成搜索。</p>\n<p>如果我们想匹配字符串<code>\\\\\\n</code>，应该怎么输入模式呢？，一种方法是:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = <span class=\"string\">'\\\\\\n'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pat = re.compile(<span class=\"string\">'\\\\\\\\\\n'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pat.pattern</span><br><span class=\"line\"><span class=\"string\">'\\\\\\\\\\n'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pat.search(s)</span><br><span class=\"line\">&lt;_sre.SRE_Match object; span=(<span class=\"number\">0</span>, <span class=\"number\">2</span>), match=<span class=\"string\">'\\\\\\n'</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>对于字符串<code>\\\\\\n</code>，它的内容其实是一个普通的<code>\\</code>字符和一个换行字符<code>\\n</code>，对于我们输入的匹配模式<code>\\\\\\\\\\n</code>，首先经过Python解释器的字符串解释，变成了两个普通的<code>\\</code>字符和一个换行字符<code>\\n</code>，然后这些内容通过<code>re</code>模块的<code>compile</code>方法，<code>compile</code>方法发现有两个连续的<code>\\</code>符号，因此将在接下来的匹配中匹配一个普通的<code>\\</code>字符(请注意理解这一点)，而<code>\\n</code>字符将会匹配一个<code>\\n</code>字符，因此该模式的匹配内容是字符串中的一个普通<code>\\</code>字符和一个<code>\\n</code>字符。当然，写这么多反斜线显得十分麻烦，所以Python也提供了一种方便的方式，即<strong><em>原始字符串</em></strong>，其格式为在字符串前添加一个<code>r</code>字符:<code>r&#39;content&#39;</code>，通过这样的书写方式，Python解释器将使用不同的规则来解释转义(原始字符串不能以<code>\\</code>符号结尾)。因此上述模式可以简化为:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = <span class=\"string\">'\\\\\\n'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pat = re.compile(<span class=\"string\">r'\\\\\\n'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pat.pattern</span><br><span class=\"line\"><span class=\"string\">'\\\\\\\\\\\\n'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pat.search(s)</span><br><span class=\"line\">&lt;_sre.SRE_Match object; span=(<span class=\"number\">0</span>, <span class=\"number\">2</span>), match=<span class=\"string\">'\\\\\\n'</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>让我们再回到普通字符串，考虑以下代码:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>s = <span class=\"string\">'\\\\\\n'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pat = re.compile(<span class=\"string\">'\\\\\\n'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pat.pattern</span><br><span class=\"line\"><span class=\"string\">'\\\\\\n'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>pat.search(s)</span><br><span class=\"line\">&lt;_sre.SRE_Match object; span=(<span class=\"number\">1</span>, <span class=\"number\">2</span>), match=<span class=\"string\">'\\n'</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>对于模式<code>\\\\\\n</code>，经过Python解释器的解释将变成一个普通’`字符和一个换行字符<code>\\n</code>，<code>re</code>模块的<code>compile</code>方法将会看到以上解释结果，然后该模式组合起来就是:<strong>匹配一个换行字符<code>\\n</code>的转义字符</strong>，也就是对换行字符<code>\\n</code>进行转义！结果是:</p>\n<div class=\"tip\">对一个转义字符进行转义将会得到其本身</div>\n\n<p>相关连接:</p>\n<ul>\n<li><a href=\"https://docs.python.org/3.6/library/re.html\" target=\"_blank\" rel=\"noopener\">Regular expression operations</a></li>\n<li><a href=\"http://stackoverflow.com/questions/33582162/backslashes-in-python-regular-expressions\" target=\"_blank\" rel=\"noopener\">Backslashes in Python Regular Expressions</a></li>\n</ul>"},{"title":"海量数据判重之布隆过滤器","date":"2018-05-07T02:57:07.000Z","_content":"\n\n查询一个对象是否存在于一个集合中，在很多任务中都是十分重要的一部分，常见的使用场景主要是海量数据的判重等。布隆过滤器(Bloom Filter)便是解决此类问题的理想工具之一。\n\n<!-- more -->\n\n我们知道，可以使用哈希表来完成O(1)时间查询一个对象是否存在于一个集合中，但是传统的哈希虽然时间效率很高，但是因为采用开放寻址法来接触哈希冲突，因此为了保证查询时间效率，所以空间效率较低，一般只能达到不到50%，假设我们有N=10,000,000条数据需要进行判重的话，那么整个空间消耗是比较大的，更不用说在日常海量数据情况下的表现了，而布隆过滤器就是一个在容忍一定假正率的情况下，时间复杂度达到O(1)，空间效率很高的一个判重工具。\n\n# 插入原理\n\n布隆过滤器的插入原理跟普通的哈希过程很相似，不同与普通的哈希算法只使用一个哈希函数，布隆过滤器使用了多个**互不相关**的哈希函数来完成哈希过程，如下图所示。\n\n![](bloom_filter.png)\n\n对于任一元素，我们使用了K（此处K=3）个哈希函数来分别其哈希值，然后将该哈希值对M（此处m=24，布隆过滤器容量大小）取模，得到3个位置，然后将该位置置为1，需要注意的是，布隆过滤器每个位置只需要判断`True`或者`False`，因此只需要一个bit即可表示，因此最后该元素对应的3个位置将被置为`True`。\n\n# 查找原理\n\n要判断一个元素是否已经存在，这一过程跟插入很相似，也是计算出多个位置，只有当这些位置都为`0b1`的时候，那么该元素才已经存在，否则该元素不存在，如下图所示。\n\n![](bloom_filter_lookup.png)\n\n对于x，因为x已经在之前将其对应的三个位置设置为了`True`，因此在本次查找中可以发现其对应的位置全部为`True`，因此该元素存在。对于z，我们发现其有两个位置不为`True`，因此该元素肯定不存在。\n\n# 伪码描述\n\n我们可以使用伪码来描述插入与查找过程。\n\n## 插入\n\n```\n# x: Target value\n# m: Capacity\n# bits: Bloom filter bits storage\n# hash_funcs: Distinct hash functions\n\ndef insert(x):\n    for hash_func in hash_funcs:\n        p = hash_func(x) % m\n        bits[p] = True\n```\n## 查找\n\n```\ndef lookup(x):\n    found = True\n    for hash_func in hash_funcs:\n        p = hash_func(x) % m\n        found = found && bits[p]\n    return found\n```\n\n# 错误率\n\n![](bloom_filter_error.png)\n\n细心的读者可能已经发现了，在前文查找z的时候，我们有一个哈希函数结果对应的位置是元素y的某个位置，那么在极端情况下，可能一个从来没有见过的元素被误认为已经见过了，如上图中的h，其对应的K个位置都被其他元素设置成了`True`，这是我们通常所说的`False Positive`，即假正，那么其对应的概率即假正率到底有多大呢？我们可以通过概率的知识来进行定量的计算。\n\n**已知**：总共有m个bit，k个哈希函数（哈希函数插入每个位置概率相等），已经插入n个元素\n**求**：对一个新元素，其被错误识别为已插入的概率\n\n插入第一个元素时，一个哈希函数将某一位设置成`True`的概率是\n\n$$ \\frac{1}{m} $$\n\n那么该位不被设置成`True`的概率是\n\n$$ 1 - \\frac{1}{m} $$\n\n在插入k个哈希位置之后，即完成一个元素的插入之后，该位不被设置成`True`的概率是\n\n$$ {(1 - \\frac{1}{m})}^k $$\n\n在完成n个元素的插入之后，该位不被设置成`True`的概率是\n\n$$ {(1 - \\frac{1}{m})}^{nk} $$\n\n那么该位被设置成`True`的概率是\n\n$$ 1 - {(1 - \\frac{1}{m})}^{nk} $$\n\n对一个新的元素，其被错误识别为已存在可以等价于其k个位置都被设置为了`True`，其概率为\n\n$$ \\varepsilon \\approx {(1 - {(1 - \\frac{1}{m})}^{nk})}^k $$\n\n我们通过极限公式\n\n$$ \\lim\\limits_{n\\to\\infty}{(1+\\dfrac {1}{n})^n} = e $$\n\n将其转化为\n\n$$ \\varepsilon \\approx {(1 - {(1 - e^{-\\frac{nk}{m}})})}^k $$\n\n我们根据以上公式可以发现，最后假正率跟n/m和k有关，基于此，我们可以使用不同组合来计算假正率，结果如下表所示。\n\n|m/n|K = 1|K = 2|K = 3|K = 4|K = 5|K = 6|K = 7|K = 8|K = 9|K = 10|K = 11|K = 12|\n|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n|2|0.3934693|0.3995764|0.4688617|0.5589732|0.6516469|0.7360810|0.8068326|0.8625315|0.9043485|0.9346272|0.9559529|0.9706572|\n|3|0.2834687|0.2367629|0.2525805|0.2940775|0.3511052|0.4179135|0.4896758|0.5620731|0.6315219|0.6954066|0.7521399|0.8010552|\n|4|0.2211992|0.1548181|0.1468916|0.1596613|0.1849078|0.2198313|0.2628405|0.3124510|0.3669978|0.4246437|0.4835067|0.5418153|\n|5|0.1812692|0.1086889|0.0918488|0.0919536|0.1009252|0.1164499|0.1377817|0.1646166|0.1966885|0.2336024|0.2747749|0.3194357|\n|6|0.1535183|0.0803545|0.0609162|0.0560567|0.0577811|0.0637969|0.0734099|0.0864816|0.1030705|0.1232749|0.1471486|0.1746517|\n|7|0.1331221|0.0617635|0.0423483|0.0358990|0.0346578|0.0363787|0.0403273|0.0463077|0.0543501|0.0645847|0.0771784|0.0922953|\n|8|0.1175031|0.0489291|0.0305794|0.0239687|0.0216792|0.0215771|0.0229297|0.0254917|0.0292244|0.0341909|0.0405091|0.0483258|\n|9|0.1051607|0.0397056|0.0227780|0.0165770|0.0140703|0.0132721|0.0134892|0.0144631|0.0161138|0.0184491|0.0215259|0.0254323|\n|10|0.0951626|0.0328585|0.0174106|0.0118133|0.0094309|0.0084362|0.0081937|0.0084555|0.0091270|0.0101859|0.0116495|0.0135606|\n|11|0.0868993|0.0276381|0.0136005|0.0086373|0.0065018|0.0055222|0.0051259|0.0050864|0.0053098|0.0057616|0.0064387|0.0073573|\n|12|0.0799556|0.0235679|0.0108231|0.0064568|0.0045945|0.0037108|0.0032939|0.0031424|0.0031695|0.0033387|0.0036380|0.0040700|\n|13|0.0740389|0.0203336|0.0087517|0.0049210|0.0033183|0.0025527|0.0021689|0.0019897|0.0019384|0.0019804|0.0021013|0.0022975|\n|14|0.0689372|0.0177215|0.0071759|0.0038147|0.0024433|0.0017934|0.0014601|0.0012887|0.0012127|0.0012012|0.0012399|0.0013234|\n|15|0.0644930|0.0155817|0.0059562|0.0030019|0.0018303|0.0012840|0.0010028|0.0008523|0.0007749|0.0007440|0.0007468|0.0007775|\n|16|0.0605869|0.0138070|0.0049977|0.0023941|0.0013925|0.0009351|0.0007015|0.0005745|0.0005049|0.0004700|0.0004587|0.0004656|\n|17|0.0571269|0.0123188|0.0042340|0.0019323|0.0010742|0.0006916|0.0004990|0.0003941|0.0003350|0.0003024|0.0002870|0.0002839|\n|18|0.0540405|0.0110588|0.0036181|0.0015765|0.0008392|0.0005188|0.0003604|0.0002748|0.0002260|0.0001980|0.0001827|0.0001761|\n|19|0.0512705|0.0099825|0.0031160|0.0012989|0.0006632|0.0003942|0.0002640|0.0001945|0.0001549|0.0001317|0.0001182|0.0001111|\n|20|0.0487706|0.0090559|0.0027026|0.0010797|0.0005296|0.0003031|0.0001959|0.0001396|0.0001077|0.0000889|0.0000777|0.0000712|\n|21|0.0465030|0.0082526|0.0023591|0.0009048|0.0004269|0.0002356|0.0001471|0.0001014|0.0000759|0.0000609|0.0000518|0.0000463|\n|22|0.0444370|0.0075515|0.0020714|0.0007639|0.0003473|0.0001850|0.0001117|0.0000746|0.0000542|0.0000423|0.0000350|0.0000305|\n|23|0.0425466|0.0069361|0.0018287|0.0006493|0.0002847|0.0001466|0.0000856|0.0000555|0.0000392|0.0000297|0.0000240|0.0000204|\n|24|0.0408105|0.0063929|0.0016224|0.0005554|0.0002352|0.0001171|0.0000663|0.0000417|0.0000286|0.0000211|0.0000166|0.0000138|\n|25|0.0392106|0.0059111|0.0014459|0.0004779|0.0001957|0.0000944|0.0000518|0.0000316|0.0000211|0.0000152|0.0000116|0.0000094|\n|26|0.0377313|0.0054818|0.0012942|0.0004135|0.0001639|0.0000766|0.0000408|0.0000242|0.0000157|0.0000110|0.0000082|0.0000065|\n|27|0.0363596|0.0050975|0.0011629|0.0003595|0.0001381|0.0000626|0.0000324|0.0000187|0.0000118|0.0000081|0.0000059|0.0000046|\n|28|0.0350841|0.0047523|0.0010489|0.0003141|0.0001170|0.0000515|0.0000259|0.0000146|0.0000090|0.0000060|0.0000043|0.0000032|\n|29|0.0338950|0.0044410|0.0009492|0.0002756|0.0000996|0.0000426|0.0000209|0.0000114|0.0000069|0.0000045|0.0000031|0.0000023|\n|30|0.0327839|0.0041593|0.0008618|0.0002428|0.0000853|0.0000355|0.0000169|0.0000090|0.0000053|0.0000034|0.0000023|0.0000016|\n|31|0.0317433|0.0039036|0.0007848|0.0002147|0.0000733|0.0000297|0.0000138|0.0000072|0.0000041|0.0000025|0.0000017|0.0000012|\n|32|0.0307668|0.0036708|0.0007167|0.0001906|0.0000633|0.0000250|0.0000113|0.0000057|0.0000032|0.0000019|0.0000013|0.0000009|\n\n画图可以看出变化曲线，如下图。\n\n![](error_rate_fig.png)\n\n通过上表，我们来计算本文开头的那个问题，假设我们有N=10,000,000个元素，容忍<0.0001的错误率，大概需要多大的空间，通过查表，我们知道当m/n=20，k=10时，错误率大概在0.0000889，满足条件，其空间消耗为**190.73MB**。\n\n上面我们选取的m/n的值和k的值是比较随意的，那么k的个数是否存在最优解呢？答案是**Yes**。\n\n在这里不再进行推导，k的最优值大致为\n\n$$ k=\\frac{m}{n} \\ln2\\approx 0.7\\frac{m}{n} $$\n\n因此对应上面问题其最优k值应该为**14**。\n\n# 总结\n\n布隆过滤器通过引入一定的错误率以及同时使用多个哈希函数，大大提高了空间使用效率，这使得在海量数据中进行判重更加高效。但是标准的布隆过滤器只支持添加而不支持删除，因此也有相关研究提出了可计数型布隆过滤器(Counting Bloom Filter)，在此不进行讨论。","source":"_posts/Bloom-Filter.md","raw":"---\ntitle: 海量数据判重之布隆过滤器\ntags:\n  - 系统设计\n  - 爬虫\n  - 哈希算法\ncategory: 系统设计\ndate: 2018-05-07 10:57:07\ncategories:\n---\n\n\n查询一个对象是否存在于一个集合中，在很多任务中都是十分重要的一部分，常见的使用场景主要是海量数据的判重等。布隆过滤器(Bloom Filter)便是解决此类问题的理想工具之一。\n\n<!-- more -->\n\n我们知道，可以使用哈希表来完成O(1)时间查询一个对象是否存在于一个集合中，但是传统的哈希虽然时间效率很高，但是因为采用开放寻址法来接触哈希冲突，因此为了保证查询时间效率，所以空间效率较低，一般只能达到不到50%，假设我们有N=10,000,000条数据需要进行判重的话，那么整个空间消耗是比较大的，更不用说在日常海量数据情况下的表现了，而布隆过滤器就是一个在容忍一定假正率的情况下，时间复杂度达到O(1)，空间效率很高的一个判重工具。\n\n# 插入原理\n\n布隆过滤器的插入原理跟普通的哈希过程很相似，不同与普通的哈希算法只使用一个哈希函数，布隆过滤器使用了多个**互不相关**的哈希函数来完成哈希过程，如下图所示。\n\n![](bloom_filter.png)\n\n对于任一元素，我们使用了K（此处K=3）个哈希函数来分别其哈希值，然后将该哈希值对M（此处m=24，布隆过滤器容量大小）取模，得到3个位置，然后将该位置置为1，需要注意的是，布隆过滤器每个位置只需要判断`True`或者`False`，因此只需要一个bit即可表示，因此最后该元素对应的3个位置将被置为`True`。\n\n# 查找原理\n\n要判断一个元素是否已经存在，这一过程跟插入很相似，也是计算出多个位置，只有当这些位置都为`0b1`的时候，那么该元素才已经存在，否则该元素不存在，如下图所示。\n\n![](bloom_filter_lookup.png)\n\n对于x，因为x已经在之前将其对应的三个位置设置为了`True`，因此在本次查找中可以发现其对应的位置全部为`True`，因此该元素存在。对于z，我们发现其有两个位置不为`True`，因此该元素肯定不存在。\n\n# 伪码描述\n\n我们可以使用伪码来描述插入与查找过程。\n\n## 插入\n\n```\n# x: Target value\n# m: Capacity\n# bits: Bloom filter bits storage\n# hash_funcs: Distinct hash functions\n\ndef insert(x):\n    for hash_func in hash_funcs:\n        p = hash_func(x) % m\n        bits[p] = True\n```\n## 查找\n\n```\ndef lookup(x):\n    found = True\n    for hash_func in hash_funcs:\n        p = hash_func(x) % m\n        found = found && bits[p]\n    return found\n```\n\n# 错误率\n\n![](bloom_filter_error.png)\n\n细心的读者可能已经发现了，在前文查找z的时候，我们有一个哈希函数结果对应的位置是元素y的某个位置，那么在极端情况下，可能一个从来没有见过的元素被误认为已经见过了，如上图中的h，其对应的K个位置都被其他元素设置成了`True`，这是我们通常所说的`False Positive`，即假正，那么其对应的概率即假正率到底有多大呢？我们可以通过概率的知识来进行定量的计算。\n\n**已知**：总共有m个bit，k个哈希函数（哈希函数插入每个位置概率相等），已经插入n个元素\n**求**：对一个新元素，其被错误识别为已插入的概率\n\n插入第一个元素时，一个哈希函数将某一位设置成`True`的概率是\n\n$$ \\frac{1}{m} $$\n\n那么该位不被设置成`True`的概率是\n\n$$ 1 - \\frac{1}{m} $$\n\n在插入k个哈希位置之后，即完成一个元素的插入之后，该位不被设置成`True`的概率是\n\n$$ {(1 - \\frac{1}{m})}^k $$\n\n在完成n个元素的插入之后，该位不被设置成`True`的概率是\n\n$$ {(1 - \\frac{1}{m})}^{nk} $$\n\n那么该位被设置成`True`的概率是\n\n$$ 1 - {(1 - \\frac{1}{m})}^{nk} $$\n\n对一个新的元素，其被错误识别为已存在可以等价于其k个位置都被设置为了`True`，其概率为\n\n$$ \\varepsilon \\approx {(1 - {(1 - \\frac{1}{m})}^{nk})}^k $$\n\n我们通过极限公式\n\n$$ \\lim\\limits_{n\\to\\infty}{(1+\\dfrac {1}{n})^n} = e $$\n\n将其转化为\n\n$$ \\varepsilon \\approx {(1 - {(1 - e^{-\\frac{nk}{m}})})}^k $$\n\n我们根据以上公式可以发现，最后假正率跟n/m和k有关，基于此，我们可以使用不同组合来计算假正率，结果如下表所示。\n\n|m/n|K = 1|K = 2|K = 3|K = 4|K = 5|K = 6|K = 7|K = 8|K = 9|K = 10|K = 11|K = 12|\n|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n|2|0.3934693|0.3995764|0.4688617|0.5589732|0.6516469|0.7360810|0.8068326|0.8625315|0.9043485|0.9346272|0.9559529|0.9706572|\n|3|0.2834687|0.2367629|0.2525805|0.2940775|0.3511052|0.4179135|0.4896758|0.5620731|0.6315219|0.6954066|0.7521399|0.8010552|\n|4|0.2211992|0.1548181|0.1468916|0.1596613|0.1849078|0.2198313|0.2628405|0.3124510|0.3669978|0.4246437|0.4835067|0.5418153|\n|5|0.1812692|0.1086889|0.0918488|0.0919536|0.1009252|0.1164499|0.1377817|0.1646166|0.1966885|0.2336024|0.2747749|0.3194357|\n|6|0.1535183|0.0803545|0.0609162|0.0560567|0.0577811|0.0637969|0.0734099|0.0864816|0.1030705|0.1232749|0.1471486|0.1746517|\n|7|0.1331221|0.0617635|0.0423483|0.0358990|0.0346578|0.0363787|0.0403273|0.0463077|0.0543501|0.0645847|0.0771784|0.0922953|\n|8|0.1175031|0.0489291|0.0305794|0.0239687|0.0216792|0.0215771|0.0229297|0.0254917|0.0292244|0.0341909|0.0405091|0.0483258|\n|9|0.1051607|0.0397056|0.0227780|0.0165770|0.0140703|0.0132721|0.0134892|0.0144631|0.0161138|0.0184491|0.0215259|0.0254323|\n|10|0.0951626|0.0328585|0.0174106|0.0118133|0.0094309|0.0084362|0.0081937|0.0084555|0.0091270|0.0101859|0.0116495|0.0135606|\n|11|0.0868993|0.0276381|0.0136005|0.0086373|0.0065018|0.0055222|0.0051259|0.0050864|0.0053098|0.0057616|0.0064387|0.0073573|\n|12|0.0799556|0.0235679|0.0108231|0.0064568|0.0045945|0.0037108|0.0032939|0.0031424|0.0031695|0.0033387|0.0036380|0.0040700|\n|13|0.0740389|0.0203336|0.0087517|0.0049210|0.0033183|0.0025527|0.0021689|0.0019897|0.0019384|0.0019804|0.0021013|0.0022975|\n|14|0.0689372|0.0177215|0.0071759|0.0038147|0.0024433|0.0017934|0.0014601|0.0012887|0.0012127|0.0012012|0.0012399|0.0013234|\n|15|0.0644930|0.0155817|0.0059562|0.0030019|0.0018303|0.0012840|0.0010028|0.0008523|0.0007749|0.0007440|0.0007468|0.0007775|\n|16|0.0605869|0.0138070|0.0049977|0.0023941|0.0013925|0.0009351|0.0007015|0.0005745|0.0005049|0.0004700|0.0004587|0.0004656|\n|17|0.0571269|0.0123188|0.0042340|0.0019323|0.0010742|0.0006916|0.0004990|0.0003941|0.0003350|0.0003024|0.0002870|0.0002839|\n|18|0.0540405|0.0110588|0.0036181|0.0015765|0.0008392|0.0005188|0.0003604|0.0002748|0.0002260|0.0001980|0.0001827|0.0001761|\n|19|0.0512705|0.0099825|0.0031160|0.0012989|0.0006632|0.0003942|0.0002640|0.0001945|0.0001549|0.0001317|0.0001182|0.0001111|\n|20|0.0487706|0.0090559|0.0027026|0.0010797|0.0005296|0.0003031|0.0001959|0.0001396|0.0001077|0.0000889|0.0000777|0.0000712|\n|21|0.0465030|0.0082526|0.0023591|0.0009048|0.0004269|0.0002356|0.0001471|0.0001014|0.0000759|0.0000609|0.0000518|0.0000463|\n|22|0.0444370|0.0075515|0.0020714|0.0007639|0.0003473|0.0001850|0.0001117|0.0000746|0.0000542|0.0000423|0.0000350|0.0000305|\n|23|0.0425466|0.0069361|0.0018287|0.0006493|0.0002847|0.0001466|0.0000856|0.0000555|0.0000392|0.0000297|0.0000240|0.0000204|\n|24|0.0408105|0.0063929|0.0016224|0.0005554|0.0002352|0.0001171|0.0000663|0.0000417|0.0000286|0.0000211|0.0000166|0.0000138|\n|25|0.0392106|0.0059111|0.0014459|0.0004779|0.0001957|0.0000944|0.0000518|0.0000316|0.0000211|0.0000152|0.0000116|0.0000094|\n|26|0.0377313|0.0054818|0.0012942|0.0004135|0.0001639|0.0000766|0.0000408|0.0000242|0.0000157|0.0000110|0.0000082|0.0000065|\n|27|0.0363596|0.0050975|0.0011629|0.0003595|0.0001381|0.0000626|0.0000324|0.0000187|0.0000118|0.0000081|0.0000059|0.0000046|\n|28|0.0350841|0.0047523|0.0010489|0.0003141|0.0001170|0.0000515|0.0000259|0.0000146|0.0000090|0.0000060|0.0000043|0.0000032|\n|29|0.0338950|0.0044410|0.0009492|0.0002756|0.0000996|0.0000426|0.0000209|0.0000114|0.0000069|0.0000045|0.0000031|0.0000023|\n|30|0.0327839|0.0041593|0.0008618|0.0002428|0.0000853|0.0000355|0.0000169|0.0000090|0.0000053|0.0000034|0.0000023|0.0000016|\n|31|0.0317433|0.0039036|0.0007848|0.0002147|0.0000733|0.0000297|0.0000138|0.0000072|0.0000041|0.0000025|0.0000017|0.0000012|\n|32|0.0307668|0.0036708|0.0007167|0.0001906|0.0000633|0.0000250|0.0000113|0.0000057|0.0000032|0.0000019|0.0000013|0.0000009|\n\n画图可以看出变化曲线，如下图。\n\n![](error_rate_fig.png)\n\n通过上表，我们来计算本文开头的那个问题，假设我们有N=10,000,000个元素，容忍<0.0001的错误率，大概需要多大的空间，通过查表，我们知道当m/n=20，k=10时，错误率大概在0.0000889，满足条件，其空间消耗为**190.73MB**。\n\n上面我们选取的m/n的值和k的值是比较随意的，那么k的个数是否存在最优解呢？答案是**Yes**。\n\n在这里不再进行推导，k的最优值大致为\n\n$$ k=\\frac{m}{n} \\ln2\\approx 0.7\\frac{m}{n} $$\n\n因此对应上面问题其最优k值应该为**14**。\n\n# 总结\n\n布隆过滤器通过引入一定的错误率以及同时使用多个哈希函数，大大提高了空间使用效率，这使得在海量数据中进行判重更加高效。但是标准的布隆过滤器只支持添加而不支持删除，因此也有相关研究提出了可计数型布隆过滤器(Counting Bloom Filter)，在此不进行讨论。","slug":"Bloom-Filter","published":1,"updated":"2018-05-07T02:58:53.473Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgvnqmkg0008w62883q260tt","content":"<p>查询一个对象是否存在于一个集合中，在很多任务中都是十分重要的一部分，常见的使用场景主要是海量数据的判重等。布隆过滤器(Bloom Filter)便是解决此类问题的理想工具之一。</p>\n<a id=\"more\"></a>\n<p>我们知道，可以使用哈希表来完成O(1)时间查询一个对象是否存在于一个集合中，但是传统的哈希虽然时间效率很高，但是因为采用开放寻址法来接触哈希冲突，因此为了保证查询时间效率，所以空间效率较低，一般只能达到不到50%，假设我们有N=10,000,000条数据需要进行判重的话，那么整个空间消耗是比较大的，更不用说在日常海量数据情况下的表现了，而布隆过滤器就是一个在容忍一定假正率的情况下，时间复杂度达到O(1)，空间效率很高的一个判重工具。</p>\n<h1 id=\"插入原理\"><a href=\"#插入原理\" class=\"headerlink\" title=\"插入原理\"></a>插入原理</h1><p>布隆过滤器的插入原理跟普通的哈希过程很相似，不同与普通的哈希算法只使用一个哈希函数，布隆过滤器使用了多个<strong>互不相关</strong>的哈希函数来完成哈希过程，如下图所示。</p>\n<p><img src=\"/2018/05/07/Bloom-Filter/bloom_filter.png\" alt=\"\"></p>\n<p>对于任一元素，我们使用了K（此处K=3）个哈希函数来分别其哈希值，然后将该哈希值对M（此处m=24，布隆过滤器容量大小）取模，得到3个位置，然后将该位置置为1，需要注意的是，布隆过滤器每个位置只需要判断<code>True</code>或者<code>False</code>，因此只需要一个bit即可表示，因此最后该元素对应的3个位置将被置为<code>True</code>。</p>\n<h1 id=\"查找原理\"><a href=\"#查找原理\" class=\"headerlink\" title=\"查找原理\"></a>查找原理</h1><p>要判断一个元素是否已经存在，这一过程跟插入很相似，也是计算出多个位置，只有当这些位置都为<code>0b1</code>的时候，那么该元素才已经存在，否则该元素不存在，如下图所示。</p>\n<p><img src=\"/2018/05/07/Bloom-Filter/bloom_filter_lookup.png\" alt=\"\"></p>\n<p>对于x，因为x已经在之前将其对应的三个位置设置为了<code>True</code>，因此在本次查找中可以发现其对应的位置全部为<code>True</code>，因此该元素存在。对于z，我们发现其有两个位置不为<code>True</code>，因此该元素肯定不存在。</p>\n<h1 id=\"伪码描述\"><a href=\"#伪码描述\" class=\"headerlink\" title=\"伪码描述\"></a>伪码描述</h1><p>我们可以使用伪码来描述插入与查找过程。</p>\n<h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># x: Target value</span><br><span class=\"line\"># m: Capacity</span><br><span class=\"line\"># bits: Bloom filter bits storage</span><br><span class=\"line\"># hash_funcs: Distinct hash functions</span><br><span class=\"line\"></span><br><span class=\"line\">def insert(x):</span><br><span class=\"line\">    for hash_func in hash_funcs:</span><br><span class=\"line\">        p = hash_func(x) % m</span><br><span class=\"line\">        bits[p] = True</span><br></pre></td></tr></table></figure>\n<h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def lookup(x):</span><br><span class=\"line\">    found = True</span><br><span class=\"line\">    for hash_func in hash_funcs:</span><br><span class=\"line\">        p = hash_func(x) % m</span><br><span class=\"line\">        found = found &amp;&amp; bits[p]</span><br><span class=\"line\">    return found</span><br></pre></td></tr></table></figure>\n<h1 id=\"错误率\"><a href=\"#错误率\" class=\"headerlink\" title=\"错误率\"></a>错误率</h1><p><img src=\"/2018/05/07/Bloom-Filter/bloom_filter_error.png\" alt=\"\"></p>\n<p>细心的读者可能已经发现了，在前文查找z的时候，我们有一个哈希函数结果对应的位置是元素y的某个位置，那么在极端情况下，可能一个从来没有见过的元素被误认为已经见过了，如上图中的h，其对应的K个位置都被其他元素设置成了<code>True</code>，这是我们通常所说的<code>False Positive</code>，即假正，那么其对应的概率即假正率到底有多大呢？我们可以通过概率的知识来进行定量的计算。</p>\n<p><strong>已知</strong>：总共有m个bit，k个哈希函数（哈希函数插入每个位置概率相等），已经插入n个元素<br><strong>求</strong>：对一个新元素，其被错误识别为已插入的概率</p>\n<p>插入第一个元素时，一个哈希函数将某一位设置成<code>True</code>的概率是</p>\n<p>$$ \\frac{1}{m} $$</p>\n<p>那么该位不被设置成<code>True</code>的概率是</p>\n<p>$$ 1 - \\frac{1}{m} $$</p>\n<p>在插入k个哈希位置之后，即完成一个元素的插入之后，该位不被设置成<code>True</code>的概率是</p>\n<p>$$ {(1 - \\frac{1}{m})}^k $$</p>\n<p>在完成n个元素的插入之后，该位不被设置成<code>True</code>的概率是</p>\n<p>$$ {(1 - \\frac{1}{m})}^{nk} $$</p>\n<p>那么该位被设置成<code>True</code>的概率是</p>\n<p>$$ 1 - {(1 - \\frac{1}{m})}^{nk} $$</p>\n<p>对一个新的元素，其被错误识别为已存在可以等价于其k个位置都被设置为了<code>True</code>，其概率为</p>\n<p>$$ \\varepsilon \\approx {(1 - {(1 - \\frac{1}{m})}^{nk})}^k $$</p>\n<p>我们通过极限公式</p>\n<p>$$ \\lim\\limits_{n\\to\\infty}{(1+\\dfrac {1}{n})^n} = e $$</p>\n<p>将其转化为</p>\n<p>$$ \\varepsilon \\approx {(1 - {(1 - e^{-\\frac{nk}{m}})})}^k $$</p>\n<p>我们根据以上公式可以发现，最后假正率跟n/m和k有关，基于此，我们可以使用不同组合来计算假正率，结果如下表所示。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">m/n</th>\n<th style=\"text-align:center\">K = 1</th>\n<th style=\"text-align:center\">K = 2</th>\n<th style=\"text-align:center\">K = 3</th>\n<th style=\"text-align:center\">K = 4</th>\n<th style=\"text-align:center\">K = 5</th>\n<th style=\"text-align:center\">K = 6</th>\n<th style=\"text-align:center\">K = 7</th>\n<th style=\"text-align:center\">K = 8</th>\n<th style=\"text-align:center\">K = 9</th>\n<th style=\"text-align:center\">K = 10</th>\n<th style=\"text-align:center\">K = 11</th>\n<th style=\"text-align:center\">K = 12</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">0.3934693</td>\n<td style=\"text-align:center\">0.3995764</td>\n<td style=\"text-align:center\">0.4688617</td>\n<td style=\"text-align:center\">0.5589732</td>\n<td style=\"text-align:center\">0.6516469</td>\n<td style=\"text-align:center\">0.7360810</td>\n<td style=\"text-align:center\">0.8068326</td>\n<td style=\"text-align:center\">0.8625315</td>\n<td style=\"text-align:center\">0.9043485</td>\n<td style=\"text-align:center\">0.9346272</td>\n<td style=\"text-align:center\">0.9559529</td>\n<td style=\"text-align:center\">0.9706572</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">0.2834687</td>\n<td style=\"text-align:center\">0.2367629</td>\n<td style=\"text-align:center\">0.2525805</td>\n<td style=\"text-align:center\">0.2940775</td>\n<td style=\"text-align:center\">0.3511052</td>\n<td style=\"text-align:center\">0.4179135</td>\n<td style=\"text-align:center\">0.4896758</td>\n<td style=\"text-align:center\">0.5620731</td>\n<td style=\"text-align:center\">0.6315219</td>\n<td style=\"text-align:center\">0.6954066</td>\n<td style=\"text-align:center\">0.7521399</td>\n<td style=\"text-align:center\">0.8010552</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">0.2211992</td>\n<td style=\"text-align:center\">0.1548181</td>\n<td style=\"text-align:center\">0.1468916</td>\n<td style=\"text-align:center\">0.1596613</td>\n<td style=\"text-align:center\">0.1849078</td>\n<td style=\"text-align:center\">0.2198313</td>\n<td style=\"text-align:center\">0.2628405</td>\n<td style=\"text-align:center\">0.3124510</td>\n<td style=\"text-align:center\">0.3669978</td>\n<td style=\"text-align:center\">0.4246437</td>\n<td style=\"text-align:center\">0.4835067</td>\n<td style=\"text-align:center\">0.5418153</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">0.1812692</td>\n<td style=\"text-align:center\">0.1086889</td>\n<td style=\"text-align:center\">0.0918488</td>\n<td style=\"text-align:center\">0.0919536</td>\n<td style=\"text-align:center\">0.1009252</td>\n<td style=\"text-align:center\">0.1164499</td>\n<td style=\"text-align:center\">0.1377817</td>\n<td style=\"text-align:center\">0.1646166</td>\n<td style=\"text-align:center\">0.1966885</td>\n<td style=\"text-align:center\">0.2336024</td>\n<td style=\"text-align:center\">0.2747749</td>\n<td style=\"text-align:center\">0.3194357</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">0.1535183</td>\n<td style=\"text-align:center\">0.0803545</td>\n<td style=\"text-align:center\">0.0609162</td>\n<td style=\"text-align:center\">0.0560567</td>\n<td style=\"text-align:center\">0.0577811</td>\n<td style=\"text-align:center\">0.0637969</td>\n<td style=\"text-align:center\">0.0734099</td>\n<td style=\"text-align:center\">0.0864816</td>\n<td style=\"text-align:center\">0.1030705</td>\n<td style=\"text-align:center\">0.1232749</td>\n<td style=\"text-align:center\">0.1471486</td>\n<td style=\"text-align:center\">0.1746517</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">0.1331221</td>\n<td style=\"text-align:center\">0.0617635</td>\n<td style=\"text-align:center\">0.0423483</td>\n<td style=\"text-align:center\">0.0358990</td>\n<td style=\"text-align:center\">0.0346578</td>\n<td style=\"text-align:center\">0.0363787</td>\n<td style=\"text-align:center\">0.0403273</td>\n<td style=\"text-align:center\">0.0463077</td>\n<td style=\"text-align:center\">0.0543501</td>\n<td style=\"text-align:center\">0.0645847</td>\n<td style=\"text-align:center\">0.0771784</td>\n<td style=\"text-align:center\">0.0922953</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">0.1175031</td>\n<td style=\"text-align:center\">0.0489291</td>\n<td style=\"text-align:center\">0.0305794</td>\n<td style=\"text-align:center\">0.0239687</td>\n<td style=\"text-align:center\">0.0216792</td>\n<td style=\"text-align:center\">0.0215771</td>\n<td style=\"text-align:center\">0.0229297</td>\n<td style=\"text-align:center\">0.0254917</td>\n<td style=\"text-align:center\">0.0292244</td>\n<td style=\"text-align:center\">0.0341909</td>\n<td style=\"text-align:center\">0.0405091</td>\n<td style=\"text-align:center\">0.0483258</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">0.1051607</td>\n<td style=\"text-align:center\">0.0397056</td>\n<td style=\"text-align:center\">0.0227780</td>\n<td style=\"text-align:center\">0.0165770</td>\n<td style=\"text-align:center\">0.0140703</td>\n<td style=\"text-align:center\">0.0132721</td>\n<td style=\"text-align:center\">0.0134892</td>\n<td style=\"text-align:center\">0.0144631</td>\n<td style=\"text-align:center\">0.0161138</td>\n<td style=\"text-align:center\">0.0184491</td>\n<td style=\"text-align:center\">0.0215259</td>\n<td style=\"text-align:center\">0.0254323</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">0.0951626</td>\n<td style=\"text-align:center\">0.0328585</td>\n<td style=\"text-align:center\">0.0174106</td>\n<td style=\"text-align:center\">0.0118133</td>\n<td style=\"text-align:center\">0.0094309</td>\n<td style=\"text-align:center\">0.0084362</td>\n<td style=\"text-align:center\">0.0081937</td>\n<td style=\"text-align:center\">0.0084555</td>\n<td style=\"text-align:center\">0.0091270</td>\n<td style=\"text-align:center\">0.0101859</td>\n<td style=\"text-align:center\">0.0116495</td>\n<td style=\"text-align:center\">0.0135606</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">0.0868993</td>\n<td style=\"text-align:center\">0.0276381</td>\n<td style=\"text-align:center\">0.0136005</td>\n<td style=\"text-align:center\">0.0086373</td>\n<td style=\"text-align:center\">0.0065018</td>\n<td style=\"text-align:center\">0.0055222</td>\n<td style=\"text-align:center\">0.0051259</td>\n<td style=\"text-align:center\">0.0050864</td>\n<td style=\"text-align:center\">0.0053098</td>\n<td style=\"text-align:center\">0.0057616</td>\n<td style=\"text-align:center\">0.0064387</td>\n<td style=\"text-align:center\">0.0073573</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">0.0799556</td>\n<td style=\"text-align:center\">0.0235679</td>\n<td style=\"text-align:center\">0.0108231</td>\n<td style=\"text-align:center\">0.0064568</td>\n<td style=\"text-align:center\">0.0045945</td>\n<td style=\"text-align:center\">0.0037108</td>\n<td style=\"text-align:center\">0.0032939</td>\n<td style=\"text-align:center\">0.0031424</td>\n<td style=\"text-align:center\">0.0031695</td>\n<td style=\"text-align:center\">0.0033387</td>\n<td style=\"text-align:center\">0.0036380</td>\n<td style=\"text-align:center\">0.0040700</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:center\">0.0740389</td>\n<td style=\"text-align:center\">0.0203336</td>\n<td style=\"text-align:center\">0.0087517</td>\n<td style=\"text-align:center\">0.0049210</td>\n<td style=\"text-align:center\">0.0033183</td>\n<td style=\"text-align:center\">0.0025527</td>\n<td style=\"text-align:center\">0.0021689</td>\n<td style=\"text-align:center\">0.0019897</td>\n<td style=\"text-align:center\">0.0019384</td>\n<td style=\"text-align:center\">0.0019804</td>\n<td style=\"text-align:center\">0.0021013</td>\n<td style=\"text-align:center\">0.0022975</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">0.0689372</td>\n<td style=\"text-align:center\">0.0177215</td>\n<td style=\"text-align:center\">0.0071759</td>\n<td style=\"text-align:center\">0.0038147</td>\n<td style=\"text-align:center\">0.0024433</td>\n<td style=\"text-align:center\">0.0017934</td>\n<td style=\"text-align:center\">0.0014601</td>\n<td style=\"text-align:center\">0.0012887</td>\n<td style=\"text-align:center\">0.0012127</td>\n<td style=\"text-align:center\">0.0012012</td>\n<td style=\"text-align:center\">0.0012399</td>\n<td style=\"text-align:center\">0.0013234</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">0.0644930</td>\n<td style=\"text-align:center\">0.0155817</td>\n<td style=\"text-align:center\">0.0059562</td>\n<td style=\"text-align:center\">0.0030019</td>\n<td style=\"text-align:center\">0.0018303</td>\n<td style=\"text-align:center\">0.0012840</td>\n<td style=\"text-align:center\">0.0010028</td>\n<td style=\"text-align:center\">0.0008523</td>\n<td style=\"text-align:center\">0.0007749</td>\n<td style=\"text-align:center\">0.0007440</td>\n<td style=\"text-align:center\">0.0007468</td>\n<td style=\"text-align:center\">0.0007775</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">0.0605869</td>\n<td style=\"text-align:center\">0.0138070</td>\n<td style=\"text-align:center\">0.0049977</td>\n<td style=\"text-align:center\">0.0023941</td>\n<td style=\"text-align:center\">0.0013925</td>\n<td style=\"text-align:center\">0.0009351</td>\n<td style=\"text-align:center\">0.0007015</td>\n<td style=\"text-align:center\">0.0005745</td>\n<td style=\"text-align:center\">0.0005049</td>\n<td style=\"text-align:center\">0.0004700</td>\n<td style=\"text-align:center\">0.0004587</td>\n<td style=\"text-align:center\">0.0004656</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">17</td>\n<td style=\"text-align:center\">0.0571269</td>\n<td style=\"text-align:center\">0.0123188</td>\n<td style=\"text-align:center\">0.0042340</td>\n<td style=\"text-align:center\">0.0019323</td>\n<td style=\"text-align:center\">0.0010742</td>\n<td style=\"text-align:center\">0.0006916</td>\n<td style=\"text-align:center\">0.0004990</td>\n<td style=\"text-align:center\">0.0003941</td>\n<td style=\"text-align:center\">0.0003350</td>\n<td style=\"text-align:center\">0.0003024</td>\n<td style=\"text-align:center\">0.0002870</td>\n<td style=\"text-align:center\">0.0002839</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">18</td>\n<td style=\"text-align:center\">0.0540405</td>\n<td style=\"text-align:center\">0.0110588</td>\n<td style=\"text-align:center\">0.0036181</td>\n<td style=\"text-align:center\">0.0015765</td>\n<td style=\"text-align:center\">0.0008392</td>\n<td style=\"text-align:center\">0.0005188</td>\n<td style=\"text-align:center\">0.0003604</td>\n<td style=\"text-align:center\">0.0002748</td>\n<td style=\"text-align:center\">0.0002260</td>\n<td style=\"text-align:center\">0.0001980</td>\n<td style=\"text-align:center\">0.0001827</td>\n<td style=\"text-align:center\">0.0001761</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">19</td>\n<td style=\"text-align:center\">0.0512705</td>\n<td style=\"text-align:center\">0.0099825</td>\n<td style=\"text-align:center\">0.0031160</td>\n<td style=\"text-align:center\">0.0012989</td>\n<td style=\"text-align:center\">0.0006632</td>\n<td style=\"text-align:center\">0.0003942</td>\n<td style=\"text-align:center\">0.0002640</td>\n<td style=\"text-align:center\">0.0001945</td>\n<td style=\"text-align:center\">0.0001549</td>\n<td style=\"text-align:center\">0.0001317</td>\n<td style=\"text-align:center\">0.0001182</td>\n<td style=\"text-align:center\">0.0001111</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">0.0487706</td>\n<td style=\"text-align:center\">0.0090559</td>\n<td style=\"text-align:center\">0.0027026</td>\n<td style=\"text-align:center\">0.0010797</td>\n<td style=\"text-align:center\">0.0005296</td>\n<td style=\"text-align:center\">0.0003031</td>\n<td style=\"text-align:center\">0.0001959</td>\n<td style=\"text-align:center\">0.0001396</td>\n<td style=\"text-align:center\">0.0001077</td>\n<td style=\"text-align:center\">0.0000889</td>\n<td style=\"text-align:center\">0.0000777</td>\n<td style=\"text-align:center\">0.0000712</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">21</td>\n<td style=\"text-align:center\">0.0465030</td>\n<td style=\"text-align:center\">0.0082526</td>\n<td style=\"text-align:center\">0.0023591</td>\n<td style=\"text-align:center\">0.0009048</td>\n<td style=\"text-align:center\">0.0004269</td>\n<td style=\"text-align:center\">0.0002356</td>\n<td style=\"text-align:center\">0.0001471</td>\n<td style=\"text-align:center\">0.0001014</td>\n<td style=\"text-align:center\">0.0000759</td>\n<td style=\"text-align:center\">0.0000609</td>\n<td style=\"text-align:center\">0.0000518</td>\n<td style=\"text-align:center\">0.0000463</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">22</td>\n<td style=\"text-align:center\">0.0444370</td>\n<td style=\"text-align:center\">0.0075515</td>\n<td style=\"text-align:center\">0.0020714</td>\n<td style=\"text-align:center\">0.0007639</td>\n<td style=\"text-align:center\">0.0003473</td>\n<td style=\"text-align:center\">0.0001850</td>\n<td style=\"text-align:center\">0.0001117</td>\n<td style=\"text-align:center\">0.0000746</td>\n<td style=\"text-align:center\">0.0000542</td>\n<td style=\"text-align:center\">0.0000423</td>\n<td style=\"text-align:center\">0.0000350</td>\n<td style=\"text-align:center\">0.0000305</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">23</td>\n<td style=\"text-align:center\">0.0425466</td>\n<td style=\"text-align:center\">0.0069361</td>\n<td style=\"text-align:center\">0.0018287</td>\n<td style=\"text-align:center\">0.0006493</td>\n<td style=\"text-align:center\">0.0002847</td>\n<td style=\"text-align:center\">0.0001466</td>\n<td style=\"text-align:center\">0.0000856</td>\n<td style=\"text-align:center\">0.0000555</td>\n<td style=\"text-align:center\">0.0000392</td>\n<td style=\"text-align:center\">0.0000297</td>\n<td style=\"text-align:center\">0.0000240</td>\n<td style=\"text-align:center\">0.0000204</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">24</td>\n<td style=\"text-align:center\">0.0408105</td>\n<td style=\"text-align:center\">0.0063929</td>\n<td style=\"text-align:center\">0.0016224</td>\n<td style=\"text-align:center\">0.0005554</td>\n<td style=\"text-align:center\">0.0002352</td>\n<td style=\"text-align:center\">0.0001171</td>\n<td style=\"text-align:center\">0.0000663</td>\n<td style=\"text-align:center\">0.0000417</td>\n<td style=\"text-align:center\">0.0000286</td>\n<td style=\"text-align:center\">0.0000211</td>\n<td style=\"text-align:center\">0.0000166</td>\n<td style=\"text-align:center\">0.0000138</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">25</td>\n<td style=\"text-align:center\">0.0392106</td>\n<td style=\"text-align:center\">0.0059111</td>\n<td style=\"text-align:center\">0.0014459</td>\n<td style=\"text-align:center\">0.0004779</td>\n<td style=\"text-align:center\">0.0001957</td>\n<td style=\"text-align:center\">0.0000944</td>\n<td style=\"text-align:center\">0.0000518</td>\n<td style=\"text-align:center\">0.0000316</td>\n<td style=\"text-align:center\">0.0000211</td>\n<td style=\"text-align:center\">0.0000152</td>\n<td style=\"text-align:center\">0.0000116</td>\n<td style=\"text-align:center\">0.0000094</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">26</td>\n<td style=\"text-align:center\">0.0377313</td>\n<td style=\"text-align:center\">0.0054818</td>\n<td style=\"text-align:center\">0.0012942</td>\n<td style=\"text-align:center\">0.0004135</td>\n<td style=\"text-align:center\">0.0001639</td>\n<td style=\"text-align:center\">0.0000766</td>\n<td style=\"text-align:center\">0.0000408</td>\n<td style=\"text-align:center\">0.0000242</td>\n<td style=\"text-align:center\">0.0000157</td>\n<td style=\"text-align:center\">0.0000110</td>\n<td style=\"text-align:center\">0.0000082</td>\n<td style=\"text-align:center\">0.0000065</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">27</td>\n<td style=\"text-align:center\">0.0363596</td>\n<td style=\"text-align:center\">0.0050975</td>\n<td style=\"text-align:center\">0.0011629</td>\n<td style=\"text-align:center\">0.0003595</td>\n<td style=\"text-align:center\">0.0001381</td>\n<td style=\"text-align:center\">0.0000626</td>\n<td style=\"text-align:center\">0.0000324</td>\n<td style=\"text-align:center\">0.0000187</td>\n<td style=\"text-align:center\">0.0000118</td>\n<td style=\"text-align:center\">0.0000081</td>\n<td style=\"text-align:center\">0.0000059</td>\n<td style=\"text-align:center\">0.0000046</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">28</td>\n<td style=\"text-align:center\">0.0350841</td>\n<td style=\"text-align:center\">0.0047523</td>\n<td style=\"text-align:center\">0.0010489</td>\n<td style=\"text-align:center\">0.0003141</td>\n<td style=\"text-align:center\">0.0001170</td>\n<td style=\"text-align:center\">0.0000515</td>\n<td style=\"text-align:center\">0.0000259</td>\n<td style=\"text-align:center\">0.0000146</td>\n<td style=\"text-align:center\">0.0000090</td>\n<td style=\"text-align:center\">0.0000060</td>\n<td style=\"text-align:center\">0.0000043</td>\n<td style=\"text-align:center\">0.0000032</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">29</td>\n<td style=\"text-align:center\">0.0338950</td>\n<td style=\"text-align:center\">0.0044410</td>\n<td style=\"text-align:center\">0.0009492</td>\n<td style=\"text-align:center\">0.0002756</td>\n<td style=\"text-align:center\">0.0000996</td>\n<td style=\"text-align:center\">0.0000426</td>\n<td style=\"text-align:center\">0.0000209</td>\n<td style=\"text-align:center\">0.0000114</td>\n<td style=\"text-align:center\">0.0000069</td>\n<td style=\"text-align:center\">0.0000045</td>\n<td style=\"text-align:center\">0.0000031</td>\n<td style=\"text-align:center\">0.0000023</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">0.0327839</td>\n<td style=\"text-align:center\">0.0041593</td>\n<td style=\"text-align:center\">0.0008618</td>\n<td style=\"text-align:center\">0.0002428</td>\n<td style=\"text-align:center\">0.0000853</td>\n<td style=\"text-align:center\">0.0000355</td>\n<td style=\"text-align:center\">0.0000169</td>\n<td style=\"text-align:center\">0.0000090</td>\n<td style=\"text-align:center\">0.0000053</td>\n<td style=\"text-align:center\">0.0000034</td>\n<td style=\"text-align:center\">0.0000023</td>\n<td style=\"text-align:center\">0.0000016</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">31</td>\n<td style=\"text-align:center\">0.0317433</td>\n<td style=\"text-align:center\">0.0039036</td>\n<td style=\"text-align:center\">0.0007848</td>\n<td style=\"text-align:center\">0.0002147</td>\n<td style=\"text-align:center\">0.0000733</td>\n<td style=\"text-align:center\">0.0000297</td>\n<td style=\"text-align:center\">0.0000138</td>\n<td style=\"text-align:center\">0.0000072</td>\n<td style=\"text-align:center\">0.0000041</td>\n<td style=\"text-align:center\">0.0000025</td>\n<td style=\"text-align:center\">0.0000017</td>\n<td style=\"text-align:center\">0.0000012</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">32</td>\n<td style=\"text-align:center\">0.0307668</td>\n<td style=\"text-align:center\">0.0036708</td>\n<td style=\"text-align:center\">0.0007167</td>\n<td style=\"text-align:center\">0.0001906</td>\n<td style=\"text-align:center\">0.0000633</td>\n<td style=\"text-align:center\">0.0000250</td>\n<td style=\"text-align:center\">0.0000113</td>\n<td style=\"text-align:center\">0.0000057</td>\n<td style=\"text-align:center\">0.0000032</td>\n<td style=\"text-align:center\">0.0000019</td>\n<td style=\"text-align:center\">0.0000013</td>\n<td style=\"text-align:center\">0.0000009</td>\n</tr>\n</tbody>\n</table>\n<p>画图可以看出变化曲线，如下图。</p>\n<p><img src=\"/2018/05/07/Bloom-Filter/error_rate_fig.png\" alt=\"\"></p>\n<p>通过上表，我们来计算本文开头的那个问题，假设我们有N=10,000,000个元素，容忍&lt;0.0001的错误率，大概需要多大的空间，通过查表，我们知道当m/n=20，k=10时，错误率大概在0.0000889，满足条件，其空间消耗为<strong>190.73MB</strong>。</p>\n<p>上面我们选取的m/n的值和k的值是比较随意的，那么k的个数是否存在最优解呢？答案是<strong>Yes</strong>。</p>\n<p>在这里不再进行推导，k的最优值大致为</p>\n<p>$$ k=\\frac{m}{n} \\ln2\\approx 0.7\\frac{m}{n} $$</p>\n<p>因此对应上面问题其最优k值应该为<strong>14</strong>。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>布隆过滤器通过引入一定的错误率以及同时使用多个哈希函数，大大提高了空间使用效率，这使得在海量数据中进行判重更加高效。但是标准的布隆过滤器只支持添加而不支持删除，因此也有相关研究提出了可计数型布隆过滤器(Counting Bloom Filter)，在此不进行讨论。</p>\n","site":{"data":{}},"excerpt":"<p>查询一个对象是否存在于一个集合中，在很多任务中都是十分重要的一部分，常见的使用场景主要是海量数据的判重等。布隆过滤器(Bloom Filter)便是解决此类问题的理想工具之一。</p>","more":"<p>我们知道，可以使用哈希表来完成O(1)时间查询一个对象是否存在于一个集合中，但是传统的哈希虽然时间效率很高，但是因为采用开放寻址法来接触哈希冲突，因此为了保证查询时间效率，所以空间效率较低，一般只能达到不到50%，假设我们有N=10,000,000条数据需要进行判重的话，那么整个空间消耗是比较大的，更不用说在日常海量数据情况下的表现了，而布隆过滤器就是一个在容忍一定假正率的情况下，时间复杂度达到O(1)，空间效率很高的一个判重工具。</p>\n<h1 id=\"插入原理\"><a href=\"#插入原理\" class=\"headerlink\" title=\"插入原理\"></a>插入原理</h1><p>布隆过滤器的插入原理跟普通的哈希过程很相似，不同与普通的哈希算法只使用一个哈希函数，布隆过滤器使用了多个<strong>互不相关</strong>的哈希函数来完成哈希过程，如下图所示。</p>\n<p><img src=\"/2018/05/07/Bloom-Filter/bloom_filter.png\" alt=\"\"></p>\n<p>对于任一元素，我们使用了K（此处K=3）个哈希函数来分别其哈希值，然后将该哈希值对M（此处m=24，布隆过滤器容量大小）取模，得到3个位置，然后将该位置置为1，需要注意的是，布隆过滤器每个位置只需要判断<code>True</code>或者<code>False</code>，因此只需要一个bit即可表示，因此最后该元素对应的3个位置将被置为<code>True</code>。</p>\n<h1 id=\"查找原理\"><a href=\"#查找原理\" class=\"headerlink\" title=\"查找原理\"></a>查找原理</h1><p>要判断一个元素是否已经存在，这一过程跟插入很相似，也是计算出多个位置，只有当这些位置都为<code>0b1</code>的时候，那么该元素才已经存在，否则该元素不存在，如下图所示。</p>\n<p><img src=\"/2018/05/07/Bloom-Filter/bloom_filter_lookup.png\" alt=\"\"></p>\n<p>对于x，因为x已经在之前将其对应的三个位置设置为了<code>True</code>，因此在本次查找中可以发现其对应的位置全部为<code>True</code>，因此该元素存在。对于z，我们发现其有两个位置不为<code>True</code>，因此该元素肯定不存在。</p>\n<h1 id=\"伪码描述\"><a href=\"#伪码描述\" class=\"headerlink\" title=\"伪码描述\"></a>伪码描述</h1><p>我们可以使用伪码来描述插入与查找过程。</p>\n<h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># x: Target value</span><br><span class=\"line\"># m: Capacity</span><br><span class=\"line\"># bits: Bloom filter bits storage</span><br><span class=\"line\"># hash_funcs: Distinct hash functions</span><br><span class=\"line\"></span><br><span class=\"line\">def insert(x):</span><br><span class=\"line\">    for hash_func in hash_funcs:</span><br><span class=\"line\">        p = hash_func(x) % m</span><br><span class=\"line\">        bits[p] = True</span><br></pre></td></tr></table></figure>\n<h2 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def lookup(x):</span><br><span class=\"line\">    found = True</span><br><span class=\"line\">    for hash_func in hash_funcs:</span><br><span class=\"line\">        p = hash_func(x) % m</span><br><span class=\"line\">        found = found &amp;&amp; bits[p]</span><br><span class=\"line\">    return found</span><br></pre></td></tr></table></figure>\n<h1 id=\"错误率\"><a href=\"#错误率\" class=\"headerlink\" title=\"错误率\"></a>错误率</h1><p><img src=\"/2018/05/07/Bloom-Filter/bloom_filter_error.png\" alt=\"\"></p>\n<p>细心的读者可能已经发现了，在前文查找z的时候，我们有一个哈希函数结果对应的位置是元素y的某个位置，那么在极端情况下，可能一个从来没有见过的元素被误认为已经见过了，如上图中的h，其对应的K个位置都被其他元素设置成了<code>True</code>，这是我们通常所说的<code>False Positive</code>，即假正，那么其对应的概率即假正率到底有多大呢？我们可以通过概率的知识来进行定量的计算。</p>\n<p><strong>已知</strong>：总共有m个bit，k个哈希函数（哈希函数插入每个位置概率相等），已经插入n个元素<br><strong>求</strong>：对一个新元素，其被错误识别为已插入的概率</p>\n<p>插入第一个元素时，一个哈希函数将某一位设置成<code>True</code>的概率是</p>\n<p>$$ \\frac{1}{m} $$</p>\n<p>那么该位不被设置成<code>True</code>的概率是</p>\n<p>$$ 1 - \\frac{1}{m} $$</p>\n<p>在插入k个哈希位置之后，即完成一个元素的插入之后，该位不被设置成<code>True</code>的概率是</p>\n<p>$$ {(1 - \\frac{1}{m})}^k $$</p>\n<p>在完成n个元素的插入之后，该位不被设置成<code>True</code>的概率是</p>\n<p>$$ {(1 - \\frac{1}{m})}^{nk} $$</p>\n<p>那么该位被设置成<code>True</code>的概率是</p>\n<p>$$ 1 - {(1 - \\frac{1}{m})}^{nk} $$</p>\n<p>对一个新的元素，其被错误识别为已存在可以等价于其k个位置都被设置为了<code>True</code>，其概率为</p>\n<p>$$ \\varepsilon \\approx {(1 - {(1 - \\frac{1}{m})}^{nk})}^k $$</p>\n<p>我们通过极限公式</p>\n<p>$$ \\lim\\limits_{n\\to\\infty}{(1+\\dfrac {1}{n})^n} = e $$</p>\n<p>将其转化为</p>\n<p>$$ \\varepsilon \\approx {(1 - {(1 - e^{-\\frac{nk}{m}})})}^k $$</p>\n<p>我们根据以上公式可以发现，最后假正率跟n/m和k有关，基于此，我们可以使用不同组合来计算假正率，结果如下表所示。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">m/n</th>\n<th style=\"text-align:center\">K = 1</th>\n<th style=\"text-align:center\">K = 2</th>\n<th style=\"text-align:center\">K = 3</th>\n<th style=\"text-align:center\">K = 4</th>\n<th style=\"text-align:center\">K = 5</th>\n<th style=\"text-align:center\">K = 6</th>\n<th style=\"text-align:center\">K = 7</th>\n<th style=\"text-align:center\">K = 8</th>\n<th style=\"text-align:center\">K = 9</th>\n<th style=\"text-align:center\">K = 10</th>\n<th style=\"text-align:center\">K = 11</th>\n<th style=\"text-align:center\">K = 12</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">0.3934693</td>\n<td style=\"text-align:center\">0.3995764</td>\n<td style=\"text-align:center\">0.4688617</td>\n<td style=\"text-align:center\">0.5589732</td>\n<td style=\"text-align:center\">0.6516469</td>\n<td style=\"text-align:center\">0.7360810</td>\n<td style=\"text-align:center\">0.8068326</td>\n<td style=\"text-align:center\">0.8625315</td>\n<td style=\"text-align:center\">0.9043485</td>\n<td style=\"text-align:center\">0.9346272</td>\n<td style=\"text-align:center\">0.9559529</td>\n<td style=\"text-align:center\">0.9706572</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">0.2834687</td>\n<td style=\"text-align:center\">0.2367629</td>\n<td style=\"text-align:center\">0.2525805</td>\n<td style=\"text-align:center\">0.2940775</td>\n<td style=\"text-align:center\">0.3511052</td>\n<td style=\"text-align:center\">0.4179135</td>\n<td style=\"text-align:center\">0.4896758</td>\n<td style=\"text-align:center\">0.5620731</td>\n<td style=\"text-align:center\">0.6315219</td>\n<td style=\"text-align:center\">0.6954066</td>\n<td style=\"text-align:center\">0.7521399</td>\n<td style=\"text-align:center\">0.8010552</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">0.2211992</td>\n<td style=\"text-align:center\">0.1548181</td>\n<td style=\"text-align:center\">0.1468916</td>\n<td style=\"text-align:center\">0.1596613</td>\n<td style=\"text-align:center\">0.1849078</td>\n<td style=\"text-align:center\">0.2198313</td>\n<td style=\"text-align:center\">0.2628405</td>\n<td style=\"text-align:center\">0.3124510</td>\n<td style=\"text-align:center\">0.3669978</td>\n<td style=\"text-align:center\">0.4246437</td>\n<td style=\"text-align:center\">0.4835067</td>\n<td style=\"text-align:center\">0.5418153</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">0.1812692</td>\n<td style=\"text-align:center\">0.1086889</td>\n<td style=\"text-align:center\">0.0918488</td>\n<td style=\"text-align:center\">0.0919536</td>\n<td style=\"text-align:center\">0.1009252</td>\n<td style=\"text-align:center\">0.1164499</td>\n<td style=\"text-align:center\">0.1377817</td>\n<td style=\"text-align:center\">0.1646166</td>\n<td style=\"text-align:center\">0.1966885</td>\n<td style=\"text-align:center\">0.2336024</td>\n<td style=\"text-align:center\">0.2747749</td>\n<td style=\"text-align:center\">0.3194357</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">0.1535183</td>\n<td style=\"text-align:center\">0.0803545</td>\n<td style=\"text-align:center\">0.0609162</td>\n<td style=\"text-align:center\">0.0560567</td>\n<td style=\"text-align:center\">0.0577811</td>\n<td style=\"text-align:center\">0.0637969</td>\n<td style=\"text-align:center\">0.0734099</td>\n<td style=\"text-align:center\">0.0864816</td>\n<td style=\"text-align:center\">0.1030705</td>\n<td style=\"text-align:center\">0.1232749</td>\n<td style=\"text-align:center\">0.1471486</td>\n<td style=\"text-align:center\">0.1746517</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">0.1331221</td>\n<td style=\"text-align:center\">0.0617635</td>\n<td style=\"text-align:center\">0.0423483</td>\n<td style=\"text-align:center\">0.0358990</td>\n<td style=\"text-align:center\">0.0346578</td>\n<td style=\"text-align:center\">0.0363787</td>\n<td style=\"text-align:center\">0.0403273</td>\n<td style=\"text-align:center\">0.0463077</td>\n<td style=\"text-align:center\">0.0543501</td>\n<td style=\"text-align:center\">0.0645847</td>\n<td style=\"text-align:center\">0.0771784</td>\n<td style=\"text-align:center\">0.0922953</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">0.1175031</td>\n<td style=\"text-align:center\">0.0489291</td>\n<td style=\"text-align:center\">0.0305794</td>\n<td style=\"text-align:center\">0.0239687</td>\n<td style=\"text-align:center\">0.0216792</td>\n<td style=\"text-align:center\">0.0215771</td>\n<td style=\"text-align:center\">0.0229297</td>\n<td style=\"text-align:center\">0.0254917</td>\n<td style=\"text-align:center\">0.0292244</td>\n<td style=\"text-align:center\">0.0341909</td>\n<td style=\"text-align:center\">0.0405091</td>\n<td style=\"text-align:center\">0.0483258</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">0.1051607</td>\n<td style=\"text-align:center\">0.0397056</td>\n<td style=\"text-align:center\">0.0227780</td>\n<td style=\"text-align:center\">0.0165770</td>\n<td style=\"text-align:center\">0.0140703</td>\n<td style=\"text-align:center\">0.0132721</td>\n<td style=\"text-align:center\">0.0134892</td>\n<td style=\"text-align:center\">0.0144631</td>\n<td style=\"text-align:center\">0.0161138</td>\n<td style=\"text-align:center\">0.0184491</td>\n<td style=\"text-align:center\">0.0215259</td>\n<td style=\"text-align:center\">0.0254323</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">0.0951626</td>\n<td style=\"text-align:center\">0.0328585</td>\n<td style=\"text-align:center\">0.0174106</td>\n<td style=\"text-align:center\">0.0118133</td>\n<td style=\"text-align:center\">0.0094309</td>\n<td style=\"text-align:center\">0.0084362</td>\n<td style=\"text-align:center\">0.0081937</td>\n<td style=\"text-align:center\">0.0084555</td>\n<td style=\"text-align:center\">0.0091270</td>\n<td style=\"text-align:center\">0.0101859</td>\n<td style=\"text-align:center\">0.0116495</td>\n<td style=\"text-align:center\">0.0135606</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">0.0868993</td>\n<td style=\"text-align:center\">0.0276381</td>\n<td style=\"text-align:center\">0.0136005</td>\n<td style=\"text-align:center\">0.0086373</td>\n<td style=\"text-align:center\">0.0065018</td>\n<td style=\"text-align:center\">0.0055222</td>\n<td style=\"text-align:center\">0.0051259</td>\n<td style=\"text-align:center\">0.0050864</td>\n<td style=\"text-align:center\">0.0053098</td>\n<td style=\"text-align:center\">0.0057616</td>\n<td style=\"text-align:center\">0.0064387</td>\n<td style=\"text-align:center\">0.0073573</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">0.0799556</td>\n<td style=\"text-align:center\">0.0235679</td>\n<td style=\"text-align:center\">0.0108231</td>\n<td style=\"text-align:center\">0.0064568</td>\n<td style=\"text-align:center\">0.0045945</td>\n<td style=\"text-align:center\">0.0037108</td>\n<td style=\"text-align:center\">0.0032939</td>\n<td style=\"text-align:center\">0.0031424</td>\n<td style=\"text-align:center\">0.0031695</td>\n<td style=\"text-align:center\">0.0033387</td>\n<td style=\"text-align:center\">0.0036380</td>\n<td style=\"text-align:center\">0.0040700</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:center\">0.0740389</td>\n<td style=\"text-align:center\">0.0203336</td>\n<td style=\"text-align:center\">0.0087517</td>\n<td style=\"text-align:center\">0.0049210</td>\n<td style=\"text-align:center\">0.0033183</td>\n<td style=\"text-align:center\">0.0025527</td>\n<td style=\"text-align:center\">0.0021689</td>\n<td style=\"text-align:center\">0.0019897</td>\n<td style=\"text-align:center\">0.0019384</td>\n<td style=\"text-align:center\">0.0019804</td>\n<td style=\"text-align:center\">0.0021013</td>\n<td style=\"text-align:center\">0.0022975</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">0.0689372</td>\n<td style=\"text-align:center\">0.0177215</td>\n<td style=\"text-align:center\">0.0071759</td>\n<td style=\"text-align:center\">0.0038147</td>\n<td style=\"text-align:center\">0.0024433</td>\n<td style=\"text-align:center\">0.0017934</td>\n<td style=\"text-align:center\">0.0014601</td>\n<td style=\"text-align:center\">0.0012887</td>\n<td style=\"text-align:center\">0.0012127</td>\n<td style=\"text-align:center\">0.0012012</td>\n<td style=\"text-align:center\">0.0012399</td>\n<td style=\"text-align:center\">0.0013234</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">0.0644930</td>\n<td style=\"text-align:center\">0.0155817</td>\n<td style=\"text-align:center\">0.0059562</td>\n<td style=\"text-align:center\">0.0030019</td>\n<td style=\"text-align:center\">0.0018303</td>\n<td style=\"text-align:center\">0.0012840</td>\n<td style=\"text-align:center\">0.0010028</td>\n<td style=\"text-align:center\">0.0008523</td>\n<td style=\"text-align:center\">0.0007749</td>\n<td style=\"text-align:center\">0.0007440</td>\n<td style=\"text-align:center\">0.0007468</td>\n<td style=\"text-align:center\">0.0007775</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">0.0605869</td>\n<td style=\"text-align:center\">0.0138070</td>\n<td style=\"text-align:center\">0.0049977</td>\n<td style=\"text-align:center\">0.0023941</td>\n<td style=\"text-align:center\">0.0013925</td>\n<td style=\"text-align:center\">0.0009351</td>\n<td style=\"text-align:center\">0.0007015</td>\n<td style=\"text-align:center\">0.0005745</td>\n<td style=\"text-align:center\">0.0005049</td>\n<td style=\"text-align:center\">0.0004700</td>\n<td style=\"text-align:center\">0.0004587</td>\n<td style=\"text-align:center\">0.0004656</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">17</td>\n<td style=\"text-align:center\">0.0571269</td>\n<td style=\"text-align:center\">0.0123188</td>\n<td style=\"text-align:center\">0.0042340</td>\n<td style=\"text-align:center\">0.0019323</td>\n<td style=\"text-align:center\">0.0010742</td>\n<td style=\"text-align:center\">0.0006916</td>\n<td style=\"text-align:center\">0.0004990</td>\n<td style=\"text-align:center\">0.0003941</td>\n<td style=\"text-align:center\">0.0003350</td>\n<td style=\"text-align:center\">0.0003024</td>\n<td style=\"text-align:center\">0.0002870</td>\n<td style=\"text-align:center\">0.0002839</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">18</td>\n<td style=\"text-align:center\">0.0540405</td>\n<td style=\"text-align:center\">0.0110588</td>\n<td style=\"text-align:center\">0.0036181</td>\n<td style=\"text-align:center\">0.0015765</td>\n<td style=\"text-align:center\">0.0008392</td>\n<td style=\"text-align:center\">0.0005188</td>\n<td style=\"text-align:center\">0.0003604</td>\n<td style=\"text-align:center\">0.0002748</td>\n<td style=\"text-align:center\">0.0002260</td>\n<td style=\"text-align:center\">0.0001980</td>\n<td style=\"text-align:center\">0.0001827</td>\n<td style=\"text-align:center\">0.0001761</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">19</td>\n<td style=\"text-align:center\">0.0512705</td>\n<td style=\"text-align:center\">0.0099825</td>\n<td style=\"text-align:center\">0.0031160</td>\n<td style=\"text-align:center\">0.0012989</td>\n<td style=\"text-align:center\">0.0006632</td>\n<td style=\"text-align:center\">0.0003942</td>\n<td style=\"text-align:center\">0.0002640</td>\n<td style=\"text-align:center\">0.0001945</td>\n<td style=\"text-align:center\">0.0001549</td>\n<td style=\"text-align:center\">0.0001317</td>\n<td style=\"text-align:center\">0.0001182</td>\n<td style=\"text-align:center\">0.0001111</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">0.0487706</td>\n<td style=\"text-align:center\">0.0090559</td>\n<td style=\"text-align:center\">0.0027026</td>\n<td style=\"text-align:center\">0.0010797</td>\n<td style=\"text-align:center\">0.0005296</td>\n<td style=\"text-align:center\">0.0003031</td>\n<td style=\"text-align:center\">0.0001959</td>\n<td style=\"text-align:center\">0.0001396</td>\n<td style=\"text-align:center\">0.0001077</td>\n<td style=\"text-align:center\">0.0000889</td>\n<td style=\"text-align:center\">0.0000777</td>\n<td style=\"text-align:center\">0.0000712</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">21</td>\n<td style=\"text-align:center\">0.0465030</td>\n<td style=\"text-align:center\">0.0082526</td>\n<td style=\"text-align:center\">0.0023591</td>\n<td style=\"text-align:center\">0.0009048</td>\n<td style=\"text-align:center\">0.0004269</td>\n<td style=\"text-align:center\">0.0002356</td>\n<td style=\"text-align:center\">0.0001471</td>\n<td style=\"text-align:center\">0.0001014</td>\n<td style=\"text-align:center\">0.0000759</td>\n<td style=\"text-align:center\">0.0000609</td>\n<td style=\"text-align:center\">0.0000518</td>\n<td style=\"text-align:center\">0.0000463</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">22</td>\n<td style=\"text-align:center\">0.0444370</td>\n<td style=\"text-align:center\">0.0075515</td>\n<td style=\"text-align:center\">0.0020714</td>\n<td style=\"text-align:center\">0.0007639</td>\n<td style=\"text-align:center\">0.0003473</td>\n<td style=\"text-align:center\">0.0001850</td>\n<td style=\"text-align:center\">0.0001117</td>\n<td style=\"text-align:center\">0.0000746</td>\n<td style=\"text-align:center\">0.0000542</td>\n<td style=\"text-align:center\">0.0000423</td>\n<td style=\"text-align:center\">0.0000350</td>\n<td style=\"text-align:center\">0.0000305</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">23</td>\n<td style=\"text-align:center\">0.0425466</td>\n<td style=\"text-align:center\">0.0069361</td>\n<td style=\"text-align:center\">0.0018287</td>\n<td style=\"text-align:center\">0.0006493</td>\n<td style=\"text-align:center\">0.0002847</td>\n<td style=\"text-align:center\">0.0001466</td>\n<td style=\"text-align:center\">0.0000856</td>\n<td style=\"text-align:center\">0.0000555</td>\n<td style=\"text-align:center\">0.0000392</td>\n<td style=\"text-align:center\">0.0000297</td>\n<td style=\"text-align:center\">0.0000240</td>\n<td style=\"text-align:center\">0.0000204</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">24</td>\n<td style=\"text-align:center\">0.0408105</td>\n<td style=\"text-align:center\">0.0063929</td>\n<td style=\"text-align:center\">0.0016224</td>\n<td style=\"text-align:center\">0.0005554</td>\n<td style=\"text-align:center\">0.0002352</td>\n<td style=\"text-align:center\">0.0001171</td>\n<td style=\"text-align:center\">0.0000663</td>\n<td style=\"text-align:center\">0.0000417</td>\n<td style=\"text-align:center\">0.0000286</td>\n<td style=\"text-align:center\">0.0000211</td>\n<td style=\"text-align:center\">0.0000166</td>\n<td style=\"text-align:center\">0.0000138</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">25</td>\n<td style=\"text-align:center\">0.0392106</td>\n<td style=\"text-align:center\">0.0059111</td>\n<td style=\"text-align:center\">0.0014459</td>\n<td style=\"text-align:center\">0.0004779</td>\n<td style=\"text-align:center\">0.0001957</td>\n<td style=\"text-align:center\">0.0000944</td>\n<td style=\"text-align:center\">0.0000518</td>\n<td style=\"text-align:center\">0.0000316</td>\n<td style=\"text-align:center\">0.0000211</td>\n<td style=\"text-align:center\">0.0000152</td>\n<td style=\"text-align:center\">0.0000116</td>\n<td style=\"text-align:center\">0.0000094</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">26</td>\n<td style=\"text-align:center\">0.0377313</td>\n<td style=\"text-align:center\">0.0054818</td>\n<td style=\"text-align:center\">0.0012942</td>\n<td style=\"text-align:center\">0.0004135</td>\n<td style=\"text-align:center\">0.0001639</td>\n<td style=\"text-align:center\">0.0000766</td>\n<td style=\"text-align:center\">0.0000408</td>\n<td style=\"text-align:center\">0.0000242</td>\n<td style=\"text-align:center\">0.0000157</td>\n<td style=\"text-align:center\">0.0000110</td>\n<td style=\"text-align:center\">0.0000082</td>\n<td style=\"text-align:center\">0.0000065</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">27</td>\n<td style=\"text-align:center\">0.0363596</td>\n<td style=\"text-align:center\">0.0050975</td>\n<td style=\"text-align:center\">0.0011629</td>\n<td style=\"text-align:center\">0.0003595</td>\n<td style=\"text-align:center\">0.0001381</td>\n<td style=\"text-align:center\">0.0000626</td>\n<td style=\"text-align:center\">0.0000324</td>\n<td style=\"text-align:center\">0.0000187</td>\n<td style=\"text-align:center\">0.0000118</td>\n<td style=\"text-align:center\">0.0000081</td>\n<td style=\"text-align:center\">0.0000059</td>\n<td style=\"text-align:center\">0.0000046</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">28</td>\n<td style=\"text-align:center\">0.0350841</td>\n<td style=\"text-align:center\">0.0047523</td>\n<td style=\"text-align:center\">0.0010489</td>\n<td style=\"text-align:center\">0.0003141</td>\n<td style=\"text-align:center\">0.0001170</td>\n<td style=\"text-align:center\">0.0000515</td>\n<td style=\"text-align:center\">0.0000259</td>\n<td style=\"text-align:center\">0.0000146</td>\n<td style=\"text-align:center\">0.0000090</td>\n<td style=\"text-align:center\">0.0000060</td>\n<td style=\"text-align:center\">0.0000043</td>\n<td style=\"text-align:center\">0.0000032</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">29</td>\n<td style=\"text-align:center\">0.0338950</td>\n<td style=\"text-align:center\">0.0044410</td>\n<td style=\"text-align:center\">0.0009492</td>\n<td style=\"text-align:center\">0.0002756</td>\n<td style=\"text-align:center\">0.0000996</td>\n<td style=\"text-align:center\">0.0000426</td>\n<td style=\"text-align:center\">0.0000209</td>\n<td style=\"text-align:center\">0.0000114</td>\n<td style=\"text-align:center\">0.0000069</td>\n<td style=\"text-align:center\">0.0000045</td>\n<td style=\"text-align:center\">0.0000031</td>\n<td style=\"text-align:center\">0.0000023</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">0.0327839</td>\n<td style=\"text-align:center\">0.0041593</td>\n<td style=\"text-align:center\">0.0008618</td>\n<td style=\"text-align:center\">0.0002428</td>\n<td style=\"text-align:center\">0.0000853</td>\n<td style=\"text-align:center\">0.0000355</td>\n<td style=\"text-align:center\">0.0000169</td>\n<td style=\"text-align:center\">0.0000090</td>\n<td style=\"text-align:center\">0.0000053</td>\n<td style=\"text-align:center\">0.0000034</td>\n<td style=\"text-align:center\">0.0000023</td>\n<td style=\"text-align:center\">0.0000016</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">31</td>\n<td style=\"text-align:center\">0.0317433</td>\n<td style=\"text-align:center\">0.0039036</td>\n<td style=\"text-align:center\">0.0007848</td>\n<td style=\"text-align:center\">0.0002147</td>\n<td style=\"text-align:center\">0.0000733</td>\n<td style=\"text-align:center\">0.0000297</td>\n<td style=\"text-align:center\">0.0000138</td>\n<td style=\"text-align:center\">0.0000072</td>\n<td style=\"text-align:center\">0.0000041</td>\n<td style=\"text-align:center\">0.0000025</td>\n<td style=\"text-align:center\">0.0000017</td>\n<td style=\"text-align:center\">0.0000012</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">32</td>\n<td style=\"text-align:center\">0.0307668</td>\n<td style=\"text-align:center\">0.0036708</td>\n<td style=\"text-align:center\">0.0007167</td>\n<td style=\"text-align:center\">0.0001906</td>\n<td style=\"text-align:center\">0.0000633</td>\n<td style=\"text-align:center\">0.0000250</td>\n<td style=\"text-align:center\">0.0000113</td>\n<td style=\"text-align:center\">0.0000057</td>\n<td style=\"text-align:center\">0.0000032</td>\n<td style=\"text-align:center\">0.0000019</td>\n<td style=\"text-align:center\">0.0000013</td>\n<td style=\"text-align:center\">0.0000009</td>\n</tr>\n</tbody>\n</table>\n<p>画图可以看出变化曲线，如下图。</p>\n<p><img src=\"/2018/05/07/Bloom-Filter/error_rate_fig.png\" alt=\"\"></p>\n<p>通过上表，我们来计算本文开头的那个问题，假设我们有N=10,000,000个元素，容忍&lt;0.0001的错误率，大概需要多大的空间，通过查表，我们知道当m/n=20，k=10时，错误率大概在0.0000889，满足条件，其空间消耗为<strong>190.73MB</strong>。</p>\n<p>上面我们选取的m/n的值和k的值是比较随意的，那么k的个数是否存在最优解呢？答案是<strong>Yes</strong>。</p>\n<p>在这里不再进行推导，k的最优值大致为</p>\n<p>$$ k=\\frac{m}{n} \\ln2\\approx 0.7\\frac{m}{n} $$</p>\n<p>因此对应上面问题其最优k值应该为<strong>14</strong>。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>布隆过滤器通过引入一定的错误率以及同时使用多个哈希函数，大大提高了空间使用效率，这使得在海量数据中进行判重更加高效。但是标准的布隆过滤器只支持添加而不支持删除，因此也有相关研究提出了可计数型布隆过滤器(Counting Bloom Filter)，在此不进行讨论。</p>"},{"title":"使用一维索引数组访问高维数组元素","date":"2017-03-30T06:34:10.000Z","_content":"\n这是这两天看书偶然间突然间想到的一个问题，假设有一个高维数组，比如3维整型数组`int arr[10][10][10];`，用户每次输入对应维数个数(3)个参数，存入一个索引数组`int idx[3]`中，根据索引返回对应索引的元素值。在低维情况下，可以采取直接访问的方式，比如输入的索引值为`idx[0] = 1, idx[1] = 2, idx[2] = 3`，可以通过`arr[idx[0]][idx[1]][idx[2]]`访问，但是如果数组维度太高，这样的方式就不可行了，比如`arr[idx[0]][idx[1]]....[idx[n]]`。所以需要换种方式。\n\n<!-- more -->\n\n**指针**\n\n我们知道，C/C++中数组的存放是采用连续内存单元的形式:\n\n![c_1d_array](c_1d_array.png)\n\n对一个长度为6的一维整型数组(`int a[6]`)，运行时将会分配一段连续的内存，我们可以通过`a[4]`来访问元素，其实这可以看做隐式的指针访问，即`*(a+4)`，该操作将会访问到第5个元素也就是`4`。\n\n对`*(a+4)`的访问过程可以这么理解:\n\n1. 得到数组a的基地址\n2. 在基地址的基础上加上偏移量`4`\n3. 获取该地址对应的整型值\n\n下面来看二维的情况。\n\n![c_2d_array](c_2d_array.png)\n\n对一个维度为3\\*3的二维整型数组(`int b[3][3]`)，运行时仍然会分配一段连续的内存，直接访问的方式和上面讲的一样，比如`b[1][2]`，同样，这可以看做`*(*(b+1)+2)`，该操作会访问到第二行第三列的元素也就是`5`，其中，`b+1`的操作对应于取第几行元素，`+2`的操作就对应于一维的偏移了，具体细节不再展开讨论。\n\n因此对于一个高维数组，比如四维数组`int c[5][5][5][5]`，`c[0][1][2][3]`代表的意思即是取`c`数组中第一维维度为`0`、第二维维度为`1`、第三维维度为`2`、第四维维度为`3`的对应元素，有了这样的理解，再看`*(*(*(*(c+0)+1)+2)+3)`就清晰多了。\n\n**问题**\n\n那么对于一个高维数组(100维、1000维等等)，就没有办法用代码直接写`*(*(*(....*(d+k1)+k2)+...+kn)`了，所以需要换个思路。\n\n既然内存单元存储的是实际值或者是地址，那么经过多次寻址，我们可以找到需要的实际值，那么怎么完成这个操作呢？\n\n我们仍然使用四维数组为例，假设有:\n\n```C\nint arr[10][10][10][10] = {0};\narr[1][2][3][4] = 1;\n```\n\n同时，索引数组为:\n\n```C\nint idx[4] = {1, 2, 3, 4};\n```\n\n我们想要的结果是得到`1`，可以直接通过`arr[idx[0]][idx[1]][idx[2]][idx[3]]`访问，但之前也说过了，这样的代码无法适用于高维情况。\n\n**`void *`(不那么好)**\n\n最开始我想到的方式是使用`void *`指针，因为C中任意指针都可以赋值给`void *`指针，那么我们访问元素的思路可以这么理解:\n\n1. 将数组`arr`的基地址赋值给`void *`指针\n2. 根据每一维索引的偏移量以及`int`类型的大小计算`void *`指针的值\n3. 将`void *`指针强制类型转换为`int *`指针并进行元素访问`*p`\n\n需要注意的是第二步中，索引的偏移量代表的是`int`尺度的偏移，即对于`int a[2]`, `&a[0]`和`&a[1]`之间的偏移量，因此需要乘以`int`类型的大小。根据上面的描述，测试代码如下:\n\n```C\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 10\n\nint main()\n{\n    int arr[N][N][N][N] = {0};\n    int idx[4] = {1, 2, 3, 4};\n    arr[1][2][3][4] = 1;\n    cout<<\"Expected: \"<<arr[1][2][3][4]<<\" at \"<<&arr[1][2][3][4]<<endl;\n\n    void *p = arr;\n    for(int i = 0; i < 4; i++)\n        p += idx[i] * int(pow(N, 3-i)) * sizeof(int);\n    cout<<\"Got with void *: \";\n    cout<<*((int*)p)<<\" at \"<<p<<endl;\n\n    return 0;\n}\n```\n\n结果:\n\n```\ntest.cpp: In function 'int main()':\ntest.cpp:21:53: warning: pointer of type 'void *' used in arithmetic [-Wpointer-arith]\n         p += idx[i] * int(pow(10, 3-i)) * sizeof(int);\n                                                     ^\nExpected: 1 at 0x7fff5cb20f18\nGot with void *: 1 at 0x7fff5cb20f18\n```\n\n程序正确地得到了我们想要的结果，但是编译器给出了警告，因为`void *`指针是未知类型指针，因此编译器并不知道相关计算，另外还有在计算偏移尺度的时候，使用了`pow`函数而且使用了强制类型转换将其转为`int`，这可能导致舍入误差。\n\n**`int *`改进**\n\n对于前述的方法，我们可以使用`int *`指针以及自己计算偏移尺度进行改进，通过将`arr`进行强制类型转换，赋值给整型指针`p`，在前面我们谈到数组的内存分配是连续的，因此我们只需要正确的计算出偏移量即可通过`p`指针得到所需要的值，此时因为使用的是整型指针`p`，因此不再需要乘以`sizeof(int)`，可以理解为`p+1`指向了下一个整型单元。\n\n```C\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 10\n\nint main()\n{\n    int arr[N][N][N][N] = {0};\n    int idx[4] = {1, 2, 3, 4};\n    arr[1][2][3][4] = 1;\n    cout<<\"Expected: \"<<arr[1][2][3][4]<<\" at \"<<&arr[1][2][3][4]<<endl;\n\n    int *p = (int *)arr;\n    int offset = 1e3;\n    for(int i = 0; i < 4; i++)\n    {\n        p += idx[i] * offset;\n        offset /= 10;\n    }\n    cout<<\"Got with int *: \";\n    cout<<*p<<\" at \"<<p<<endl;\n\n    return 0;\n}\n```\n\n结果:\n\n```\nExpected: 1 at 0x7fff51d37f08\nGot with int *: 1 at 0x7fff51d37f08\n```\n\n**后话**\n\n以上方法需要对指针以及指针的运算有一定的了解，当然，更多情况下，我们完全可以将高维数组展开成低维甚至一维数组，这样的访问将会很方便。或许处理这种问题还有其他更好的方式，有兴趣的读者可以自行研究。","source":"_posts/CPP-Access-n-d-array-with-1-d-index-array.md","raw":"---\ntitle: 使用一维索引数组访问高维数组元素\ndate: 2017-03-30 14:34:10\ntags: [CPP,指针,数组]\ncategories: CPP\n---\n\n这是这两天看书偶然间突然间想到的一个问题，假设有一个高维数组，比如3维整型数组`int arr[10][10][10];`，用户每次输入对应维数个数(3)个参数，存入一个索引数组`int idx[3]`中，根据索引返回对应索引的元素值。在低维情况下，可以采取直接访问的方式，比如输入的索引值为`idx[0] = 1, idx[1] = 2, idx[2] = 3`，可以通过`arr[idx[0]][idx[1]][idx[2]]`访问，但是如果数组维度太高，这样的方式就不可行了，比如`arr[idx[0]][idx[1]]....[idx[n]]`。所以需要换种方式。\n\n<!-- more -->\n\n**指针**\n\n我们知道，C/C++中数组的存放是采用连续内存单元的形式:\n\n![c_1d_array](c_1d_array.png)\n\n对一个长度为6的一维整型数组(`int a[6]`)，运行时将会分配一段连续的内存，我们可以通过`a[4]`来访问元素，其实这可以看做隐式的指针访问，即`*(a+4)`，该操作将会访问到第5个元素也就是`4`。\n\n对`*(a+4)`的访问过程可以这么理解:\n\n1. 得到数组a的基地址\n2. 在基地址的基础上加上偏移量`4`\n3. 获取该地址对应的整型值\n\n下面来看二维的情况。\n\n![c_2d_array](c_2d_array.png)\n\n对一个维度为3\\*3的二维整型数组(`int b[3][3]`)，运行时仍然会分配一段连续的内存，直接访问的方式和上面讲的一样，比如`b[1][2]`，同样，这可以看做`*(*(b+1)+2)`，该操作会访问到第二行第三列的元素也就是`5`，其中，`b+1`的操作对应于取第几行元素，`+2`的操作就对应于一维的偏移了，具体细节不再展开讨论。\n\n因此对于一个高维数组，比如四维数组`int c[5][5][5][5]`，`c[0][1][2][3]`代表的意思即是取`c`数组中第一维维度为`0`、第二维维度为`1`、第三维维度为`2`、第四维维度为`3`的对应元素，有了这样的理解，再看`*(*(*(*(c+0)+1)+2)+3)`就清晰多了。\n\n**问题**\n\n那么对于一个高维数组(100维、1000维等等)，就没有办法用代码直接写`*(*(*(....*(d+k1)+k2)+...+kn)`了，所以需要换个思路。\n\n既然内存单元存储的是实际值或者是地址，那么经过多次寻址，我们可以找到需要的实际值，那么怎么完成这个操作呢？\n\n我们仍然使用四维数组为例，假设有:\n\n```C\nint arr[10][10][10][10] = {0};\narr[1][2][3][4] = 1;\n```\n\n同时，索引数组为:\n\n```C\nint idx[4] = {1, 2, 3, 4};\n```\n\n我们想要的结果是得到`1`，可以直接通过`arr[idx[0]][idx[1]][idx[2]][idx[3]]`访问，但之前也说过了，这样的代码无法适用于高维情况。\n\n**`void *`(不那么好)**\n\n最开始我想到的方式是使用`void *`指针，因为C中任意指针都可以赋值给`void *`指针，那么我们访问元素的思路可以这么理解:\n\n1. 将数组`arr`的基地址赋值给`void *`指针\n2. 根据每一维索引的偏移量以及`int`类型的大小计算`void *`指针的值\n3. 将`void *`指针强制类型转换为`int *`指针并进行元素访问`*p`\n\n需要注意的是第二步中，索引的偏移量代表的是`int`尺度的偏移，即对于`int a[2]`, `&a[0]`和`&a[1]`之间的偏移量，因此需要乘以`int`类型的大小。根据上面的描述，测试代码如下:\n\n```C\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 10\n\nint main()\n{\n    int arr[N][N][N][N] = {0};\n    int idx[4] = {1, 2, 3, 4};\n    arr[1][2][3][4] = 1;\n    cout<<\"Expected: \"<<arr[1][2][3][4]<<\" at \"<<&arr[1][2][3][4]<<endl;\n\n    void *p = arr;\n    for(int i = 0; i < 4; i++)\n        p += idx[i] * int(pow(N, 3-i)) * sizeof(int);\n    cout<<\"Got with void *: \";\n    cout<<*((int*)p)<<\" at \"<<p<<endl;\n\n    return 0;\n}\n```\n\n结果:\n\n```\ntest.cpp: In function 'int main()':\ntest.cpp:21:53: warning: pointer of type 'void *' used in arithmetic [-Wpointer-arith]\n         p += idx[i] * int(pow(10, 3-i)) * sizeof(int);\n                                                     ^\nExpected: 1 at 0x7fff5cb20f18\nGot with void *: 1 at 0x7fff5cb20f18\n```\n\n程序正确地得到了我们想要的结果，但是编译器给出了警告，因为`void *`指针是未知类型指针，因此编译器并不知道相关计算，另外还有在计算偏移尺度的时候，使用了`pow`函数而且使用了强制类型转换将其转为`int`，这可能导致舍入误差。\n\n**`int *`改进**\n\n对于前述的方法，我们可以使用`int *`指针以及自己计算偏移尺度进行改进，通过将`arr`进行强制类型转换，赋值给整型指针`p`，在前面我们谈到数组的内存分配是连续的，因此我们只需要正确的计算出偏移量即可通过`p`指针得到所需要的值，此时因为使用的是整型指针`p`，因此不再需要乘以`sizeof(int)`，可以理解为`p+1`指向了下一个整型单元。\n\n```C\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 10\n\nint main()\n{\n    int arr[N][N][N][N] = {0};\n    int idx[4] = {1, 2, 3, 4};\n    arr[1][2][3][4] = 1;\n    cout<<\"Expected: \"<<arr[1][2][3][4]<<\" at \"<<&arr[1][2][3][4]<<endl;\n\n    int *p = (int *)arr;\n    int offset = 1e3;\n    for(int i = 0; i < 4; i++)\n    {\n        p += idx[i] * offset;\n        offset /= 10;\n    }\n    cout<<\"Got with int *: \";\n    cout<<*p<<\" at \"<<p<<endl;\n\n    return 0;\n}\n```\n\n结果:\n\n```\nExpected: 1 at 0x7fff51d37f08\nGot with int *: 1 at 0x7fff51d37f08\n```\n\n**后话**\n\n以上方法需要对指针以及指针的运算有一定的了解，当然，更多情况下，我们完全可以将高维数组展开成低维甚至一维数组，这样的访问将会很方便。或许处理这种问题还有其他更好的方式，有兴趣的读者可以自行研究。","slug":"CPP-Access-n-d-array-with-1-d-index-array","published":1,"updated":"2018-01-13T00:50:39.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgvnqmkj000bw628o2xttoz2","content":"<p>这是这两天看书偶然间突然间想到的一个问题，假设有一个高维数组，比如3维整型数组<code>int arr[10][10][10];</code>，用户每次输入对应维数个数(3)个参数，存入一个索引数组<code>int idx[3]</code>中，根据索引返回对应索引的元素值。在低维情况下，可以采取直接访问的方式，比如输入的索引值为<code>idx[0] = 1, idx[1] = 2, idx[2] = 3</code>，可以通过<code>arr[idx[0]][idx[1]][idx[2]]</code>访问，但是如果数组维度太高，这样的方式就不可行了，比如<code>arr[idx[0]][idx[1]]....[idx[n]]</code>。所以需要换种方式。</p>\n<a id=\"more\"></a>\n<p><strong>指针</strong></p>\n<p>我们知道，C/C++中数组的存放是采用连续内存单元的形式:</p>\n<p><img src=\"/2017/03/30/CPP-Access-n-d-array-with-1-d-index-array/c_1d_array.png\" alt=\"c_1d_array\"></p>\n<p>对一个长度为6的一维整型数组(<code>int a[6]</code>)，运行时将会分配一段连续的内存，我们可以通过<code>a[4]</code>来访问元素，其实这可以看做隐式的指针访问，即<code>*(a+4)</code>，该操作将会访问到第5个元素也就是<code>4</code>。</p>\n<p>对<code>*(a+4)</code>的访问过程可以这么理解:</p>\n<ol>\n<li>得到数组a的基地址</li>\n<li>在基地址的基础上加上偏移量<code>4</code></li>\n<li>获取该地址对应的整型值</li>\n</ol>\n<p>下面来看二维的情况。</p>\n<p><img src=\"/2017/03/30/CPP-Access-n-d-array-with-1-d-index-array/c_2d_array.png\" alt=\"c_2d_array\"></p>\n<p>对一个维度为3*3的二维整型数组(<code>int b[3][3]</code>)，运行时仍然会分配一段连续的内存，直接访问的方式和上面讲的一样，比如<code>b[1][2]</code>，同样，这可以看做<code>*(*(b+1)+2)</code>，该操作会访问到第二行第三列的元素也就是<code>5</code>，其中，<code>b+1</code>的操作对应于取第几行元素，<code>+2</code>的操作就对应于一维的偏移了，具体细节不再展开讨论。</p>\n<p>因此对于一个高维数组，比如四维数组<code>int c[5][5][5][5]</code>，<code>c[0][1][2][3]</code>代表的意思即是取<code>c</code>数组中第一维维度为<code>0</code>、第二维维度为<code>1</code>、第三维维度为<code>2</code>、第四维维度为<code>3</code>的对应元素，有了这样的理解，再看<code>*(*(*(*(c+0)+1)+2)+3)</code>就清晰多了。</p>\n<p><strong>问题</strong></p>\n<p>那么对于一个高维数组(100维、1000维等等)，就没有办法用代码直接写<code>*(*(*(....*(d+k1)+k2)+...+kn)</code>了，所以需要换个思路。</p>\n<p>既然内存单元存储的是实际值或者是地址，那么经过多次寻址，我们可以找到需要的实际值，那么怎么完成这个操作呢？</p>\n<p>我们仍然使用四维数组为例，假设有:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">10</span>][<span class=\"number\">10</span>][<span class=\"number\">10</span>][<span class=\"number\">10</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">arr[<span class=\"number\">1</span>][<span class=\"number\">2</span>][<span class=\"number\">3</span>][<span class=\"number\">4</span>] = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>同时，索引数组为:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> idx[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们想要的结果是得到<code>1</code>，可以直接通过<code>arr[idx[0]][idx[1]][idx[2]][idx[3]]</code>访问，但之前也说过了，这样的代码无法适用于高维情况。</p>\n<p><strong><code>void *</code>(不那么好)</strong></p>\n<p>最开始我想到的方式是使用<code>void *</code>指针，因为C中任意指针都可以赋值给<code>void *</code>指针，那么我们访问元素的思路可以这么理解:</p>\n<ol>\n<li>将数组<code>arr</code>的基地址赋值给<code>void *</code>指针</li>\n<li>根据每一维索引的偏移量以及<code>int</code>类型的大小计算<code>void *</code>指针的值</li>\n<li>将<code>void *</code>指针强制类型转换为<code>int *</code>指针并进行元素访问<code>*p</code></li>\n</ol>\n<p>需要注意的是第二步中，索引的偏移量代表的是<code>int</code>尺度的偏移，即对于<code>int a[2]</code>, <code>&amp;a[0]</code>和<code>&amp;a[1]</code>之间的偏移量，因此需要乘以<code>int</code>类型的大小。根据上面的描述，测试代码如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[N][N][N][N] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">    arr[<span class=\"number\">1</span>][<span class=\"number\">2</span>][<span class=\"number\">3</span>][<span class=\"number\">4</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"Expected: \"</span>&lt;&lt;arr[<span class=\"number\">1</span>][<span class=\"number\">2</span>][<span class=\"number\">3</span>][<span class=\"number\">4</span>]&lt;&lt;<span class=\"string\">\" at \"</span>&lt;&lt;&amp;arr[<span class=\"number\">1</span>][<span class=\"number\">2</span>][<span class=\"number\">3</span>][<span class=\"number\">4</span>]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *p = arr;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</span><br><span class=\"line\">        p += idx[i] * <span class=\"keyword\">int</span>(<span class=\"built_in\">pow</span>(N, <span class=\"number\">3</span>-i)) * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"Got with void *: \"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;*((<span class=\"keyword\">int</span>*)p)&lt;&lt;<span class=\"string\">\" at \"</span>&lt;&lt;p&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test.cpp: In function &apos;int main()&apos;:</span><br><span class=\"line\">test.cpp:21:53: warning: pointer of type &apos;void *&apos; used in arithmetic [-Wpointer-arith]</span><br><span class=\"line\">         p += idx[i] * int(pow(10, 3-i)) * sizeof(int);</span><br><span class=\"line\">                                                     ^</span><br><span class=\"line\">Expected: 1 at 0x7fff5cb20f18</span><br><span class=\"line\">Got with void *: 1 at 0x7fff5cb20f18</span><br></pre></td></tr></table></figure>\n<p>程序正确地得到了我们想要的结果，但是编译器给出了警告，因为<code>void *</code>指针是未知类型指针，因此编译器并不知道相关计算，另外还有在计算偏移尺度的时候，使用了<code>pow</code>函数而且使用了强制类型转换将其转为<code>int</code>，这可能导致舍入误差。</p>\n<p><strong><code>int *</code>改进</strong></p>\n<p>对于前述的方法，我们可以使用<code>int *</code>指针以及自己计算偏移尺度进行改进，通过将<code>arr</code>进行强制类型转换，赋值给整型指针<code>p</code>，在前面我们谈到数组的内存分配是连续的，因此我们只需要正确的计算出偏移量即可通过<code>p</code>指针得到所需要的值，此时因为使用的是整型指针<code>p</code>，因此不再需要乘以<code>sizeof(int)</code>，可以理解为<code>p+1</code>指向了下一个整型单元。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[N][N][N][N] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">    arr[<span class=\"number\">1</span>][<span class=\"number\">2</span>][<span class=\"number\">3</span>][<span class=\"number\">4</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"Expected: \"</span>&lt;&lt;arr[<span class=\"number\">1</span>][<span class=\"number\">2</span>][<span class=\"number\">3</span>][<span class=\"number\">4</span>]&lt;&lt;<span class=\"string\">\" at \"</span>&lt;&lt;&amp;arr[<span class=\"number\">1</span>][<span class=\"number\">2</span>][<span class=\"number\">3</span>][<span class=\"number\">4</span>]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = (<span class=\"keyword\">int</span> *)arr;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> offset = <span class=\"number\">1e3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p += idx[i] * offset;</span><br><span class=\"line\">        offset /= <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"Got with int *: \"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"string\">\" at \"</span>&lt;&lt;p&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Expected: 1 at 0x7fff51d37f08</span><br><span class=\"line\">Got with int *: 1 at 0x7fff51d37f08</span><br></pre></td></tr></table></figure>\n<p><strong>后话</strong></p>\n<p>以上方法需要对指针以及指针的运算有一定的了解，当然，更多情况下，我们完全可以将高维数组展开成低维甚至一维数组，这样的访问将会很方便。或许处理这种问题还有其他更好的方式，有兴趣的读者可以自行研究。</p>\n","site":{"data":{}},"excerpt":"<p>这是这两天看书偶然间突然间想到的一个问题，假设有一个高维数组，比如3维整型数组<code>int arr[10][10][10];</code>，用户每次输入对应维数个数(3)个参数，存入一个索引数组<code>int idx[3]</code>中，根据索引返回对应索引的元素值。在低维情况下，可以采取直接访问的方式，比如输入的索引值为<code>idx[0] = 1, idx[1] = 2, idx[2] = 3</code>，可以通过<code>arr[idx[0]][idx[1]][idx[2]]</code>访问，但是如果数组维度太高，这样的方式就不可行了，比如<code>arr[idx[0]][idx[1]]....[idx[n]]</code>。所以需要换种方式。</p>","more":"<p><strong>指针</strong></p>\n<p>我们知道，C/C++中数组的存放是采用连续内存单元的形式:</p>\n<p><img src=\"/2017/03/30/CPP-Access-n-d-array-with-1-d-index-array/c_1d_array.png\" alt=\"c_1d_array\"></p>\n<p>对一个长度为6的一维整型数组(<code>int a[6]</code>)，运行时将会分配一段连续的内存，我们可以通过<code>a[4]</code>来访问元素，其实这可以看做隐式的指针访问，即<code>*(a+4)</code>，该操作将会访问到第5个元素也就是<code>4</code>。</p>\n<p>对<code>*(a+4)</code>的访问过程可以这么理解:</p>\n<ol>\n<li>得到数组a的基地址</li>\n<li>在基地址的基础上加上偏移量<code>4</code></li>\n<li>获取该地址对应的整型值</li>\n</ol>\n<p>下面来看二维的情况。</p>\n<p><img src=\"/2017/03/30/CPP-Access-n-d-array-with-1-d-index-array/c_2d_array.png\" alt=\"c_2d_array\"></p>\n<p>对一个维度为3*3的二维整型数组(<code>int b[3][3]</code>)，运行时仍然会分配一段连续的内存，直接访问的方式和上面讲的一样，比如<code>b[1][2]</code>，同样，这可以看做<code>*(*(b+1)+2)</code>，该操作会访问到第二行第三列的元素也就是<code>5</code>，其中，<code>b+1</code>的操作对应于取第几行元素，<code>+2</code>的操作就对应于一维的偏移了，具体细节不再展开讨论。</p>\n<p>因此对于一个高维数组，比如四维数组<code>int c[5][5][5][5]</code>，<code>c[0][1][2][3]</code>代表的意思即是取<code>c</code>数组中第一维维度为<code>0</code>、第二维维度为<code>1</code>、第三维维度为<code>2</code>、第四维维度为<code>3</code>的对应元素，有了这样的理解，再看<code>*(*(*(*(c+0)+1)+2)+3)</code>就清晰多了。</p>\n<p><strong>问题</strong></p>\n<p>那么对于一个高维数组(100维、1000维等等)，就没有办法用代码直接写<code>*(*(*(....*(d+k1)+k2)+...+kn)</code>了，所以需要换个思路。</p>\n<p>既然内存单元存储的是实际值或者是地址，那么经过多次寻址，我们可以找到需要的实际值，那么怎么完成这个操作呢？</p>\n<p>我们仍然使用四维数组为例，假设有:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">10</span>][<span class=\"number\">10</span>][<span class=\"number\">10</span>][<span class=\"number\">10</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">arr[<span class=\"number\">1</span>][<span class=\"number\">2</span>][<span class=\"number\">3</span>][<span class=\"number\">4</span>] = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>同时，索引数组为:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> idx[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们想要的结果是得到<code>1</code>，可以直接通过<code>arr[idx[0]][idx[1]][idx[2]][idx[3]]</code>访问，但之前也说过了，这样的代码无法适用于高维情况。</p>\n<p><strong><code>void *</code>(不那么好)</strong></p>\n<p>最开始我想到的方式是使用<code>void *</code>指针，因为C中任意指针都可以赋值给<code>void *</code>指针，那么我们访问元素的思路可以这么理解:</p>\n<ol>\n<li>将数组<code>arr</code>的基地址赋值给<code>void *</code>指针</li>\n<li>根据每一维索引的偏移量以及<code>int</code>类型的大小计算<code>void *</code>指针的值</li>\n<li>将<code>void *</code>指针强制类型转换为<code>int *</code>指针并进行元素访问<code>*p</code></li>\n</ol>\n<p>需要注意的是第二步中，索引的偏移量代表的是<code>int</code>尺度的偏移，即对于<code>int a[2]</code>, <code>&amp;a[0]</code>和<code>&amp;a[1]</code>之间的偏移量，因此需要乘以<code>int</code>类型的大小。根据上面的描述，测试代码如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[N][N][N][N] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">    arr[<span class=\"number\">1</span>][<span class=\"number\">2</span>][<span class=\"number\">3</span>][<span class=\"number\">4</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"Expected: \"</span>&lt;&lt;arr[<span class=\"number\">1</span>][<span class=\"number\">2</span>][<span class=\"number\">3</span>][<span class=\"number\">4</span>]&lt;&lt;<span class=\"string\">\" at \"</span>&lt;&lt;&amp;arr[<span class=\"number\">1</span>][<span class=\"number\">2</span>][<span class=\"number\">3</span>][<span class=\"number\">4</span>]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> *p = arr;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</span><br><span class=\"line\">        p += idx[i] * <span class=\"keyword\">int</span>(<span class=\"built_in\">pow</span>(N, <span class=\"number\">3</span>-i)) * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"Got with void *: \"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;*((<span class=\"keyword\">int</span>*)p)&lt;&lt;<span class=\"string\">\" at \"</span>&lt;&lt;p&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test.cpp: In function &apos;int main()&apos;:</span><br><span class=\"line\">test.cpp:21:53: warning: pointer of type &apos;void *&apos; used in arithmetic [-Wpointer-arith]</span><br><span class=\"line\">         p += idx[i] * int(pow(10, 3-i)) * sizeof(int);</span><br><span class=\"line\">                                                     ^</span><br><span class=\"line\">Expected: 1 at 0x7fff5cb20f18</span><br><span class=\"line\">Got with void *: 1 at 0x7fff5cb20f18</span><br></pre></td></tr></table></figure>\n<p>程序正确地得到了我们想要的结果，但是编译器给出了警告，因为<code>void *</code>指针是未知类型指针，因此编译器并不知道相关计算，另外还有在计算偏移尺度的时候，使用了<code>pow</code>函数而且使用了强制类型转换将其转为<code>int</code>，这可能导致舍入误差。</p>\n<p><strong><code>int *</code>改进</strong></p>\n<p>对于前述的方法，我们可以使用<code>int *</code>指针以及自己计算偏移尺度进行改进，通过将<code>arr</code>进行强制类型转换，赋值给整型指针<code>p</code>，在前面我们谈到数组的内存分配是连续的，因此我们只需要正确的计算出偏移量即可通过<code>p</code>指针得到所需要的值，此时因为使用的是整型指针<code>p</code>，因此不再需要乘以<code>sizeof(int)</code>，可以理解为<code>p+1</code>指向了下一个整型单元。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[N][N][N][N] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idx[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">    arr[<span class=\"number\">1</span>][<span class=\"number\">2</span>][<span class=\"number\">3</span>][<span class=\"number\">4</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"Expected: \"</span>&lt;&lt;arr[<span class=\"number\">1</span>][<span class=\"number\">2</span>][<span class=\"number\">3</span>][<span class=\"number\">4</span>]&lt;&lt;<span class=\"string\">\" at \"</span>&lt;&lt;&amp;arr[<span class=\"number\">1</span>][<span class=\"number\">2</span>][<span class=\"number\">3</span>][<span class=\"number\">4</span>]&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> *p = (<span class=\"keyword\">int</span> *)arr;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> offset = <span class=\"number\">1e3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        p += idx[i] * offset;</span><br><span class=\"line\">        offset /= <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"Got with int *: \"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"string\">\" at \"</span>&lt;&lt;p&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Expected: 1 at 0x7fff51d37f08</span><br><span class=\"line\">Got with int *: 1 at 0x7fff51d37f08</span><br></pre></td></tr></table></figure>\n<p><strong>后话</strong></p>\n<p>以上方法需要对指针以及指针的运算有一定的了解，当然，更多情况下，我们完全可以将高维数组展开成低维甚至一维数组，这样的访问将会很方便。或许处理这种问题还有其他更好的方式，有兴趣的读者可以自行研究。</p>"},{"title":"浅谈分布式缓存与一致性哈希算法","date":"2018-04-22T01:26:43.000Z","_content":"\n之前听到过一致性哈希算法，但是没有去进行了解。恰逢最近在看系统设计方面的内容，看到设计缓存系统的部分，对于如何合理有效地分配缓存而使用的一致性哈希算法进行了一些了解。\n\n<!-- more -->\n\n# 缓存\n\n缓存是目前各种应用中广泛使用的技术，比如DNS、Web服务器缓存等，是一种以空间换时间的方式。\n\n常见的缓存算法有很多，LRU（最久未使用)、LFU（最近最少使用）等等。下面简单介绍一下LRU算法。\n\n一个缓存算法应该支持这些操作：插入、删除、查找。对于LRU，为了实现快速查找，我们需要使用到哈希表，另外由于我们需要根据使用情况，快速调整一个对象的位置，那么我们很容易能想到使用链表来实现，同时由于需要从链表中删除一个对象后保证链表连接，因此我们需要使用到双向链表。\n\nLRU的工作流程如下：\n\n* 查找：给定一个键(key)，从LRU缓存中查询结果\n\t* 若该键存在于哈希表中：从哈希表中获取该键对应的值以及在双向链表中的位置，从双向链表中删除该键并调整前后结点的连接，将该键重新插入到链表头部，返回值。\n\t* 若该键不存在于哈希表中：直接返回告知调用者该键不存在。\n* 插入：给定一个键值对(key-val)，加入LRU缓存\n\t* 若该键存在于哈希表中：从哈希表中获取键在双向链表中的位置，从双向链表中删除该键并调整前后结点的连接，将该键重新插入到链表头部，更新哈希表中键对应的值。\n\t* 若该键不存在于哈希表中：（若LRU已满，获得链表最后一个结点的键，删除该结点以及其对应的哈希表的内容）将该键插入到链表头部，在哈希表中保存键对应的值以及链表位置。\n* 删除：给定一个键，从LRU缓存中删除\n\t* 若该键存在于哈希表中：从哈希表中获取键在双向链表中的位置，从双向链表中删除该键并调整前后结点的连接，从哈希表中删除该键。\n\t* 若该键不存在于哈希表中：直接返回。\n\n# 缓存并发性\n\n当多个客户端同时尝试更新缓存时，可能会发生读写冲突。例如两个客户端可能竞争相同的缓存槽，而最后一个更新缓存的客户端将获胜。要解决读写冲突，常见的方法就是使用锁，但是使用锁将带来严重的性能影响，那么如何优化呢？\n\n一种方法是缓存分成多个分片，为每个分片分配一个锁，这样客户端在理想情况下会更新不同分片的缓存，就不用再相互等待。但是在极端情况下，仍然无法避免竞争的问题。\n\n另一种方法是使用提交日志。所有的改动被存储到一个日志中，而不是立即对缓存进行更新。一些后台进程将异步执行日志来更新缓存。这一策略在数据库设计中经常使用。\n\n# 分布式缓存\n\n当我们的系统达到一定的规模时，我们需要将缓存分配给多台机器。假设我们有M台服务器以及N张图片需要缓存，我们希望通过3台服务器来缓存这N张图片，平衡服务器负载压力。\n\n## 随机分配\n\n考虑最简单的情况，我们直接将这N张图片随机分给M台服务器，每台分得N/M张图片，在这种情况下，如果我们想访问某个缓存项，我们需要遍历M台服务器去找到该缓存项，然而缓存的目的是为了提高速度，改善用户体验，减轻后端服务器压力，如果每次访问都需要遍历所有服务器，那么该缓存是很失败的。\n\n## 哈希表\n\n我们还可以在一台服务器上保存一张哈希表，这张哈希表能帮助我们找到某个缓存项在哪一台服务器上。这样做的好处是现在我们只需要访问2台服务器就能得到所需要的缓存项，但是缺点是使用了大量的空间来维护哈希表。\n\n## 取模运算\n\n常见的一种操作是对缓存项的键进行哈希计算，然后将hash之后的结果对服务器的数量进行取模运算，根据该结果来确定缓存会在哪一台服务器上。\n\n$$ idx = hash(pic\\\\_name) \\pmod{N} $$\n\n举例说明，有10条数据，3个结点，如果按照取模的方式，那么缓存的分配情况将会是：\n\n* Node A: 0, 3, 6, 9\n* Node B: 1, 4, 7\n* Node C: 2, 5, 8\n\n但是使用这种方法进行缓存时会有一些缺陷，如果3台缓存服务器不够用了我们应该怎么做呢？没错，增加额外的结点，我们考虑再增加一台服务器，此时分配情况将会变为：\n\n* Node A: 0, 4, 8\n* Node B: 1, 5, 9\n* Node C: 2, 6\n* Node D: 3, 7\n\n通过观察可以发现，数据3, 4, 5, 6, 7, 8, 9在增加结点之后，都被重新分配了位置，这一成本实在是太高，而在重新分配位置这一期间，缓存这段时间内是失效的，因此如果有客户端请求数据，应用将不得不向后端服务器请求。由于大量缓存同时失效，造成缓存雪崩，整个系统可能会被压垮，所以我们要避免这种情况的发生。\n\n# 一致性哈希算法\n\n我们在前文谈到了采用普通哈希算法会出现的问题。\n\n1. 当缓存服务器数量变化时，会引起缓存雪崩，可能导致系统崩溃。\n2. 当缓存服务器数量变化时，几乎所有缓存位置都会发生改变。\n\n其实第一个问题主要来源于第二个问题，因此我们只要能保证在缓存服务器数量变化时，尽量维持缓存的位置即可。因此在[Karger](https://zh.wikipedia.org/w/index.php?title=David_Karger&action=edit&redlink=1)等人1997年的一篇论文中介绍了“一致哈希”如何应用于用户易变的分布式Web服务中。哈希表中的每一个代表分布式系统中一个节点，在系统添加或删除节点只需要移动N/M项。\n\n## 过程\n\n一致性哈希算法也是取模的过程，不过不同于对服务器数量进行取模，一致性哈希是对$ 2^{32} $取模。\n\n我们可以想象一个环，这个环上面一共有$ 2^{32} $个点，顺时针从0开始计数: 0, 1, 2, ..., $ 2^{32} - 1 $，我们将该环称作哈希环，如下图所示。\n\n![hash_ring.png](hash_ring.png)\n\n对于我们已有的3台缓存服务器，我们通常对其IP地址进行哈希计算然后对$ 2^{32} $取模，得到一个$ 0 $到$ 2^{32} - 1 $之间的数，该数即服务器在环上位置，这样，我们能得到3台服务器在环上的位置，如下图所示。\n\n$$ idx = hash(server\\\\_ip) \\pmod{2^{32}} $$\n\n![servers_on_hash_ring.png](servers_on_hash_ring.png)\n\n同样道理，我们将需要缓存的对象也映射到哈希环上，可以使用图片名称来进行哈希。\n\n$$ idx = hash(pic\\\\_name) \\pmod{2^{32}} $$\n\n![pic_on_hash_ring.png](pic_on_hash_ring.png)\n\n现在服务器与缓存项都被映射到了哈希环上，我们最后需要决定缓存项被分配到哪一台服务器上，通常做法是沿着顺时针方向找到的第一台服务器就是缓存项应在的服务器，在本例中缓存项应被分配到服务器A上。\n\n![pic_belong.png](pic_belong.png)\n\n## 优点\n\n那么我们使用了一致性哈希算法后解决了缓存雪崩的问题了吗？\n\n考虑多个缓存项已经完成分配的情况下，服务器B出现了故障，如下图所示。\n\n![pics_on_hash_ring.png](pics_on_hash_ring.png)\n\n当我们失去服务器B以后，只需要移动两个缓存项，而不是近乎所有缓存项。\n\n## 哈希环偏斜\n\n在前面的论述中，我们理想地将3台服务器划分的很均匀，但是实际情况可能差得多，如下图所示。\n\n![bias_on_hash_ring.png](bias_on_hash_ring.png)\n\n在这种情况下，几乎所有的缓存项将被分配到服务器C，而A和B将会分得很少，一致性哈希算法提出了“虚拟结点”这一概念来解决这一问题。\n\n## 虚拟结点\n\n这一概念其实很简单，在增加一个结点到环上的时候，我们会为其分配多个位置（因为实际结点只有一个，因此多出来的结点就称为虚拟结点）。引入虚拟结点之后，缓存的分布就均衡多了，如下图所示。\n\n![virtual_nodes_on_hash_ring.png](virtual_nodes_on_hash_ring.png)\n\n## 实验\n\n通过编写相关代码，我模拟了拥有在5个服务器，每个服务器拥有150个结点的情况下，对100000个缓存项进行一致性哈希分配的过程，结果如下表所示。\n\n|服务器IP|缓存项数量|\n|:--:|:--:|\n|192.168.1.5|20216|\n|192.168.1.39|21106|\n|192.168.1.53|17599|\n|192.168.1.66|19560|\n|192.168.1.127|21519|\n\n可以看出，使用一致性哈希算法之后，每个服务器能够被比较均匀的分配到缓存项，同时如果增加或删除服务器，需要迁移的缓存项数量也基本符合N/M这一数量。\n\n有兴趣的读者可以参考我的实现代码[Github](https://github.com/Time1ess/MyProjects/tree/master/ConsistentHashRing)。\n\n# 参考文献\n\n* https://wizardforcel.gitbooks.io/gainlo-interview-guide/content/sd11.html\n* https://blog.csdn.net/gerryke/article/details/53939212\n* http://www.zsythink.net/archives/1182\n* https://zh.wikipedia.org/wiki/一致哈希\n","source":"_posts/Consistent-Hashing.md","raw":"---\ntitle: 浅谈分布式缓存与一致性哈希算法\ndate: 2018-04-22 09:26:43\ntags: [哈希算法, 分布式, 缓存]\ncategories: 系统架构\n---\n\n之前听到过一致性哈希算法，但是没有去进行了解。恰逢最近在看系统设计方面的内容，看到设计缓存系统的部分，对于如何合理有效地分配缓存而使用的一致性哈希算法进行了一些了解。\n\n<!-- more -->\n\n# 缓存\n\n缓存是目前各种应用中广泛使用的技术，比如DNS、Web服务器缓存等，是一种以空间换时间的方式。\n\n常见的缓存算法有很多，LRU（最久未使用)、LFU（最近最少使用）等等。下面简单介绍一下LRU算法。\n\n一个缓存算法应该支持这些操作：插入、删除、查找。对于LRU，为了实现快速查找，我们需要使用到哈希表，另外由于我们需要根据使用情况，快速调整一个对象的位置，那么我们很容易能想到使用链表来实现，同时由于需要从链表中删除一个对象后保证链表连接，因此我们需要使用到双向链表。\n\nLRU的工作流程如下：\n\n* 查找：给定一个键(key)，从LRU缓存中查询结果\n\t* 若该键存在于哈希表中：从哈希表中获取该键对应的值以及在双向链表中的位置，从双向链表中删除该键并调整前后结点的连接，将该键重新插入到链表头部，返回值。\n\t* 若该键不存在于哈希表中：直接返回告知调用者该键不存在。\n* 插入：给定一个键值对(key-val)，加入LRU缓存\n\t* 若该键存在于哈希表中：从哈希表中获取键在双向链表中的位置，从双向链表中删除该键并调整前后结点的连接，将该键重新插入到链表头部，更新哈希表中键对应的值。\n\t* 若该键不存在于哈希表中：（若LRU已满，获得链表最后一个结点的键，删除该结点以及其对应的哈希表的内容）将该键插入到链表头部，在哈希表中保存键对应的值以及链表位置。\n* 删除：给定一个键，从LRU缓存中删除\n\t* 若该键存在于哈希表中：从哈希表中获取键在双向链表中的位置，从双向链表中删除该键并调整前后结点的连接，从哈希表中删除该键。\n\t* 若该键不存在于哈希表中：直接返回。\n\n# 缓存并发性\n\n当多个客户端同时尝试更新缓存时，可能会发生读写冲突。例如两个客户端可能竞争相同的缓存槽，而最后一个更新缓存的客户端将获胜。要解决读写冲突，常见的方法就是使用锁，但是使用锁将带来严重的性能影响，那么如何优化呢？\n\n一种方法是缓存分成多个分片，为每个分片分配一个锁，这样客户端在理想情况下会更新不同分片的缓存，就不用再相互等待。但是在极端情况下，仍然无法避免竞争的问题。\n\n另一种方法是使用提交日志。所有的改动被存储到一个日志中，而不是立即对缓存进行更新。一些后台进程将异步执行日志来更新缓存。这一策略在数据库设计中经常使用。\n\n# 分布式缓存\n\n当我们的系统达到一定的规模时，我们需要将缓存分配给多台机器。假设我们有M台服务器以及N张图片需要缓存，我们希望通过3台服务器来缓存这N张图片，平衡服务器负载压力。\n\n## 随机分配\n\n考虑最简单的情况，我们直接将这N张图片随机分给M台服务器，每台分得N/M张图片，在这种情况下，如果我们想访问某个缓存项，我们需要遍历M台服务器去找到该缓存项，然而缓存的目的是为了提高速度，改善用户体验，减轻后端服务器压力，如果每次访问都需要遍历所有服务器，那么该缓存是很失败的。\n\n## 哈希表\n\n我们还可以在一台服务器上保存一张哈希表，这张哈希表能帮助我们找到某个缓存项在哪一台服务器上。这样做的好处是现在我们只需要访问2台服务器就能得到所需要的缓存项，但是缺点是使用了大量的空间来维护哈希表。\n\n## 取模运算\n\n常见的一种操作是对缓存项的键进行哈希计算，然后将hash之后的结果对服务器的数量进行取模运算，根据该结果来确定缓存会在哪一台服务器上。\n\n$$ idx = hash(pic\\\\_name) \\pmod{N} $$\n\n举例说明，有10条数据，3个结点，如果按照取模的方式，那么缓存的分配情况将会是：\n\n* Node A: 0, 3, 6, 9\n* Node B: 1, 4, 7\n* Node C: 2, 5, 8\n\n但是使用这种方法进行缓存时会有一些缺陷，如果3台缓存服务器不够用了我们应该怎么做呢？没错，增加额外的结点，我们考虑再增加一台服务器，此时分配情况将会变为：\n\n* Node A: 0, 4, 8\n* Node B: 1, 5, 9\n* Node C: 2, 6\n* Node D: 3, 7\n\n通过观察可以发现，数据3, 4, 5, 6, 7, 8, 9在增加结点之后，都被重新分配了位置，这一成本实在是太高，而在重新分配位置这一期间，缓存这段时间内是失效的，因此如果有客户端请求数据，应用将不得不向后端服务器请求。由于大量缓存同时失效，造成缓存雪崩，整个系统可能会被压垮，所以我们要避免这种情况的发生。\n\n# 一致性哈希算法\n\n我们在前文谈到了采用普通哈希算法会出现的问题。\n\n1. 当缓存服务器数量变化时，会引起缓存雪崩，可能导致系统崩溃。\n2. 当缓存服务器数量变化时，几乎所有缓存位置都会发生改变。\n\n其实第一个问题主要来源于第二个问题，因此我们只要能保证在缓存服务器数量变化时，尽量维持缓存的位置即可。因此在[Karger](https://zh.wikipedia.org/w/index.php?title=David_Karger&action=edit&redlink=1)等人1997年的一篇论文中介绍了“一致哈希”如何应用于用户易变的分布式Web服务中。哈希表中的每一个代表分布式系统中一个节点，在系统添加或删除节点只需要移动N/M项。\n\n## 过程\n\n一致性哈希算法也是取模的过程，不过不同于对服务器数量进行取模，一致性哈希是对$ 2^{32} $取模。\n\n我们可以想象一个环，这个环上面一共有$ 2^{32} $个点，顺时针从0开始计数: 0, 1, 2, ..., $ 2^{32} - 1 $，我们将该环称作哈希环，如下图所示。\n\n![hash_ring.png](hash_ring.png)\n\n对于我们已有的3台缓存服务器，我们通常对其IP地址进行哈希计算然后对$ 2^{32} $取模，得到一个$ 0 $到$ 2^{32} - 1 $之间的数，该数即服务器在环上位置，这样，我们能得到3台服务器在环上的位置，如下图所示。\n\n$$ idx = hash(server\\\\_ip) \\pmod{2^{32}} $$\n\n![servers_on_hash_ring.png](servers_on_hash_ring.png)\n\n同样道理，我们将需要缓存的对象也映射到哈希环上，可以使用图片名称来进行哈希。\n\n$$ idx = hash(pic\\\\_name) \\pmod{2^{32}} $$\n\n![pic_on_hash_ring.png](pic_on_hash_ring.png)\n\n现在服务器与缓存项都被映射到了哈希环上，我们最后需要决定缓存项被分配到哪一台服务器上，通常做法是沿着顺时针方向找到的第一台服务器就是缓存项应在的服务器，在本例中缓存项应被分配到服务器A上。\n\n![pic_belong.png](pic_belong.png)\n\n## 优点\n\n那么我们使用了一致性哈希算法后解决了缓存雪崩的问题了吗？\n\n考虑多个缓存项已经完成分配的情况下，服务器B出现了故障，如下图所示。\n\n![pics_on_hash_ring.png](pics_on_hash_ring.png)\n\n当我们失去服务器B以后，只需要移动两个缓存项，而不是近乎所有缓存项。\n\n## 哈希环偏斜\n\n在前面的论述中，我们理想地将3台服务器划分的很均匀，但是实际情况可能差得多，如下图所示。\n\n![bias_on_hash_ring.png](bias_on_hash_ring.png)\n\n在这种情况下，几乎所有的缓存项将被分配到服务器C，而A和B将会分得很少，一致性哈希算法提出了“虚拟结点”这一概念来解决这一问题。\n\n## 虚拟结点\n\n这一概念其实很简单，在增加一个结点到环上的时候，我们会为其分配多个位置（因为实际结点只有一个，因此多出来的结点就称为虚拟结点）。引入虚拟结点之后，缓存的分布就均衡多了，如下图所示。\n\n![virtual_nodes_on_hash_ring.png](virtual_nodes_on_hash_ring.png)\n\n## 实验\n\n通过编写相关代码，我模拟了拥有在5个服务器，每个服务器拥有150个结点的情况下，对100000个缓存项进行一致性哈希分配的过程，结果如下表所示。\n\n|服务器IP|缓存项数量|\n|:--:|:--:|\n|192.168.1.5|20216|\n|192.168.1.39|21106|\n|192.168.1.53|17599|\n|192.168.1.66|19560|\n|192.168.1.127|21519|\n\n可以看出，使用一致性哈希算法之后，每个服务器能够被比较均匀的分配到缓存项，同时如果增加或删除服务器，需要迁移的缓存项数量也基本符合N/M这一数量。\n\n有兴趣的读者可以参考我的实现代码[Github](https://github.com/Time1ess/MyProjects/tree/master/ConsistentHashRing)。\n\n# 参考文献\n\n* https://wizardforcel.gitbooks.io/gainlo-interview-guide/content/sd11.html\n* https://blog.csdn.net/gerryke/article/details/53939212\n* http://www.zsythink.net/archives/1182\n* https://zh.wikipedia.org/wiki/一致哈希\n","slug":"Consistent-Hashing","published":1,"updated":"2018-04-22T03:04:08.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgvnqmko000cw6284vskvqpv","content":"<p>之前听到过一致性哈希算法，但是没有去进行了解。恰逢最近在看系统设计方面的内容，看到设计缓存系统的部分，对于如何合理有效地分配缓存而使用的一致性哈希算法进行了一些了解。</p>\n<a id=\"more\"></a>\n<h1 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h1><p>缓存是目前各种应用中广泛使用的技术，比如DNS、Web服务器缓存等，是一种以空间换时间的方式。</p>\n<p>常见的缓存算法有很多，LRU（最久未使用)、LFU（最近最少使用）等等。下面简单介绍一下LRU算法。</p>\n<p>一个缓存算法应该支持这些操作：插入、删除、查找。对于LRU，为了实现快速查找，我们需要使用到哈希表，另外由于我们需要根据使用情况，快速调整一个对象的位置，那么我们很容易能想到使用链表来实现，同时由于需要从链表中删除一个对象后保证链表连接，因此我们需要使用到双向链表。</p>\n<p>LRU的工作流程如下：</p>\n<ul>\n<li>查找：给定一个键(key)，从LRU缓存中查询结果<ul>\n<li>若该键存在于哈希表中：从哈希表中获取该键对应的值以及在双向链表中的位置，从双向链表中删除该键并调整前后结点的连接，将该键重新插入到链表头部，返回值。</li>\n<li>若该键不存在于哈希表中：直接返回告知调用者该键不存在。</li>\n</ul>\n</li>\n<li>插入：给定一个键值对(key-val)，加入LRU缓存<ul>\n<li>若该键存在于哈希表中：从哈希表中获取键在双向链表中的位置，从双向链表中删除该键并调整前后结点的连接，将该键重新插入到链表头部，更新哈希表中键对应的值。</li>\n<li>若该键不存在于哈希表中：（若LRU已满，获得链表最后一个结点的键，删除该结点以及其对应的哈希表的内容）将该键插入到链表头部，在哈希表中保存键对应的值以及链表位置。</li>\n</ul>\n</li>\n<li>删除：给定一个键，从LRU缓存中删除<ul>\n<li>若该键存在于哈希表中：从哈希表中获取键在双向链表中的位置，从双向链表中删除该键并调整前后结点的连接，从哈希表中删除该键。</li>\n<li>若该键不存在于哈希表中：直接返回。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"缓存并发性\"><a href=\"#缓存并发性\" class=\"headerlink\" title=\"缓存并发性\"></a>缓存并发性</h1><p>当多个客户端同时尝试更新缓存时，可能会发生读写冲突。例如两个客户端可能竞争相同的缓存槽，而最后一个更新缓存的客户端将获胜。要解决读写冲突，常见的方法就是使用锁，但是使用锁将带来严重的性能影响，那么如何优化呢？</p>\n<p>一种方法是缓存分成多个分片，为每个分片分配一个锁，这样客户端在理想情况下会更新不同分片的缓存，就不用再相互等待。但是在极端情况下，仍然无法避免竞争的问题。</p>\n<p>另一种方法是使用提交日志。所有的改动被存储到一个日志中，而不是立即对缓存进行更新。一些后台进程将异步执行日志来更新缓存。这一策略在数据库设计中经常使用。</p>\n<h1 id=\"分布式缓存\"><a href=\"#分布式缓存\" class=\"headerlink\" title=\"分布式缓存\"></a>分布式缓存</h1><p>当我们的系统达到一定的规模时，我们需要将缓存分配给多台机器。假设我们有M台服务器以及N张图片需要缓存，我们希望通过3台服务器来缓存这N张图片，平衡服务器负载压力。</p>\n<h2 id=\"随机分配\"><a href=\"#随机分配\" class=\"headerlink\" title=\"随机分配\"></a>随机分配</h2><p>考虑最简单的情况，我们直接将这N张图片随机分给M台服务器，每台分得N/M张图片，在这种情况下，如果我们想访问某个缓存项，我们需要遍历M台服务器去找到该缓存项，然而缓存的目的是为了提高速度，改善用户体验，减轻后端服务器压力，如果每次访问都需要遍历所有服务器，那么该缓存是很失败的。</p>\n<h2 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h2><p>我们还可以在一台服务器上保存一张哈希表，这张哈希表能帮助我们找到某个缓存项在哪一台服务器上。这样做的好处是现在我们只需要访问2台服务器就能得到所需要的缓存项，但是缺点是使用了大量的空间来维护哈希表。</p>\n<h2 id=\"取模运算\"><a href=\"#取模运算\" class=\"headerlink\" title=\"取模运算\"></a>取模运算</h2><p>常见的一种操作是对缓存项的键进行哈希计算，然后将hash之后的结果对服务器的数量进行取模运算，根据该结果来确定缓存会在哪一台服务器上。</p>\n<p>$$ idx = hash(pic\\_name) \\pmod{N} $$</p>\n<p>举例说明，有10条数据，3个结点，如果按照取模的方式，那么缓存的分配情况将会是：</p>\n<ul>\n<li>Node A: 0, 3, 6, 9</li>\n<li>Node B: 1, 4, 7</li>\n<li>Node C: 2, 5, 8</li>\n</ul>\n<p>但是使用这种方法进行缓存时会有一些缺陷，如果3台缓存服务器不够用了我们应该怎么做呢？没错，增加额外的结点，我们考虑再增加一台服务器，此时分配情况将会变为：</p>\n<ul>\n<li>Node A: 0, 4, 8</li>\n<li>Node B: 1, 5, 9</li>\n<li>Node C: 2, 6</li>\n<li>Node D: 3, 7</li>\n</ul>\n<p>通过观察可以发现，数据3, 4, 5, 6, 7, 8, 9在增加结点之后，都被重新分配了位置，这一成本实在是太高，而在重新分配位置这一期间，缓存这段时间内是失效的，因此如果有客户端请求数据，应用将不得不向后端服务器请求。由于大量缓存同时失效，造成缓存雪崩，整个系统可能会被压垮，所以我们要避免这种情况的发生。</p>\n<h1 id=\"一致性哈希算法\"><a href=\"#一致性哈希算法\" class=\"headerlink\" title=\"一致性哈希算法\"></a>一致性哈希算法</h1><p>我们在前文谈到了采用普通哈希算法会出现的问题。</p>\n<ol>\n<li>当缓存服务器数量变化时，会引起缓存雪崩，可能导致系统崩溃。</li>\n<li>当缓存服务器数量变化时，几乎所有缓存位置都会发生改变。</li>\n</ol>\n<p>其实第一个问题主要来源于第二个问题，因此我们只要能保证在缓存服务器数量变化时，尽量维持缓存的位置即可。因此在<a href=\"https://zh.wikipedia.org/w/index.php?title=David_Karger&amp;action=edit&amp;redlink=1\" target=\"_blank\" rel=\"noopener\">Karger</a>等人1997年的一篇论文中介绍了“一致哈希”如何应用于用户易变的分布式Web服务中。哈希表中的每一个代表分布式系统中一个节点，在系统添加或删除节点只需要移动N/M项。</p>\n<h2 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h2><p>一致性哈希算法也是取模的过程，不过不同于对服务器数量进行取模，一致性哈希是对$ 2^{32} $取模。</p>\n<p>我们可以想象一个环，这个环上面一共有$ 2^{32} $个点，顺时针从0开始计数: 0, 1, 2, …, $ 2^{32} - 1 $，我们将该环称作哈希环，如下图所示。</p>\n<p><img src=\"/2018/04/22/Consistent-Hashing/hash_ring.png\" alt=\"hash_ring.png\"></p>\n<p>对于我们已有的3台缓存服务器，我们通常对其IP地址进行哈希计算然后对$ 2^{32} $取模，得到一个$ 0 $到$ 2^{32} - 1 $之间的数，该数即服务器在环上位置，这样，我们能得到3台服务器在环上的位置，如下图所示。</p>\n<p>$$ idx = hash(server\\_ip) \\pmod{2^{32}} $$</p>\n<p><img src=\"/2018/04/22/Consistent-Hashing/servers_on_hash_ring.png\" alt=\"servers_on_hash_ring.png\"></p>\n<p>同样道理，我们将需要缓存的对象也映射到哈希环上，可以使用图片名称来进行哈希。</p>\n<p>$$ idx = hash(pic\\_name) \\pmod{2^{32}} $$</p>\n<p><img src=\"/2018/04/22/Consistent-Hashing/pic_on_hash_ring.png\" alt=\"pic_on_hash_ring.png\"></p>\n<p>现在服务器与缓存项都被映射到了哈希环上，我们最后需要决定缓存项被分配到哪一台服务器上，通常做法是沿着顺时针方向找到的第一台服务器就是缓存项应在的服务器，在本例中缓存项应被分配到服务器A上。</p>\n<p><img src=\"/2018/04/22/Consistent-Hashing/pic_belong.png\" alt=\"pic_belong.png\"></p>\n<h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><p>那么我们使用了一致性哈希算法后解决了缓存雪崩的问题了吗？</p>\n<p>考虑多个缓存项已经完成分配的情况下，服务器B出现了故障，如下图所示。</p>\n<p><img src=\"/2018/04/22/Consistent-Hashing/pics_on_hash_ring.png\" alt=\"pics_on_hash_ring.png\"></p>\n<p>当我们失去服务器B以后，只需要移动两个缓存项，而不是近乎所有缓存项。</p>\n<h2 id=\"哈希环偏斜\"><a href=\"#哈希环偏斜\" class=\"headerlink\" title=\"哈希环偏斜\"></a>哈希环偏斜</h2><p>在前面的论述中，我们理想地将3台服务器划分的很均匀，但是实际情况可能差得多，如下图所示。</p>\n<p><img src=\"/2018/04/22/Consistent-Hashing/bias_on_hash_ring.png\" alt=\"bias_on_hash_ring.png\"></p>\n<p>在这种情况下，几乎所有的缓存项将被分配到服务器C，而A和B将会分得很少，一致性哈希算法提出了“虚拟结点”这一概念来解决这一问题。</p>\n<h2 id=\"虚拟结点\"><a href=\"#虚拟结点\" class=\"headerlink\" title=\"虚拟结点\"></a>虚拟结点</h2><p>这一概念其实很简单，在增加一个结点到环上的时候，我们会为其分配多个位置（因为实际结点只有一个，因此多出来的结点就称为虚拟结点）。引入虚拟结点之后，缓存的分布就均衡多了，如下图所示。</p>\n<p><img src=\"/2018/04/22/Consistent-Hashing/virtual_nodes_on_hash_ring.png\" alt=\"virtual_nodes_on_hash_ring.png\"></p>\n<h2 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h2><p>通过编写相关代码，我模拟了拥有在5个服务器，每个服务器拥有150个结点的情况下，对100000个缓存项进行一致性哈希分配的过程，结果如下表所示。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">服务器IP</th>\n<th style=\"text-align:center\">缓存项数量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">192.168.1.5</td>\n<td style=\"text-align:center\">20216</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">192.168.1.39</td>\n<td style=\"text-align:center\">21106</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">192.168.1.53</td>\n<td style=\"text-align:center\">17599</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">192.168.1.66</td>\n<td style=\"text-align:center\">19560</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">192.168.1.127</td>\n<td style=\"text-align:center\">21519</td>\n</tr>\n</tbody>\n</table>\n<p>可以看出，使用一致性哈希算法之后，每个服务器能够被比较均匀的分配到缓存项，同时如果增加或删除服务器，需要迁移的缓存项数量也基本符合N/M这一数量。</p>\n<p>有兴趣的读者可以参考我的实现代码<a href=\"https://github.com/Time1ess/MyProjects/tree/master/ConsistentHashRing\" target=\"_blank\" rel=\"noopener\">Github</a>。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://wizardforcel.gitbooks.io/gainlo-interview-guide/content/sd11.html\" target=\"_blank\" rel=\"noopener\">https://wizardforcel.gitbooks.io/gainlo-interview-guide/content/sd11.html</a></li>\n<li><a href=\"https://blog.csdn.net/gerryke/article/details/53939212\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/gerryke/article/details/53939212</a></li>\n<li><a href=\"http://www.zsythink.net/archives/1182\" target=\"_blank\" rel=\"noopener\">http://www.zsythink.net/archives/1182</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/一致哈希\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/一致哈希</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>之前听到过一致性哈希算法，但是没有去进行了解。恰逢最近在看系统设计方面的内容，看到设计缓存系统的部分，对于如何合理有效地分配缓存而使用的一致性哈希算法进行了一些了解。</p>","more":"<h1 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h1><p>缓存是目前各种应用中广泛使用的技术，比如DNS、Web服务器缓存等，是一种以空间换时间的方式。</p>\n<p>常见的缓存算法有很多，LRU（最久未使用)、LFU（最近最少使用）等等。下面简单介绍一下LRU算法。</p>\n<p>一个缓存算法应该支持这些操作：插入、删除、查找。对于LRU，为了实现快速查找，我们需要使用到哈希表，另外由于我们需要根据使用情况，快速调整一个对象的位置，那么我们很容易能想到使用链表来实现，同时由于需要从链表中删除一个对象后保证链表连接，因此我们需要使用到双向链表。</p>\n<p>LRU的工作流程如下：</p>\n<ul>\n<li>查找：给定一个键(key)，从LRU缓存中查询结果<ul>\n<li>若该键存在于哈希表中：从哈希表中获取该键对应的值以及在双向链表中的位置，从双向链表中删除该键并调整前后结点的连接，将该键重新插入到链表头部，返回值。</li>\n<li>若该键不存在于哈希表中：直接返回告知调用者该键不存在。</li>\n</ul>\n</li>\n<li>插入：给定一个键值对(key-val)，加入LRU缓存<ul>\n<li>若该键存在于哈希表中：从哈希表中获取键在双向链表中的位置，从双向链表中删除该键并调整前后结点的连接，将该键重新插入到链表头部，更新哈希表中键对应的值。</li>\n<li>若该键不存在于哈希表中：（若LRU已满，获得链表最后一个结点的键，删除该结点以及其对应的哈希表的内容）将该键插入到链表头部，在哈希表中保存键对应的值以及链表位置。</li>\n</ul>\n</li>\n<li>删除：给定一个键，从LRU缓存中删除<ul>\n<li>若该键存在于哈希表中：从哈希表中获取键在双向链表中的位置，从双向链表中删除该键并调整前后结点的连接，从哈希表中删除该键。</li>\n<li>若该键不存在于哈希表中：直接返回。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"缓存并发性\"><a href=\"#缓存并发性\" class=\"headerlink\" title=\"缓存并发性\"></a>缓存并发性</h1><p>当多个客户端同时尝试更新缓存时，可能会发生读写冲突。例如两个客户端可能竞争相同的缓存槽，而最后一个更新缓存的客户端将获胜。要解决读写冲突，常见的方法就是使用锁，但是使用锁将带来严重的性能影响，那么如何优化呢？</p>\n<p>一种方法是缓存分成多个分片，为每个分片分配一个锁，这样客户端在理想情况下会更新不同分片的缓存，就不用再相互等待。但是在极端情况下，仍然无法避免竞争的问题。</p>\n<p>另一种方法是使用提交日志。所有的改动被存储到一个日志中，而不是立即对缓存进行更新。一些后台进程将异步执行日志来更新缓存。这一策略在数据库设计中经常使用。</p>\n<h1 id=\"分布式缓存\"><a href=\"#分布式缓存\" class=\"headerlink\" title=\"分布式缓存\"></a>分布式缓存</h1><p>当我们的系统达到一定的规模时，我们需要将缓存分配给多台机器。假设我们有M台服务器以及N张图片需要缓存，我们希望通过3台服务器来缓存这N张图片，平衡服务器负载压力。</p>\n<h2 id=\"随机分配\"><a href=\"#随机分配\" class=\"headerlink\" title=\"随机分配\"></a>随机分配</h2><p>考虑最简单的情况，我们直接将这N张图片随机分给M台服务器，每台分得N/M张图片，在这种情况下，如果我们想访问某个缓存项，我们需要遍历M台服务器去找到该缓存项，然而缓存的目的是为了提高速度，改善用户体验，减轻后端服务器压力，如果每次访问都需要遍历所有服务器，那么该缓存是很失败的。</p>\n<h2 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h2><p>我们还可以在一台服务器上保存一张哈希表，这张哈希表能帮助我们找到某个缓存项在哪一台服务器上。这样做的好处是现在我们只需要访问2台服务器就能得到所需要的缓存项，但是缺点是使用了大量的空间来维护哈希表。</p>\n<h2 id=\"取模运算\"><a href=\"#取模运算\" class=\"headerlink\" title=\"取模运算\"></a>取模运算</h2><p>常见的一种操作是对缓存项的键进行哈希计算，然后将hash之后的结果对服务器的数量进行取模运算，根据该结果来确定缓存会在哪一台服务器上。</p>\n<p>$$ idx = hash(pic\\_name) \\pmod{N} $$</p>\n<p>举例说明，有10条数据，3个结点，如果按照取模的方式，那么缓存的分配情况将会是：</p>\n<ul>\n<li>Node A: 0, 3, 6, 9</li>\n<li>Node B: 1, 4, 7</li>\n<li>Node C: 2, 5, 8</li>\n</ul>\n<p>但是使用这种方法进行缓存时会有一些缺陷，如果3台缓存服务器不够用了我们应该怎么做呢？没错，增加额外的结点，我们考虑再增加一台服务器，此时分配情况将会变为：</p>\n<ul>\n<li>Node A: 0, 4, 8</li>\n<li>Node B: 1, 5, 9</li>\n<li>Node C: 2, 6</li>\n<li>Node D: 3, 7</li>\n</ul>\n<p>通过观察可以发现，数据3, 4, 5, 6, 7, 8, 9在增加结点之后，都被重新分配了位置，这一成本实在是太高，而在重新分配位置这一期间，缓存这段时间内是失效的，因此如果有客户端请求数据，应用将不得不向后端服务器请求。由于大量缓存同时失效，造成缓存雪崩，整个系统可能会被压垮，所以我们要避免这种情况的发生。</p>\n<h1 id=\"一致性哈希算法\"><a href=\"#一致性哈希算法\" class=\"headerlink\" title=\"一致性哈希算法\"></a>一致性哈希算法</h1><p>我们在前文谈到了采用普通哈希算法会出现的问题。</p>\n<ol>\n<li>当缓存服务器数量变化时，会引起缓存雪崩，可能导致系统崩溃。</li>\n<li>当缓存服务器数量变化时，几乎所有缓存位置都会发生改变。</li>\n</ol>\n<p>其实第一个问题主要来源于第二个问题，因此我们只要能保证在缓存服务器数量变化时，尽量维持缓存的位置即可。因此在<a href=\"https://zh.wikipedia.org/w/index.php?title=David_Karger&amp;action=edit&amp;redlink=1\" target=\"_blank\" rel=\"noopener\">Karger</a>等人1997年的一篇论文中介绍了“一致哈希”如何应用于用户易变的分布式Web服务中。哈希表中的每一个代表分布式系统中一个节点，在系统添加或删除节点只需要移动N/M项。</p>\n<h2 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h2><p>一致性哈希算法也是取模的过程，不过不同于对服务器数量进行取模，一致性哈希是对$ 2^{32} $取模。</p>\n<p>我们可以想象一个环，这个环上面一共有$ 2^{32} $个点，顺时针从0开始计数: 0, 1, 2, …, $ 2^{32} - 1 $，我们将该环称作哈希环，如下图所示。</p>\n<p><img src=\"/2018/04/22/Consistent-Hashing/hash_ring.png\" alt=\"hash_ring.png\"></p>\n<p>对于我们已有的3台缓存服务器，我们通常对其IP地址进行哈希计算然后对$ 2^{32} $取模，得到一个$ 0 $到$ 2^{32} - 1 $之间的数，该数即服务器在环上位置，这样，我们能得到3台服务器在环上的位置，如下图所示。</p>\n<p>$$ idx = hash(server\\_ip) \\pmod{2^{32}} $$</p>\n<p><img src=\"/2018/04/22/Consistent-Hashing/servers_on_hash_ring.png\" alt=\"servers_on_hash_ring.png\"></p>\n<p>同样道理，我们将需要缓存的对象也映射到哈希环上，可以使用图片名称来进行哈希。</p>\n<p>$$ idx = hash(pic\\_name) \\pmod{2^{32}} $$</p>\n<p><img src=\"/2018/04/22/Consistent-Hashing/pic_on_hash_ring.png\" alt=\"pic_on_hash_ring.png\"></p>\n<p>现在服务器与缓存项都被映射到了哈希环上，我们最后需要决定缓存项被分配到哪一台服务器上，通常做法是沿着顺时针方向找到的第一台服务器就是缓存项应在的服务器，在本例中缓存项应被分配到服务器A上。</p>\n<p><img src=\"/2018/04/22/Consistent-Hashing/pic_belong.png\" alt=\"pic_belong.png\"></p>\n<h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><p>那么我们使用了一致性哈希算法后解决了缓存雪崩的问题了吗？</p>\n<p>考虑多个缓存项已经完成分配的情况下，服务器B出现了故障，如下图所示。</p>\n<p><img src=\"/2018/04/22/Consistent-Hashing/pics_on_hash_ring.png\" alt=\"pics_on_hash_ring.png\"></p>\n<p>当我们失去服务器B以后，只需要移动两个缓存项，而不是近乎所有缓存项。</p>\n<h2 id=\"哈希环偏斜\"><a href=\"#哈希环偏斜\" class=\"headerlink\" title=\"哈希环偏斜\"></a>哈希环偏斜</h2><p>在前面的论述中，我们理想地将3台服务器划分的很均匀，但是实际情况可能差得多，如下图所示。</p>\n<p><img src=\"/2018/04/22/Consistent-Hashing/bias_on_hash_ring.png\" alt=\"bias_on_hash_ring.png\"></p>\n<p>在这种情况下，几乎所有的缓存项将被分配到服务器C，而A和B将会分得很少，一致性哈希算法提出了“虚拟结点”这一概念来解决这一问题。</p>\n<h2 id=\"虚拟结点\"><a href=\"#虚拟结点\" class=\"headerlink\" title=\"虚拟结点\"></a>虚拟结点</h2><p>这一概念其实很简单，在增加一个结点到环上的时候，我们会为其分配多个位置（因为实际结点只有一个，因此多出来的结点就称为虚拟结点）。引入虚拟结点之后，缓存的分布就均衡多了，如下图所示。</p>\n<p><img src=\"/2018/04/22/Consistent-Hashing/virtual_nodes_on_hash_ring.png\" alt=\"virtual_nodes_on_hash_ring.png\"></p>\n<h2 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h2><p>通过编写相关代码，我模拟了拥有在5个服务器，每个服务器拥有150个结点的情况下，对100000个缓存项进行一致性哈希分配的过程，结果如下表所示。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">服务器IP</th>\n<th style=\"text-align:center\">缓存项数量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">192.168.1.5</td>\n<td style=\"text-align:center\">20216</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">192.168.1.39</td>\n<td style=\"text-align:center\">21106</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">192.168.1.53</td>\n<td style=\"text-align:center\">17599</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">192.168.1.66</td>\n<td style=\"text-align:center\">19560</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">192.168.1.127</td>\n<td style=\"text-align:center\">21519</td>\n</tr>\n</tbody>\n</table>\n<p>可以看出，使用一致性哈希算法之后，每个服务器能够被比较均匀的分配到缓存项，同时如果增加或删除服务器，需要迁移的缓存项数量也基本符合N/M这一数量。</p>\n<p>有兴趣的读者可以参考我的实现代码<a href=\"https://github.com/Time1ess/MyProjects/tree/master/ConsistentHashRing\" target=\"_blank\" rel=\"noopener\">Github</a>。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://wizardforcel.gitbooks.io/gainlo-interview-guide/content/sd11.html\" target=\"_blank\" rel=\"noopener\">https://wizardforcel.gitbooks.io/gainlo-interview-guide/content/sd11.html</a></li>\n<li><a href=\"https://blog.csdn.net/gerryke/article/details/53939212\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/gerryke/article/details/53939212</a></li>\n<li><a href=\"http://www.zsythink.net/archives/1182\" target=\"_blank\" rel=\"noopener\">http://www.zsythink.net/archives/1182</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/一致哈希\" target=\"_blank\" rel=\"noopener\">https://zh.wikipedia.org/wiki/一致哈希</a></li>\n</ul>"},{"title":"DDIA读书笔记1-可靠性、可扩展性和可维护性(一)","date":"2018-02-23T02:36:33.000Z","_content":"\n之前在搜索时无意中发现了这本书[《Designing Data-Intensive Applications》](https://book.douban.com/subject/26197294/)，豆瓣评分高达9.4，于是尝试进行阅读，发现真是堪称教科书一般的存在，深入浅出的介绍了后端开发中这么多年来大热的各种技术相关知识，如从数据库语言的诞生一直到NoSQL的火热，分布式等等，由于此书包含内容很多，且无中文翻译，因此阅读起来难免会遗忘之前的内容，因此写下此笔记帮助日后复习回忆。\n\n<!-- more -->\n\n当今许多应用都应算为*数据密集型*，这与传统的*计算密集型*相对。因为相对于海量的数据，数据的复杂性，以及数据快速变化，CPU计算能力对这些应用来说几乎并不算限制因素。\n\n常见的应用需要完成以下功能:\n\n* 存储数据，以便自身或其他应用在日后进行访问(*数据库*)\n* 存储复杂操作的计算结果，以便提升读取效率(*缓存*)\n* 允许用户以不同方式使用关键字来查询或者过滤数据(*索引*)\n* 以异步的方式向其他进程发送消息(*流处理*)\n* 周期性地处理一大批积累的数据(*批处理*)\n\n但对于编写一个新的应用，开发者根本不会去编写一个新的数据存储引擎，因为对于这个工作来说，数据库已经是一个十分适合的工具了。但是现实并没有那么简单，因为当下存在很多数据库，它们拥有不同特性，不同的缓存方式，不同的创建索引方式等等。因此当我们编写一个新的应用的时候，如何去选择最合适工具以及方式来解决手头的问题仍然是我们需要解决的问题。本书从原理以及实践出发，对数据系统，以及如何使用这些工具来编写数据密集型应用进行了说明。\n\n# 数据系统\n\n我们通常认为数据库、队列、缓存等式不同类型的工具，那么为什么我们要将它们都归结为*数据系统*呢？\n\n1. 首先，近些年来许多用于数据存储和处理的工具呈现合并的趋势。比如可充当消息队列的数据存储工具*Redis*，以及可提供类数据库持久化的消息队列(*Apache Kafka*)。\n2. 其次，随着当下大量应用需求的飞速发展，单一工具已经不能再满足所有的数据处理以及存储需求。例如，假设你有一个由应用管理的缓存层(使用Memcached等工具)，或是一个独立于主数据库的全文搜索服务器(如Elasticsearch)，那么正常情况下应该由应用程序自身来与主数据库同步并保留相关缓存或索引，如下图所示。\n\n![](Data_system_architecture_combining_several_components.png)\n\n当你结合多个工具来完成一项服务的提供时，其API通常会对客户端隐藏实现细节。此时你本质上是通过更小的通用型的工具来创建了一个新的特殊用途的数据系统。如缓存将会正确无效化或在数据库写入时更新，使得外界客户端得到一致的结果。此时你不仅是一个应用开发者，同时也是一个数据系统设计者。\n\n当你设计如此一个数据系统或服务时，将会出现很多棘手的问题。在内部出错的情况下如何保证数据正确且完整？如何保证即使在部分系统降级的情况下始终如一地向客户端提供良好服务？如何扩容来满足处理负载的增加？一个优秀的API应是什么样？\n\n有许许多多的因素来影响一个数据系统的设计，在本书中主要着重讲述大多数软件系统中最重要的三点。\n\n* *可靠性*(**Reliability**):系统即使在遭遇灾难(硬件或软件错误，甚至是人为错误)的时候仍应保证正常运行\n* *可扩展性*(**Scalability**):应存在合理的方式来处理系统的增长(数据量，流量，复杂性)\n* *可维护性*(**Maintainability**):随着时间推移，会有不同的人于该系统上工作(维护现有任务并调整系统适应新的需求)，工作人员应当能够高效的完成这些工作。\n\n# 可靠性\n\n每个人对某个东西可靠或不可靠都有不同的定义，对软件来说，对其的期望主要包括:\n\n* 应用程序表现出用户预期的功能\n* 其可容忍用户错误操作或使用非预期方式来使用软件\n* 在预期负载量以及数据量的情况下，其性能表现良好\n* 系统能够阻止任意非授权的访问或者攻击\n\n如果以上代表了“正常工作”，那么我们可以大致的理解可靠性为:“即使在事情出错的情况下仍能继续正常工作”。\n\n## 硬件故障\n\n当我们讨论系统失效的原因的时候，很容易就会想到硬件故障。硬盘崩溃，RAM出错，电网停电，错拔网线。任何有过大型数据中心工作经验的人都会告诉你当你有大量机器的时候这些问题随时都在发生。\n\n硬盘通常拥有10到50年的平均失效前时间。因此，对于一个拥有10000个硬盘的存储集群来说，我们可以计算出平均每天都有一个硬盘失效。\n\n我们第一个应对措施便是为系统的独立硬件组件增加冗余，来减少失效率。磁盘可以通过组件RAID，服务器可以拥有双电源的热插拔CPU，数据中心可以增加电池以及柴油发电机作为备用电源。当一个部件出错，冗余部件能够及时代替出错部件工作。这种方法不能完全阻止硬件故障带来的系统错误，但是确实一个常用的且效果还不错的方式。\n\n但是近些年随着数据量以及应用计算能力需求的增加，许多应用开始使用大量的机器，这导致了硬件故障的概率大大增加。因此在系统能容忍丢失整个机器这一点上，有了长足的进步，具体实现方式是优先使用软件层面的容错技术或作为增加硬件冗余的补充。这样的系统在操作上具有优势:一个单机系统如果需要重启机器的话那么需要一定的服务离线时间(如应用系统安全补丁等操作)，然而一个能够容忍机器失效的系统可以一次操作一个结点，而不会引起整个系统服务的离线(*滚动升级*)。\n\n## 软件错误\n\n另一类错误是系统错误，这类错误更难以预料，因为它们常常是跨不同结点关联，相对于硬件故障，这类错误更容易导致更多的系统失效，包括:\n\n* 一个软件bug导致应用服务器的每一个实例在接收到一个特殊错误输入的时候崩溃。如2012年6月30日闰秒带来的问题，由Linux内核引起的一个bug导致许多程序被同时挂起。\n* 一个失效进程用尽共享资源，如CPU，内存，磁盘，网络带宽等。\n* 一个系统依赖的服务变慢，反应迟钝，或返回错误结果。\n* 级联错误，当一个部件中的小错误引起了另一个部件中的错误，而该错误又会继续引起其他错误。\n\n该类错误没有快速的解决方法。但是有许多细节可以帮助:小心思考系统的假设以及交互；完备的测试；进程隔离；允许进程崩溃重启；在生产环境中监测、评价以及分析系统的行为。\n\n## 人为错误\n\n人类设计并搭建了软件系统，保证系统运转的操作者仍然是人类。即使他们有最好的意图，人类仍然是不可靠的。例如，一个面向大量互联网服务的调查表明引起运行中断的首要原因是操作者的配置错误，而硬件故障(服务器或者网络)只占比10-25%。\n\n我们如何使我们的系统更加可靠，尽管有不可靠的人类？优秀的系统常常包含以下方法:\n\n* 设计一个最大程度下减少出错可能的系统。如良好的抽象，API，提供管理员界面使得“做正确的事”简单并不鼓励“做不正确的事”。然而，如果管理员界面如果限制太多，人们将会绕过它们，否定它们的好处，所以这是一个棘手的平衡。\n* 解耦人们最容易犯错的地方与会造成错误的地方。特别的，提供完成的非生产沙盒环境供用户安全地探索及实验，使用真实数据，却不影响真实用户。\n* 在所有层面都进行完备的测试，从单元测试到整个系统的集成测试以及手动测试。自动测试是一个被广泛使用，广泛认知，尤其对覆盖在正常运行中很少出现的角落案例非常有用的工具。\n* 允许从用户错误中快速且方便的恢复，以最大程度上减少该错误带来的影响。\n* 建立详细且清晰的监测，例如性能度量以及错误率。\n* 实施良好的管理实践和培训。\n\n未完待续...\n","source":"_posts/DDIA读书笔记1.md","raw":"---\ntitle: DDIA读书笔记1-可靠性、可扩展性和可维护性(一)\ndate: 2018-02-23 10:36:33\ntags: [数据系统,可靠性]\ncategories: 系统架构\n---\n\n之前在搜索时无意中发现了这本书[《Designing Data-Intensive Applications》](https://book.douban.com/subject/26197294/)，豆瓣评分高达9.4，于是尝试进行阅读，发现真是堪称教科书一般的存在，深入浅出的介绍了后端开发中这么多年来大热的各种技术相关知识，如从数据库语言的诞生一直到NoSQL的火热，分布式等等，由于此书包含内容很多，且无中文翻译，因此阅读起来难免会遗忘之前的内容，因此写下此笔记帮助日后复习回忆。\n\n<!-- more -->\n\n当今许多应用都应算为*数据密集型*，这与传统的*计算密集型*相对。因为相对于海量的数据，数据的复杂性，以及数据快速变化，CPU计算能力对这些应用来说几乎并不算限制因素。\n\n常见的应用需要完成以下功能:\n\n* 存储数据，以便自身或其他应用在日后进行访问(*数据库*)\n* 存储复杂操作的计算结果，以便提升读取效率(*缓存*)\n* 允许用户以不同方式使用关键字来查询或者过滤数据(*索引*)\n* 以异步的方式向其他进程发送消息(*流处理*)\n* 周期性地处理一大批积累的数据(*批处理*)\n\n但对于编写一个新的应用，开发者根本不会去编写一个新的数据存储引擎，因为对于这个工作来说，数据库已经是一个十分适合的工具了。但是现实并没有那么简单，因为当下存在很多数据库，它们拥有不同特性，不同的缓存方式，不同的创建索引方式等等。因此当我们编写一个新的应用的时候，如何去选择最合适工具以及方式来解决手头的问题仍然是我们需要解决的问题。本书从原理以及实践出发，对数据系统，以及如何使用这些工具来编写数据密集型应用进行了说明。\n\n# 数据系统\n\n我们通常认为数据库、队列、缓存等式不同类型的工具，那么为什么我们要将它们都归结为*数据系统*呢？\n\n1. 首先，近些年来许多用于数据存储和处理的工具呈现合并的趋势。比如可充当消息队列的数据存储工具*Redis*，以及可提供类数据库持久化的消息队列(*Apache Kafka*)。\n2. 其次，随着当下大量应用需求的飞速发展，单一工具已经不能再满足所有的数据处理以及存储需求。例如，假设你有一个由应用管理的缓存层(使用Memcached等工具)，或是一个独立于主数据库的全文搜索服务器(如Elasticsearch)，那么正常情况下应该由应用程序自身来与主数据库同步并保留相关缓存或索引，如下图所示。\n\n![](Data_system_architecture_combining_several_components.png)\n\n当你结合多个工具来完成一项服务的提供时，其API通常会对客户端隐藏实现细节。此时你本质上是通过更小的通用型的工具来创建了一个新的特殊用途的数据系统。如缓存将会正确无效化或在数据库写入时更新，使得外界客户端得到一致的结果。此时你不仅是一个应用开发者，同时也是一个数据系统设计者。\n\n当你设计如此一个数据系统或服务时，将会出现很多棘手的问题。在内部出错的情况下如何保证数据正确且完整？如何保证即使在部分系统降级的情况下始终如一地向客户端提供良好服务？如何扩容来满足处理负载的增加？一个优秀的API应是什么样？\n\n有许许多多的因素来影响一个数据系统的设计，在本书中主要着重讲述大多数软件系统中最重要的三点。\n\n* *可靠性*(**Reliability**):系统即使在遭遇灾难(硬件或软件错误，甚至是人为错误)的时候仍应保证正常运行\n* *可扩展性*(**Scalability**):应存在合理的方式来处理系统的增长(数据量，流量，复杂性)\n* *可维护性*(**Maintainability**):随着时间推移，会有不同的人于该系统上工作(维护现有任务并调整系统适应新的需求)，工作人员应当能够高效的完成这些工作。\n\n# 可靠性\n\n每个人对某个东西可靠或不可靠都有不同的定义，对软件来说，对其的期望主要包括:\n\n* 应用程序表现出用户预期的功能\n* 其可容忍用户错误操作或使用非预期方式来使用软件\n* 在预期负载量以及数据量的情况下，其性能表现良好\n* 系统能够阻止任意非授权的访问或者攻击\n\n如果以上代表了“正常工作”，那么我们可以大致的理解可靠性为:“即使在事情出错的情况下仍能继续正常工作”。\n\n## 硬件故障\n\n当我们讨论系统失效的原因的时候，很容易就会想到硬件故障。硬盘崩溃，RAM出错，电网停电，错拔网线。任何有过大型数据中心工作经验的人都会告诉你当你有大量机器的时候这些问题随时都在发生。\n\n硬盘通常拥有10到50年的平均失效前时间。因此，对于一个拥有10000个硬盘的存储集群来说，我们可以计算出平均每天都有一个硬盘失效。\n\n我们第一个应对措施便是为系统的独立硬件组件增加冗余，来减少失效率。磁盘可以通过组件RAID，服务器可以拥有双电源的热插拔CPU，数据中心可以增加电池以及柴油发电机作为备用电源。当一个部件出错，冗余部件能够及时代替出错部件工作。这种方法不能完全阻止硬件故障带来的系统错误，但是确实一个常用的且效果还不错的方式。\n\n但是近些年随着数据量以及应用计算能力需求的增加，许多应用开始使用大量的机器，这导致了硬件故障的概率大大增加。因此在系统能容忍丢失整个机器这一点上，有了长足的进步，具体实现方式是优先使用软件层面的容错技术或作为增加硬件冗余的补充。这样的系统在操作上具有优势:一个单机系统如果需要重启机器的话那么需要一定的服务离线时间(如应用系统安全补丁等操作)，然而一个能够容忍机器失效的系统可以一次操作一个结点，而不会引起整个系统服务的离线(*滚动升级*)。\n\n## 软件错误\n\n另一类错误是系统错误，这类错误更难以预料，因为它们常常是跨不同结点关联，相对于硬件故障，这类错误更容易导致更多的系统失效，包括:\n\n* 一个软件bug导致应用服务器的每一个实例在接收到一个特殊错误输入的时候崩溃。如2012年6月30日闰秒带来的问题，由Linux内核引起的一个bug导致许多程序被同时挂起。\n* 一个失效进程用尽共享资源，如CPU，内存，磁盘，网络带宽等。\n* 一个系统依赖的服务变慢，反应迟钝，或返回错误结果。\n* 级联错误，当一个部件中的小错误引起了另一个部件中的错误，而该错误又会继续引起其他错误。\n\n该类错误没有快速的解决方法。但是有许多细节可以帮助:小心思考系统的假设以及交互；完备的测试；进程隔离；允许进程崩溃重启；在生产环境中监测、评价以及分析系统的行为。\n\n## 人为错误\n\n人类设计并搭建了软件系统，保证系统运转的操作者仍然是人类。即使他们有最好的意图，人类仍然是不可靠的。例如，一个面向大量互联网服务的调查表明引起运行中断的首要原因是操作者的配置错误，而硬件故障(服务器或者网络)只占比10-25%。\n\n我们如何使我们的系统更加可靠，尽管有不可靠的人类？优秀的系统常常包含以下方法:\n\n* 设计一个最大程度下减少出错可能的系统。如良好的抽象，API，提供管理员界面使得“做正确的事”简单并不鼓励“做不正确的事”。然而，如果管理员界面如果限制太多，人们将会绕过它们，否定它们的好处，所以这是一个棘手的平衡。\n* 解耦人们最容易犯错的地方与会造成错误的地方。特别的，提供完成的非生产沙盒环境供用户安全地探索及实验，使用真实数据，却不影响真实用户。\n* 在所有层面都进行完备的测试，从单元测试到整个系统的集成测试以及手动测试。自动测试是一个被广泛使用，广泛认知，尤其对覆盖在正常运行中很少出现的角落案例非常有用的工具。\n* 允许从用户错误中快速且方便的恢复，以最大程度上减少该错误带来的影响。\n* 建立详细且清晰的监测，例如性能度量以及错误率。\n* 实施良好的管理实践和培训。\n\n未完待续...\n","slug":"DDIA读书笔记1","published":1,"updated":"2018-02-26T03:54:56.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgvnqmkr000fw628x9b1homu","content":"<p>之前在搜索时无意中发现了这本书<a href=\"https://book.douban.com/subject/26197294/\" target=\"_blank\" rel=\"noopener\">《Designing Data-Intensive Applications》</a>，豆瓣评分高达9.4，于是尝试进行阅读，发现真是堪称教科书一般的存在，深入浅出的介绍了后端开发中这么多年来大热的各种技术相关知识，如从数据库语言的诞生一直到NoSQL的火热，分布式等等，由于此书包含内容很多，且无中文翻译，因此阅读起来难免会遗忘之前的内容，因此写下此笔记帮助日后复习回忆。</p>\n<a id=\"more\"></a>\n<p>当今许多应用都应算为<em>数据密集型</em>，这与传统的<em>计算密集型</em>相对。因为相对于海量的数据，数据的复杂性，以及数据快速变化，CPU计算能力对这些应用来说几乎并不算限制因素。</p>\n<p>常见的应用需要完成以下功能:</p>\n<ul>\n<li>存储数据，以便自身或其他应用在日后进行访问(<em>数据库</em>)</li>\n<li>存储复杂操作的计算结果，以便提升读取效率(<em>缓存</em>)</li>\n<li>允许用户以不同方式使用关键字来查询或者过滤数据(<em>索引</em>)</li>\n<li>以异步的方式向其他进程发送消息(<em>流处理</em>)</li>\n<li>周期性地处理一大批积累的数据(<em>批处理</em>)</li>\n</ul>\n<p>但对于编写一个新的应用，开发者根本不会去编写一个新的数据存储引擎，因为对于这个工作来说，数据库已经是一个十分适合的工具了。但是现实并没有那么简单，因为当下存在很多数据库，它们拥有不同特性，不同的缓存方式，不同的创建索引方式等等。因此当我们编写一个新的应用的时候，如何去选择最合适工具以及方式来解决手头的问题仍然是我们需要解决的问题。本书从原理以及实践出发，对数据系统，以及如何使用这些工具来编写数据密集型应用进行了说明。</p>\n<h1 id=\"数据系统\"><a href=\"#数据系统\" class=\"headerlink\" title=\"数据系统\"></a>数据系统</h1><p>我们通常认为数据库、队列、缓存等式不同类型的工具，那么为什么我们要将它们都归结为<em>数据系统</em>呢？</p>\n<ol>\n<li>首先，近些年来许多用于数据存储和处理的工具呈现合并的趋势。比如可充当消息队列的数据存储工具<em>Redis</em>，以及可提供类数据库持久化的消息队列(<em>Apache Kafka</em>)。</li>\n<li>其次，随着当下大量应用需求的飞速发展，单一工具已经不能再满足所有的数据处理以及存储需求。例如，假设你有一个由应用管理的缓存层(使用Memcached等工具)，或是一个独立于主数据库的全文搜索服务器(如Elasticsearch)，那么正常情况下应该由应用程序自身来与主数据库同步并保留相关缓存或索引，如下图所示。</li>\n</ol>\n<p><img src=\"/2018/02/23/DDIA读书笔记1/Data_system_architecture_combining_several_components.png\" alt=\"\"></p>\n<p>当你结合多个工具来完成一项服务的提供时，其API通常会对客户端隐藏实现细节。此时你本质上是通过更小的通用型的工具来创建了一个新的特殊用途的数据系统。如缓存将会正确无效化或在数据库写入时更新，使得外界客户端得到一致的结果。此时你不仅是一个应用开发者，同时也是一个数据系统设计者。</p>\n<p>当你设计如此一个数据系统或服务时，将会出现很多棘手的问题。在内部出错的情况下如何保证数据正确且完整？如何保证即使在部分系统降级的情况下始终如一地向客户端提供良好服务？如何扩容来满足处理负载的增加？一个优秀的API应是什么样？</p>\n<p>有许许多多的因素来影响一个数据系统的设计，在本书中主要着重讲述大多数软件系统中最重要的三点。</p>\n<ul>\n<li><em>可靠性</em>(<strong>Reliability</strong>):系统即使在遭遇灾难(硬件或软件错误，甚至是人为错误)的时候仍应保证正常运行</li>\n<li><em>可扩展性</em>(<strong>Scalability</strong>):应存在合理的方式来处理系统的增长(数据量，流量，复杂性)</li>\n<li><em>可维护性</em>(<strong>Maintainability</strong>):随着时间推移，会有不同的人于该系统上工作(维护现有任务并调整系统适应新的需求)，工作人员应当能够高效的完成这些工作。</li>\n</ul>\n<h1 id=\"可靠性\"><a href=\"#可靠性\" class=\"headerlink\" title=\"可靠性\"></a>可靠性</h1><p>每个人对某个东西可靠或不可靠都有不同的定义，对软件来说，对其的期望主要包括:</p>\n<ul>\n<li>应用程序表现出用户预期的功能</li>\n<li>其可容忍用户错误操作或使用非预期方式来使用软件</li>\n<li>在预期负载量以及数据量的情况下，其性能表现良好</li>\n<li>系统能够阻止任意非授权的访问或者攻击</li>\n</ul>\n<p>如果以上代表了“正常工作”，那么我们可以大致的理解可靠性为:“即使在事情出错的情况下仍能继续正常工作”。</p>\n<h2 id=\"硬件故障\"><a href=\"#硬件故障\" class=\"headerlink\" title=\"硬件故障\"></a>硬件故障</h2><p>当我们讨论系统失效的原因的时候，很容易就会想到硬件故障。硬盘崩溃，RAM出错，电网停电，错拔网线。任何有过大型数据中心工作经验的人都会告诉你当你有大量机器的时候这些问题随时都在发生。</p>\n<p>硬盘通常拥有10到50年的平均失效前时间。因此，对于一个拥有10000个硬盘的存储集群来说，我们可以计算出平均每天都有一个硬盘失效。</p>\n<p>我们第一个应对措施便是为系统的独立硬件组件增加冗余，来减少失效率。磁盘可以通过组件RAID，服务器可以拥有双电源的热插拔CPU，数据中心可以增加电池以及柴油发电机作为备用电源。当一个部件出错，冗余部件能够及时代替出错部件工作。这种方法不能完全阻止硬件故障带来的系统错误，但是确实一个常用的且效果还不错的方式。</p>\n<p>但是近些年随着数据量以及应用计算能力需求的增加，许多应用开始使用大量的机器，这导致了硬件故障的概率大大增加。因此在系统能容忍丢失整个机器这一点上，有了长足的进步，具体实现方式是优先使用软件层面的容错技术或作为增加硬件冗余的补充。这样的系统在操作上具有优势:一个单机系统如果需要重启机器的话那么需要一定的服务离线时间(如应用系统安全补丁等操作)，然而一个能够容忍机器失效的系统可以一次操作一个结点，而不会引起整个系统服务的离线(<em>滚动升级</em>)。</p>\n<h2 id=\"软件错误\"><a href=\"#软件错误\" class=\"headerlink\" title=\"软件错误\"></a>软件错误</h2><p>另一类错误是系统错误，这类错误更难以预料，因为它们常常是跨不同结点关联，相对于硬件故障，这类错误更容易导致更多的系统失效，包括:</p>\n<ul>\n<li>一个软件bug导致应用服务器的每一个实例在接收到一个特殊错误输入的时候崩溃。如2012年6月30日闰秒带来的问题，由Linux内核引起的一个bug导致许多程序被同时挂起。</li>\n<li>一个失效进程用尽共享资源，如CPU，内存，磁盘，网络带宽等。</li>\n<li>一个系统依赖的服务变慢，反应迟钝，或返回错误结果。</li>\n<li>级联错误，当一个部件中的小错误引起了另一个部件中的错误，而该错误又会继续引起其他错误。</li>\n</ul>\n<p>该类错误没有快速的解决方法。但是有许多细节可以帮助:小心思考系统的假设以及交互；完备的测试；进程隔离；允许进程崩溃重启；在生产环境中监测、评价以及分析系统的行为。</p>\n<h2 id=\"人为错误\"><a href=\"#人为错误\" class=\"headerlink\" title=\"人为错误\"></a>人为错误</h2><p>人类设计并搭建了软件系统，保证系统运转的操作者仍然是人类。即使他们有最好的意图，人类仍然是不可靠的。例如，一个面向大量互联网服务的调查表明引起运行中断的首要原因是操作者的配置错误，而硬件故障(服务器或者网络)只占比10-25%。</p>\n<p>我们如何使我们的系统更加可靠，尽管有不可靠的人类？优秀的系统常常包含以下方法:</p>\n<ul>\n<li>设计一个最大程度下减少出错可能的系统。如良好的抽象，API，提供管理员界面使得“做正确的事”简单并不鼓励“做不正确的事”。然而，如果管理员界面如果限制太多，人们将会绕过它们，否定它们的好处，所以这是一个棘手的平衡。</li>\n<li>解耦人们最容易犯错的地方与会造成错误的地方。特别的，提供完成的非生产沙盒环境供用户安全地探索及实验，使用真实数据，却不影响真实用户。</li>\n<li>在所有层面都进行完备的测试，从单元测试到整个系统的集成测试以及手动测试。自动测试是一个被广泛使用，广泛认知，尤其对覆盖在正常运行中很少出现的角落案例非常有用的工具。</li>\n<li>允许从用户错误中快速且方便的恢复，以最大程度上减少该错误带来的影响。</li>\n<li>建立详细且清晰的监测，例如性能度量以及错误率。</li>\n<li>实施良好的管理实践和培训。</li>\n</ul>\n<p>未完待续…</p>\n","site":{"data":{}},"excerpt":"<p>之前在搜索时无意中发现了这本书<a href=\"https://book.douban.com/subject/26197294/\" target=\"_blank\" rel=\"noopener\">《Designing Data-Intensive Applications》</a>，豆瓣评分高达9.4，于是尝试进行阅读，发现真是堪称教科书一般的存在，深入浅出的介绍了后端开发中这么多年来大热的各种技术相关知识，如从数据库语言的诞生一直到NoSQL的火热，分布式等等，由于此书包含内容很多，且无中文翻译，因此阅读起来难免会遗忘之前的内容，因此写下此笔记帮助日后复习回忆。</p>","more":"<p>当今许多应用都应算为<em>数据密集型</em>，这与传统的<em>计算密集型</em>相对。因为相对于海量的数据，数据的复杂性，以及数据快速变化，CPU计算能力对这些应用来说几乎并不算限制因素。</p>\n<p>常见的应用需要完成以下功能:</p>\n<ul>\n<li>存储数据，以便自身或其他应用在日后进行访问(<em>数据库</em>)</li>\n<li>存储复杂操作的计算结果，以便提升读取效率(<em>缓存</em>)</li>\n<li>允许用户以不同方式使用关键字来查询或者过滤数据(<em>索引</em>)</li>\n<li>以异步的方式向其他进程发送消息(<em>流处理</em>)</li>\n<li>周期性地处理一大批积累的数据(<em>批处理</em>)</li>\n</ul>\n<p>但对于编写一个新的应用，开发者根本不会去编写一个新的数据存储引擎，因为对于这个工作来说，数据库已经是一个十分适合的工具了。但是现实并没有那么简单，因为当下存在很多数据库，它们拥有不同特性，不同的缓存方式，不同的创建索引方式等等。因此当我们编写一个新的应用的时候，如何去选择最合适工具以及方式来解决手头的问题仍然是我们需要解决的问题。本书从原理以及实践出发，对数据系统，以及如何使用这些工具来编写数据密集型应用进行了说明。</p>\n<h1 id=\"数据系统\"><a href=\"#数据系统\" class=\"headerlink\" title=\"数据系统\"></a>数据系统</h1><p>我们通常认为数据库、队列、缓存等式不同类型的工具，那么为什么我们要将它们都归结为<em>数据系统</em>呢？</p>\n<ol>\n<li>首先，近些年来许多用于数据存储和处理的工具呈现合并的趋势。比如可充当消息队列的数据存储工具<em>Redis</em>，以及可提供类数据库持久化的消息队列(<em>Apache Kafka</em>)。</li>\n<li>其次，随着当下大量应用需求的飞速发展，单一工具已经不能再满足所有的数据处理以及存储需求。例如，假设你有一个由应用管理的缓存层(使用Memcached等工具)，或是一个独立于主数据库的全文搜索服务器(如Elasticsearch)，那么正常情况下应该由应用程序自身来与主数据库同步并保留相关缓存或索引，如下图所示。</li>\n</ol>\n<p><img src=\"/2018/02/23/DDIA读书笔记1/Data_system_architecture_combining_several_components.png\" alt=\"\"></p>\n<p>当你结合多个工具来完成一项服务的提供时，其API通常会对客户端隐藏实现细节。此时你本质上是通过更小的通用型的工具来创建了一个新的特殊用途的数据系统。如缓存将会正确无效化或在数据库写入时更新，使得外界客户端得到一致的结果。此时你不仅是一个应用开发者，同时也是一个数据系统设计者。</p>\n<p>当你设计如此一个数据系统或服务时，将会出现很多棘手的问题。在内部出错的情况下如何保证数据正确且完整？如何保证即使在部分系统降级的情况下始终如一地向客户端提供良好服务？如何扩容来满足处理负载的增加？一个优秀的API应是什么样？</p>\n<p>有许许多多的因素来影响一个数据系统的设计，在本书中主要着重讲述大多数软件系统中最重要的三点。</p>\n<ul>\n<li><em>可靠性</em>(<strong>Reliability</strong>):系统即使在遭遇灾难(硬件或软件错误，甚至是人为错误)的时候仍应保证正常运行</li>\n<li><em>可扩展性</em>(<strong>Scalability</strong>):应存在合理的方式来处理系统的增长(数据量，流量，复杂性)</li>\n<li><em>可维护性</em>(<strong>Maintainability</strong>):随着时间推移，会有不同的人于该系统上工作(维护现有任务并调整系统适应新的需求)，工作人员应当能够高效的完成这些工作。</li>\n</ul>\n<h1 id=\"可靠性\"><a href=\"#可靠性\" class=\"headerlink\" title=\"可靠性\"></a>可靠性</h1><p>每个人对某个东西可靠或不可靠都有不同的定义，对软件来说，对其的期望主要包括:</p>\n<ul>\n<li>应用程序表现出用户预期的功能</li>\n<li>其可容忍用户错误操作或使用非预期方式来使用软件</li>\n<li>在预期负载量以及数据量的情况下，其性能表现良好</li>\n<li>系统能够阻止任意非授权的访问或者攻击</li>\n</ul>\n<p>如果以上代表了“正常工作”，那么我们可以大致的理解可靠性为:“即使在事情出错的情况下仍能继续正常工作”。</p>\n<h2 id=\"硬件故障\"><a href=\"#硬件故障\" class=\"headerlink\" title=\"硬件故障\"></a>硬件故障</h2><p>当我们讨论系统失效的原因的时候，很容易就会想到硬件故障。硬盘崩溃，RAM出错，电网停电，错拔网线。任何有过大型数据中心工作经验的人都会告诉你当你有大量机器的时候这些问题随时都在发生。</p>\n<p>硬盘通常拥有10到50年的平均失效前时间。因此，对于一个拥有10000个硬盘的存储集群来说，我们可以计算出平均每天都有一个硬盘失效。</p>\n<p>我们第一个应对措施便是为系统的独立硬件组件增加冗余，来减少失效率。磁盘可以通过组件RAID，服务器可以拥有双电源的热插拔CPU，数据中心可以增加电池以及柴油发电机作为备用电源。当一个部件出错，冗余部件能够及时代替出错部件工作。这种方法不能完全阻止硬件故障带来的系统错误，但是确实一个常用的且效果还不错的方式。</p>\n<p>但是近些年随着数据量以及应用计算能力需求的增加，许多应用开始使用大量的机器，这导致了硬件故障的概率大大增加。因此在系统能容忍丢失整个机器这一点上，有了长足的进步，具体实现方式是优先使用软件层面的容错技术或作为增加硬件冗余的补充。这样的系统在操作上具有优势:一个单机系统如果需要重启机器的话那么需要一定的服务离线时间(如应用系统安全补丁等操作)，然而一个能够容忍机器失效的系统可以一次操作一个结点，而不会引起整个系统服务的离线(<em>滚动升级</em>)。</p>\n<h2 id=\"软件错误\"><a href=\"#软件错误\" class=\"headerlink\" title=\"软件错误\"></a>软件错误</h2><p>另一类错误是系统错误，这类错误更难以预料，因为它们常常是跨不同结点关联，相对于硬件故障，这类错误更容易导致更多的系统失效，包括:</p>\n<ul>\n<li>一个软件bug导致应用服务器的每一个实例在接收到一个特殊错误输入的时候崩溃。如2012年6月30日闰秒带来的问题，由Linux内核引起的一个bug导致许多程序被同时挂起。</li>\n<li>一个失效进程用尽共享资源，如CPU，内存，磁盘，网络带宽等。</li>\n<li>一个系统依赖的服务变慢，反应迟钝，或返回错误结果。</li>\n<li>级联错误，当一个部件中的小错误引起了另一个部件中的错误，而该错误又会继续引起其他错误。</li>\n</ul>\n<p>该类错误没有快速的解决方法。但是有许多细节可以帮助:小心思考系统的假设以及交互；完备的测试；进程隔离；允许进程崩溃重启；在生产环境中监测、评价以及分析系统的行为。</p>\n<h2 id=\"人为错误\"><a href=\"#人为错误\" class=\"headerlink\" title=\"人为错误\"></a>人为错误</h2><p>人类设计并搭建了软件系统，保证系统运转的操作者仍然是人类。即使他们有最好的意图，人类仍然是不可靠的。例如，一个面向大量互联网服务的调查表明引起运行中断的首要原因是操作者的配置错误，而硬件故障(服务器或者网络)只占比10-25%。</p>\n<p>我们如何使我们的系统更加可靠，尽管有不可靠的人类？优秀的系统常常包含以下方法:</p>\n<ul>\n<li>设计一个最大程度下减少出错可能的系统。如良好的抽象，API，提供管理员界面使得“做正确的事”简单并不鼓励“做不正确的事”。然而，如果管理员界面如果限制太多，人们将会绕过它们，否定它们的好处，所以这是一个棘手的平衡。</li>\n<li>解耦人们最容易犯错的地方与会造成错误的地方。特别的，提供完成的非生产沙盒环境供用户安全地探索及实验，使用真实数据，却不影响真实用户。</li>\n<li>在所有层面都进行完备的测试，从单元测试到整个系统的集成测试以及手动测试。自动测试是一个被广泛使用，广泛认知，尤其对覆盖在正常运行中很少出现的角落案例非常有用的工具。</li>\n<li>允许从用户错误中快速且方便的恢复，以最大程度上减少该错误带来的影响。</li>\n<li>建立详细且清晰的监测，例如性能度量以及错误率。</li>\n<li>实施良好的管理实践和培训。</li>\n</ul>\n<p>未完待续…</p>"},{"title":"DDIA读书笔记2-可靠性、可扩展性和可维护性(二)","date":"2018-02-24T07:27:37.000Z","_content":"\n\n前文讲述了数据系统与可靠性，本篇中将对可扩展性以及可维护性进行总结。\n\n<!-- more -->\n\n# 可扩展性\n\n即使一个系统在当下可靠的运行，并不代表在未来也会可靠运行。一个常见的原因是负载的增加：或许系统从支持10k的并发用户增加到了支持100k的并发用户，或者从1m增加到了10m。或许系统处理了比之前更多的数据量。\n\n可扩展性是一个我们用来描述系统应对负载增长能力的术语。但需要注意的是，这并不是我们直接赋予系统的一个一维的标签:说“X可扩展”或者是“Y不可扩展”毫无意义。而应该是，“如果一个系统在某种程度上增长了，我们有哪些选项来应对这种增长？”和“我们如何增加更多的计算资源来应对额外的负载？”\n\n## 描述负载\n\n首先我们需要简要的描述当前系统的负载，之后才能讨论增长的问题。负载可以通过几个我们称之为负载参数的数字来进行描述。对于参数的最好选择依赖于系统架构：可能是网络服务器的每秒请求数，数据库的读写比，聊天室的并发活跃用户数，缓存命中率等等。或许平均情况下是你最在意哪个或者你的瓶颈来自于小部分极端案例。\n\n为了更具体的描述，我们考虑Twitter，Twitter的两个主要操作是:\n\n* 发布推文：每个用户能够发送新的信息给所有关注他的人(平均4.6k请求每秒，峰值12k请求每秒)\n* 主页时间线：用户可以浏览他关注的人的所有推文(300k请求每秒)\n\n单纯处理12k每秒的写是十分简单的。但是，Twitter的扩展挑战并不主要来自于推文的容量，而是扇出(**fan-out**)——每个用户关注了许多用户，每个用户被许多用户关注。有两种方式来实现以上操作：\n\n1. 发布一条推文只是简单的向推文集合里面插入一条新的推文。当一个用户请求的主页时间线时，查找所有其关注的用户，以及这些用户发布的推文，然后聚合这些推文(以时间排序)。在一个关系型数据库中，你可以写出以下语句：\n\t![](twitter_sql.png)\n2. 为每个用户的主页时间线维护一个缓存——就像为每个用户提供一个推文的收件邮箱。当一个用户发布一个推文，查找所有关注该用户的用户，将该新推文插入到他们的主页时间线中。对主页时间线的请求将变得轻量，因为它的结果已经提前被计算好的。\n\nTwitter最开始使用的是方法1，但是系统无法跟上主页时间线请求负载的增加，因此它们转向了方法2.其表现更好的原因是发布推文的平均频率几乎小于请求主页时间线平均频率两个数量级，因此在本案例中在写入的时候做更多的工作优于在读的时候做更多的工作。\n\n然而，方法2存在的一个弊端是发布一个推文需要更多的额外工作。平均情况下，一条推文将会发送给大约75个关注这，因此4.6k每秒的推特发布速度变成了345k每秒的主页时间线缓存写入。但是这样的平均下隐藏了一个事实，那就是每个用户的关注者数量差别巨大，有些用户拥有超过30m的关注者。者代表着一条推文可能导致超过30m的主页时间线写入！而完成这项操作是十分耗时的——Twitter试图将推文的投递给所有关注者这一操作限制到5秒以内——这是一个巨大的挑战。\n\n最终Twitter采用的版本是两种方法的混合。大多数用户的推文保持在发布是写入到关注者的主页时间线中，少部分拥有大量关注者的用户不采用扇出的方式。用户在访问主页时间线时其关注的名人的推文将单独获取并合并到用户的主页时间线中，就像方法1一样。\n\n## 描述性能\n\n当你可以描述系统的负载之后，你就可以开始调查当负载增加时会发生些什么。可以从这两方面进行：\n\n* 当你增加一个负载参数的值并保持系统资源（CPU，内存，网络带宽等等）不变，系统的性能如何？\n* 当你增加一个负载参数的值，需要增加多少系统资源来保持系统性能不变？\n\n这两个问题都需要性能数字来回答，因此让我们来简单的描述系统的性能。\n\n在Hadoop之类的批处理系统中，我们通常关心*吞吐量(throughput)*——一秒钟能处理的数据数量，或是处理一个固定大小数据集所需要的总时间。在线上系统中，通常更重要的是服务的*响应时间(response time)*，即客户端从发出请求到接收到响应的时间。\n\n在实际使用中，一个系统处理大量的请求，其响应时间可能大不相同。因此我们不能将响应时间定义为一个简单的数字，而是一个能测量到的数值的分布。如下图所示，每一个灰柱代表了向服务器的一次请求，高度表明了其响应时间。\n\n![](requests.png)\n\n许多请求都相当快速，但是时不时地会出现一些耗时很长的特殊请求。或许这些慢请求本质上是因为计算太多，比如它们处理了更多的数据。但是即使在某种场景下你认为所有的请求应该具有相同的响应时间，这仍然无法办到：由于上下文被切换到后台进程带来的随机延迟，由于网络丢包以及TCP重传，垃圾回收带来的暂停，缺页导致从磁盘读取，来自于服务器支架的机械振动，以及其他种种原因。\n\n因此我们经常一个服务的*平均*响应时间。但是，如果你想知道具有代表性的响应时间的话，均值并不是一个很好的度量指标，因为它没有告诉你有多少用户实际上是这么长的延迟。\n\n因此更好的选择是*百分数(percentiles)*，如果你将所有的响应时间从最快到最慢进行排序，那么*中位数*刚好是一个分界点：假设你的响应时间的中位数是200ms，这代表了所有请求中的一半都快于200ms，剩下的一半都慢于200ms。\n\n这使得中位数是一个好的评价指标，中位数通常也被称为*50th percentile*，或简写为*p50*。需要注意的是，中位数代表了一个请求，如果用户进行了多次请求，其中至少一个请求的慢于中位数的概率远远大于50%。\n\n为了找出这些特别耗时的特殊请求究竟有多耗时，我们通常还可以取*95th*，*99*和*99.9*（*p95*，*p99*，*p99*)。这些响应时间表达了95%，99%或99.9%的请求小于当前响应时间。\n\n## 处理负载的方法\n\n现在我们已经有了描述负载的参数以及度量性能的方法，我们可以开始讨论可扩展性这一问题了：当负载参数增加一定值的时候我们要如何仍然保证良好的性能？\n\n一个适合某个数量级负载的架构设计可能并不能处理负载增加为10倍的情况。如果你正在负责一个快速增长的服务，那么自然而然地你需要在不同尺度下的负载增加的时候重新思考你的架构设计，或更频繁。\n\n人们通常会讨论*垂直扩容（scaling up）*（迁移到一个更强大的计算机）和*水平扩容（scaling out）*（将负载分布到多台小型机器上面）这两个对立的概念。将负载分布到多台机器上面也被称为*无共享（shared-nothing）*架构。一个能运行于单机的系统通常是简单的，但是一个高性能计算机通常是很昂贵的，因此几乎不可避免的会需要水平扩容。在现实情况下，一个优秀的架构通常会需要更实用的多种方法的混合体：使用多台性能还不错的机器仍然比大量小型虚拟机更加简单以及便宜。\n\n有些系统是*有弹性的（elastic）*，这代表着它们可以在检测到负载增加的时候自动增加更多的计算资源，与此相对其他系统需要手动扩容（由开发者来分析容量并决定向系统增加更多机器）。一个弹性系统对于负载高度不可预测这种情况是十分游泳的，但是手动扩容系统更加简单而且更不容易出错。\n\n虽然在许多台机器间分发无状态服务是十分简单的，但是将有状态的数据系统从单一节点扩展为分布式设置将带来大量额外的复杂工作。因此，直到最近仍在使用的常见方法是将数据库存储于单一节点（垂直扩容）直到扩容花销或高可用需求迫使你将其进行分布式。\n\n# 可维护性\n\n众所周知一个软件的主要开销并不在于其初始的开发过程中，而是其后期维护——修复bug，保持系统运行，调查错误，适应新平台，根据需求进行修改，支付专利费，添加新功能。\n\n我们应该以一种能够尝试最大程度减轻后期维护负担的方式来进行开发，为了完成这一目标，我们需要特别注意以下三个设计原则：\n\n* *可操作性（Operability）*：使得运维团队让保证系统流畅运行变得简单。\n* *简易性（Simplicity）*：使新工程师熟悉该系统变得简单，可以通过尽可能消除复杂性的方法（这和UI的简易性不同）\n* *可进化性（Evolvability）*：使得工程师未来由于需求变化以需要适应未预料到的用户使用情况而改变系统变得简单。也被称为可扩展性，可修改性，可塑性。\n\n## 可操作性\n\n好的可操作性代表了使得运维团队的工作变得简单，让他们可以关注其更有价值的活动。数据系统可以通过以下方法来提高可操作性：\n\n* 对系统的运行时以及内部环境提供可视化工具以及好的监控工具\n* 为自动化以及标准工具继承提供好的支持\n* 避免单机依赖（允许机器被换下维护同时系统可以正常运行不受影响）\n* 提供好的文档说明以及简单易懂的操作流程（如果我做了X，将会发生Y）\n* 提供好的默认行为，但也应给予管理员在需要的时候重写这些行为的自由\n* 在合适的时候自我修复，但也应允许管理员在需要的时候手动控制系统状态\n* 列出可预测的行为，最小化意外情况\n\n## 简易性\n\n使一个系统更加简单并不意味着减少其功能，而是代表减少偶发复杂性。**Moseley**和**Marks**以不是用户能够看到的问题引发但是是来自于代码实现中的偶发情况来定义复杂性。\n\n减少偶发复杂性的最有效工具之一就是*抽象*。一个好的抽象能够将大量的实现细节隐藏于一个干净的，简单易懂的门后面。一个好的抽象也能在大量不同的应用之间使用。不仅是因为这种方法重用了大量实现而不需要重复实现，而且这带来了高质量软件，随着抽象组件质量的提高使得所有使用该组件的应用都能受益。\n\n然而，找到一个好的抽象是很困难的。在分布式系统中，虽然有许多优秀的算法，但是他们远不够简洁，无法让我们知道如何将这些东西打包并抽象，来帮助我们让系统的复杂度在一个可控的水平上。\n\n## 可进化性\n\n一个系统的需求永远不变这几乎不可能。它们更像一个永远不停的过程：你了解了新的事实，之前没预料到的使用情况出现了，业务重点变化，用户要求新的功能，新平台代替旧平台，法律或监管需求改变，系统增加迫使架构改变等等。\n\n在组织流程方面，*敏捷(Agile)开发*为适应改变提供了一个框架。该社区还开发了一系列工具以及有用的模式来帮助在快速变化的环境里开发软件，比如*测试驱动开发（TDD）*和*重构*。","source":"_posts/DDIA读书笔记2.md","raw":"---\ntitle: DDIA读书笔记2-可靠性、可扩展性和可维护性(二)\ntags:\n  - 可扩展性\n  - 负载\n  - 可维护性\ncategories: 系统架构\ndate: 2018-02-24 15:27:37\n---\n\n\n前文讲述了数据系统与可靠性，本篇中将对可扩展性以及可维护性进行总结。\n\n<!-- more -->\n\n# 可扩展性\n\n即使一个系统在当下可靠的运行，并不代表在未来也会可靠运行。一个常见的原因是负载的增加：或许系统从支持10k的并发用户增加到了支持100k的并发用户，或者从1m增加到了10m。或许系统处理了比之前更多的数据量。\n\n可扩展性是一个我们用来描述系统应对负载增长能力的术语。但需要注意的是，这并不是我们直接赋予系统的一个一维的标签:说“X可扩展”或者是“Y不可扩展”毫无意义。而应该是，“如果一个系统在某种程度上增长了，我们有哪些选项来应对这种增长？”和“我们如何增加更多的计算资源来应对额外的负载？”\n\n## 描述负载\n\n首先我们需要简要的描述当前系统的负载，之后才能讨论增长的问题。负载可以通过几个我们称之为负载参数的数字来进行描述。对于参数的最好选择依赖于系统架构：可能是网络服务器的每秒请求数，数据库的读写比，聊天室的并发活跃用户数，缓存命中率等等。或许平均情况下是你最在意哪个或者你的瓶颈来自于小部分极端案例。\n\n为了更具体的描述，我们考虑Twitter，Twitter的两个主要操作是:\n\n* 发布推文：每个用户能够发送新的信息给所有关注他的人(平均4.6k请求每秒，峰值12k请求每秒)\n* 主页时间线：用户可以浏览他关注的人的所有推文(300k请求每秒)\n\n单纯处理12k每秒的写是十分简单的。但是，Twitter的扩展挑战并不主要来自于推文的容量，而是扇出(**fan-out**)——每个用户关注了许多用户，每个用户被许多用户关注。有两种方式来实现以上操作：\n\n1. 发布一条推文只是简单的向推文集合里面插入一条新的推文。当一个用户请求的主页时间线时，查找所有其关注的用户，以及这些用户发布的推文，然后聚合这些推文(以时间排序)。在一个关系型数据库中，你可以写出以下语句：\n\t![](twitter_sql.png)\n2. 为每个用户的主页时间线维护一个缓存——就像为每个用户提供一个推文的收件邮箱。当一个用户发布一个推文，查找所有关注该用户的用户，将该新推文插入到他们的主页时间线中。对主页时间线的请求将变得轻量，因为它的结果已经提前被计算好的。\n\nTwitter最开始使用的是方法1，但是系统无法跟上主页时间线请求负载的增加，因此它们转向了方法2.其表现更好的原因是发布推文的平均频率几乎小于请求主页时间线平均频率两个数量级，因此在本案例中在写入的时候做更多的工作优于在读的时候做更多的工作。\n\n然而，方法2存在的一个弊端是发布一个推文需要更多的额外工作。平均情况下，一条推文将会发送给大约75个关注这，因此4.6k每秒的推特发布速度变成了345k每秒的主页时间线缓存写入。但是这样的平均下隐藏了一个事实，那就是每个用户的关注者数量差别巨大，有些用户拥有超过30m的关注者。者代表着一条推文可能导致超过30m的主页时间线写入！而完成这项操作是十分耗时的——Twitter试图将推文的投递给所有关注者这一操作限制到5秒以内——这是一个巨大的挑战。\n\n最终Twitter采用的版本是两种方法的混合。大多数用户的推文保持在发布是写入到关注者的主页时间线中，少部分拥有大量关注者的用户不采用扇出的方式。用户在访问主页时间线时其关注的名人的推文将单独获取并合并到用户的主页时间线中，就像方法1一样。\n\n## 描述性能\n\n当你可以描述系统的负载之后，你就可以开始调查当负载增加时会发生些什么。可以从这两方面进行：\n\n* 当你增加一个负载参数的值并保持系统资源（CPU，内存，网络带宽等等）不变，系统的性能如何？\n* 当你增加一个负载参数的值，需要增加多少系统资源来保持系统性能不变？\n\n这两个问题都需要性能数字来回答，因此让我们来简单的描述系统的性能。\n\n在Hadoop之类的批处理系统中，我们通常关心*吞吐量(throughput)*——一秒钟能处理的数据数量，或是处理一个固定大小数据集所需要的总时间。在线上系统中，通常更重要的是服务的*响应时间(response time)*，即客户端从发出请求到接收到响应的时间。\n\n在实际使用中，一个系统处理大量的请求，其响应时间可能大不相同。因此我们不能将响应时间定义为一个简单的数字，而是一个能测量到的数值的分布。如下图所示，每一个灰柱代表了向服务器的一次请求，高度表明了其响应时间。\n\n![](requests.png)\n\n许多请求都相当快速，但是时不时地会出现一些耗时很长的特殊请求。或许这些慢请求本质上是因为计算太多，比如它们处理了更多的数据。但是即使在某种场景下你认为所有的请求应该具有相同的响应时间，这仍然无法办到：由于上下文被切换到后台进程带来的随机延迟，由于网络丢包以及TCP重传，垃圾回收带来的暂停，缺页导致从磁盘读取，来自于服务器支架的机械振动，以及其他种种原因。\n\n因此我们经常一个服务的*平均*响应时间。但是，如果你想知道具有代表性的响应时间的话，均值并不是一个很好的度量指标，因为它没有告诉你有多少用户实际上是这么长的延迟。\n\n因此更好的选择是*百分数(percentiles)*，如果你将所有的响应时间从最快到最慢进行排序，那么*中位数*刚好是一个分界点：假设你的响应时间的中位数是200ms，这代表了所有请求中的一半都快于200ms，剩下的一半都慢于200ms。\n\n这使得中位数是一个好的评价指标，中位数通常也被称为*50th percentile*，或简写为*p50*。需要注意的是，中位数代表了一个请求，如果用户进行了多次请求，其中至少一个请求的慢于中位数的概率远远大于50%。\n\n为了找出这些特别耗时的特殊请求究竟有多耗时，我们通常还可以取*95th*，*99*和*99.9*（*p95*，*p99*，*p99*)。这些响应时间表达了95%，99%或99.9%的请求小于当前响应时间。\n\n## 处理负载的方法\n\n现在我们已经有了描述负载的参数以及度量性能的方法，我们可以开始讨论可扩展性这一问题了：当负载参数增加一定值的时候我们要如何仍然保证良好的性能？\n\n一个适合某个数量级负载的架构设计可能并不能处理负载增加为10倍的情况。如果你正在负责一个快速增长的服务，那么自然而然地你需要在不同尺度下的负载增加的时候重新思考你的架构设计，或更频繁。\n\n人们通常会讨论*垂直扩容（scaling up）*（迁移到一个更强大的计算机）和*水平扩容（scaling out）*（将负载分布到多台小型机器上面）这两个对立的概念。将负载分布到多台机器上面也被称为*无共享（shared-nothing）*架构。一个能运行于单机的系统通常是简单的，但是一个高性能计算机通常是很昂贵的，因此几乎不可避免的会需要水平扩容。在现实情况下，一个优秀的架构通常会需要更实用的多种方法的混合体：使用多台性能还不错的机器仍然比大量小型虚拟机更加简单以及便宜。\n\n有些系统是*有弹性的（elastic）*，这代表着它们可以在检测到负载增加的时候自动增加更多的计算资源，与此相对其他系统需要手动扩容（由开发者来分析容量并决定向系统增加更多机器）。一个弹性系统对于负载高度不可预测这种情况是十分游泳的，但是手动扩容系统更加简单而且更不容易出错。\n\n虽然在许多台机器间分发无状态服务是十分简单的，但是将有状态的数据系统从单一节点扩展为分布式设置将带来大量额外的复杂工作。因此，直到最近仍在使用的常见方法是将数据库存储于单一节点（垂直扩容）直到扩容花销或高可用需求迫使你将其进行分布式。\n\n# 可维护性\n\n众所周知一个软件的主要开销并不在于其初始的开发过程中，而是其后期维护——修复bug，保持系统运行，调查错误，适应新平台，根据需求进行修改，支付专利费，添加新功能。\n\n我们应该以一种能够尝试最大程度减轻后期维护负担的方式来进行开发，为了完成这一目标，我们需要特别注意以下三个设计原则：\n\n* *可操作性（Operability）*：使得运维团队让保证系统流畅运行变得简单。\n* *简易性（Simplicity）*：使新工程师熟悉该系统变得简单，可以通过尽可能消除复杂性的方法（这和UI的简易性不同）\n* *可进化性（Evolvability）*：使得工程师未来由于需求变化以需要适应未预料到的用户使用情况而改变系统变得简单。也被称为可扩展性，可修改性，可塑性。\n\n## 可操作性\n\n好的可操作性代表了使得运维团队的工作变得简单，让他们可以关注其更有价值的活动。数据系统可以通过以下方法来提高可操作性：\n\n* 对系统的运行时以及内部环境提供可视化工具以及好的监控工具\n* 为自动化以及标准工具继承提供好的支持\n* 避免单机依赖（允许机器被换下维护同时系统可以正常运行不受影响）\n* 提供好的文档说明以及简单易懂的操作流程（如果我做了X，将会发生Y）\n* 提供好的默认行为，但也应给予管理员在需要的时候重写这些行为的自由\n* 在合适的时候自我修复，但也应允许管理员在需要的时候手动控制系统状态\n* 列出可预测的行为，最小化意外情况\n\n## 简易性\n\n使一个系统更加简单并不意味着减少其功能，而是代表减少偶发复杂性。**Moseley**和**Marks**以不是用户能够看到的问题引发但是是来自于代码实现中的偶发情况来定义复杂性。\n\n减少偶发复杂性的最有效工具之一就是*抽象*。一个好的抽象能够将大量的实现细节隐藏于一个干净的，简单易懂的门后面。一个好的抽象也能在大量不同的应用之间使用。不仅是因为这种方法重用了大量实现而不需要重复实现，而且这带来了高质量软件，随着抽象组件质量的提高使得所有使用该组件的应用都能受益。\n\n然而，找到一个好的抽象是很困难的。在分布式系统中，虽然有许多优秀的算法，但是他们远不够简洁，无法让我们知道如何将这些东西打包并抽象，来帮助我们让系统的复杂度在一个可控的水平上。\n\n## 可进化性\n\n一个系统的需求永远不变这几乎不可能。它们更像一个永远不停的过程：你了解了新的事实，之前没预料到的使用情况出现了，业务重点变化，用户要求新的功能，新平台代替旧平台，法律或监管需求改变，系统增加迫使架构改变等等。\n\n在组织流程方面，*敏捷(Agile)开发*为适应改变提供了一个框架。该社区还开发了一系列工具以及有用的模式来帮助在快速变化的环境里开发软件，比如*测试驱动开发（TDD）*和*重构*。","slug":"DDIA读书笔记2","published":1,"updated":"2018-02-26T03:55:25.665Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgvnqmkv000hw628tqu1bnpb","content":"<p>前文讲述了数据系统与可靠性，本篇中将对可扩展性以及可维护性进行总结。</p>\n<a id=\"more\"></a>\n<h1 id=\"可扩展性\"><a href=\"#可扩展性\" class=\"headerlink\" title=\"可扩展性\"></a>可扩展性</h1><p>即使一个系统在当下可靠的运行，并不代表在未来也会可靠运行。一个常见的原因是负载的增加：或许系统从支持10k的并发用户增加到了支持100k的并发用户，或者从1m增加到了10m。或许系统处理了比之前更多的数据量。</p>\n<p>可扩展性是一个我们用来描述系统应对负载增长能力的术语。但需要注意的是，这并不是我们直接赋予系统的一个一维的标签:说“X可扩展”或者是“Y不可扩展”毫无意义。而应该是，“如果一个系统在某种程度上增长了，我们有哪些选项来应对这种增长？”和“我们如何增加更多的计算资源来应对额外的负载？”</p>\n<h2 id=\"描述负载\"><a href=\"#描述负载\" class=\"headerlink\" title=\"描述负载\"></a>描述负载</h2><p>首先我们需要简要的描述当前系统的负载，之后才能讨论增长的问题。负载可以通过几个我们称之为负载参数的数字来进行描述。对于参数的最好选择依赖于系统架构：可能是网络服务器的每秒请求数，数据库的读写比，聊天室的并发活跃用户数，缓存命中率等等。或许平均情况下是你最在意哪个或者你的瓶颈来自于小部分极端案例。</p>\n<p>为了更具体的描述，我们考虑Twitter，Twitter的两个主要操作是:</p>\n<ul>\n<li>发布推文：每个用户能够发送新的信息给所有关注他的人(平均4.6k请求每秒，峰值12k请求每秒)</li>\n<li>主页时间线：用户可以浏览他关注的人的所有推文(300k请求每秒)</li>\n</ul>\n<p>单纯处理12k每秒的写是十分简单的。但是，Twitter的扩展挑战并不主要来自于推文的容量，而是扇出(<strong>fan-out</strong>)——每个用户关注了许多用户，每个用户被许多用户关注。有两种方式来实现以上操作：</p>\n<ol>\n<li>发布一条推文只是简单的向推文集合里面插入一条新的推文。当一个用户请求的主页时间线时，查找所有其关注的用户，以及这些用户发布的推文，然后聚合这些推文(以时间排序)。在一个关系型数据库中，你可以写出以下语句：<br> <img src=\"/2018/02/24/DDIA读书笔记2/twitter_sql.png\" alt=\"\"></li>\n<li>为每个用户的主页时间线维护一个缓存——就像为每个用户提供一个推文的收件邮箱。当一个用户发布一个推文，查找所有关注该用户的用户，将该新推文插入到他们的主页时间线中。对主页时间线的请求将变得轻量，因为它的结果已经提前被计算好的。</li>\n</ol>\n<p>Twitter最开始使用的是方法1，但是系统无法跟上主页时间线请求负载的增加，因此它们转向了方法2.其表现更好的原因是发布推文的平均频率几乎小于请求主页时间线平均频率两个数量级，因此在本案例中在写入的时候做更多的工作优于在读的时候做更多的工作。</p>\n<p>然而，方法2存在的一个弊端是发布一个推文需要更多的额外工作。平均情况下，一条推文将会发送给大约75个关注这，因此4.6k每秒的推特发布速度变成了345k每秒的主页时间线缓存写入。但是这样的平均下隐藏了一个事实，那就是每个用户的关注者数量差别巨大，有些用户拥有超过30m的关注者。者代表着一条推文可能导致超过30m的主页时间线写入！而完成这项操作是十分耗时的——Twitter试图将推文的投递给所有关注者这一操作限制到5秒以内——这是一个巨大的挑战。</p>\n<p>最终Twitter采用的版本是两种方法的混合。大多数用户的推文保持在发布是写入到关注者的主页时间线中，少部分拥有大量关注者的用户不采用扇出的方式。用户在访问主页时间线时其关注的名人的推文将单独获取并合并到用户的主页时间线中，就像方法1一样。</p>\n<h2 id=\"描述性能\"><a href=\"#描述性能\" class=\"headerlink\" title=\"描述性能\"></a>描述性能</h2><p>当你可以描述系统的负载之后，你就可以开始调查当负载增加时会发生些什么。可以从这两方面进行：</p>\n<ul>\n<li>当你增加一个负载参数的值并保持系统资源（CPU，内存，网络带宽等等）不变，系统的性能如何？</li>\n<li>当你增加一个负载参数的值，需要增加多少系统资源来保持系统性能不变？</li>\n</ul>\n<p>这两个问题都需要性能数字来回答，因此让我们来简单的描述系统的性能。</p>\n<p>在Hadoop之类的批处理系统中，我们通常关心<em>吞吐量(throughput)</em>——一秒钟能处理的数据数量，或是处理一个固定大小数据集所需要的总时间。在线上系统中，通常更重要的是服务的<em>响应时间(response time)</em>，即客户端从发出请求到接收到响应的时间。</p>\n<p>在实际使用中，一个系统处理大量的请求，其响应时间可能大不相同。因此我们不能将响应时间定义为一个简单的数字，而是一个能测量到的数值的分布。如下图所示，每一个灰柱代表了向服务器的一次请求，高度表明了其响应时间。</p>\n<p><img src=\"/2018/02/24/DDIA读书笔记2/requests.png\" alt=\"\"></p>\n<p>许多请求都相当快速，但是时不时地会出现一些耗时很长的特殊请求。或许这些慢请求本质上是因为计算太多，比如它们处理了更多的数据。但是即使在某种场景下你认为所有的请求应该具有相同的响应时间，这仍然无法办到：由于上下文被切换到后台进程带来的随机延迟，由于网络丢包以及TCP重传，垃圾回收带来的暂停，缺页导致从磁盘读取，来自于服务器支架的机械振动，以及其他种种原因。</p>\n<p>因此我们经常一个服务的<em>平均</em>响应时间。但是，如果你想知道具有代表性的响应时间的话，均值并不是一个很好的度量指标，因为它没有告诉你有多少用户实际上是这么长的延迟。</p>\n<p>因此更好的选择是<em>百分数(percentiles)</em>，如果你将所有的响应时间从最快到最慢进行排序，那么<em>中位数</em>刚好是一个分界点：假设你的响应时间的中位数是200ms，这代表了所有请求中的一半都快于200ms，剩下的一半都慢于200ms。</p>\n<p>这使得中位数是一个好的评价指标，中位数通常也被称为<em>50th percentile</em>，或简写为<em>p50</em>。需要注意的是，中位数代表了一个请求，如果用户进行了多次请求，其中至少一个请求的慢于中位数的概率远远大于50%。</p>\n<p>为了找出这些特别耗时的特殊请求究竟有多耗时，我们通常还可以取<em>95th</em>，<em>99</em>和<em>99.9</em>（<em>p95</em>，<em>p99</em>，<em>p99</em>)。这些响应时间表达了95%，99%或99.9%的请求小于当前响应时间。</p>\n<h2 id=\"处理负载的方法\"><a href=\"#处理负载的方法\" class=\"headerlink\" title=\"处理负载的方法\"></a>处理负载的方法</h2><p>现在我们已经有了描述负载的参数以及度量性能的方法，我们可以开始讨论可扩展性这一问题了：当负载参数增加一定值的时候我们要如何仍然保证良好的性能？</p>\n<p>一个适合某个数量级负载的架构设计可能并不能处理负载增加为10倍的情况。如果你正在负责一个快速增长的服务，那么自然而然地你需要在不同尺度下的负载增加的时候重新思考你的架构设计，或更频繁。</p>\n<p>人们通常会讨论<em>垂直扩容（scaling up）</em>（迁移到一个更强大的计算机）和<em>水平扩容（scaling out）</em>（将负载分布到多台小型机器上面）这两个对立的概念。将负载分布到多台机器上面也被称为<em>无共享（shared-nothing）</em>架构。一个能运行于单机的系统通常是简单的，但是一个高性能计算机通常是很昂贵的，因此几乎不可避免的会需要水平扩容。在现实情况下，一个优秀的架构通常会需要更实用的多种方法的混合体：使用多台性能还不错的机器仍然比大量小型虚拟机更加简单以及便宜。</p>\n<p>有些系统是<em>有弹性的（elastic）</em>，这代表着它们可以在检测到负载增加的时候自动增加更多的计算资源，与此相对其他系统需要手动扩容（由开发者来分析容量并决定向系统增加更多机器）。一个弹性系统对于负载高度不可预测这种情况是十分游泳的，但是手动扩容系统更加简单而且更不容易出错。</p>\n<p>虽然在许多台机器间分发无状态服务是十分简单的，但是将有状态的数据系统从单一节点扩展为分布式设置将带来大量额外的复杂工作。因此，直到最近仍在使用的常见方法是将数据库存储于单一节点（垂直扩容）直到扩容花销或高可用需求迫使你将其进行分布式。</p>\n<h1 id=\"可维护性\"><a href=\"#可维护性\" class=\"headerlink\" title=\"可维护性\"></a>可维护性</h1><p>众所周知一个软件的主要开销并不在于其初始的开发过程中，而是其后期维护——修复bug，保持系统运行，调查错误，适应新平台，根据需求进行修改，支付专利费，添加新功能。</p>\n<p>我们应该以一种能够尝试最大程度减轻后期维护负担的方式来进行开发，为了完成这一目标，我们需要特别注意以下三个设计原则：</p>\n<ul>\n<li><em>可操作性（Operability）</em>：使得运维团队让保证系统流畅运行变得简单。</li>\n<li><em>简易性（Simplicity）</em>：使新工程师熟悉该系统变得简单，可以通过尽可能消除复杂性的方法（这和UI的简易性不同）</li>\n<li><em>可进化性（Evolvability）</em>：使得工程师未来由于需求变化以需要适应未预料到的用户使用情况而改变系统变得简单。也被称为可扩展性，可修改性，可塑性。</li>\n</ul>\n<h2 id=\"可操作性\"><a href=\"#可操作性\" class=\"headerlink\" title=\"可操作性\"></a>可操作性</h2><p>好的可操作性代表了使得运维团队的工作变得简单，让他们可以关注其更有价值的活动。数据系统可以通过以下方法来提高可操作性：</p>\n<ul>\n<li>对系统的运行时以及内部环境提供可视化工具以及好的监控工具</li>\n<li>为自动化以及标准工具继承提供好的支持</li>\n<li>避免单机依赖（允许机器被换下维护同时系统可以正常运行不受影响）</li>\n<li>提供好的文档说明以及简单易懂的操作流程（如果我做了X，将会发生Y）</li>\n<li>提供好的默认行为，但也应给予管理员在需要的时候重写这些行为的自由</li>\n<li>在合适的时候自我修复，但也应允许管理员在需要的时候手动控制系统状态</li>\n<li>列出可预测的行为，最小化意外情况</li>\n</ul>\n<h2 id=\"简易性\"><a href=\"#简易性\" class=\"headerlink\" title=\"简易性\"></a>简易性</h2><p>使一个系统更加简单并不意味着减少其功能，而是代表减少偶发复杂性。<strong>Moseley</strong>和<strong>Marks</strong>以不是用户能够看到的问题引发但是是来自于代码实现中的偶发情况来定义复杂性。</p>\n<p>减少偶发复杂性的最有效工具之一就是<em>抽象</em>。一个好的抽象能够将大量的实现细节隐藏于一个干净的，简单易懂的门后面。一个好的抽象也能在大量不同的应用之间使用。不仅是因为这种方法重用了大量实现而不需要重复实现，而且这带来了高质量软件，随着抽象组件质量的提高使得所有使用该组件的应用都能受益。</p>\n<p>然而，找到一个好的抽象是很困难的。在分布式系统中，虽然有许多优秀的算法，但是他们远不够简洁，无法让我们知道如何将这些东西打包并抽象，来帮助我们让系统的复杂度在一个可控的水平上。</p>\n<h2 id=\"可进化性\"><a href=\"#可进化性\" class=\"headerlink\" title=\"可进化性\"></a>可进化性</h2><p>一个系统的需求永远不变这几乎不可能。它们更像一个永远不停的过程：你了解了新的事实，之前没预料到的使用情况出现了，业务重点变化，用户要求新的功能，新平台代替旧平台，法律或监管需求改变，系统增加迫使架构改变等等。</p>\n<p>在组织流程方面，<em>敏捷(Agile)开发</em>为适应改变提供了一个框架。该社区还开发了一系列工具以及有用的模式来帮助在快速变化的环境里开发软件，比如<em>测试驱动开发（TDD）</em>和<em>重构</em>。</p>\n","site":{"data":{}},"excerpt":"<p>前文讲述了数据系统与可靠性，本篇中将对可扩展性以及可维护性进行总结。</p>","more":"<h1 id=\"可扩展性\"><a href=\"#可扩展性\" class=\"headerlink\" title=\"可扩展性\"></a>可扩展性</h1><p>即使一个系统在当下可靠的运行，并不代表在未来也会可靠运行。一个常见的原因是负载的增加：或许系统从支持10k的并发用户增加到了支持100k的并发用户，或者从1m增加到了10m。或许系统处理了比之前更多的数据量。</p>\n<p>可扩展性是一个我们用来描述系统应对负载增长能力的术语。但需要注意的是，这并不是我们直接赋予系统的一个一维的标签:说“X可扩展”或者是“Y不可扩展”毫无意义。而应该是，“如果一个系统在某种程度上增长了，我们有哪些选项来应对这种增长？”和“我们如何增加更多的计算资源来应对额外的负载？”</p>\n<h2 id=\"描述负载\"><a href=\"#描述负载\" class=\"headerlink\" title=\"描述负载\"></a>描述负载</h2><p>首先我们需要简要的描述当前系统的负载，之后才能讨论增长的问题。负载可以通过几个我们称之为负载参数的数字来进行描述。对于参数的最好选择依赖于系统架构：可能是网络服务器的每秒请求数，数据库的读写比，聊天室的并发活跃用户数，缓存命中率等等。或许平均情况下是你最在意哪个或者你的瓶颈来自于小部分极端案例。</p>\n<p>为了更具体的描述，我们考虑Twitter，Twitter的两个主要操作是:</p>\n<ul>\n<li>发布推文：每个用户能够发送新的信息给所有关注他的人(平均4.6k请求每秒，峰值12k请求每秒)</li>\n<li>主页时间线：用户可以浏览他关注的人的所有推文(300k请求每秒)</li>\n</ul>\n<p>单纯处理12k每秒的写是十分简单的。但是，Twitter的扩展挑战并不主要来自于推文的容量，而是扇出(<strong>fan-out</strong>)——每个用户关注了许多用户，每个用户被许多用户关注。有两种方式来实现以上操作：</p>\n<ol>\n<li>发布一条推文只是简单的向推文集合里面插入一条新的推文。当一个用户请求的主页时间线时，查找所有其关注的用户，以及这些用户发布的推文，然后聚合这些推文(以时间排序)。在一个关系型数据库中，你可以写出以下语句：<br> <img src=\"/2018/02/24/DDIA读书笔记2/twitter_sql.png\" alt=\"\"></li>\n<li>为每个用户的主页时间线维护一个缓存——就像为每个用户提供一个推文的收件邮箱。当一个用户发布一个推文，查找所有关注该用户的用户，将该新推文插入到他们的主页时间线中。对主页时间线的请求将变得轻量，因为它的结果已经提前被计算好的。</li>\n</ol>\n<p>Twitter最开始使用的是方法1，但是系统无法跟上主页时间线请求负载的增加，因此它们转向了方法2.其表现更好的原因是发布推文的平均频率几乎小于请求主页时间线平均频率两个数量级，因此在本案例中在写入的时候做更多的工作优于在读的时候做更多的工作。</p>\n<p>然而，方法2存在的一个弊端是发布一个推文需要更多的额外工作。平均情况下，一条推文将会发送给大约75个关注这，因此4.6k每秒的推特发布速度变成了345k每秒的主页时间线缓存写入。但是这样的平均下隐藏了一个事实，那就是每个用户的关注者数量差别巨大，有些用户拥有超过30m的关注者。者代表着一条推文可能导致超过30m的主页时间线写入！而完成这项操作是十分耗时的——Twitter试图将推文的投递给所有关注者这一操作限制到5秒以内——这是一个巨大的挑战。</p>\n<p>最终Twitter采用的版本是两种方法的混合。大多数用户的推文保持在发布是写入到关注者的主页时间线中，少部分拥有大量关注者的用户不采用扇出的方式。用户在访问主页时间线时其关注的名人的推文将单独获取并合并到用户的主页时间线中，就像方法1一样。</p>\n<h2 id=\"描述性能\"><a href=\"#描述性能\" class=\"headerlink\" title=\"描述性能\"></a>描述性能</h2><p>当你可以描述系统的负载之后，你就可以开始调查当负载增加时会发生些什么。可以从这两方面进行：</p>\n<ul>\n<li>当你增加一个负载参数的值并保持系统资源（CPU，内存，网络带宽等等）不变，系统的性能如何？</li>\n<li>当你增加一个负载参数的值，需要增加多少系统资源来保持系统性能不变？</li>\n</ul>\n<p>这两个问题都需要性能数字来回答，因此让我们来简单的描述系统的性能。</p>\n<p>在Hadoop之类的批处理系统中，我们通常关心<em>吞吐量(throughput)</em>——一秒钟能处理的数据数量，或是处理一个固定大小数据集所需要的总时间。在线上系统中，通常更重要的是服务的<em>响应时间(response time)</em>，即客户端从发出请求到接收到响应的时间。</p>\n<p>在实际使用中，一个系统处理大量的请求，其响应时间可能大不相同。因此我们不能将响应时间定义为一个简单的数字，而是一个能测量到的数值的分布。如下图所示，每一个灰柱代表了向服务器的一次请求，高度表明了其响应时间。</p>\n<p><img src=\"/2018/02/24/DDIA读书笔记2/requests.png\" alt=\"\"></p>\n<p>许多请求都相当快速，但是时不时地会出现一些耗时很长的特殊请求。或许这些慢请求本质上是因为计算太多，比如它们处理了更多的数据。但是即使在某种场景下你认为所有的请求应该具有相同的响应时间，这仍然无法办到：由于上下文被切换到后台进程带来的随机延迟，由于网络丢包以及TCP重传，垃圾回收带来的暂停，缺页导致从磁盘读取，来自于服务器支架的机械振动，以及其他种种原因。</p>\n<p>因此我们经常一个服务的<em>平均</em>响应时间。但是，如果你想知道具有代表性的响应时间的话，均值并不是一个很好的度量指标，因为它没有告诉你有多少用户实际上是这么长的延迟。</p>\n<p>因此更好的选择是<em>百分数(percentiles)</em>，如果你将所有的响应时间从最快到最慢进行排序，那么<em>中位数</em>刚好是一个分界点：假设你的响应时间的中位数是200ms，这代表了所有请求中的一半都快于200ms，剩下的一半都慢于200ms。</p>\n<p>这使得中位数是一个好的评价指标，中位数通常也被称为<em>50th percentile</em>，或简写为<em>p50</em>。需要注意的是，中位数代表了一个请求，如果用户进行了多次请求，其中至少一个请求的慢于中位数的概率远远大于50%。</p>\n<p>为了找出这些特别耗时的特殊请求究竟有多耗时，我们通常还可以取<em>95th</em>，<em>99</em>和<em>99.9</em>（<em>p95</em>，<em>p99</em>，<em>p99</em>)。这些响应时间表达了95%，99%或99.9%的请求小于当前响应时间。</p>\n<h2 id=\"处理负载的方法\"><a href=\"#处理负载的方法\" class=\"headerlink\" title=\"处理负载的方法\"></a>处理负载的方法</h2><p>现在我们已经有了描述负载的参数以及度量性能的方法，我们可以开始讨论可扩展性这一问题了：当负载参数增加一定值的时候我们要如何仍然保证良好的性能？</p>\n<p>一个适合某个数量级负载的架构设计可能并不能处理负载增加为10倍的情况。如果你正在负责一个快速增长的服务，那么自然而然地你需要在不同尺度下的负载增加的时候重新思考你的架构设计，或更频繁。</p>\n<p>人们通常会讨论<em>垂直扩容（scaling up）</em>（迁移到一个更强大的计算机）和<em>水平扩容（scaling out）</em>（将负载分布到多台小型机器上面）这两个对立的概念。将负载分布到多台机器上面也被称为<em>无共享（shared-nothing）</em>架构。一个能运行于单机的系统通常是简单的，但是一个高性能计算机通常是很昂贵的，因此几乎不可避免的会需要水平扩容。在现实情况下，一个优秀的架构通常会需要更实用的多种方法的混合体：使用多台性能还不错的机器仍然比大量小型虚拟机更加简单以及便宜。</p>\n<p>有些系统是<em>有弹性的（elastic）</em>，这代表着它们可以在检测到负载增加的时候自动增加更多的计算资源，与此相对其他系统需要手动扩容（由开发者来分析容量并决定向系统增加更多机器）。一个弹性系统对于负载高度不可预测这种情况是十分游泳的，但是手动扩容系统更加简单而且更不容易出错。</p>\n<p>虽然在许多台机器间分发无状态服务是十分简单的，但是将有状态的数据系统从单一节点扩展为分布式设置将带来大量额外的复杂工作。因此，直到最近仍在使用的常见方法是将数据库存储于单一节点（垂直扩容）直到扩容花销或高可用需求迫使你将其进行分布式。</p>\n<h1 id=\"可维护性\"><a href=\"#可维护性\" class=\"headerlink\" title=\"可维护性\"></a>可维护性</h1><p>众所周知一个软件的主要开销并不在于其初始的开发过程中，而是其后期维护——修复bug，保持系统运行，调查错误，适应新平台，根据需求进行修改，支付专利费，添加新功能。</p>\n<p>我们应该以一种能够尝试最大程度减轻后期维护负担的方式来进行开发，为了完成这一目标，我们需要特别注意以下三个设计原则：</p>\n<ul>\n<li><em>可操作性（Operability）</em>：使得运维团队让保证系统流畅运行变得简单。</li>\n<li><em>简易性（Simplicity）</em>：使新工程师熟悉该系统变得简单，可以通过尽可能消除复杂性的方法（这和UI的简易性不同）</li>\n<li><em>可进化性（Evolvability）</em>：使得工程师未来由于需求变化以需要适应未预料到的用户使用情况而改变系统变得简单。也被称为可扩展性，可修改性，可塑性。</li>\n</ul>\n<h2 id=\"可操作性\"><a href=\"#可操作性\" class=\"headerlink\" title=\"可操作性\"></a>可操作性</h2><p>好的可操作性代表了使得运维团队的工作变得简单，让他们可以关注其更有价值的活动。数据系统可以通过以下方法来提高可操作性：</p>\n<ul>\n<li>对系统的运行时以及内部环境提供可视化工具以及好的监控工具</li>\n<li>为自动化以及标准工具继承提供好的支持</li>\n<li>避免单机依赖（允许机器被换下维护同时系统可以正常运行不受影响）</li>\n<li>提供好的文档说明以及简单易懂的操作流程（如果我做了X，将会发生Y）</li>\n<li>提供好的默认行为，但也应给予管理员在需要的时候重写这些行为的自由</li>\n<li>在合适的时候自我修复，但也应允许管理员在需要的时候手动控制系统状态</li>\n<li>列出可预测的行为，最小化意外情况</li>\n</ul>\n<h2 id=\"简易性\"><a href=\"#简易性\" class=\"headerlink\" title=\"简易性\"></a>简易性</h2><p>使一个系统更加简单并不意味着减少其功能，而是代表减少偶发复杂性。<strong>Moseley</strong>和<strong>Marks</strong>以不是用户能够看到的问题引发但是是来自于代码实现中的偶发情况来定义复杂性。</p>\n<p>减少偶发复杂性的最有效工具之一就是<em>抽象</em>。一个好的抽象能够将大量的实现细节隐藏于一个干净的，简单易懂的门后面。一个好的抽象也能在大量不同的应用之间使用。不仅是因为这种方法重用了大量实现而不需要重复实现，而且这带来了高质量软件，随着抽象组件质量的提高使得所有使用该组件的应用都能受益。</p>\n<p>然而，找到一个好的抽象是很困难的。在分布式系统中，虽然有许多优秀的算法，但是他们远不够简洁，无法让我们知道如何将这些东西打包并抽象，来帮助我们让系统的复杂度在一个可控的水平上。</p>\n<h2 id=\"可进化性\"><a href=\"#可进化性\" class=\"headerlink\" title=\"可进化性\"></a>可进化性</h2><p>一个系统的需求永远不变这几乎不可能。它们更像一个永远不停的过程：你了解了新的事实，之前没预料到的使用情况出现了，业务重点变化，用户要求新的功能，新平台代替旧平台，法律或监管需求改变，系统增加迫使架构改变等等。</p>\n<p>在组织流程方面，<em>敏捷(Agile)开发</em>为适应改变提供了一个框架。该社区还开发了一系列工具以及有用的模式来帮助在快速变化的环境里开发软件，比如<em>测试驱动开发（TDD）</em>和<em>重构</em>。</p>"},{"title":"Django中的select_related与prefetch_related","date":"2018-01-12T09:11:00.000Z","_content":"\nDjango是一个基于Python的网站开发框架，一个很重要的特点就是Battery Included，简单来说就是包含了常规开发中所需要的一切东西，包括但不限于完整的ORM模型、中间件、会话处理、模板语言、路由映射、管理员站点等，大大提高了开发者的开发体验，今天要谈的东西便是属于Django ORM这块中查询集优化的内容。\n\n<!-- more -->\n\n在很早之前(1.4)就已经接触到了Django，也使用Django开发了一些项目练手，但是直到最近的一个项目才让我对Django的认识有了进一步的提高。这个问题来源于默认情况下ORM查询集的效率比较低，特别对于外键关系较多较深的模型，使用默认的查询将会导致难以忍受低效率，要谈到优化首先得从Django ORM的查询集工作方式说起。\n\n# Queryset惰性求值\n\n## Queryset是惰性的\n\n在Django中，所有的Queryset都是惰性的，意思是当创建一个查询集的时候，并没有跟数据库发生任何交互。因此我们可以对查询集进行级联的filter等操作，只有在访问Queryset的内容的时候，Django才会真正进行数据库的访问，如以下例子:\n\n```Python\n>>> q = Entry.objects.filter(headline__startswith=\"What\")\n>>> q = q.filter(pub_date__lte=datetime.date.today())\n>>> q = q.exclude(body_text__icontains=\"food\")\n>>> print(q)\n```\n\n表面上来看该段代码进行了3次查询集操作，第一次获取所有以字段`headline`以`What`开头的Entry对象，第二次在前一次的基础上再次过滤，第三次在过滤。但实际上，Queryset的结果在真正使用之前都不会被获取，因此，只有到了最后一句`print(q)`的时候，Django才会真正的到数据库中获取相关数据，因此，整段代码其实只执行了一次数据库查询。\n\n## 外键关系仍然是惰性的\n\n在数据库中，外键(Foreignkey)这一字段是十分常见的，而在Django中也提供了对应的相关字段，如以下定义:\n\n```Python\nclass A(models.Model):\n    foo = models.IntegerField()\n\n\nclass B(models.Model):\n    a = models.ForeignKey(A, on_delete=models.CASCADE, related_name='bs')\n```\n\n我们定义了一个带有一个`foo`字段的模型`A`，以及一个外键关联到`A`上的模型`B`，当我们获取一个`B`对象的时候，其`a`字段对应的模型`A`并没有被立刻获取，如以下代码:\n\n```Python\n>>> b = B.objects.first()\n>>> print(b.a)\n```\n\n执行第一条语句获取到对象`b`的时候并没有把对应的a也获取到，因为实际上数据库`B`这个表中存储的`a`字段是`a_id`，即关联的对象的`id`，因此此处可以通过`b.a_id`获取到`id`而不真的获取`a`这个对象，这一方式也在Django的文档中提到，主要用于实际只需要`id`而不需要对象的情况。\n\n> If you only need a foreign key value, use the foreign key value that is already on the object you’ve got, rather than getting the whole related object and taking its primary key.(译: 当你只需要一个外键值的时候，直接使用已经获得对象上的值，而不要去获取整个对象然后取它的主键值)\n\n这一方式也引入了今天的主题，假如我需要获取一个Queryset以及其对应的外键的对象，应该如何操作？\n\n# 访问外键对象\n\n## 原始的访问方式\n\n同样以上部分代码中定义的`A`与`B`为例，假设我们想打印所有`id`小于等于`k`的`B`对象的`A`对象的`foo`字段，最原始的写法是:\n\n```Python\n>>> qs = B.objects.filter(id__lte=k)\n>>> for b in qs:\n>>>     print(b.a.foo)\n```\n\n这种写法符合逻辑，但是在性能上却是十分低下，原因在于，虽然我们使用`filter`获得了查询集`qs`，然后使用`for`遍历`qs`(求值)，只进行了一次数据库查询，但是在`for`循环体中`print(b.a.foo)`会再次触发查询，前面讲到了，Django的外键关系也是惰性的，因此获取`B`对象的时候并没有去获取相应的`A`对象，而是在真正使用的时候触发查询，也就是在打印`b.a.foo`的时候，这时候会触发一次数据库查询去查找`b`对应的`a`，而`for`在查询集`qs`上一共循环了`k`次，因此一共导致了`k+1`次数据库查询。\n\n为了直观的演示这一过程，我们以`k=5`为例，并使用[django-debug-toolbar](https://github.com/jazzband/django-debug-toolbar)工具监视数据库查询。结果如下:\n\n![](filter_id_lte_5.png)\n\n可以看到，第三行SQL语句查询了所有`id <= 5`的`B`对象，然后每次进行`print`的时候，都会触发一次SQL查询获得`a`的信息，因此共执行了`6`次查询。\n\n## select_related - 数据库上的join\n\nDjango考虑到了这种低效的查询方式，因此在设计ORM的时候设计了提升性能的方式。`select_related`就是其中之一。\n\n`select_related`将会根据外键关系，在执行查询语句的时候一次性获得相关对象的信息，这种操作带来的结果是更加复杂的查询语句和避免对于即将使用的外键对象的额外数据库查询。Django的[文档](https://docs.djangoproject.com/en/2.0/ref/models/querysets/#django.db.models.query.QuerySet.select_related)详细的描述了相关内容，在此只进行简要介绍。标准的查询代码如下:\n\n```Python\n# 执行数据库查询获取b\nb = B.objects.get(id=5)\n\n# 再次执行数据库查询获取关联的对象a\na = b.a\n```\n\n![](get_without_select_related.png)\n\n\n换用`select_related`之后，代码如下:\n\n```Python\n# 执行数据库查询获取b\nb = B.objects.select_related('a').get(id=5)\n\n# 不再执行数据库查询，因为前一次操作中已经获取了a的相关信息\na = b.a\n```\n\n![](get_with_select_related.png)\n\n我们可以看到，`select_related`实际上是在数据库层面进行了一次`inner join`操作，因此一次性获取了所有需要的信息。\n\n需要注意的是，我们可以使用任意外键关系(ForeignKeyField)或一对一关系(OneToOneField)作为参数传给`select_related`，同时也可以使用反向的一对一关系，此时应使用`related_name`作为参数。某些情况下，你可能想获取所有的相关对象，或者你并不知道关联关系，此时可以使用不加参数的`.select_related()`，该方式下将会根据关联关系(级联的)获取所有关联的对象, 即假设有外键关系为`A<-B<-C`，使用`C.objects.select_related()`将同时获取相关`A`和`B`的信息。\n\n<div class=\"tip\">\n该方式在**大多数情况下不推荐使用**\n</div>\n\n## prefetch_related - Python上的join\n\n与`select_related`类似，`prefetch_related`也可以大幅提高查询效率，但是`prefetch_related`的方式跟`select_related`大不一样。\n\n`select_reateld`是通过创建一条包含SQL join操作的`SELECT`语句来一次性获得所有相关对象的信息。因此，`select_related`需要从**同一个**数据库中获得相关对象。但是，为了避免由于join操作带来的较大的查询集结果，`select_related`被限制在了**单值**关系——外键关系或一对一关系。\n\n另一方面，`prefetch_related`为每一个关系使用了单独的查询，并在Python层面进行'join'操作，因此该操作允许多对多关系以及反向关系，而这是`select_related`无法做到的。我们这次使用`prefetch_related`执行查询，代码如下:\n\n```Python\n# 执行数据库查询获取b\nb = B.objects.prefetch_related('a').get(id=5)\n\n# 不再执行数据库查询，因为前一次操作中已经获取了a的相关信息\na = b.a\n```\n\n![](get_with_prefetch_related.png)\n\n可以看到，Django首先进行了`id=5`的第一次查询获取对象`b`，然后根据外键关系进行了第二次查询获取`b.a`。为了增强理解，我们引入第三个模型`C`，这次我们从`A`模型上查询`id__lte=5`的`A`对象及其相关对象，代码如下:\n\n```Python\n# 定义\nclass C(models.Model):\n    b = models.ForeignKey(B, on_delete=models.CASCADE, related_name='cs')\n    \n\nqs = A.objects.prefetch_related('bs', 'bs__cs').filter(id__lte=5)\n```\n\n![](filter_id_lte_5_with_prefetch_related.png)\n\nDjango首先查询了`id`小于等于5的所有`A`对象，然后根据反向关联关系，查询所有外键到这些`A`对象的`B`对象，然后查询所有外键到这些`B`对象的`C`对象。\n\n篇幅关系，对于`prefetch_related`的介绍就到这里，下面对三种查询方式(原始，`select_related`，`prefetch_related`)的性能进行一些简单的实验。\n\n# select_related与prefetch_related性能对比\n\n为了比较两种优化方式相比于标准查询带来的性能提升，我分别定义了两组模型并编写代码进行了相关实验，模型简要说明如下:\n\n### 第一组:\n模型|字段说明\n:--:|:--:\nA|4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField\nB|ForeignKey(A), 4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField\nC|ForeignKey(B), 4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField\nD|ForeignKey(C), 4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField\nE|ForeignKey(D), 4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField\n\n### 第二组:\n模型|字段说明x\n:--:|:--:\nA1|1 x IntegerField, 1 x FloatField, 1 x DateTimeField\nB1|ForeignKey(A1), 1 x IntegerField, 1 x FloatField, 1 x DateTimeField\nC1|ForeignKey(B1), 1 x IntegerField, 1 x FloatField, 1 x DateTimeField\nD1|ForeignKey(C1), 1 x IntegerField, 1 x FloatField, 1 x DateTimeField\nE1|ForeignKey(D1), 1 x IntegerField, 1 x FloatField, 1 x DateTimeField\n\n前一组每个模型拥有约21个字段，后一组每个模型拥有约4个字段，CharField设置了max_length=100，DateTimeField设置了auto_now_add=True，UUIDField设置了default=uuid4, editable=False，所有的查询都是以E(E1)为出发点。\n\n## 复杂模型上的表现\n\n首先来看第一组的实验结果, 首先我们来比较随着获取对象数量的提高，查询时间的变化:\n\n![](complex_raw_sel_pre_tot.png)\n\n可以看出，三者耗时随获取对象数量的争夺呈现近乎线性的关系，符合直观预期，同时，没有经过优化的标准查询相比于经过优化的查询，斜率明显高很多，标准查询更易受查询集大小变化的影响，因此在查询集较大时进行优化是必不可少的，且根据前文所述，我们可以很容易的计算执行的SQL语句数量，标准查询: `1 + 5 * N`条，`select_related`: `1`条，`prefetch_related`: `5`条。\n\n> 注: 横坐标的对象指的是一共获取的对象数量，因为`A<-B<-C<-D<-E`，查询每一个`E`对象，都会获得5个对象，因此横坐标的100000代表一共查询了20000个E对象。\n\n再来看每个对象的平均查询时间:\n\n![](complex_raw_sel_pre_avg.png)\n\n可以看出，每个对象的查询时间在实验条件下并没有随着查询集的大小发生太大的变化，且单个对象的查询效率优化后有至少7倍以上的提高。\n\n为了详细对比`select_related`与`prefetch_related`，我们剔除标准查询后再进行比较:\n\n![](complex_sel_pre_tot.png)\n![](complex_sel_pre_avg.png)\n\n可以看出，在总时间上，查询对象数量小于大约135000的时候二者的查询效率区别并不大，`select_related`略优于`prefetch_related`，但是超过了这一界限之后，二者的差距明显拉开，这可以理解为当查询集增大时SQL的`join`操作的开销大于多次`SELECT`的开销，从平均查询时间的图中也可以得出结论，由于查询集大小的增加，`prefetch_related`中多条`SELECT`语句的开销被均摊，因此导致单个对象的查询效率提高(查询时间降低)，而`select_related`的`join`操作的开销并不随着数量增多被均摊。因此在查询集较大的时候使用`prefetch_related`性能上可能更好。 \n\n## 简单模型上的表现\n\n我们再来看第二组实验结果，查询时间随获取对象数量的提高的变化结果与前一组类似，优化后仍远好于优化前:\n\n![](simple_raw_sel_pre_tot.png)\n![](simple_raw_sel_pre_avg.png)\n\n我认为区别较大的地方在`select_related`与`prefetch_related`的变化:\n\n![](simple_sel_pre_tot.png)\n![](simple_sel_pre_avg.png)\n\n在有限的实验条件内，在模型字段并不复杂且数量并不多的情况下，`select_related`的效率均优于`prefetch_related`，具体表现为前者查询总时间上均少于后者，但是从第二幅图中，我们可以观测到`prefetch_related`的平均查询时间下降的趋势，由于时间关系我只再进行了一次`X=600000`的实验，并没有观测到超过`select_related`的情况。\n\n## 小结\n\n在查询集中的对象字段较多较复杂，且查询集较大的时候，或需要使用反向外键关系或多对多关系作为参数优化查询的时候，应该选用`prefetch_related`，在查询集中对象字段简单的，查询集不大的时候，应选用`select_related`。\n\n# 总结\n\n本文通过对Django的查询集的惰性求值相关内容的介绍，引入了使用`select_related`和`prefetch_related`优化查询集效率的介绍，最后通过两组实验比较了`select_related`和`prefetch_related`的性能并给出了选用建议。\n\n# 参考文献\n\n* https://docs.djangoproject.com/en/2.0/topics/db/queries/#querysets-are-lazy\n* https://docs.djangoproject.com/en/2.0/ref/models/querysets/#select-related\n* https://docs.djangoproject.com/en/2.0/ref/models/querysets/#prefetch-related","source":"_posts/Django中的select-related与prefetch-related.md","raw":"---\ntitle: Django中的select_related与prefetch_related\ndate: 2018-01-12 17:11:00\ntags: [Python,Django,数据库]\ncategories: Django\n---\n\nDjango是一个基于Python的网站开发框架，一个很重要的特点就是Battery Included，简单来说就是包含了常规开发中所需要的一切东西，包括但不限于完整的ORM模型、中间件、会话处理、模板语言、路由映射、管理员站点等，大大提高了开发者的开发体验，今天要谈的东西便是属于Django ORM这块中查询集优化的内容。\n\n<!-- more -->\n\n在很早之前(1.4)就已经接触到了Django，也使用Django开发了一些项目练手，但是直到最近的一个项目才让我对Django的认识有了进一步的提高。这个问题来源于默认情况下ORM查询集的效率比较低，特别对于外键关系较多较深的模型，使用默认的查询将会导致难以忍受低效率，要谈到优化首先得从Django ORM的查询集工作方式说起。\n\n# Queryset惰性求值\n\n## Queryset是惰性的\n\n在Django中，所有的Queryset都是惰性的，意思是当创建一个查询集的时候，并没有跟数据库发生任何交互。因此我们可以对查询集进行级联的filter等操作，只有在访问Queryset的内容的时候，Django才会真正进行数据库的访问，如以下例子:\n\n```Python\n>>> q = Entry.objects.filter(headline__startswith=\"What\")\n>>> q = q.filter(pub_date__lte=datetime.date.today())\n>>> q = q.exclude(body_text__icontains=\"food\")\n>>> print(q)\n```\n\n表面上来看该段代码进行了3次查询集操作，第一次获取所有以字段`headline`以`What`开头的Entry对象，第二次在前一次的基础上再次过滤，第三次在过滤。但实际上，Queryset的结果在真正使用之前都不会被获取，因此，只有到了最后一句`print(q)`的时候，Django才会真正的到数据库中获取相关数据，因此，整段代码其实只执行了一次数据库查询。\n\n## 外键关系仍然是惰性的\n\n在数据库中，外键(Foreignkey)这一字段是十分常见的，而在Django中也提供了对应的相关字段，如以下定义:\n\n```Python\nclass A(models.Model):\n    foo = models.IntegerField()\n\n\nclass B(models.Model):\n    a = models.ForeignKey(A, on_delete=models.CASCADE, related_name='bs')\n```\n\n我们定义了一个带有一个`foo`字段的模型`A`，以及一个外键关联到`A`上的模型`B`，当我们获取一个`B`对象的时候，其`a`字段对应的模型`A`并没有被立刻获取，如以下代码:\n\n```Python\n>>> b = B.objects.first()\n>>> print(b.a)\n```\n\n执行第一条语句获取到对象`b`的时候并没有把对应的a也获取到，因为实际上数据库`B`这个表中存储的`a`字段是`a_id`，即关联的对象的`id`，因此此处可以通过`b.a_id`获取到`id`而不真的获取`a`这个对象，这一方式也在Django的文档中提到，主要用于实际只需要`id`而不需要对象的情况。\n\n> If you only need a foreign key value, use the foreign key value that is already on the object you’ve got, rather than getting the whole related object and taking its primary key.(译: 当你只需要一个外键值的时候，直接使用已经获得对象上的值，而不要去获取整个对象然后取它的主键值)\n\n这一方式也引入了今天的主题，假如我需要获取一个Queryset以及其对应的外键的对象，应该如何操作？\n\n# 访问外键对象\n\n## 原始的访问方式\n\n同样以上部分代码中定义的`A`与`B`为例，假设我们想打印所有`id`小于等于`k`的`B`对象的`A`对象的`foo`字段，最原始的写法是:\n\n```Python\n>>> qs = B.objects.filter(id__lte=k)\n>>> for b in qs:\n>>>     print(b.a.foo)\n```\n\n这种写法符合逻辑，但是在性能上却是十分低下，原因在于，虽然我们使用`filter`获得了查询集`qs`，然后使用`for`遍历`qs`(求值)，只进行了一次数据库查询，但是在`for`循环体中`print(b.a.foo)`会再次触发查询，前面讲到了，Django的外键关系也是惰性的，因此获取`B`对象的时候并没有去获取相应的`A`对象，而是在真正使用的时候触发查询，也就是在打印`b.a.foo`的时候，这时候会触发一次数据库查询去查找`b`对应的`a`，而`for`在查询集`qs`上一共循环了`k`次，因此一共导致了`k+1`次数据库查询。\n\n为了直观的演示这一过程，我们以`k=5`为例，并使用[django-debug-toolbar](https://github.com/jazzband/django-debug-toolbar)工具监视数据库查询。结果如下:\n\n![](filter_id_lte_5.png)\n\n可以看到，第三行SQL语句查询了所有`id <= 5`的`B`对象，然后每次进行`print`的时候，都会触发一次SQL查询获得`a`的信息，因此共执行了`6`次查询。\n\n## select_related - 数据库上的join\n\nDjango考虑到了这种低效的查询方式，因此在设计ORM的时候设计了提升性能的方式。`select_related`就是其中之一。\n\n`select_related`将会根据外键关系，在执行查询语句的时候一次性获得相关对象的信息，这种操作带来的结果是更加复杂的查询语句和避免对于即将使用的外键对象的额外数据库查询。Django的[文档](https://docs.djangoproject.com/en/2.0/ref/models/querysets/#django.db.models.query.QuerySet.select_related)详细的描述了相关内容，在此只进行简要介绍。标准的查询代码如下:\n\n```Python\n# 执行数据库查询获取b\nb = B.objects.get(id=5)\n\n# 再次执行数据库查询获取关联的对象a\na = b.a\n```\n\n![](get_without_select_related.png)\n\n\n换用`select_related`之后，代码如下:\n\n```Python\n# 执行数据库查询获取b\nb = B.objects.select_related('a').get(id=5)\n\n# 不再执行数据库查询，因为前一次操作中已经获取了a的相关信息\na = b.a\n```\n\n![](get_with_select_related.png)\n\n我们可以看到，`select_related`实际上是在数据库层面进行了一次`inner join`操作，因此一次性获取了所有需要的信息。\n\n需要注意的是，我们可以使用任意外键关系(ForeignKeyField)或一对一关系(OneToOneField)作为参数传给`select_related`，同时也可以使用反向的一对一关系，此时应使用`related_name`作为参数。某些情况下，你可能想获取所有的相关对象，或者你并不知道关联关系，此时可以使用不加参数的`.select_related()`，该方式下将会根据关联关系(级联的)获取所有关联的对象, 即假设有外键关系为`A<-B<-C`，使用`C.objects.select_related()`将同时获取相关`A`和`B`的信息。\n\n<div class=\"tip\">\n该方式在**大多数情况下不推荐使用**\n</div>\n\n## prefetch_related - Python上的join\n\n与`select_related`类似，`prefetch_related`也可以大幅提高查询效率，但是`prefetch_related`的方式跟`select_related`大不一样。\n\n`select_reateld`是通过创建一条包含SQL join操作的`SELECT`语句来一次性获得所有相关对象的信息。因此，`select_related`需要从**同一个**数据库中获得相关对象。但是，为了避免由于join操作带来的较大的查询集结果，`select_related`被限制在了**单值**关系——外键关系或一对一关系。\n\n另一方面，`prefetch_related`为每一个关系使用了单独的查询，并在Python层面进行'join'操作，因此该操作允许多对多关系以及反向关系，而这是`select_related`无法做到的。我们这次使用`prefetch_related`执行查询，代码如下:\n\n```Python\n# 执行数据库查询获取b\nb = B.objects.prefetch_related('a').get(id=5)\n\n# 不再执行数据库查询，因为前一次操作中已经获取了a的相关信息\na = b.a\n```\n\n![](get_with_prefetch_related.png)\n\n可以看到，Django首先进行了`id=5`的第一次查询获取对象`b`，然后根据外键关系进行了第二次查询获取`b.a`。为了增强理解，我们引入第三个模型`C`，这次我们从`A`模型上查询`id__lte=5`的`A`对象及其相关对象，代码如下:\n\n```Python\n# 定义\nclass C(models.Model):\n    b = models.ForeignKey(B, on_delete=models.CASCADE, related_name='cs')\n    \n\nqs = A.objects.prefetch_related('bs', 'bs__cs').filter(id__lte=5)\n```\n\n![](filter_id_lte_5_with_prefetch_related.png)\n\nDjango首先查询了`id`小于等于5的所有`A`对象，然后根据反向关联关系，查询所有外键到这些`A`对象的`B`对象，然后查询所有外键到这些`B`对象的`C`对象。\n\n篇幅关系，对于`prefetch_related`的介绍就到这里，下面对三种查询方式(原始，`select_related`，`prefetch_related`)的性能进行一些简单的实验。\n\n# select_related与prefetch_related性能对比\n\n为了比较两种优化方式相比于标准查询带来的性能提升，我分别定义了两组模型并编写代码进行了相关实验，模型简要说明如下:\n\n### 第一组:\n模型|字段说明\n:--:|:--:\nA|4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField\nB|ForeignKey(A), 4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField\nC|ForeignKey(B), 4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField\nD|ForeignKey(C), 4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField\nE|ForeignKey(D), 4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField\n\n### 第二组:\n模型|字段说明x\n:--:|:--:\nA1|1 x IntegerField, 1 x FloatField, 1 x DateTimeField\nB1|ForeignKey(A1), 1 x IntegerField, 1 x FloatField, 1 x DateTimeField\nC1|ForeignKey(B1), 1 x IntegerField, 1 x FloatField, 1 x DateTimeField\nD1|ForeignKey(C1), 1 x IntegerField, 1 x FloatField, 1 x DateTimeField\nE1|ForeignKey(D1), 1 x IntegerField, 1 x FloatField, 1 x DateTimeField\n\n前一组每个模型拥有约21个字段，后一组每个模型拥有约4个字段，CharField设置了max_length=100，DateTimeField设置了auto_now_add=True，UUIDField设置了default=uuid4, editable=False，所有的查询都是以E(E1)为出发点。\n\n## 复杂模型上的表现\n\n首先来看第一组的实验结果, 首先我们来比较随着获取对象数量的提高，查询时间的变化:\n\n![](complex_raw_sel_pre_tot.png)\n\n可以看出，三者耗时随获取对象数量的争夺呈现近乎线性的关系，符合直观预期，同时，没有经过优化的标准查询相比于经过优化的查询，斜率明显高很多，标准查询更易受查询集大小变化的影响，因此在查询集较大时进行优化是必不可少的，且根据前文所述，我们可以很容易的计算执行的SQL语句数量，标准查询: `1 + 5 * N`条，`select_related`: `1`条，`prefetch_related`: `5`条。\n\n> 注: 横坐标的对象指的是一共获取的对象数量，因为`A<-B<-C<-D<-E`，查询每一个`E`对象，都会获得5个对象，因此横坐标的100000代表一共查询了20000个E对象。\n\n再来看每个对象的平均查询时间:\n\n![](complex_raw_sel_pre_avg.png)\n\n可以看出，每个对象的查询时间在实验条件下并没有随着查询集的大小发生太大的变化，且单个对象的查询效率优化后有至少7倍以上的提高。\n\n为了详细对比`select_related`与`prefetch_related`，我们剔除标准查询后再进行比较:\n\n![](complex_sel_pre_tot.png)\n![](complex_sel_pre_avg.png)\n\n可以看出，在总时间上，查询对象数量小于大约135000的时候二者的查询效率区别并不大，`select_related`略优于`prefetch_related`，但是超过了这一界限之后，二者的差距明显拉开，这可以理解为当查询集增大时SQL的`join`操作的开销大于多次`SELECT`的开销，从平均查询时间的图中也可以得出结论，由于查询集大小的增加，`prefetch_related`中多条`SELECT`语句的开销被均摊，因此导致单个对象的查询效率提高(查询时间降低)，而`select_related`的`join`操作的开销并不随着数量增多被均摊。因此在查询集较大的时候使用`prefetch_related`性能上可能更好。 \n\n## 简单模型上的表现\n\n我们再来看第二组实验结果，查询时间随获取对象数量的提高的变化结果与前一组类似，优化后仍远好于优化前:\n\n![](simple_raw_sel_pre_tot.png)\n![](simple_raw_sel_pre_avg.png)\n\n我认为区别较大的地方在`select_related`与`prefetch_related`的变化:\n\n![](simple_sel_pre_tot.png)\n![](simple_sel_pre_avg.png)\n\n在有限的实验条件内，在模型字段并不复杂且数量并不多的情况下，`select_related`的效率均优于`prefetch_related`，具体表现为前者查询总时间上均少于后者，但是从第二幅图中，我们可以观测到`prefetch_related`的平均查询时间下降的趋势，由于时间关系我只再进行了一次`X=600000`的实验，并没有观测到超过`select_related`的情况。\n\n## 小结\n\n在查询集中的对象字段较多较复杂，且查询集较大的时候，或需要使用反向外键关系或多对多关系作为参数优化查询的时候，应该选用`prefetch_related`，在查询集中对象字段简单的，查询集不大的时候，应选用`select_related`。\n\n# 总结\n\n本文通过对Django的查询集的惰性求值相关内容的介绍，引入了使用`select_related`和`prefetch_related`优化查询集效率的介绍，最后通过两组实验比较了`select_related`和`prefetch_related`的性能并给出了选用建议。\n\n# 参考文献\n\n* https://docs.djangoproject.com/en/2.0/topics/db/queries/#querysets-are-lazy\n* https://docs.djangoproject.com/en/2.0/ref/models/querysets/#select-related\n* https://docs.djangoproject.com/en/2.0/ref/models/querysets/#prefetch-related","slug":"Django中的select-related与prefetch-related","published":1,"updated":"2018-01-13T01:56:07.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgvnqmky000kw628fafkq5cb","content":"<p>Django是一个基于Python的网站开发框架，一个很重要的特点就是Battery Included，简单来说就是包含了常规开发中所需要的一切东西，包括但不限于完整的ORM模型、中间件、会话处理、模板语言、路由映射、管理员站点等，大大提高了开发者的开发体验，今天要谈的东西便是属于Django ORM这块中查询集优化的内容。</p>\n<a id=\"more\"></a>\n<p>在很早之前(1.4)就已经接触到了Django，也使用Django开发了一些项目练手，但是直到最近的一个项目才让我对Django的认识有了进一步的提高。这个问题来源于默认情况下ORM查询集的效率比较低，特别对于外键关系较多较深的模型，使用默认的查询将会导致难以忍受低效率，要谈到优化首先得从Django ORM的查询集工作方式说起。</p>\n<h1 id=\"Queryset惰性求值\"><a href=\"#Queryset惰性求值\" class=\"headerlink\" title=\"Queryset惰性求值\"></a>Queryset惰性求值</h1><h2 id=\"Queryset是惰性的\"><a href=\"#Queryset是惰性的\" class=\"headerlink\" title=\"Queryset是惰性的\"></a>Queryset是惰性的</h2><p>在Django中，所有的Queryset都是惰性的，意思是当创建一个查询集的时候，并没有跟数据库发生任何交互。因此我们可以对查询集进行级联的filter等操作，只有在访问Queryset的内容的时候，Django才会真正进行数据库的访问，如以下例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q = Entry.objects.filter(headline__startswith=<span class=\"string\">\"What\"</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q = q.filter(pub_date__lte=datetime.date.today())</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q = q.exclude(body_text__icontains=<span class=\"string\">\"food\"</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(q)</span><br></pre></td></tr></table></figure>\n<p>表面上来看该段代码进行了3次查询集操作，第一次获取所有以字段<code>headline</code>以<code>What</code>开头的Entry对象，第二次在前一次的基础上再次过滤，第三次在过滤。但实际上，Queryset的结果在真正使用之前都不会被获取，因此，只有到了最后一句<code>print(q)</code>的时候，Django才会真正的到数据库中获取相关数据，因此，整段代码其实只执行了一次数据库查询。</p>\n<h2 id=\"外键关系仍然是惰性的\"><a href=\"#外键关系仍然是惰性的\" class=\"headerlink\" title=\"外键关系仍然是惰性的\"></a>外键关系仍然是惰性的</h2><p>在数据库中，外键(Foreignkey)这一字段是十分常见的，而在Django中也提供了对应的相关字段，如以下定义:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(models.Model)</span>:</span></span><br><span class=\"line\">    foo = models.IntegerField()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(models.Model)</span>:</span></span><br><span class=\"line\">    a = models.ForeignKey(A, on_delete=models.CASCADE, related_name=<span class=\"string\">'bs'</span>)</span><br></pre></td></tr></table></figure>\n<p>我们定义了一个带有一个<code>foo</code>字段的模型<code>A</code>，以及一个外键关联到<code>A</code>上的模型<code>B</code>，当我们获取一个<code>B</code>对象的时候，其<code>a</code>字段对应的模型<code>A</code>并没有被立刻获取，如以下代码:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = B.objects.first()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(b.a)</span><br></pre></td></tr></table></figure>\n<p>执行第一条语句获取到对象<code>b</code>的时候并没有把对应的a也获取到，因为实际上数据库<code>B</code>这个表中存储的<code>a</code>字段是<code>a_id</code>，即关联的对象的<code>id</code>，因此此处可以通过<code>b.a_id</code>获取到<code>id</code>而不真的获取<code>a</code>这个对象，这一方式也在Django的文档中提到，主要用于实际只需要<code>id</code>而不需要对象的情况。</p>\n<blockquote>\n<p>If you only need a foreign key value, use the foreign key value that is already on the object you’ve got, rather than getting the whole related object and taking its primary key.(译: 当你只需要一个外键值的时候，直接使用已经获得对象上的值，而不要去获取整个对象然后取它的主键值)</p>\n</blockquote>\n<p>这一方式也引入了今天的主题，假如我需要获取一个Queryset以及其对应的外键的对象，应该如何操作？</p>\n<h1 id=\"访问外键对象\"><a href=\"#访问外键对象\" class=\"headerlink\" title=\"访问外键对象\"></a>访问外键对象</h1><h2 id=\"原始的访问方式\"><a href=\"#原始的访问方式\" class=\"headerlink\" title=\"原始的访问方式\"></a>原始的访问方式</h2><p>同样以上部分代码中定义的<code>A</code>与<code>B</code>为例，假设我们想打印所有<code>id</code>小于等于<code>k</code>的<code>B</code>对象的<code>A</code>对象的<code>foo</code>字段，最原始的写法是:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>qs = B.objects.filter(id__lte=k)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> qs:</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>    print(b.a.foo)</span><br></pre></td></tr></table></figure>\n<p>这种写法符合逻辑，但是在性能上却是十分低下，原因在于，虽然我们使用<code>filter</code>获得了查询集<code>qs</code>，然后使用<code>for</code>遍历<code>qs</code>(求值)，只进行了一次数据库查询，但是在<code>for</code>循环体中<code>print(b.a.foo)</code>会再次触发查询，前面讲到了，Django的外键关系也是惰性的，因此获取<code>B</code>对象的时候并没有去获取相应的<code>A</code>对象，而是在真正使用的时候触发查询，也就是在打印<code>b.a.foo</code>的时候，这时候会触发一次数据库查询去查找<code>b</code>对应的<code>a</code>，而<code>for</code>在查询集<code>qs</code>上一共循环了<code>k</code>次，因此一共导致了<code>k+1</code>次数据库查询。</p>\n<p>为了直观的演示这一过程，我们以<code>k=5</code>为例，并使用<a href=\"https://github.com/jazzband/django-debug-toolbar\" target=\"_blank\" rel=\"noopener\">django-debug-toolbar</a>工具监视数据库查询。结果如下:</p>\n<p><img src=\"/2018/01/12/Django中的select-related与prefetch-related/filter_id_lte_5.png\" alt=\"\"></p>\n<p>可以看到，第三行SQL语句查询了所有<code>id &lt;= 5</code>的<code>B</code>对象，然后每次进行<code>print</code>的时候，都会触发一次SQL查询获得<code>a</code>的信息，因此共执行了<code>6</code>次查询。</p>\n<h2 id=\"select-related-数据库上的join\"><a href=\"#select-related-数据库上的join\" class=\"headerlink\" title=\"select_related - 数据库上的join\"></a>select_related - 数据库上的join</h2><p>Django考虑到了这种低效的查询方式，因此在设计ORM的时候设计了提升性能的方式。<code>select_related</code>就是其中之一。</p>\n<p><code>select_related</code>将会根据外键关系，在执行查询语句的时候一次性获得相关对象的信息，这种操作带来的结果是更加复杂的查询语句和避免对于即将使用的外键对象的额外数据库查询。Django的<a href=\"https://docs.djangoproject.com/en/2.0/ref/models/querysets/#django.db.models.query.QuerySet.select_related\" target=\"_blank\" rel=\"noopener\">文档</a>详细的描述了相关内容，在此只进行简要介绍。标准的查询代码如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 执行数据库查询获取b</span></span><br><span class=\"line\">b = B.objects.get(id=<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 再次执行数据库查询获取关联的对象a</span></span><br><span class=\"line\">a = b.a</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2018/01/12/Django中的select-related与prefetch-related/get_without_select_related.png\" alt=\"\"></p>\n<p>换用<code>select_related</code>之后，代码如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 执行数据库查询获取b</span></span><br><span class=\"line\">b = B.objects.select_related(<span class=\"string\">'a'</span>).get(id=<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 不再执行数据库查询，因为前一次操作中已经获取了a的相关信息</span></span><br><span class=\"line\">a = b.a</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2018/01/12/Django中的select-related与prefetch-related/get_with_select_related.png\" alt=\"\"></p>\n<p>我们可以看到，<code>select_related</code>实际上是在数据库层面进行了一次<code>inner join</code>操作，因此一次性获取了所有需要的信息。</p>\n<p>需要注意的是，我们可以使用任意外键关系(ForeignKeyField)或一对一关系(OneToOneField)作为参数传给<code>select_related</code>，同时也可以使用反向的一对一关系，此时应使用<code>related_name</code>作为参数。某些情况下，你可能想获取所有的相关对象，或者你并不知道关联关系，此时可以使用不加参数的<code>.select_related()</code>，该方式下将会根据关联关系(级联的)获取所有关联的对象, 即假设有外键关系为<code>A&lt;-B&lt;-C</code>，使用<code>C.objects.select_related()</code>将同时获取相关<code>A</code>和<code>B</code>的信息。</p>\n<div class=\"tip\"><br>该方式在<strong>大多数情况下不推荐使用</strong><br></div>\n\n<h2 id=\"prefetch-related-Python上的join\"><a href=\"#prefetch-related-Python上的join\" class=\"headerlink\" title=\"prefetch_related - Python上的join\"></a>prefetch_related - Python上的join</h2><p>与<code>select_related</code>类似，<code>prefetch_related</code>也可以大幅提高查询效率，但是<code>prefetch_related</code>的方式跟<code>select_related</code>大不一样。</p>\n<p><code>select_reateld</code>是通过创建一条包含SQL join操作的<code>SELECT</code>语句来一次性获得所有相关对象的信息。因此，<code>select_related</code>需要从<strong>同一个</strong>数据库中获得相关对象。但是，为了避免由于join操作带来的较大的查询集结果，<code>select_related</code>被限制在了<strong>单值</strong>关系——外键关系或一对一关系。</p>\n<p>另一方面，<code>prefetch_related</code>为每一个关系使用了单独的查询，并在Python层面进行’join’操作，因此该操作允许多对多关系以及反向关系，而这是<code>select_related</code>无法做到的。我们这次使用<code>prefetch_related</code>执行查询，代码如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 执行数据库查询获取b</span></span><br><span class=\"line\">b = B.objects.prefetch_related(<span class=\"string\">'a'</span>).get(id=<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 不再执行数据库查询，因为前一次操作中已经获取了a的相关信息</span></span><br><span class=\"line\">a = b.a</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2018/01/12/Django中的select-related与prefetch-related/get_with_prefetch_related.png\" alt=\"\"></p>\n<p>可以看到，Django首先进行了<code>id=5</code>的第一次查询获取对象<code>b</code>，然后根据外键关系进行了第二次查询获取<code>b.a</code>。为了增强理解，我们引入第三个模型<code>C</code>，这次我们从<code>A</code>模型上查询<code>id__lte=5</code>的<code>A</code>对象及其相关对象，代码如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(models.Model)</span>:</span></span><br><span class=\"line\">    b = models.ForeignKey(B, on_delete=models.CASCADE, related_name=<span class=\"string\">'cs'</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">qs = A.objects.prefetch_related(<span class=\"string\">'bs'</span>, <span class=\"string\">'bs__cs'</span>).filter(id__lte=<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2018/01/12/Django中的select-related与prefetch-related/filter_id_lte_5_with_prefetch_related.png\" alt=\"\"></p>\n<p>Django首先查询了<code>id</code>小于等于5的所有<code>A</code>对象，然后根据反向关联关系，查询所有外键到这些<code>A</code>对象的<code>B</code>对象，然后查询所有外键到这些<code>B</code>对象的<code>C</code>对象。</p>\n<p>篇幅关系，对于<code>prefetch_related</code>的介绍就到这里，下面对三种查询方式(原始，<code>select_related</code>，<code>prefetch_related</code>)的性能进行一些简单的实验。</p>\n<h1 id=\"select-related与prefetch-related性能对比\"><a href=\"#select-related与prefetch-related性能对比\" class=\"headerlink\" title=\"select_related与prefetch_related性能对比\"></a>select_related与prefetch_related性能对比</h1><p>为了比较两种优化方式相比于标准查询带来的性能提升，我分别定义了两组模型并编写代码进行了相关实验，模型简要说明如下:</p>\n<h3 id=\"第一组\"><a href=\"#第一组\" class=\"headerlink\" title=\"第一组:\"></a>第一组:</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">模型</th>\n<th style=\"text-align:center\">字段说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">ForeignKey(A), 4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">ForeignKey(B), 4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">ForeignKey(C), 4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">ForeignKey(D), 4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"第二组\"><a href=\"#第二组\" class=\"headerlink\" title=\"第二组:\"></a>第二组:</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">模型</th>\n<th style=\"text-align:center\">字段说明x</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">A1</td>\n<td style=\"text-align:center\">1 x IntegerField, 1 x FloatField, 1 x DateTimeField</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">B1</td>\n<td style=\"text-align:center\">ForeignKey(A1), 1 x IntegerField, 1 x FloatField, 1 x DateTimeField</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C1</td>\n<td style=\"text-align:center\">ForeignKey(B1), 1 x IntegerField, 1 x FloatField, 1 x DateTimeField</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D1</td>\n<td style=\"text-align:center\">ForeignKey(C1), 1 x IntegerField, 1 x FloatField, 1 x DateTimeField</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">E1</td>\n<td style=\"text-align:center\">ForeignKey(D1), 1 x IntegerField, 1 x FloatField, 1 x DateTimeField</td>\n</tr>\n</tbody>\n</table>\n<p>前一组每个模型拥有约21个字段，后一组每个模型拥有约4个字段，CharField设置了max_length=100，DateTimeField设置了auto_now_add=True，UUIDField设置了default=uuid4, editable=False，所有的查询都是以E(E1)为出发点。</p>\n<h2 id=\"复杂模型上的表现\"><a href=\"#复杂模型上的表现\" class=\"headerlink\" title=\"复杂模型上的表现\"></a>复杂模型上的表现</h2><p>首先来看第一组的实验结果, 首先我们来比较随着获取对象数量的提高，查询时间的变化:</p>\n<p><img src=\"/2018/01/12/Django中的select-related与prefetch-related/complex_raw_sel_pre_tot.png\" alt=\"\"></p>\n<p>可以看出，三者耗时随获取对象数量的争夺呈现近乎线性的关系，符合直观预期，同时，没有经过优化的标准查询相比于经过优化的查询，斜率明显高很多，标准查询更易受查询集大小变化的影响，因此在查询集较大时进行优化是必不可少的，且根据前文所述，我们可以很容易的计算执行的SQL语句数量，标准查询: <code>1 + 5 * N</code>条，<code>select_related</code>: <code>1</code>条，<code>prefetch_related</code>: <code>5</code>条。</p>\n<blockquote>\n<p>注: 横坐标的对象指的是一共获取的对象数量，因为<code>A&lt;-B&lt;-C&lt;-D&lt;-E</code>，查询每一个<code>E</code>对象，都会获得5个对象，因此横坐标的100000代表一共查询了20000个E对象。</p>\n</blockquote>\n<p>再来看每个对象的平均查询时间:</p>\n<p><img src=\"/2018/01/12/Django中的select-related与prefetch-related/complex_raw_sel_pre_avg.png\" alt=\"\"></p>\n<p>可以看出，每个对象的查询时间在实验条件下并没有随着查询集的大小发生太大的变化，且单个对象的查询效率优化后有至少7倍以上的提高。</p>\n<p>为了详细对比<code>select_related</code>与<code>prefetch_related</code>，我们剔除标准查询后再进行比较:</p>\n<p><img src=\"/2018/01/12/Django中的select-related与prefetch-related/complex_sel_pre_tot.png\" alt=\"\"><br><img src=\"/2018/01/12/Django中的select-related与prefetch-related/complex_sel_pre_avg.png\" alt=\"\"></p>\n<p>可以看出，在总时间上，查询对象数量小于大约135000的时候二者的查询效率区别并不大，<code>select_related</code>略优于<code>prefetch_related</code>，但是超过了这一界限之后，二者的差距明显拉开，这可以理解为当查询集增大时SQL的<code>join</code>操作的开销大于多次<code>SELECT</code>的开销，从平均查询时间的图中也可以得出结论，由于查询集大小的增加，<code>prefetch_related</code>中多条<code>SELECT</code>语句的开销被均摊，因此导致单个对象的查询效率提高(查询时间降低)，而<code>select_related</code>的<code>join</code>操作的开销并不随着数量增多被均摊。因此在查询集较大的时候使用<code>prefetch_related</code>性能上可能更好。 </p>\n<h2 id=\"简单模型上的表现\"><a href=\"#简单模型上的表现\" class=\"headerlink\" title=\"简单模型上的表现\"></a>简单模型上的表现</h2><p>我们再来看第二组实验结果，查询时间随获取对象数量的提高的变化结果与前一组类似，优化后仍远好于优化前:</p>\n<p><img src=\"/2018/01/12/Django中的select-related与prefetch-related/simple_raw_sel_pre_tot.png\" alt=\"\"><br><img src=\"/2018/01/12/Django中的select-related与prefetch-related/simple_raw_sel_pre_avg.png\" alt=\"\"></p>\n<p>我认为区别较大的地方在<code>select_related</code>与<code>prefetch_related</code>的变化:</p>\n<p><img src=\"/2018/01/12/Django中的select-related与prefetch-related/simple_sel_pre_tot.png\" alt=\"\"><br><img src=\"/2018/01/12/Django中的select-related与prefetch-related/simple_sel_pre_avg.png\" alt=\"\"></p>\n<p>在有限的实验条件内，在模型字段并不复杂且数量并不多的情况下，<code>select_related</code>的效率均优于<code>prefetch_related</code>，具体表现为前者查询总时间上均少于后者，但是从第二幅图中，我们可以观测到<code>prefetch_related</code>的平均查询时间下降的趋势，由于时间关系我只再进行了一次<code>X=600000</code>的实验，并没有观测到超过<code>select_related</code>的情况。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>在查询集中的对象字段较多较复杂，且查询集较大的时候，或需要使用反向外键关系或多对多关系作为参数优化查询的时候，应该选用<code>prefetch_related</code>，在查询集中对象字段简单的，查询集不大的时候，应选用<code>select_related</code>。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文通过对Django的查询集的惰性求值相关内容的介绍，引入了使用<code>select_related</code>和<code>prefetch_related</code>优化查询集效率的介绍，最后通过两组实验比较了<code>select_related</code>和<code>prefetch_related</code>的性能并给出了选用建议。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://docs.djangoproject.com/en/2.0/topics/db/queries/#querysets-are-lazy\" target=\"_blank\" rel=\"noopener\">https://docs.djangoproject.com/en/2.0/topics/db/queries/#querysets-are-lazy</a></li>\n<li><a href=\"https://docs.djangoproject.com/en/2.0/ref/models/querysets/#select-related\" target=\"_blank\" rel=\"noopener\">https://docs.djangoproject.com/en/2.0/ref/models/querysets/#select-related</a></li>\n<li><a href=\"https://docs.djangoproject.com/en/2.0/ref/models/querysets/#prefetch-related\" target=\"_blank\" rel=\"noopener\">https://docs.djangoproject.com/en/2.0/ref/models/querysets/#prefetch-related</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Django是一个基于Python的网站开发框架，一个很重要的特点就是Battery Included，简单来说就是包含了常规开发中所需要的一切东西，包括但不限于完整的ORM模型、中间件、会话处理、模板语言、路由映射、管理员站点等，大大提高了开发者的开发体验，今天要谈的东西便是属于Django ORM这块中查询集优化的内容。</p>","more":"<p>在很早之前(1.4)就已经接触到了Django，也使用Django开发了一些项目练手，但是直到最近的一个项目才让我对Django的认识有了进一步的提高。这个问题来源于默认情况下ORM查询集的效率比较低，特别对于外键关系较多较深的模型，使用默认的查询将会导致难以忍受低效率，要谈到优化首先得从Django ORM的查询集工作方式说起。</p>\n<h1 id=\"Queryset惰性求值\"><a href=\"#Queryset惰性求值\" class=\"headerlink\" title=\"Queryset惰性求值\"></a>Queryset惰性求值</h1><h2 id=\"Queryset是惰性的\"><a href=\"#Queryset是惰性的\" class=\"headerlink\" title=\"Queryset是惰性的\"></a>Queryset是惰性的</h2><p>在Django中，所有的Queryset都是惰性的，意思是当创建一个查询集的时候，并没有跟数据库发生任何交互。因此我们可以对查询集进行级联的filter等操作，只有在访问Queryset的内容的时候，Django才会真正进行数据库的访问，如以下例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q = Entry.objects.filter(headline__startswith=<span class=\"string\">\"What\"</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q = q.filter(pub_date__lte=datetime.date.today())</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>q = q.exclude(body_text__icontains=<span class=\"string\">\"food\"</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(q)</span><br></pre></td></tr></table></figure>\n<p>表面上来看该段代码进行了3次查询集操作，第一次获取所有以字段<code>headline</code>以<code>What</code>开头的Entry对象，第二次在前一次的基础上再次过滤，第三次在过滤。但实际上，Queryset的结果在真正使用之前都不会被获取，因此，只有到了最后一句<code>print(q)</code>的时候，Django才会真正的到数据库中获取相关数据，因此，整段代码其实只执行了一次数据库查询。</p>\n<h2 id=\"外键关系仍然是惰性的\"><a href=\"#外键关系仍然是惰性的\" class=\"headerlink\" title=\"外键关系仍然是惰性的\"></a>外键关系仍然是惰性的</h2><p>在数据库中，外键(Foreignkey)这一字段是十分常见的，而在Django中也提供了对应的相关字段，如以下定义:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(models.Model)</span>:</span></span><br><span class=\"line\">    foo = models.IntegerField()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(models.Model)</span>:</span></span><br><span class=\"line\">    a = models.ForeignKey(A, on_delete=models.CASCADE, related_name=<span class=\"string\">'bs'</span>)</span><br></pre></td></tr></table></figure>\n<p>我们定义了一个带有一个<code>foo</code>字段的模型<code>A</code>，以及一个外键关联到<code>A</code>上的模型<code>B</code>，当我们获取一个<code>B</code>对象的时候，其<code>a</code>字段对应的模型<code>A</code>并没有被立刻获取，如以下代码:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = B.objects.first()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(b.a)</span><br></pre></td></tr></table></figure>\n<p>执行第一条语句获取到对象<code>b</code>的时候并没有把对应的a也获取到，因为实际上数据库<code>B</code>这个表中存储的<code>a</code>字段是<code>a_id</code>，即关联的对象的<code>id</code>，因此此处可以通过<code>b.a_id</code>获取到<code>id</code>而不真的获取<code>a</code>这个对象，这一方式也在Django的文档中提到，主要用于实际只需要<code>id</code>而不需要对象的情况。</p>\n<blockquote>\n<p>If you only need a foreign key value, use the foreign key value that is already on the object you’ve got, rather than getting the whole related object and taking its primary key.(译: 当你只需要一个外键值的时候，直接使用已经获得对象上的值，而不要去获取整个对象然后取它的主键值)</p>\n</blockquote>\n<p>这一方式也引入了今天的主题，假如我需要获取一个Queryset以及其对应的外键的对象，应该如何操作？</p>\n<h1 id=\"访问外键对象\"><a href=\"#访问外键对象\" class=\"headerlink\" title=\"访问外键对象\"></a>访问外键对象</h1><h2 id=\"原始的访问方式\"><a href=\"#原始的访问方式\" class=\"headerlink\" title=\"原始的访问方式\"></a>原始的访问方式</h2><p>同样以上部分代码中定义的<code>A</code>与<code>B</code>为例，假设我们想打印所有<code>id</code>小于等于<code>k</code>的<code>B</code>对象的<code>A</code>对象的<code>foo</code>字段，最原始的写法是:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>qs = B.objects.filter(id__lte=k)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> qs:</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>    print(b.a.foo)</span><br></pre></td></tr></table></figure>\n<p>这种写法符合逻辑，但是在性能上却是十分低下，原因在于，虽然我们使用<code>filter</code>获得了查询集<code>qs</code>，然后使用<code>for</code>遍历<code>qs</code>(求值)，只进行了一次数据库查询，但是在<code>for</code>循环体中<code>print(b.a.foo)</code>会再次触发查询，前面讲到了，Django的外键关系也是惰性的，因此获取<code>B</code>对象的时候并没有去获取相应的<code>A</code>对象，而是在真正使用的时候触发查询，也就是在打印<code>b.a.foo</code>的时候，这时候会触发一次数据库查询去查找<code>b</code>对应的<code>a</code>，而<code>for</code>在查询集<code>qs</code>上一共循环了<code>k</code>次，因此一共导致了<code>k+1</code>次数据库查询。</p>\n<p>为了直观的演示这一过程，我们以<code>k=5</code>为例，并使用<a href=\"https://github.com/jazzband/django-debug-toolbar\" target=\"_blank\" rel=\"noopener\">django-debug-toolbar</a>工具监视数据库查询。结果如下:</p>\n<p><img src=\"/2018/01/12/Django中的select-related与prefetch-related/filter_id_lte_5.png\" alt=\"\"></p>\n<p>可以看到，第三行SQL语句查询了所有<code>id &lt;= 5</code>的<code>B</code>对象，然后每次进行<code>print</code>的时候，都会触发一次SQL查询获得<code>a</code>的信息，因此共执行了<code>6</code>次查询。</p>\n<h2 id=\"select-related-数据库上的join\"><a href=\"#select-related-数据库上的join\" class=\"headerlink\" title=\"select_related - 数据库上的join\"></a>select_related - 数据库上的join</h2><p>Django考虑到了这种低效的查询方式，因此在设计ORM的时候设计了提升性能的方式。<code>select_related</code>就是其中之一。</p>\n<p><code>select_related</code>将会根据外键关系，在执行查询语句的时候一次性获得相关对象的信息，这种操作带来的结果是更加复杂的查询语句和避免对于即将使用的外键对象的额外数据库查询。Django的<a href=\"https://docs.djangoproject.com/en/2.0/ref/models/querysets/#django.db.models.query.QuerySet.select_related\" target=\"_blank\" rel=\"noopener\">文档</a>详细的描述了相关内容，在此只进行简要介绍。标准的查询代码如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 执行数据库查询获取b</span></span><br><span class=\"line\">b = B.objects.get(id=<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 再次执行数据库查询获取关联的对象a</span></span><br><span class=\"line\">a = b.a</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2018/01/12/Django中的select-related与prefetch-related/get_without_select_related.png\" alt=\"\"></p>\n<p>换用<code>select_related</code>之后，代码如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 执行数据库查询获取b</span></span><br><span class=\"line\">b = B.objects.select_related(<span class=\"string\">'a'</span>).get(id=<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 不再执行数据库查询，因为前一次操作中已经获取了a的相关信息</span></span><br><span class=\"line\">a = b.a</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2018/01/12/Django中的select-related与prefetch-related/get_with_select_related.png\" alt=\"\"></p>\n<p>我们可以看到，<code>select_related</code>实际上是在数据库层面进行了一次<code>inner join</code>操作，因此一次性获取了所有需要的信息。</p>\n<p>需要注意的是，我们可以使用任意外键关系(ForeignKeyField)或一对一关系(OneToOneField)作为参数传给<code>select_related</code>，同时也可以使用反向的一对一关系，此时应使用<code>related_name</code>作为参数。某些情况下，你可能想获取所有的相关对象，或者你并不知道关联关系，此时可以使用不加参数的<code>.select_related()</code>，该方式下将会根据关联关系(级联的)获取所有关联的对象, 即假设有外键关系为<code>A&lt;-B&lt;-C</code>，使用<code>C.objects.select_related()</code>将同时获取相关<code>A</code>和<code>B</code>的信息。</p>\n<div class=\"tip\"><br>该方式在<strong>大多数情况下不推荐使用</strong><br></div>\n\n<h2 id=\"prefetch-related-Python上的join\"><a href=\"#prefetch-related-Python上的join\" class=\"headerlink\" title=\"prefetch_related - Python上的join\"></a>prefetch_related - Python上的join</h2><p>与<code>select_related</code>类似，<code>prefetch_related</code>也可以大幅提高查询效率，但是<code>prefetch_related</code>的方式跟<code>select_related</code>大不一样。</p>\n<p><code>select_reateld</code>是通过创建一条包含SQL join操作的<code>SELECT</code>语句来一次性获得所有相关对象的信息。因此，<code>select_related</code>需要从<strong>同一个</strong>数据库中获得相关对象。但是，为了避免由于join操作带来的较大的查询集结果，<code>select_related</code>被限制在了<strong>单值</strong>关系——外键关系或一对一关系。</p>\n<p>另一方面，<code>prefetch_related</code>为每一个关系使用了单独的查询，并在Python层面进行’join’操作，因此该操作允许多对多关系以及反向关系，而这是<code>select_related</code>无法做到的。我们这次使用<code>prefetch_related</code>执行查询，代码如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 执行数据库查询获取b</span></span><br><span class=\"line\">b = B.objects.prefetch_related(<span class=\"string\">'a'</span>).get(id=<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 不再执行数据库查询，因为前一次操作中已经获取了a的相关信息</span></span><br><span class=\"line\">a = b.a</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2018/01/12/Django中的select-related与prefetch-related/get_with_prefetch_related.png\" alt=\"\"></p>\n<p>可以看到，Django首先进行了<code>id=5</code>的第一次查询获取对象<code>b</code>，然后根据外键关系进行了第二次查询获取<code>b.a</code>。为了增强理解，我们引入第三个模型<code>C</code>，这次我们从<code>A</code>模型上查询<code>id__lte=5</code>的<code>A</code>对象及其相关对象，代码如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(models.Model)</span>:</span></span><br><span class=\"line\">    b = models.ForeignKey(B, on_delete=models.CASCADE, related_name=<span class=\"string\">'cs'</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">qs = A.objects.prefetch_related(<span class=\"string\">'bs'</span>, <span class=\"string\">'bs__cs'</span>).filter(id__lte=<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2018/01/12/Django中的select-related与prefetch-related/filter_id_lte_5_with_prefetch_related.png\" alt=\"\"></p>\n<p>Django首先查询了<code>id</code>小于等于5的所有<code>A</code>对象，然后根据反向关联关系，查询所有外键到这些<code>A</code>对象的<code>B</code>对象，然后查询所有外键到这些<code>B</code>对象的<code>C</code>对象。</p>\n<p>篇幅关系，对于<code>prefetch_related</code>的介绍就到这里，下面对三种查询方式(原始，<code>select_related</code>，<code>prefetch_related</code>)的性能进行一些简单的实验。</p>\n<h1 id=\"select-related与prefetch-related性能对比\"><a href=\"#select-related与prefetch-related性能对比\" class=\"headerlink\" title=\"select_related与prefetch_related性能对比\"></a>select_related与prefetch_related性能对比</h1><p>为了比较两种优化方式相比于标准查询带来的性能提升，我分别定义了两组模型并编写代码进行了相关实验，模型简要说明如下:</p>\n<h3 id=\"第一组\"><a href=\"#第一组\" class=\"headerlink\" title=\"第一组:\"></a>第一组:</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">模型</th>\n<th style=\"text-align:center\">字段说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">ForeignKey(A), 4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">ForeignKey(B), 4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">ForeignKey(C), 4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">ForeignKey(D), 4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"第二组\"><a href=\"#第二组\" class=\"headerlink\" title=\"第二组:\"></a>第二组:</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">模型</th>\n<th style=\"text-align:center\">字段说明x</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">A1</td>\n<td style=\"text-align:center\">1 x IntegerField, 1 x FloatField, 1 x DateTimeField</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">B1</td>\n<td style=\"text-align:center\">ForeignKey(A1), 1 x IntegerField, 1 x FloatField, 1 x DateTimeField</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C1</td>\n<td style=\"text-align:center\">ForeignKey(B1), 1 x IntegerField, 1 x FloatField, 1 x DateTimeField</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D1</td>\n<td style=\"text-align:center\">ForeignKey(C1), 1 x IntegerField, 1 x FloatField, 1 x DateTimeField</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">E1</td>\n<td style=\"text-align:center\">ForeignKey(D1), 1 x IntegerField, 1 x FloatField, 1 x DateTimeField</td>\n</tr>\n</tbody>\n</table>\n<p>前一组每个模型拥有约21个字段，后一组每个模型拥有约4个字段，CharField设置了max_length=100，DateTimeField设置了auto_now_add=True，UUIDField设置了default=uuid4, editable=False，所有的查询都是以E(E1)为出发点。</p>\n<h2 id=\"复杂模型上的表现\"><a href=\"#复杂模型上的表现\" class=\"headerlink\" title=\"复杂模型上的表现\"></a>复杂模型上的表现</h2><p>首先来看第一组的实验结果, 首先我们来比较随着获取对象数量的提高，查询时间的变化:</p>\n<p><img src=\"/2018/01/12/Django中的select-related与prefetch-related/complex_raw_sel_pre_tot.png\" alt=\"\"></p>\n<p>可以看出，三者耗时随获取对象数量的争夺呈现近乎线性的关系，符合直观预期，同时，没有经过优化的标准查询相比于经过优化的查询，斜率明显高很多，标准查询更易受查询集大小变化的影响，因此在查询集较大时进行优化是必不可少的，且根据前文所述，我们可以很容易的计算执行的SQL语句数量，标准查询: <code>1 + 5 * N</code>条，<code>select_related</code>: <code>1</code>条，<code>prefetch_related</code>: <code>5</code>条。</p>\n<blockquote>\n<p>注: 横坐标的对象指的是一共获取的对象数量，因为<code>A&lt;-B&lt;-C&lt;-D&lt;-E</code>，查询每一个<code>E</code>对象，都会获得5个对象，因此横坐标的100000代表一共查询了20000个E对象。</p>\n</blockquote>\n<p>再来看每个对象的平均查询时间:</p>\n<p><img src=\"/2018/01/12/Django中的select-related与prefetch-related/complex_raw_sel_pre_avg.png\" alt=\"\"></p>\n<p>可以看出，每个对象的查询时间在实验条件下并没有随着查询集的大小发生太大的变化，且单个对象的查询效率优化后有至少7倍以上的提高。</p>\n<p>为了详细对比<code>select_related</code>与<code>prefetch_related</code>，我们剔除标准查询后再进行比较:</p>\n<p><img src=\"/2018/01/12/Django中的select-related与prefetch-related/complex_sel_pre_tot.png\" alt=\"\"><br><img src=\"/2018/01/12/Django中的select-related与prefetch-related/complex_sel_pre_avg.png\" alt=\"\"></p>\n<p>可以看出，在总时间上，查询对象数量小于大约135000的时候二者的查询效率区别并不大，<code>select_related</code>略优于<code>prefetch_related</code>，但是超过了这一界限之后，二者的差距明显拉开，这可以理解为当查询集增大时SQL的<code>join</code>操作的开销大于多次<code>SELECT</code>的开销，从平均查询时间的图中也可以得出结论，由于查询集大小的增加，<code>prefetch_related</code>中多条<code>SELECT</code>语句的开销被均摊，因此导致单个对象的查询效率提高(查询时间降低)，而<code>select_related</code>的<code>join</code>操作的开销并不随着数量增多被均摊。因此在查询集较大的时候使用<code>prefetch_related</code>性能上可能更好。 </p>\n<h2 id=\"简单模型上的表现\"><a href=\"#简单模型上的表现\" class=\"headerlink\" title=\"简单模型上的表现\"></a>简单模型上的表现</h2><p>我们再来看第二组实验结果，查询时间随获取对象数量的提高的变化结果与前一组类似，优化后仍远好于优化前:</p>\n<p><img src=\"/2018/01/12/Django中的select-related与prefetch-related/simple_raw_sel_pre_tot.png\" alt=\"\"><br><img src=\"/2018/01/12/Django中的select-related与prefetch-related/simple_raw_sel_pre_avg.png\" alt=\"\"></p>\n<p>我认为区别较大的地方在<code>select_related</code>与<code>prefetch_related</code>的变化:</p>\n<p><img src=\"/2018/01/12/Django中的select-related与prefetch-related/simple_sel_pre_tot.png\" alt=\"\"><br><img src=\"/2018/01/12/Django中的select-related与prefetch-related/simple_sel_pre_avg.png\" alt=\"\"></p>\n<p>在有限的实验条件内，在模型字段并不复杂且数量并不多的情况下，<code>select_related</code>的效率均优于<code>prefetch_related</code>，具体表现为前者查询总时间上均少于后者，但是从第二幅图中，我们可以观测到<code>prefetch_related</code>的平均查询时间下降的趋势，由于时间关系我只再进行了一次<code>X=600000</code>的实验，并没有观测到超过<code>select_related</code>的情况。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>在查询集中的对象字段较多较复杂，且查询集较大的时候，或需要使用反向外键关系或多对多关系作为参数优化查询的时候，应该选用<code>prefetch_related</code>，在查询集中对象字段简单的，查询集不大的时候，应选用<code>select_related</code>。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文通过对Django的查询集的惰性求值相关内容的介绍，引入了使用<code>select_related</code>和<code>prefetch_related</code>优化查询集效率的介绍，最后通过两组实验比较了<code>select_related</code>和<code>prefetch_related</code>的性能并给出了选用建议。</p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"https://docs.djangoproject.com/en/2.0/topics/db/queries/#querysets-are-lazy\" target=\"_blank\" rel=\"noopener\">https://docs.djangoproject.com/en/2.0/topics/db/queries/#querysets-are-lazy</a></li>\n<li><a href=\"https://docs.djangoproject.com/en/2.0/ref/models/querysets/#select-related\" target=\"_blank\" rel=\"noopener\">https://docs.djangoproject.com/en/2.0/ref/models/querysets/#select-related</a></li>\n<li><a href=\"https://docs.djangoproject.com/en/2.0/ref/models/querysets/#prefetch-related\" target=\"_blank\" rel=\"noopener\">https://docs.djangoproject.com/en/2.0/ref/models/querysets/#prefetch-related</a></li>\n</ul>"},{"title":"初窥asyncio","date":"2017-05-10T06:10:06.000Z","_content":"前两天花了些时间阅读了Python的[`asyncio`](https://docs.python.org/3/library/asyncio.html#module-asyncio)模块的相关文档，综合之前对[Twisted](http://twistedmatrix.com/trac/)的一些了解，分享一些学习结果。\n\n根据官方文档的介绍，`asyncio`这个模块是在Python 3.4进行引入的，这个模块提供了使用协程编写单线程并发程序、对sockets以及其他资源的多路I/O访问、执行网络客户端和服务器等工作的基础。模块内容主要包含:\n\n* 一个多种平台相关实现的可插拔事件循环；\n* `transport`和`protocol`抽象(与[Twisted](http://twistedmatrix.com/trac/)的概念相似)；\n* 对TCP、UDP、SSL、子进程管道、延迟调用、以及其他功能(以上操作可能平台相关)的有力支持；\n* 一个模仿[`concurrent.futures`](https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures)模块实现的`Future`类，但增加了对事件循环的适应；\n* 使用[`yield from`](https://www.python.org/dev/peps/pep-0380)的协程(coroutines)以及作业(tasks)，以帮助使用顺序方式编写并发代码；\n* 对取消`Future`和协程的支持；\n* 在单线程的不同协程中使用的[同步原语](https://docs.python.org/3/library/asyncio-sync.html#asyncio-sync)，模仿[threading](https://docs.python.org/3/library/threading.html#module-threading)实现；\n* 一个向线程池传递任务的接口，以解决无可避免地需要使用某些会造成I/O阻塞库的调用。\n\n<div class=\"tip\">本文相关特性需Python 3.4以上版本支持，部分内容需要Python 3.5以上版本支持</div>\n\n<!-- more -->\n\n在开始相关的介绍之前，我们需要对同步、异步等工作方式有一个简单的了解，以下部分内容引用自[*krondo*](http://krondo.com)编写的[Twisted Introduction](http://krondo.com/an-introduction-to-asynchronous-programming-and-twisted/)。\n\n# 同步与异步\n\n大部分程序员应该非常熟悉同步模型了：\n\n![](sync.png)\n\n这是最简单的一种编程方式，每个任务依次执行，只有上一个任务结束以后下一个才会执行，任务都是按照确定顺序执行的，后面的任务可以认为所有之前的任务都是没有错误的正常结束，且他们的输出可以正常使用。\n\n当然，我们也可以对比多线程(同步)模型：\n\n![](threaded.png)\n\n在该模型中，每一个任务都在一个单独的线程中执行，线程由操作系统管理，且在某些拥有多处理器或多核的操作系统上，可能可以真正的并发执行，或者都被放入同一处理器中执行。关键在于，多线程模型的执行细节是由操作系统控制的，对于不相关的指令流程序员应该认为其是同时执行的。因此，虽然图看起来简单，但实际编写多线程模型可能比较复杂，因为不同线程之间需要保持一定的协调。线程通信以及协调是一个高级编程话题而且要正确实现很困难。\n\n下面让我们来看异步模型：\n\n![](async.png)\n\n在该模型中，任务之间彼此交错，但是都在同一线程中执行。这比多线程的情况要简单因为程序要总是知道**同一时间只有一个任务在执行**。除此之外，异步模型与多线程模型之前还有一个区别，在多线程模型中，线程的挂起与执行是由操作系统而不是程序员决定的，程序员需要假设一个线程可能被随时挂起。与此相反，在异步模型中，一个任务将会持续运行直到在适当的时候明确主动地放弃CPU资源占用让其他任务执行，这比多线程模型简单许多。\n\n# 为什么要使用异步模型\n\n有很多原因促使我们使用异步模型，其中一个比较常见的就是解决阻塞问题：\n\n![](block.png)\n\n图中的灰色部分代表了一个任务正在阻塞等待而无法继续执行。为什么一个任务会阻塞？一个常见的原因就是该任务正在等待完成I/O，完成向外接设备传递数据或者从外界设备接收数据。通常情况下，由于CPU处理数据的速度是磁盘或者网络连接处理数据速度的几个数量级，因此一个完成大量I/O操作的程序将会在阻塞上大量时间以等待磁盘或者网络完成操作。回过头看异步模型，对于遇到一个任务可能在同步模型下阻塞的时候，将会让出CPU转而执行其他没有阻塞的任务。因此异步模型只在没有任务可以继续执行即所有任务都在等待I/O的时候“阻塞”。\n\n相比较于同步模型，异步模型在以下情况下表现更好：\n\n1. 有大量任务需要执行且无论什么时候至少有一个任务可以继续执行。\n2. 要完成的任务中需要完成大量I/O操作，导致同步程序在其他任务可以继续执行时候会浪费大量时间阻塞等待。\n3. 任务之间基本不相关因此不需要任务间交互。\n\n那么asyncio的异步模型实现是基于什么呢？\n\n![](reactor-1.png)\n\n如图所示，这是反应器模式的一个基本结构，它总是处在等待事件以及处理事件的状态之一，因此也被称作**事件循环(event loop)**，也即asyncio模块的核心之一。\n\n# 事件循环示例\n\n让我们从一些官方文档示例开始。\n\n第一个例子是简单地打印字符串：\n\n```Python\nimport asyncio\n\ndef hello_world(loop):\n    print('Hello World')\n    loop.stop()\n\nloop = asyncio.get_event_loop()\n\n# Schedule a call to hello_world()\nloop.call_soon(hello_world, loop)\n\n# Blocking call interrupted by loop.stop()\nloop.run_forever()\nloop.close()\n```\n\n代码首先导入了我们需要使用的asyncio模块，然后定义了一个接收一个参数的`hello_world`函数，该函数只完成了两件事，打印一段字符串并在一个对象上调用了`stop`方法，关键在这之后：\n\n1. `get_event_loop`: 我们通过使用asyncio模块的`get_event_loop`方法取得了事件循环，之前说过了，事件循环是整个asyncio模块的核心，我们需要把我们的任务添加到事件循环中，那么第一步便是取得事件循环。除了取得事件循环，还可以更改或者新建事件循环，以及更底层的Policy，但是由于我们是初次接触，就不再深究。\n2. `call_soon`: 接着，我们在loop对象上调用了`call_soon`方法，该方法接收多个参数，第一个参数是一个可调用对象，后面的参数将会传给该对象，在此处我们传递了`hello_world`函数和loop对象。该函数的作用是在事件循环启动之后尽快调用传递的对象。\n3. `run_forever`: 通过调用loop对象的`run_forever`函数，将启动事件循环，外部代码将会阻塞，即`run_forever`之后的函数将不会继续执行。\n4. `stop`: 由于启动了事件循环，之前通过`call_soon`调度的`hello_world`函数将会执行，打印字符串并调用loop对象的`stop`方法，该方法将会停止事件循环，使得外部代码继续执行。\n5. `close`: 关闭事件循环，需要注意的是关闭之前必须保证事件循环没有执行。\n\n第二个例子每秒打印一次当前日期时间：\n\n```Python\nimport asyncio\nimport datetime\n\ndef display_date(end_time, loop):\n    print(datetime.datetime.now())\n    if (loop.time() + 1.0) < end_time:\n        loop.call_later(1, display_date, end_time, loop)\n    else:\n        loop.stop()\n\nloop = asyncio.get_event_loop()\n\n# Schedule the first call to display_date()\nend_time = loop.time() + 5.0\nloop.call_soon(display_date, end_time, loop)\n\n# Blocking call interrupted by loop.stop()\nloop.run_forever()\nloop.close()\n```\n\n`call_soon`和`run_forever`等方法的调用和前一个例子相同，区别在于调用`display_date`函数将会打印当前日期时间然后判断当前时间是否超过结束时间，如果超过则停止事件循环，否则则使用`call_later`方法设置1秒后对`display_date`函数进行调用。需要注意的一点是loop的`time`方法和`time`模块的`time`方法相似，不过使用的loop的内部时钟。\n\n第三个例子是监视文件描述符的读事件：\n\n```Python\nimport asyncio\ntry:\n    from socket import socketpair\nexcept ImportError:\n    from asyncio.windows_utils import socketpair\n\n# Create a pair of connected file descriptors\nrsock, wsock = socketpair()\nloop = asyncio.get_event_loop()\n\ndef reader():\n    data = rsock.recv(100)\n    print(\"Received:\", data.decode())\n    # We are done: unregister the file descriptor\n    loop.remove_reader(rsock)\n    # Stop the event loop\n    loop.stop()\n\n# Register the file descriptor for read event\nloop.add_reader(rsock, reader)\n\n# Simulate the reception of data from the network\nloop.call_soon(wsock.send, 'abc'.encode())\n\n# Run the event loop\nloop.run_forever()\n\n# We are done, close sockets and the event loop\nrsock.close()\nwsock.close()\nloop.close()\n```\n\n该示例通过使用socketpair函数创建了一组相连接的socket对象，`loop.call_soon(wsock.send, 'abc'.encode())`将会在事件循环启动后尽快调用wsock的`send`方法，方法参数为`'abc'.encode()`。除此之外，通过调用loop的`add_reader`方法，监视rsock的读事件，当读可用时，将会调用注册的`reader`函数，接收内容并打印出来，然后取消对rsock的注册并停止事件循环。\n\n最后一个例子是为`SIGINT`和`SIGTERM`等信号设置处理器：\n\n```Python\nimport asyncio\nimport functools\nimport os\nimport signal\n\ndef ask_exit(signame):\n    print(\"got signal %s: exit\" % signame)\n    loop.stop()\n\nloop = asyncio.get_event_loop()\nfor signame in ('SIGINT', 'SIGTERM'):\n    loop.add_signal_handler(getattr(signal, signame),\n                            functools.partial(ask_exit, signame))\n\nprint(\"Event loop running forever, press Ctrl+C to interrupt.\")\nprint(\"pid %s: send SIGINT or SIGTERM to exit.\" % os.getpid())\ntry:\n    loop.run_forever()\nfinally:\n    loop.close()\n```\n\n上面一段代码里面最重要的部分就是`add_signal_handler`方法，第一个参数为信号对象，第二个参数为该信号出现时该调用的函数。在本例中，即当`SIGINT`和`SIGTERM`信号出现时调用`ask_exit`函数。\n\n在使用asyncio时，还有一点需要注意的是：\n\n> 许多asyncio模块的函数都不接受关键字参数。因此，如果需要向回调函数传递关键字参数，需要使用`functools`模块的`partial`方法，比如`loop.call_soon(functools.partial(print, \"Hello\", flush=True))`将会调用`print(\"Hello\", flush=True)`。\n\n限于篇幅原因，本文止步于此，对于asyncio模块的其他内容的学习在接下来的文章中会进行分享。\n","source":"_posts/New-to-asyncio.md","raw":"---\ntitle: 初窥asyncio\ndate: 2017-05-10 14:10:06\ntags: [Python,协程,asyncio]\ncategories: Python\n---\n前两天花了些时间阅读了Python的[`asyncio`](https://docs.python.org/3/library/asyncio.html#module-asyncio)模块的相关文档，综合之前对[Twisted](http://twistedmatrix.com/trac/)的一些了解，分享一些学习结果。\n\n根据官方文档的介绍，`asyncio`这个模块是在Python 3.4进行引入的，这个模块提供了使用协程编写单线程并发程序、对sockets以及其他资源的多路I/O访问、执行网络客户端和服务器等工作的基础。模块内容主要包含:\n\n* 一个多种平台相关实现的可插拔事件循环；\n* `transport`和`protocol`抽象(与[Twisted](http://twistedmatrix.com/trac/)的概念相似)；\n* 对TCP、UDP、SSL、子进程管道、延迟调用、以及其他功能(以上操作可能平台相关)的有力支持；\n* 一个模仿[`concurrent.futures`](https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures)模块实现的`Future`类，但增加了对事件循环的适应；\n* 使用[`yield from`](https://www.python.org/dev/peps/pep-0380)的协程(coroutines)以及作业(tasks)，以帮助使用顺序方式编写并发代码；\n* 对取消`Future`和协程的支持；\n* 在单线程的不同协程中使用的[同步原语](https://docs.python.org/3/library/asyncio-sync.html#asyncio-sync)，模仿[threading](https://docs.python.org/3/library/threading.html#module-threading)实现；\n* 一个向线程池传递任务的接口，以解决无可避免地需要使用某些会造成I/O阻塞库的调用。\n\n<div class=\"tip\">本文相关特性需Python 3.4以上版本支持，部分内容需要Python 3.5以上版本支持</div>\n\n<!-- more -->\n\n在开始相关的介绍之前，我们需要对同步、异步等工作方式有一个简单的了解，以下部分内容引用自[*krondo*](http://krondo.com)编写的[Twisted Introduction](http://krondo.com/an-introduction-to-asynchronous-programming-and-twisted/)。\n\n# 同步与异步\n\n大部分程序员应该非常熟悉同步模型了：\n\n![](sync.png)\n\n这是最简单的一种编程方式，每个任务依次执行，只有上一个任务结束以后下一个才会执行，任务都是按照确定顺序执行的，后面的任务可以认为所有之前的任务都是没有错误的正常结束，且他们的输出可以正常使用。\n\n当然，我们也可以对比多线程(同步)模型：\n\n![](threaded.png)\n\n在该模型中，每一个任务都在一个单独的线程中执行，线程由操作系统管理，且在某些拥有多处理器或多核的操作系统上，可能可以真正的并发执行，或者都被放入同一处理器中执行。关键在于，多线程模型的执行细节是由操作系统控制的，对于不相关的指令流程序员应该认为其是同时执行的。因此，虽然图看起来简单，但实际编写多线程模型可能比较复杂，因为不同线程之间需要保持一定的协调。线程通信以及协调是一个高级编程话题而且要正确实现很困难。\n\n下面让我们来看异步模型：\n\n![](async.png)\n\n在该模型中，任务之间彼此交错，但是都在同一线程中执行。这比多线程的情况要简单因为程序要总是知道**同一时间只有一个任务在执行**。除此之外，异步模型与多线程模型之前还有一个区别，在多线程模型中，线程的挂起与执行是由操作系统而不是程序员决定的，程序员需要假设一个线程可能被随时挂起。与此相反，在异步模型中，一个任务将会持续运行直到在适当的时候明确主动地放弃CPU资源占用让其他任务执行，这比多线程模型简单许多。\n\n# 为什么要使用异步模型\n\n有很多原因促使我们使用异步模型，其中一个比较常见的就是解决阻塞问题：\n\n![](block.png)\n\n图中的灰色部分代表了一个任务正在阻塞等待而无法继续执行。为什么一个任务会阻塞？一个常见的原因就是该任务正在等待完成I/O，完成向外接设备传递数据或者从外界设备接收数据。通常情况下，由于CPU处理数据的速度是磁盘或者网络连接处理数据速度的几个数量级，因此一个完成大量I/O操作的程序将会在阻塞上大量时间以等待磁盘或者网络完成操作。回过头看异步模型，对于遇到一个任务可能在同步模型下阻塞的时候，将会让出CPU转而执行其他没有阻塞的任务。因此异步模型只在没有任务可以继续执行即所有任务都在等待I/O的时候“阻塞”。\n\n相比较于同步模型，异步模型在以下情况下表现更好：\n\n1. 有大量任务需要执行且无论什么时候至少有一个任务可以继续执行。\n2. 要完成的任务中需要完成大量I/O操作，导致同步程序在其他任务可以继续执行时候会浪费大量时间阻塞等待。\n3. 任务之间基本不相关因此不需要任务间交互。\n\n那么asyncio的异步模型实现是基于什么呢？\n\n![](reactor-1.png)\n\n如图所示，这是反应器模式的一个基本结构，它总是处在等待事件以及处理事件的状态之一，因此也被称作**事件循环(event loop)**，也即asyncio模块的核心之一。\n\n# 事件循环示例\n\n让我们从一些官方文档示例开始。\n\n第一个例子是简单地打印字符串：\n\n```Python\nimport asyncio\n\ndef hello_world(loop):\n    print('Hello World')\n    loop.stop()\n\nloop = asyncio.get_event_loop()\n\n# Schedule a call to hello_world()\nloop.call_soon(hello_world, loop)\n\n# Blocking call interrupted by loop.stop()\nloop.run_forever()\nloop.close()\n```\n\n代码首先导入了我们需要使用的asyncio模块，然后定义了一个接收一个参数的`hello_world`函数，该函数只完成了两件事，打印一段字符串并在一个对象上调用了`stop`方法，关键在这之后：\n\n1. `get_event_loop`: 我们通过使用asyncio模块的`get_event_loop`方法取得了事件循环，之前说过了，事件循环是整个asyncio模块的核心，我们需要把我们的任务添加到事件循环中，那么第一步便是取得事件循环。除了取得事件循环，还可以更改或者新建事件循环，以及更底层的Policy，但是由于我们是初次接触，就不再深究。\n2. `call_soon`: 接着，我们在loop对象上调用了`call_soon`方法，该方法接收多个参数，第一个参数是一个可调用对象，后面的参数将会传给该对象，在此处我们传递了`hello_world`函数和loop对象。该函数的作用是在事件循环启动之后尽快调用传递的对象。\n3. `run_forever`: 通过调用loop对象的`run_forever`函数，将启动事件循环，外部代码将会阻塞，即`run_forever`之后的函数将不会继续执行。\n4. `stop`: 由于启动了事件循环，之前通过`call_soon`调度的`hello_world`函数将会执行，打印字符串并调用loop对象的`stop`方法，该方法将会停止事件循环，使得外部代码继续执行。\n5. `close`: 关闭事件循环，需要注意的是关闭之前必须保证事件循环没有执行。\n\n第二个例子每秒打印一次当前日期时间：\n\n```Python\nimport asyncio\nimport datetime\n\ndef display_date(end_time, loop):\n    print(datetime.datetime.now())\n    if (loop.time() + 1.0) < end_time:\n        loop.call_later(1, display_date, end_time, loop)\n    else:\n        loop.stop()\n\nloop = asyncio.get_event_loop()\n\n# Schedule the first call to display_date()\nend_time = loop.time() + 5.0\nloop.call_soon(display_date, end_time, loop)\n\n# Blocking call interrupted by loop.stop()\nloop.run_forever()\nloop.close()\n```\n\n`call_soon`和`run_forever`等方法的调用和前一个例子相同，区别在于调用`display_date`函数将会打印当前日期时间然后判断当前时间是否超过结束时间，如果超过则停止事件循环，否则则使用`call_later`方法设置1秒后对`display_date`函数进行调用。需要注意的一点是loop的`time`方法和`time`模块的`time`方法相似，不过使用的loop的内部时钟。\n\n第三个例子是监视文件描述符的读事件：\n\n```Python\nimport asyncio\ntry:\n    from socket import socketpair\nexcept ImportError:\n    from asyncio.windows_utils import socketpair\n\n# Create a pair of connected file descriptors\nrsock, wsock = socketpair()\nloop = asyncio.get_event_loop()\n\ndef reader():\n    data = rsock.recv(100)\n    print(\"Received:\", data.decode())\n    # We are done: unregister the file descriptor\n    loop.remove_reader(rsock)\n    # Stop the event loop\n    loop.stop()\n\n# Register the file descriptor for read event\nloop.add_reader(rsock, reader)\n\n# Simulate the reception of data from the network\nloop.call_soon(wsock.send, 'abc'.encode())\n\n# Run the event loop\nloop.run_forever()\n\n# We are done, close sockets and the event loop\nrsock.close()\nwsock.close()\nloop.close()\n```\n\n该示例通过使用socketpair函数创建了一组相连接的socket对象，`loop.call_soon(wsock.send, 'abc'.encode())`将会在事件循环启动后尽快调用wsock的`send`方法，方法参数为`'abc'.encode()`。除此之外，通过调用loop的`add_reader`方法，监视rsock的读事件，当读可用时，将会调用注册的`reader`函数，接收内容并打印出来，然后取消对rsock的注册并停止事件循环。\n\n最后一个例子是为`SIGINT`和`SIGTERM`等信号设置处理器：\n\n```Python\nimport asyncio\nimport functools\nimport os\nimport signal\n\ndef ask_exit(signame):\n    print(\"got signal %s: exit\" % signame)\n    loop.stop()\n\nloop = asyncio.get_event_loop()\nfor signame in ('SIGINT', 'SIGTERM'):\n    loop.add_signal_handler(getattr(signal, signame),\n                            functools.partial(ask_exit, signame))\n\nprint(\"Event loop running forever, press Ctrl+C to interrupt.\")\nprint(\"pid %s: send SIGINT or SIGTERM to exit.\" % os.getpid())\ntry:\n    loop.run_forever()\nfinally:\n    loop.close()\n```\n\n上面一段代码里面最重要的部分就是`add_signal_handler`方法，第一个参数为信号对象，第二个参数为该信号出现时该调用的函数。在本例中，即当`SIGINT`和`SIGTERM`信号出现时调用`ask_exit`函数。\n\n在使用asyncio时，还有一点需要注意的是：\n\n> 许多asyncio模块的函数都不接受关键字参数。因此，如果需要向回调函数传递关键字参数，需要使用`functools`模块的`partial`方法，比如`loop.call_soon(functools.partial(print, \"Hello\", flush=True))`将会调用`print(\"Hello\", flush=True)`。\n\n限于篇幅原因，本文止步于此，对于asyncio模块的其他内容的学习在接下来的文章中会进行分享。\n","slug":"New-to-asyncio","published":1,"updated":"2018-01-15T01:18:15.816Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgvnqml2000nw628x8rdpejh","content":"<p>前两天花了些时间阅读了Python的<a href=\"https://docs.python.org/3/library/asyncio.html#module-asyncio\" target=\"_blank\" rel=\"noopener\"><code>asyncio</code></a>模块的相关文档，综合之前对<a href=\"http://twistedmatrix.com/trac/\" target=\"_blank\" rel=\"noopener\">Twisted</a>的一些了解，分享一些学习结果。</p>\n<p>根据官方文档的介绍，<code>asyncio</code>这个模块是在Python 3.4进行引入的，这个模块提供了使用协程编写单线程并发程序、对sockets以及其他资源的多路I/O访问、执行网络客户端和服务器等工作的基础。模块内容主要包含:</p>\n<ul>\n<li>一个多种平台相关实现的可插拔事件循环；</li>\n<li><code>transport</code>和<code>protocol</code>抽象(与<a href=\"http://twistedmatrix.com/trac/\" target=\"_blank\" rel=\"noopener\">Twisted</a>的概念相似)；</li>\n<li>对TCP、UDP、SSL、子进程管道、延迟调用、以及其他功能(以上操作可能平台相关)的有力支持；</li>\n<li>一个模仿<a href=\"https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures\" target=\"_blank\" rel=\"noopener\"><code>concurrent.futures</code></a>模块实现的<code>Future</code>类，但增加了对事件循环的适应；</li>\n<li>使用<a href=\"https://www.python.org/dev/peps/pep-0380\" target=\"_blank\" rel=\"noopener\"><code>yield from</code></a>的协程(coroutines)以及作业(tasks)，以帮助使用顺序方式编写并发代码；</li>\n<li>对取消<code>Future</code>和协程的支持；</li>\n<li>在单线程的不同协程中使用的<a href=\"https://docs.python.org/3/library/asyncio-sync.html#asyncio-sync\" target=\"_blank\" rel=\"noopener\">同步原语</a>，模仿<a href=\"https://docs.python.org/3/library/threading.html#module-threading\" target=\"_blank\" rel=\"noopener\">threading</a>实现；</li>\n<li>一个向线程池传递任务的接口，以解决无可避免地需要使用某些会造成I/O阻塞库的调用。</li>\n</ul>\n<div class=\"tip\">本文相关特性需Python 3.4以上版本支持，部分内容需要Python 3.5以上版本支持</div>\n\n<a id=\"more\"></a>\n<p>在开始相关的介绍之前，我们需要对同步、异步等工作方式有一个简单的了解，以下部分内容引用自<a href=\"http://krondo.com\" target=\"_blank\" rel=\"noopener\"><em>krondo</em></a>编写的<a href=\"http://krondo.com/an-introduction-to-asynchronous-programming-and-twisted/\" target=\"_blank\" rel=\"noopener\">Twisted Introduction</a>。</p>\n<h1 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h1><p>大部分程序员应该非常熟悉同步模型了：</p>\n<p><img src=\"/2017/05/10/New-to-asyncio/sync.png\" alt=\"\"></p>\n<p>这是最简单的一种编程方式，每个任务依次执行，只有上一个任务结束以后下一个才会执行，任务都是按照确定顺序执行的，后面的任务可以认为所有之前的任务都是没有错误的正常结束，且他们的输出可以正常使用。</p>\n<p>当然，我们也可以对比多线程(同步)模型：</p>\n<p><img src=\"/2017/05/10/New-to-asyncio/threaded.png\" alt=\"\"></p>\n<p>在该模型中，每一个任务都在一个单独的线程中执行，线程由操作系统管理，且在某些拥有多处理器或多核的操作系统上，可能可以真正的并发执行，或者都被放入同一处理器中执行。关键在于，多线程模型的执行细节是由操作系统控制的，对于不相关的指令流程序员应该认为其是同时执行的。因此，虽然图看起来简单，但实际编写多线程模型可能比较复杂，因为不同线程之间需要保持一定的协调。线程通信以及协调是一个高级编程话题而且要正确实现很困难。</p>\n<p>下面让我们来看异步模型：</p>\n<p><img src=\"/2017/05/10/New-to-asyncio/async.png\" alt=\"\"></p>\n<p>在该模型中，任务之间彼此交错，但是都在同一线程中执行。这比多线程的情况要简单因为程序要总是知道<strong>同一时间只有一个任务在执行</strong>。除此之外，异步模型与多线程模型之前还有一个区别，在多线程模型中，线程的挂起与执行是由操作系统而不是程序员决定的，程序员需要假设一个线程可能被随时挂起。与此相反，在异步模型中，一个任务将会持续运行直到在适当的时候明确主动地放弃CPU资源占用让其他任务执行，这比多线程模型简单许多。</p>\n<h1 id=\"为什么要使用异步模型\"><a href=\"#为什么要使用异步模型\" class=\"headerlink\" title=\"为什么要使用异步模型\"></a>为什么要使用异步模型</h1><p>有很多原因促使我们使用异步模型，其中一个比较常见的就是解决阻塞问题：</p>\n<p><img src=\"/2017/05/10/New-to-asyncio/block.png\" alt=\"\"></p>\n<p>图中的灰色部分代表了一个任务正在阻塞等待而无法继续执行。为什么一个任务会阻塞？一个常见的原因就是该任务正在等待完成I/O，完成向外接设备传递数据或者从外界设备接收数据。通常情况下，由于CPU处理数据的速度是磁盘或者网络连接处理数据速度的几个数量级，因此一个完成大量I/O操作的程序将会在阻塞上大量时间以等待磁盘或者网络完成操作。回过头看异步模型，对于遇到一个任务可能在同步模型下阻塞的时候，将会让出CPU转而执行其他没有阻塞的任务。因此异步模型只在没有任务可以继续执行即所有任务都在等待I/O的时候“阻塞”。</p>\n<p>相比较于同步模型，异步模型在以下情况下表现更好：</p>\n<ol>\n<li>有大量任务需要执行且无论什么时候至少有一个任务可以继续执行。</li>\n<li>要完成的任务中需要完成大量I/O操作，导致同步程序在其他任务可以继续执行时候会浪费大量时间阻塞等待。</li>\n<li>任务之间基本不相关因此不需要任务间交互。</li>\n</ol>\n<p>那么asyncio的异步模型实现是基于什么呢？</p>\n<p><img src=\"/2017/05/10/New-to-asyncio/reactor-1.png\" alt=\"\"></p>\n<p>如图所示，这是反应器模式的一个基本结构，它总是处在等待事件以及处理事件的状态之一，因此也被称作<strong>事件循环(event loop)</strong>，也即asyncio模块的核心之一。</p>\n<h1 id=\"事件循环示例\"><a href=\"#事件循环示例\" class=\"headerlink\" title=\"事件循环示例\"></a>事件循环示例</h1><p>让我们从一些官方文档示例开始。</p>\n<p>第一个例子是简单地打印字符串：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> asyncio</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello_world</span><span class=\"params\">(loop)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Hello World'</span>)</span><br><span class=\"line\">    loop.stop()</span><br><span class=\"line\"></span><br><span class=\"line\">loop = asyncio.get_event_loop()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Schedule a call to hello_world()</span></span><br><span class=\"line\">loop.call_soon(hello_world, loop)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Blocking call interrupted by loop.stop()</span></span><br><span class=\"line\">loop.run_forever()</span><br><span class=\"line\">loop.close()</span><br></pre></td></tr></table></figure>\n<p>代码首先导入了我们需要使用的asyncio模块，然后定义了一个接收一个参数的<code>hello_world</code>函数，该函数只完成了两件事，打印一段字符串并在一个对象上调用了<code>stop</code>方法，关键在这之后：</p>\n<ol>\n<li><code>get_event_loop</code>: 我们通过使用asyncio模块的<code>get_event_loop</code>方法取得了事件循环，之前说过了，事件循环是整个asyncio模块的核心，我们需要把我们的任务添加到事件循环中，那么第一步便是取得事件循环。除了取得事件循环，还可以更改或者新建事件循环，以及更底层的Policy，但是由于我们是初次接触，就不再深究。</li>\n<li><code>call_soon</code>: 接着，我们在loop对象上调用了<code>call_soon</code>方法，该方法接收多个参数，第一个参数是一个可调用对象，后面的参数将会传给该对象，在此处我们传递了<code>hello_world</code>函数和loop对象。该函数的作用是在事件循环启动之后尽快调用传递的对象。</li>\n<li><code>run_forever</code>: 通过调用loop对象的<code>run_forever</code>函数，将启动事件循环，外部代码将会阻塞，即<code>run_forever</code>之后的函数将不会继续执行。</li>\n<li><code>stop</code>: 由于启动了事件循环，之前通过<code>call_soon</code>调度的<code>hello_world</code>函数将会执行，打印字符串并调用loop对象的<code>stop</code>方法，该方法将会停止事件循环，使得外部代码继续执行。</li>\n<li><code>close</code>: 关闭事件循环，需要注意的是关闭之前必须保证事件循环没有执行。</li>\n</ol>\n<p>第二个例子每秒打印一次当前日期时间：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> asyncio</span><br><span class=\"line\"><span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">display_date</span><span class=\"params\">(end_time, loop)</span>:</span></span><br><span class=\"line\">    print(datetime.datetime.now())</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loop.time() + <span class=\"number\">1.0</span>) &lt; end_time:</span><br><span class=\"line\">        loop.call_later(<span class=\"number\">1</span>, display_date, end_time, loop)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        loop.stop()</span><br><span class=\"line\"></span><br><span class=\"line\">loop = asyncio.get_event_loop()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Schedule the first call to display_date()</span></span><br><span class=\"line\">end_time = loop.time() + <span class=\"number\">5.0</span></span><br><span class=\"line\">loop.call_soon(display_date, end_time, loop)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Blocking call interrupted by loop.stop()</span></span><br><span class=\"line\">loop.run_forever()</span><br><span class=\"line\">loop.close()</span><br></pre></td></tr></table></figure>\n<p><code>call_soon</code>和<code>run_forever</code>等方法的调用和前一个例子相同，区别在于调用<code>display_date</code>函数将会打印当前日期时间然后判断当前时间是否超过结束时间，如果超过则停止事件循环，否则则使用<code>call_later</code>方法设置1秒后对<code>display_date</code>函数进行调用。需要注意的一点是loop的<code>time</code>方法和<code>time</code>模块的<code>time</code>方法相似，不过使用的loop的内部时钟。</p>\n<p>第三个例子是监视文件描述符的读事件：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> asyncio</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">from</span> socket <span class=\"keyword\">import</span> socketpair</span><br><span class=\"line\"><span class=\"keyword\">except</span> ImportError:</span><br><span class=\"line\">    <span class=\"keyword\">from</span> asyncio.windows_utils <span class=\"keyword\">import</span> socketpair</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Create a pair of connected file descriptors</span></span><br><span class=\"line\">rsock, wsock = socketpair()</span><br><span class=\"line\">loop = asyncio.get_event_loop()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reader</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    data = rsock.recv(<span class=\"number\">100</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"Received:\"</span>, data.decode())</span><br><span class=\"line\">    <span class=\"comment\"># We are done: unregister the file descriptor</span></span><br><span class=\"line\">    loop.remove_reader(rsock)</span><br><span class=\"line\">    <span class=\"comment\"># Stop the event loop</span></span><br><span class=\"line\">    loop.stop()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Register the file descriptor for read event</span></span><br><span class=\"line\">loop.add_reader(rsock, reader)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Simulate the reception of data from the network</span></span><br><span class=\"line\">loop.call_soon(wsock.send, <span class=\"string\">'abc'</span>.encode())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Run the event loop</span></span><br><span class=\"line\">loop.run_forever()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># We are done, close sockets and the event loop</span></span><br><span class=\"line\">rsock.close()</span><br><span class=\"line\">wsock.close()</span><br><span class=\"line\">loop.close()</span><br></pre></td></tr></table></figure>\n<p>该示例通过使用socketpair函数创建了一组相连接的socket对象，<code>loop.call_soon(wsock.send, &#39;abc&#39;.encode())</code>将会在事件循环启动后尽快调用wsock的<code>send</code>方法，方法参数为<code>&#39;abc&#39;.encode()</code>。除此之外，通过调用loop的<code>add_reader</code>方法，监视rsock的读事件，当读可用时，将会调用注册的<code>reader</code>函数，接收内容并打印出来，然后取消对rsock的注册并停止事件循环。</p>\n<p>最后一个例子是为<code>SIGINT</code>和<code>SIGTERM</code>等信号设置处理器：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> asyncio</span><br><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> signal</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ask_exit</span><span class=\"params\">(signame)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"got signal %s: exit\"</span> % signame)</span><br><span class=\"line\">    loop.stop()</span><br><span class=\"line\"></span><br><span class=\"line\">loop = asyncio.get_event_loop()</span><br><span class=\"line\"><span class=\"keyword\">for</span> signame <span class=\"keyword\">in</span> (<span class=\"string\">'SIGINT'</span>, <span class=\"string\">'SIGTERM'</span>):</span><br><span class=\"line\">    loop.add_signal_handler(getattr(signal, signame),</span><br><span class=\"line\">                            functools.partial(ask_exit, signame))</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">\"Event loop running forever, press Ctrl+C to interrupt.\"</span>)</span><br><span class=\"line\">print(<span class=\"string\">\"pid %s: send SIGINT or SIGTERM to exit.\"</span> % os.getpid())</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    loop.run_forever()</span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">    loop.close()</span><br></pre></td></tr></table></figure>\n<p>上面一段代码里面最重要的部分就是<code>add_signal_handler</code>方法，第一个参数为信号对象，第二个参数为该信号出现时该调用的函数。在本例中，即当<code>SIGINT</code>和<code>SIGTERM</code>信号出现时调用<code>ask_exit</code>函数。</p>\n<p>在使用asyncio时，还有一点需要注意的是：</p>\n<blockquote>\n<p>许多asyncio模块的函数都不接受关键字参数。因此，如果需要向回调函数传递关键字参数，需要使用<code>functools</code>模块的<code>partial</code>方法，比如<code>loop.call_soon(functools.partial(print, &quot;Hello&quot;, flush=True))</code>将会调用<code>print(&quot;Hello&quot;, flush=True)</code>。</p>\n</blockquote>\n<p>限于篇幅原因，本文止步于此，对于asyncio模块的其他内容的学习在接下来的文章中会进行分享。</p>\n","site":{"data":{}},"excerpt":"<p>前两天花了些时间阅读了Python的<a href=\"https://docs.python.org/3/library/asyncio.html#module-asyncio\" target=\"_blank\" rel=\"noopener\"><code>asyncio</code></a>模块的相关文档，综合之前对<a href=\"http://twistedmatrix.com/trac/\" target=\"_blank\" rel=\"noopener\">Twisted</a>的一些了解，分享一些学习结果。</p>\n<p>根据官方文档的介绍，<code>asyncio</code>这个模块是在Python 3.4进行引入的，这个模块提供了使用协程编写单线程并发程序、对sockets以及其他资源的多路I/O访问、执行网络客户端和服务器等工作的基础。模块内容主要包含:</p>\n<ul>\n<li>一个多种平台相关实现的可插拔事件循环；</li>\n<li><code>transport</code>和<code>protocol</code>抽象(与<a href=\"http://twistedmatrix.com/trac/\" target=\"_blank\" rel=\"noopener\">Twisted</a>的概念相似)；</li>\n<li>对TCP、UDP、SSL、子进程管道、延迟调用、以及其他功能(以上操作可能平台相关)的有力支持；</li>\n<li>一个模仿<a href=\"https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures\" target=\"_blank\" rel=\"noopener\"><code>concurrent.futures</code></a>模块实现的<code>Future</code>类，但增加了对事件循环的适应；</li>\n<li>使用<a href=\"https://www.python.org/dev/peps/pep-0380\" target=\"_blank\" rel=\"noopener\"><code>yield from</code></a>的协程(coroutines)以及作业(tasks)，以帮助使用顺序方式编写并发代码；</li>\n<li>对取消<code>Future</code>和协程的支持；</li>\n<li>在单线程的不同协程中使用的<a href=\"https://docs.python.org/3/library/asyncio-sync.html#asyncio-sync\" target=\"_blank\" rel=\"noopener\">同步原语</a>，模仿<a href=\"https://docs.python.org/3/library/threading.html#module-threading\" target=\"_blank\" rel=\"noopener\">threading</a>实现；</li>\n<li>一个向线程池传递任务的接口，以解决无可避免地需要使用某些会造成I/O阻塞库的调用。</li>\n</ul>\n<div class=\"tip\">本文相关特性需Python 3.4以上版本支持，部分内容需要Python 3.5以上版本支持</div>","more":"<p>在开始相关的介绍之前，我们需要对同步、异步等工作方式有一个简单的了解，以下部分内容引用自<a href=\"http://krondo.com\" target=\"_blank\" rel=\"noopener\"><em>krondo</em></a>编写的<a href=\"http://krondo.com/an-introduction-to-asynchronous-programming-and-twisted/\" target=\"_blank\" rel=\"noopener\">Twisted Introduction</a>。</p>\n<h1 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h1><p>大部分程序员应该非常熟悉同步模型了：</p>\n<p><img src=\"/2017/05/10/New-to-asyncio/sync.png\" alt=\"\"></p>\n<p>这是最简单的一种编程方式，每个任务依次执行，只有上一个任务结束以后下一个才会执行，任务都是按照确定顺序执行的，后面的任务可以认为所有之前的任务都是没有错误的正常结束，且他们的输出可以正常使用。</p>\n<p>当然，我们也可以对比多线程(同步)模型：</p>\n<p><img src=\"/2017/05/10/New-to-asyncio/threaded.png\" alt=\"\"></p>\n<p>在该模型中，每一个任务都在一个单独的线程中执行，线程由操作系统管理，且在某些拥有多处理器或多核的操作系统上，可能可以真正的并发执行，或者都被放入同一处理器中执行。关键在于，多线程模型的执行细节是由操作系统控制的，对于不相关的指令流程序员应该认为其是同时执行的。因此，虽然图看起来简单，但实际编写多线程模型可能比较复杂，因为不同线程之间需要保持一定的协调。线程通信以及协调是一个高级编程话题而且要正确实现很困难。</p>\n<p>下面让我们来看异步模型：</p>\n<p><img src=\"/2017/05/10/New-to-asyncio/async.png\" alt=\"\"></p>\n<p>在该模型中，任务之间彼此交错，但是都在同一线程中执行。这比多线程的情况要简单因为程序要总是知道<strong>同一时间只有一个任务在执行</strong>。除此之外，异步模型与多线程模型之前还有一个区别，在多线程模型中，线程的挂起与执行是由操作系统而不是程序员决定的，程序员需要假设一个线程可能被随时挂起。与此相反，在异步模型中，一个任务将会持续运行直到在适当的时候明确主动地放弃CPU资源占用让其他任务执行，这比多线程模型简单许多。</p>\n<h1 id=\"为什么要使用异步模型\"><a href=\"#为什么要使用异步模型\" class=\"headerlink\" title=\"为什么要使用异步模型\"></a>为什么要使用异步模型</h1><p>有很多原因促使我们使用异步模型，其中一个比较常见的就是解决阻塞问题：</p>\n<p><img src=\"/2017/05/10/New-to-asyncio/block.png\" alt=\"\"></p>\n<p>图中的灰色部分代表了一个任务正在阻塞等待而无法继续执行。为什么一个任务会阻塞？一个常见的原因就是该任务正在等待完成I/O，完成向外接设备传递数据或者从外界设备接收数据。通常情况下，由于CPU处理数据的速度是磁盘或者网络连接处理数据速度的几个数量级，因此一个完成大量I/O操作的程序将会在阻塞上大量时间以等待磁盘或者网络完成操作。回过头看异步模型，对于遇到一个任务可能在同步模型下阻塞的时候，将会让出CPU转而执行其他没有阻塞的任务。因此异步模型只在没有任务可以继续执行即所有任务都在等待I/O的时候“阻塞”。</p>\n<p>相比较于同步模型，异步模型在以下情况下表现更好：</p>\n<ol>\n<li>有大量任务需要执行且无论什么时候至少有一个任务可以继续执行。</li>\n<li>要完成的任务中需要完成大量I/O操作，导致同步程序在其他任务可以继续执行时候会浪费大量时间阻塞等待。</li>\n<li>任务之间基本不相关因此不需要任务间交互。</li>\n</ol>\n<p>那么asyncio的异步模型实现是基于什么呢？</p>\n<p><img src=\"/2017/05/10/New-to-asyncio/reactor-1.png\" alt=\"\"></p>\n<p>如图所示，这是反应器模式的一个基本结构，它总是处在等待事件以及处理事件的状态之一，因此也被称作<strong>事件循环(event loop)</strong>，也即asyncio模块的核心之一。</p>\n<h1 id=\"事件循环示例\"><a href=\"#事件循环示例\" class=\"headerlink\" title=\"事件循环示例\"></a>事件循环示例</h1><p>让我们从一些官方文档示例开始。</p>\n<p>第一个例子是简单地打印字符串：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> asyncio</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello_world</span><span class=\"params\">(loop)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Hello World'</span>)</span><br><span class=\"line\">    loop.stop()</span><br><span class=\"line\"></span><br><span class=\"line\">loop = asyncio.get_event_loop()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Schedule a call to hello_world()</span></span><br><span class=\"line\">loop.call_soon(hello_world, loop)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Blocking call interrupted by loop.stop()</span></span><br><span class=\"line\">loop.run_forever()</span><br><span class=\"line\">loop.close()</span><br></pre></td></tr></table></figure>\n<p>代码首先导入了我们需要使用的asyncio模块，然后定义了一个接收一个参数的<code>hello_world</code>函数，该函数只完成了两件事，打印一段字符串并在一个对象上调用了<code>stop</code>方法，关键在这之后：</p>\n<ol>\n<li><code>get_event_loop</code>: 我们通过使用asyncio模块的<code>get_event_loop</code>方法取得了事件循环，之前说过了，事件循环是整个asyncio模块的核心，我们需要把我们的任务添加到事件循环中，那么第一步便是取得事件循环。除了取得事件循环，还可以更改或者新建事件循环，以及更底层的Policy，但是由于我们是初次接触，就不再深究。</li>\n<li><code>call_soon</code>: 接着，我们在loop对象上调用了<code>call_soon</code>方法，该方法接收多个参数，第一个参数是一个可调用对象，后面的参数将会传给该对象，在此处我们传递了<code>hello_world</code>函数和loop对象。该函数的作用是在事件循环启动之后尽快调用传递的对象。</li>\n<li><code>run_forever</code>: 通过调用loop对象的<code>run_forever</code>函数，将启动事件循环，外部代码将会阻塞，即<code>run_forever</code>之后的函数将不会继续执行。</li>\n<li><code>stop</code>: 由于启动了事件循环，之前通过<code>call_soon</code>调度的<code>hello_world</code>函数将会执行，打印字符串并调用loop对象的<code>stop</code>方法，该方法将会停止事件循环，使得外部代码继续执行。</li>\n<li><code>close</code>: 关闭事件循环，需要注意的是关闭之前必须保证事件循环没有执行。</li>\n</ol>\n<p>第二个例子每秒打印一次当前日期时间：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> asyncio</span><br><span class=\"line\"><span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">display_date</span><span class=\"params\">(end_time, loop)</span>:</span></span><br><span class=\"line\">    print(datetime.datetime.now())</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loop.time() + <span class=\"number\">1.0</span>) &lt; end_time:</span><br><span class=\"line\">        loop.call_later(<span class=\"number\">1</span>, display_date, end_time, loop)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        loop.stop()</span><br><span class=\"line\"></span><br><span class=\"line\">loop = asyncio.get_event_loop()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Schedule the first call to display_date()</span></span><br><span class=\"line\">end_time = loop.time() + <span class=\"number\">5.0</span></span><br><span class=\"line\">loop.call_soon(display_date, end_time, loop)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Blocking call interrupted by loop.stop()</span></span><br><span class=\"line\">loop.run_forever()</span><br><span class=\"line\">loop.close()</span><br></pre></td></tr></table></figure>\n<p><code>call_soon</code>和<code>run_forever</code>等方法的调用和前一个例子相同，区别在于调用<code>display_date</code>函数将会打印当前日期时间然后判断当前时间是否超过结束时间，如果超过则停止事件循环，否则则使用<code>call_later</code>方法设置1秒后对<code>display_date</code>函数进行调用。需要注意的一点是loop的<code>time</code>方法和<code>time</code>模块的<code>time</code>方法相似，不过使用的loop的内部时钟。</p>\n<p>第三个例子是监视文件描述符的读事件：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> asyncio</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">from</span> socket <span class=\"keyword\">import</span> socketpair</span><br><span class=\"line\"><span class=\"keyword\">except</span> ImportError:</span><br><span class=\"line\">    <span class=\"keyword\">from</span> asyncio.windows_utils <span class=\"keyword\">import</span> socketpair</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Create a pair of connected file descriptors</span></span><br><span class=\"line\">rsock, wsock = socketpair()</span><br><span class=\"line\">loop = asyncio.get_event_loop()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reader</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    data = rsock.recv(<span class=\"number\">100</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"Received:\"</span>, data.decode())</span><br><span class=\"line\">    <span class=\"comment\"># We are done: unregister the file descriptor</span></span><br><span class=\"line\">    loop.remove_reader(rsock)</span><br><span class=\"line\">    <span class=\"comment\"># Stop the event loop</span></span><br><span class=\"line\">    loop.stop()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Register the file descriptor for read event</span></span><br><span class=\"line\">loop.add_reader(rsock, reader)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Simulate the reception of data from the network</span></span><br><span class=\"line\">loop.call_soon(wsock.send, <span class=\"string\">'abc'</span>.encode())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Run the event loop</span></span><br><span class=\"line\">loop.run_forever()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># We are done, close sockets and the event loop</span></span><br><span class=\"line\">rsock.close()</span><br><span class=\"line\">wsock.close()</span><br><span class=\"line\">loop.close()</span><br></pre></td></tr></table></figure>\n<p>该示例通过使用socketpair函数创建了一组相连接的socket对象，<code>loop.call_soon(wsock.send, &#39;abc&#39;.encode())</code>将会在事件循环启动后尽快调用wsock的<code>send</code>方法，方法参数为<code>&#39;abc&#39;.encode()</code>。除此之外，通过调用loop的<code>add_reader</code>方法，监视rsock的读事件，当读可用时，将会调用注册的<code>reader</code>函数，接收内容并打印出来，然后取消对rsock的注册并停止事件循环。</p>\n<p>最后一个例子是为<code>SIGINT</code>和<code>SIGTERM</code>等信号设置处理器：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> asyncio</span><br><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> signal</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ask_exit</span><span class=\"params\">(signame)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"got signal %s: exit\"</span> % signame)</span><br><span class=\"line\">    loop.stop()</span><br><span class=\"line\"></span><br><span class=\"line\">loop = asyncio.get_event_loop()</span><br><span class=\"line\"><span class=\"keyword\">for</span> signame <span class=\"keyword\">in</span> (<span class=\"string\">'SIGINT'</span>, <span class=\"string\">'SIGTERM'</span>):</span><br><span class=\"line\">    loop.add_signal_handler(getattr(signal, signame),</span><br><span class=\"line\">                            functools.partial(ask_exit, signame))</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">\"Event loop running forever, press Ctrl+C to interrupt.\"</span>)</span><br><span class=\"line\">print(<span class=\"string\">\"pid %s: send SIGINT or SIGTERM to exit.\"</span> % os.getpid())</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    loop.run_forever()</span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">    loop.close()</span><br></pre></td></tr></table></figure>\n<p>上面一段代码里面最重要的部分就是<code>add_signal_handler</code>方法，第一个参数为信号对象，第二个参数为该信号出现时该调用的函数。在本例中，即当<code>SIGINT</code>和<code>SIGTERM</code>信号出现时调用<code>ask_exit</code>函数。</p>\n<p>在使用asyncio时，还有一点需要注意的是：</p>\n<blockquote>\n<p>许多asyncio模块的函数都不接受关键字参数。因此，如果需要向回调函数传递关键字参数，需要使用<code>functools</code>模块的<code>partial</code>方法，比如<code>loop.call_soon(functools.partial(print, &quot;Hello&quot;, flush=True))</code>将会调用<code>print(&quot;Hello&quot;, flush=True)</code>。</p>\n</blockquote>\n<p>限于篇幅原因，本文止步于此，对于asyncio模块的其他内容的学习在接下来的文章中会进行分享。</p>"},{"title":"基于Scrapy的京东商品评论爬虫","date":"2017-03-12T14:07:57.000Z","_content":"今天想跟大家分享的是关于网络爬虫的相关知识，网络爬虫是一种根据一定的规则，自动地对互联网上相关内容进行抓取的程序或者脚本，本文的内容主要是通过分析京东评论的加载过程，获取相关API，然后通过使用基于Python语言的开源网络爬虫框架——Scrapy，大量获取相关评论内容。\n\n<div class=\"tip\">\n本文假定读者具有一定的Python编程经验，具有少量HTTP协议和HTML的相关知识，对爬虫的工作原理有一定了解。\n</div>\n\n<!-- more -->\n\n# API获取\n\n在开始编写爬虫之前，我们需要获得启动爬虫所需要的相关链接。在本文，我们将以对京东鞋类评论爬取为例，进行说明(其他种类爬取流程类似，区别只在于数据处理)。\n首先打开京东，搜索“鞋”，打开任意一件商品，并切换到“商品评价”标签页，如图所示。\n\n![comments_tab](item_shoe_comments_tab.png)\n\n启用浏览器的网页分析功能，以Safari浏览器为例，右键点击网页任意部分，选择”检查元素“，切换到“网络”标签下，如果有其他内容的话，可以点击右侧的垃圾桶图标清空历史，如图所示。\n\n![console_network_before](console_network_before.png)\n\n然后我们点击评论区的换页按钮，切换到任意一页新的评论，此时可以发现浏览器对本次点击产生的数据交换过程进行了记录，我们发现其中有一条名为\"productPageComments.action\"的记录，对其进行分析可以看到对应的完整URL，如图所示。\n\n![console_network_after](console_network_after.png)\n\n其完整URL为:`https://club.jd.com/comment/productPageComments.action?callback=fetchJSON_comment98vv6630&productId=10353518575&score=0&sortType=5&page=1&pageSize=10&isShadowSku=0`\n\n显而易见，评论的加载是通过GET请求实现，对我们来说，该URL中最关键的GET参数为`productID`和`page`，它们分别定义了对应的商品编号以及评论页码。通过访问该URL，我们可以得到内容如图所示。\n\n![comments_json_1](comments_json_1.png)\n\n可以看到，该URL返回的内容为json数据包，同时以请求中`callback`定义的函数名对其进行包裹，这一点从整个数据包最前方可以看出。我们将GET请求中callback参数去掉以后即可得到原始的json数据包，如图所示。\n\n![comments_json_2](comments_json_2.png)\n\n因此，在不考虑其他参数的情况下，我们需要的API格式为:`https://club.jd.com/comment/productPageComments.action?productId={}&score=0&sortType=5&page={}&pageSize=10&isShadowSku=0`\n\n\n至此，我们获得了返回任意商品的任意评论页的API，下面我们将对API返回数据本身的内容进行分析。\n\n# API返回字典分析\n\n从前面图中可以看出，API返回数据应该是一个字典，我们通过使用requests获得API返回字典以及Python的json模块进行分析。\n\n```Python\n>>> import requests\n>>> import json\n>>> url = 'https://club.jd.com/comment/productPageComments.action?productId=10353518575&score=0&sortType=5&page=1&pageSize=10&isShadowSku=0'\n>>> html = requests.get(url)\n>>> data = json.loads(html.text)\n>>> print(data.keys())\ndict_keys(['productAttr', 'productCommentSummary', 'hotCommentTagStatistics',\n'jwotestProduct', 'maxPage', 'score', 'soType', 'imageListCount',\n'vTagStatistics', 'comments'])\n```\n\n其中对我们来说最重要的是键`comments`所对应的值，值为一个列表，其中每个元素为一个字典，存放的是每一条评论的相关信息。\n\n```Python\n>>> print(type(data['comments']))\n<class 'list'>\n>>> import pprint\n>>> pprint(data['comments'][0])\n{'afterDays': 0,\n 'anonymousFlag': 1,\n 'commentTags': [{'commentId': 1927838458,\n                  'created': '2016-10-19 18:26:50',\n                  'id': 12373951,\n                  'modified': '2016-10-19 18:26:50',\n                  'name': '穿上很舒服',\n                  'pin': '',\n                  'productId': 10353518575,\n                  'rid': 11632,\n                  'status': 0}],\n 'content': '鞋子很不错，弹性很不错，材质很轻。穿上很舒服。透气性好，而且又长高了两厘米。',\n 'creationTime': '2016-10-19 18:26:20',\n 'days': 8,\n 'firstCategory': 1318,\n 'guid': 'cc2fec79-304b-48c5-a263-151bf7d098d2',\n 'id': 1927838458,\n 'integral': -20,\n 'isMobile': False,\n 'isReplyGrade': False,\n 'isTop': False,\n 'nickname': 'j***k',\n 'orderId': 0,\n 'plusAvailable': 0,\n 'productColor': '黑/安踏白',\n 'productSales': [],\n 'productSize': '8(男41)',\n 'recommend': True,\n 'referenceId': '10353518575',\n 'referenceImage': 'jfs/t3073/150/7342609081/176958/b211c3f7/58b4c73cN9621804d.jpg',\n 'referenceName': '安踏男鞋 易弯折科技跑步鞋 2017新款透气网面运动鞋 黑/安踏白-1 8(男41)',\n 'referenceTime': '2016-10-11 20:03:00',\n 'referenceType': 'Product',\n 'referenceTypeId': 0,\n 'replyCount': 0,\n 'score': 5,\n 'secondCategory': 12099,\n 'status': 1,\n 'thirdCategory': 9756,\n 'title': '',\n 'usefulVoteCount': 1,\n 'uselessVoteCount': 0,\n 'userClient': 0,\n 'userClientShow': '',\n 'userImage': 'misc.360buyimg.com/lib/img/u/b56.gif',\n 'userImageUrl': 'misc.360buyimg.com/lib/img/u/b56.gif',\n 'userImgFlag': 0,\n 'userLevelColor': '#666666',\n 'userLevelId': '56',\n 'userLevelName': '铜牌会员',\n 'userProvince': '',\n 'viewCount': 0}\n```\n\n根据实际需要，在本次实现中选取了以下信息:\n\n* guid\t\t\t\t--> 评论用户id\n* id\t\t\t\t--> 该评论id\n* referenceId\t\t--> 评论商品id\n* creationTime\t--> 评论时间\n* score\t\t\t--> 评论评分\n* userProvince\t--> 评论用户归属地\n* userLevelName\t--> 评论用户会员级别\n* productColor\t--> 评论用户购买颜色\n* productSize\t\t--> 评论用户购买尺寸\n\n至此，我们完成了对API返回字典的分析，在构建Scrapy爬虫之前，我们还需要对商品列表进行分析。\n\n# 商品列表分析\n\n我们已经拥有对任意给定的商品id,获取其所有评论的API，但在构建爬虫之前，我们还有最后一个问题，如何获得商品id?\n我们可以很容易的获得并格式化京东的搜索链接:`https://search.jd.com/Search?keyword={}&enc=utf-8&page={}`，根据该格式化链接，我们只需要填写搜索关键字以及搜索页码就能得到对应页的搜索结果。通过对网页源代码进行分析，可以发现每个商品都处于`class=\"gl-item\"`的`li`元素下，如图所示。\n\n![console_item_list](console_item_list.png)\n![console_item_list_2](console_item_list_2.png)\n\n我们只需要对`class=\"gl-item\"`的`li`元素下`class=\"p-img\"`的`div`元素下的`a`元素的`href`属性进行提取处理即可得到商品id，如图中的`10353518575`。\n\n至此，我们完成了对商品列表的分析工作，接下来我们将构建基于Scrapy的爬虫来完成对评论的爬取工作。\n\n# (可选)商品详细信息\n\n我们在上节中获得了商品的详细信息链接，如:`https://item.jd.com/10353518575.html`，我们可以对该页面内容进行爬取以获得更全面的商品信息。在这部分需要注意的是，很多内容是通过JavaScript进行动态加载的，在爬取时需要注意，否则得到的数据并不符合需要。通过启用浏览器的“停用JavaScript\"功能，可以看到在不执行JavaScript时的页面是什么样的，如图所示。\n\n![item_detail_no_js](item_detail_no_js.png)\n\n可以看到，商品的价格等信息是没有进行加载的，所以如果需要对价格进行爬取，需要使用到selenium等工具来完成浏览器的模拟或者进一步分析JavaScript的执行逻辑。\n\n# Scrapy爬虫\n\nScrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。其最初是为了网络抓取所设计的，也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。\n\n要使用Scrapy，首先得建立项目:\n\n```\n$ scrapy startproject jd\nNew Scrapy project 'jd', using template directory '/usr/local/lib/python3.6/site-packages/scrapy/templates/project', created in:\n    /private/tmp/jd\n\nYou can start your first spider with:\n    cd jd\n    scrapy genspider example example.com\n```\n\n在建好的`jd`文件夹下，有一个`jd`文件夹以及一个`scrapy.cfg`文件，进入前者，可以看到以下内容:\n\n```\n$ ls\n__init__.py    items.py       pipelines.py   spiders\n__pycache__    middlewares.py settings.py\n```\n\n其中:\n\n* items.py \t\t--> 完成数据容器Item的定义\n\t爬取的主要目标就是从非结构性的数据源提取结构性数据，例如网页。Scrapy提供 Item 类来满足这样的需求。Item 对象是种简单的容器，保存了爬取到得数据。 其提供了 类似于词典(dictionary-like) 的API以及用于声明可用字段的简单语法。\n* pipelines.py\t--> 完成对Item处理流水线的定义\n\t当Item在Spider中被收集之后，它将会被传递到Item Pipeline，一些组件会按照一定的顺序执行对Item的处理。每个item pipeline组件(有时称之为“Item Pipeline”)是实现了简单方法的Python类。他们接收到Item并通过它执行一些行为，同时也决定此Item是否继续通过pipeline，或是被丢弃而不再进行处理。\n\t以下是item pipeline的一些典型应用：\n\t* 清理HTML数据\n\t* 验证爬取的数据(检查item包含某些字段)\n\t* 查重(并丢弃)\n\t* 将爬取结果保存到数据库中\n* middlewares.py\t--> 完成Spider中间件的定义\n\tSpider中间件是介入到Scrapy的spider处理机制的钩子框架，通过定义并使用中间件，可以对发送给Spiders的response以及Spiders产生的Request对象进行处理。\n* settings.py\t\t--> 完成对爬虫的控制\n\tScrapy settings提供了定制Scrapy组件的方法。通过修改settings.py，可以控制包括核心(core)，插件(extension)，pipeline及spider组件。settings为代码提供了提取以key-value映射的配置值的的全局命名空间(namespace)。settings同时也是选择当前激活的Scrapy项目的方法。\n* spiders\t\t\t--> 完成对爬虫Spider的定义\n\tSpider类定义了如何爬取某个(或某些)网站。包括了爬取的动作(例如:是否跟进链接)以及如何从网页的内容中提取结构化数据(爬取item)。换句话说，Spider就是定义爬取的动作及分析某个网页(或者是有些网页)的地方。\n\n#### 定义数据容器items\n```Python\nimport scrapy\n\n\nclass ShoeCommentItem(scrapy.Item):\n    # define the fields for your item here like:\n    # name = scrapy.Field()\n    _id = scrapy.Field()\n    iid = scrapy.Field()\n    uid = scrapy.Field()\n    creation_time = scrapy.Field()\n    score = scrapy.Field()\n    user_province = scrapy.Field()\n    user_level = scrapy.Field()\n    color = scrapy.Field()\n    size = scrapy.Field()\n\nclass ShoeDetailItem(scrapy.Item):\n    iid = scrapy.Field()\n    name = scrapy.Field()\n    shop = scrapy.Field()\n    scores = scrapy.Field()\n```\n\n#### 定义爬虫类\n\n创建爬虫类的命令为:`scrapy genspider [爬虫名] [允许爬取域名]`\n\n```\n$ scrapy genspider shoes jd.com\nCreated spider 'shoes' using template 'basic' in module:\n  jd.spiders.shoes\n```\n\n接着打开`spiders`文件夹下的`shoes.py`文件进行编辑:\n* 首先我们需要定义一些变量，比如包含搜索关键字的列表、格式化搜索链接、格式化评论API链接等:\n```Python\nshoe_cates = [\n    '女深口单鞋', '工装鞋', '女鞋', '正装鞋', '平底鞋', '平底女鞋',\n    '功能鞋', '中跟单鞋', '女拖鞋', '凉鞋', '拖鞋', '帆布鞋', '人字拖',\n    '马丁靴', '商务休闲鞋', '传统布鞋', '休闲鞋', '鞋', '棉鞋', '定制鞋',\n    '男靴', '坡跟单鞋', '短靴', '雨鞋', '平板鞋', '尖头单鞋', '军靴', '女靴',\n    '皮鞋', '小白鞋', '雪地靴', '女豆豆鞋', '妈妈鞋', '增高鞋', '劳保鞋',\n    '豆豆鞋', '踝靴', '沙滩鞋', '鞋 女', '深口单鞋', '板鞋', '高帮鞋',\n    '人字拖鞋', '内增高', '发光鞋', '运动鞋', '高跟鞋', '雨靴', '鞋 男',\n    '乐福鞋', '内增高休闲鞋', '老人鞋', '男鞋', '平底单鞋', '浅口单鞋', '单鞋']\nshoe_list_url = 'https://search.jd.com/Search?keyword={}&enc=utf-8&page={}'\ncomment_url_api = ('https://club.jd.com/comment/productPageComments.action?'\n    'productId={}&score=0&sortType=5&page={}&pageSize=10&isShadowSku=0')\nnum_pat = re.compile('(\\d*?)')\n```\n\n* 然后编辑`ShoesSpider`类:\n```Python\nclass ShoesSpider(Spider):\n    name = 'shoes'\n    allowed_domains = ['jd.com']\n    start_urls = [shoe_list_url.format(cate, page) for cate in shoe_cates\n                  for page in range(1, 101)]\n\n    def parse(self, response):\n        item_urls = response.xpath('//li[@class=\"gl-item\"]/div')\n        for item_xpath in item_urls:\n            url = item_xpath.xpath('div[@class=\"p-img\"]/a'\n                                   '/@href').extract_first()\n            if not url or 'ccc-x' in url:\n                continue\n            iid = url[url.rfind('/')+1:-5]\n            detail_url = 'http:' + url\n            yield Request(\n                detail_url,\n                callback=self.parse_detail,\n                meta={'iid': iid})\n            yield Request(\n                comment_url_api.format(iid, 1),\n                callback=self.parse_comment,\n                meta={'page': 1, 'iid': iid, 'retry': 0})\n\n    def parse_detail(self, response):\n        iid = int(response.meta['iid'])\n        name = response.xpath('//div[@class=\"sku-name\"]'\n                              '/text()').extract_first().strip('\\n ')\n        xpath_aside = response.xpath('//div[@class=\"aside\"]')\n        shop = xpath_aside.xpath('//div[@class=\"mt\"]/'\n                                 'h3/a/@title').extract_first().strip('\\n ')\n        scores = xpath_aside.xpath('//div[@class=\"mc\"]/div/'\n                                   'a//text()').extract()\n        scores = [s for s in scores if s.strip('\\n ')][::2]\n\n        sd = ShoeDetailItem(iid=iid, name=name, shop=shop,\n                            scores='|'.join(scores))\n        yield sd\n\n    def parse_comment(self, response):\n        iid = response.meta['iid']\n        page = int(response.meta['page'])\n        retry = int(response.meta['retry'])\n        try:\n            json_data = json.loads(response.text)\n        except Exception as e:\n            if retry < 10:\n                yield Request(\n                    comment_url_api.format(iid, page),\n                    callback=self.parse_comment,\n                    meta={'page': page, 'iid': iid, 'retry': retry+1})\n            return\n\n        if not json_data['comments']:\n            return\n        for cd in json_data['comments']:\n            d = {}\n            d['_id'] = cd['id']\n            d['iid'] = cd['referenceId']\n            d['uid'] = cd['guid']\n            d['creation_time'] = cd['creationTime']\n            d['score'] = cd['score']\n            d['user_province'] = cd['userProvince']\n            d['user_level'] = cd['userLevelName']\n            d['color'] = cd['productColor']\n            d['size'] = cd['productSize']\n            sc = ShoeCommentItem(d)\n            yield sc\n        yield Request(\n            comment_url_api.format(iid, page+1),\n            callback=self.parse_comment,\n            meta={'page': page+1, 'iid': iid, 'retry': 0})\n```\n\n详细分析下这段代码:\n* 类`ShoesSpider`继承自`Spider`，其余可继承的类还有`CrawlSpider`、`XMLFeedSpider`、`SitemapSpider`，在这里我们使用了最基本的`Spider`。\n* 属性`name`定义了该爬虫的名字，在启动爬虫的步骤中需要提供爬虫名字。\n* 属性`allowed_domains`定义了一个列表，可以包含一个或多个域名，爬虫只会对该域名下的链接进行爬取。\n* 属性`start_urls`定义了一个列表，spider启动时将从中获取链接进行爬取。\n* 实例方法`parse`定义了对商品列表页面进行处理的相关逻辑:\n\t* 接收一个`response`参数，该`response`对象为爬虫根据`Request`对象请求获得的结果。\n\t* 根据前面几节的描述，`parse`方法针对商品列表页面使用xpath进行分析。\n\t* 在提取到商品`iid`后，对该页面下所有商品`iid`进行遍历，分别为商品详细页面(可选)以及商品评论页面构建`Request`请求，注意使用了`yield`，因为我们需要返回多个请求而不是一个请求。\n\t* 对每个`Request`请求，我们指定了相关参数，比如链接、回调函数，以及通过`meta`关键字保存上下文信息字典，这可以在回调函数中访问`Response`的`meta`属性获得。\n* 实例方法`parse_detail`定义了对商品详细页面进行处理的相关逻辑:\n\t* 我们依然通过xpath进行分析，获得了商品名、商家名、商家评分等信息，使用其实例化`ShoeDetailItem`类并返回该实例。\n* 实例方法`parse_comment`定义了对商品评论进行处理的相关逻辑:\n\t* 根据在`Request`对象中设置`meta`属性，我们可以很方便地获得当前物品id、当前评论页码、以及访问重试次数。\n\t* 我们需要对`response`对象的`text`属性使用`json.loads`进行格式化，但是由于各种原因可能会失败，所以我们设置了方式重试次数这一变量来控制重试，当本次`json.loads`格式化失败，我们会再次进行尝试访问该评论链接，直到达到最大重试次数10次，然后放弃。\n\t* 如果解析成功，判断解析后的字典中键`comments`所对应的内容是否为空，为空代表已经没有更多评论，则返回。\n\t* 否则，对每条评论进行遍历，使用其中的参数实例化`ShoeCommentItem`类并返回该实例。\n\t* 在结束评论遍历后，尝试对评论下一页发出`Request`请求。\n\n至此，我们完成了爬虫的工作逻辑，接下来需要对流水线进行定义，完成数据的查重以及保存等操作。\n\n#### 定义pipeline流水线\n\n对于各个`parse`方法返回的`Item`对象，它们将会被传递到在`pipelines.py`中定义以及`settings.py`中启用的流水线中进行处理。\n在本文中我们需要对每个`Item`对象做两件事，去重以及保存。对于`ShoeCommentItem`的流水线定义如下:\n\n\n```Python\nclass ShoeCommentPipeline(object):\n    seen_ids = set()\n\n    @classmethod\n    def from_crawler(cls, crawler):\n        pipe = cls()\n        if not os.path.exists('shoe_comments.csv'):\n            return pipe\n        pat = re.compile('^\\d+?,')\n        with open('shoe_comments.csv', 'r') as f:\n            for line in f:\n                _id = pat.findall(line)\n                if _id:\n                    pipe.seen_ids.add(_id[0])\n        return pipe\n\n    def process_item(self, item, spider):\n        if not isinstance(item, ShoeCommentItem):\n            return item\n\n        _id = item['_id']\n        if _id in self.seen_ids:\n            raise DropItem('{} Have been processed.'.format(_id))\n        self.seen_ids.add(_id)\n\n        key_values = list(item.items())\n        key_values.sort(key=lambda x: val_indices[x[0]])\n        values = [str(val) for key, val in key_values]\n        with open('shoe_comments.csv', 'a') as f:\n            f.write(','.join(values)+'\\n')\n        return item\n```\n\n需要解释的是类方法`from_crawler`和实例方法`process_item`，前者在初始化时会被调用，后者在出现`Item`对象时被调用。\n对于`from_crawler`方法:\n* 我们需要忽略之前已经处理过的评论，因此采用了一个`set`来存储已经处理过的`id`\n* 在初始化时，打开之前保存的评论文件`shoe_comments.csv`，从中获取`id`并对`seen_ids`进行填充\n* 这是一个类方法，需要在最后返回类的实例\n\n对于`process_item`方法:\n* 方法接收两个参数，前一个是返回的`Item`对象，后一个是返回该对象的对应`Spider`对象\n* 首先判断了该`Item`是否是类`ShoeCommentItem`实例，如果不是的话不进行处理直接返回该对象\n* 提取该对象的`id`并判断该对象是否已经处理过，已经处理过的话抛出`DropItem`异常，停止后续流水线的处理\n* 将该对象`id`加入`seen_ids`，并根据`val_indices`定义的顺序将其排序及格式化字符串并追加到`shoe_comments.csv`中\n* 返回该对象\n\n> 需要特别注意的是，`process_item`方法必须返回一个`Item`(或任何继承类)对象或者是抛出`DropItem`异常，被丢弃的item将不会被之后的pipeline组件所处理，而正常返回的会。\n\n同理我们可以定义`ShoeDetailItem`的流水线:\n\n```Python\nclass ShoeDetailPipeline(object):\n    seen_ids = set()\n\n    @classmethod\n    def from_crawler(cls, crawler):\n        pipe = cls()\n        if not os.path.exists('shoe_details.csv'):\n            return pipe\n        pat = re.compile('^\\d+?,')\n        with open('shoe_details.csv', 'r') as f:\n            for line in f:\n                iid = pat.findall(line)\n                if iid:\n                    pipe.seen_ids.add(iid[0])\n        return pipe\n\n    def process_item(self, item, spider):\n        if not isinstance(item, ShoeDetailItem):\n            return item\n\n        iid = item['iid']\n        if iid in self.seen_ids:\n            raise DropItem('{} detail have been processed.'.format(iid))\n        self.seen_ids.add(iid)\n\n        key_values = list(item.items())\n        key_values.sort(key=lambda x: detail_indices[x[0]])\n        values = [str(val) for key, val in key_values]\n        with open('shoe_details.csv', 'a') as f:\n            f.write(','.join(values)+'\\n')\n        return item\n```\n\n该流水线逻辑与前一个类似，在此不再赘述。\n\n#### settings.py的配置\n\n我们还需要对`settings.py`进行配置。\n其中关键的几个设置是:\n* CONCURRENT_REQUESTS(并发请求数): 100\n* COOKIES_ENABLED(启用cookies): False\n* ITEM_PIPELINES(item流水线): {'jd.pipelines.ShoeCommentPipeline': 300, 'jd.pipelines.ShoeDetailPipeline': 301}\n\n具体设置可以根据自己的需求进行设置，以上只是一个示例。\n\n#### 启动\n\n最后，让我们启动这个爬虫:\n\n```\n$ scrapy crawl shoes\n```\n\n可以在控制台看到输出:\n\n```\n2017-03-13 19:21:12 [scrapy.utils.log] INFO: Scrapy 1.3.0 started (bot: jd)\n2017-03-13 19:21:12 [scrapy.utils.log] INFO: Overridden settings: {'BOT_NAME': 'jd', 'CONCURRENT_REQUESTS': 100, 'COOKIES_ENABLED': False, 'DOWNLOAD_DELAY': 0.01, 'NEWSPIDER_MODULE': 'jd.spiders', 'SPIDER_MODULES': ['jd.spiders']}\n2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled extensions:\n['scrapy.extensions.corestats.CoreStats',\n 'scrapy.extensions.telnet.TelnetConsole',\n 'scrapy.extensions.logstats.LogStats']\n2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled downloader middlewares:\n['scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware',\n 'scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware',\n 'scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware',\n 'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware',\n 'jd.middlewares.RandomUserAgentMiddleware',\n 'jd.middlewares.ProxyMiddleware',\n 'scrapy.downloadermiddlewares.retry.RetryMiddleware',\n 'scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware',\n 'scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware',\n 'scrapy.downloadermiddlewares.redirect.RedirectMiddleware',\n 'scrapy.downloadermiddlewares.stats.DownloaderStats']\n2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled spider middlewares:\n['scrapy.spidermiddlewares.httperror.HttpErrorMiddleware',\n 'scrapy.spidermiddlewares.offsite.OffsiteMiddleware',\n 'scrapy.spidermiddlewares.referer.RefererMiddleware',\n 'scrapy.spidermiddlewares.urllength.UrlLengthMiddleware',\n 'scrapy.spidermiddlewares.depth.DepthMiddleware']\n2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled item pipelines:\n['jd.pipelines.ShoeCommentPipeline', 'jd.pipelines.ShoeDetailPipeline']\n2017-03-13 19:21:12 [scrapy.core.engine] INFO: Spider opened\n2017-03-13 19:21:12 [scrapy.extensions.logstats] INFO: Crawled 0 pages (at 0 pages/min), scraped 0 items (at 0 items/min)\n2017-03-13 19:21:12 [scrapy.extensions.telnet] DEBUG: Telnet console listening on 127.0.0.1:6023\n2017-03-13 19:21:13 [scrapy.core.engine] DEBUG: Crawled (200) <GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=3> (referer: None)\n2017-03-13 19:21:13 [scrapy.core.engine] DEBUG: Crawled (200) <GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=7> (referer: None)\n2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) <GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=6> (referer: None)\n2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) <GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=9> (referer: None)\n2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) <GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=5> (referer: None)\n2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) <GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=10> (referer: None)\n2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) <GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=2> (referer: None)\n2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) <GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=1> (referer: None)\n2017-03-13 19:21:16 [scrapy.dupefilters] DEBUG: Filtered duplicate request: <GET http://item.jd.com/10536835318.html> - no more duplicates will be shown (see DUPEFILTER_DEBUG to show all duplicates)\n2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) <GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=8> (referer: None)\n2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://item.jd.com/10536835318.html> (referer: https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=6)\n2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) <GET https://club.jd.com/comment/productPageComments.action?productId=10589923020&score=0&sortType=5&page=1&pageSize=10&isShadowSku=0> (referer: https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=7)\n2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from <200 http://item.jd.com/10536835318.html>\n{'iid': 10536835318,\n 'name': '她芙 单鞋女2017春季新款中跟短靴女时尚女鞋性感尖头细跟单鞋深口裸靴防水台高跟鞋 黑色 37-标准码',\n 'scores': '9.72|9.75|9.65|9.63',\n 'shop': '卡曼鞋类专营店'}\n2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from <200 https://club.jd.com/comment/productPageComments.action?productId=10589923020&score=0&sortType=5&page=1&pageSize=10&isShadowSku=0>\n{'_id': 10199823376,\n 'color': '金黑色.',\n 'creation_time': '2017-03-10 13:59:31',\n 'iid': '10589923020',\n 'score': 5,\n 'size': '36',\n 'uid': '069d0baa-022b-421b-a43a-584f5aa3921e',\n 'user_level': '铜牌会员',\n 'user_province': ''}\n2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from <200 https://club.jd.com/comment/productPageComments.action?productId=10589923020&score=0&sortType=5&page=1&pageSize=10&isShadowSku=0>\n{'_id': 10175008135,\n 'color': '金黑色.',\n 'creation_time': '2017-03-02 12:18:57',\n 'iid': '10589923020',\n 'score': 5,\n 'size': '36',\n 'uid': '28dfd6c2-caf2-427d-9927-cf088d3099ea',\n 'user_level': '铜牌会员',\n 'user_province': '湖南'}\n2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from <200 https://club.jd.com/comment/productPageComments.action?productId=10589923020&score=0&sortType=5&page=1&pageSize=10&isShadowSku=0>\n{'_id': 10163486837,\n 'color': '金黑色.',\n 'creation_time': '2017-02-26 15:28:14',\n 'iid': '10589923020',\n 'score': 5,\n 'size': '36',\n 'uid': '736ad5a4-9470-4dcc-832d-b59094cf84f4',\n 'user_level': '铜牌会员',\n 'user_province': '云南'}\n ```\n\n在运行一段时间后，查看`shoe_comments.csv`和`shoe_details.csv`内容:\n\n* `shoe_comments.csv`\n```\n10199823376,10589923020,069d0baa-022b-421b-a43a-584f5aa3921e,2017-03-10 13:59:31,5,,铜牌会员,金黑色.,36\n10175008135,10589923020,28dfd6c2-caf2-427d-9927-cf088d3099ea,2017-03-02 12:18:57,5,湖南,铜牌会员,金黑色.,36\n10163486837,10589923020,736ad5a4-9470-4dcc-832d-b59094cf84f4,2017-02-26 15:28:14,5,云南,铜牌会员,金黑色.,36\n10205838152,10589923020,93f35818-129f-4aaa-8ea9-549c28a4f791,2017-03-12 14:37:59,5,,注册会员,金黑色.,36\n10175298549,10589923020,fe1a26e0-8cae-43c3-b0d4-c99bf1d961cf,2017-03-02 13:49:07,5,,铜牌会员,金黑色.,36\n10205858068,10589923020,65a7243e-7116-4075-b64a-6e8d8d8382a4,2017-03-12 14:44:29,5,,铜牌会员,金黑色.,36\n10206280836,10589923020,1d9b5332-5ca6-40be-b408-250606f68c17,2017-03-12 17:00:48,5,,注册会员,金黑色.,36\n10200243913,10589923020,966cda26-ce10-432a-8309-95199ad1903e,2017-03-10 16:15:02,5,,铜牌会员,金黑色.,36\n10164313667,10589923020,d09eab89-ed53-47a3-abd1-c897a8bcf694,2017-02-26 20:15:01,5,北京,铜牌会员,金黑色.,36\n10162862191,10589923020,ddb58374-f48b-45f9-a2a6-e5e60d53d4ce,2017-02-26 11:42:58,5,,铜牌会员,金黑色.,36\n10149921178,11242420873,5f410ce9-fc38-4736-8465-88bbdd7da347,2017-02-21 19:45:56,5,上海,铜牌会员,70060黑色,36\n10143787582,11242420873,3f15f14f-1d37-4ccb-befa-9acccd22a3d1,2017-02-19 19:07:20,5,海南,铜牌会员,70060黑色,36\n10150729539,11242420873,a601a457-1cef-41c4-955b-3df3dd2646ec,2017-02-22 07:32:52,5,新疆,铜牌会员,70060黑色,36\n10147517331,11242420873,b50e1e32-e1fe-4084-b95a-71be8a720950,2017-02-20 23:29:52,5,北京,铜牌会员,70060黑色,36\n10147357719,11242420873,fe6ec9de-c39b-4d5e-9cee-bf5926abb465,2017-02-20 22:18:46,5,湖南,铜牌会员,70060黑色,36\n10187242860,11242420873,f12f02f7-b378-457f-a501-cdd81f69de6c,2017-03-06 13:53:31,5,云南,铜牌会员,70060黑色,36\n10203999129,11242420873,f61e40df-f919-43a2-b876-e81176d59cf9,2017-03-11 20:55:40,5,内蒙古,注册会员,70060黑色,36\n10203827884,11242420873,4a73b3d7-b489-4880-8f8a-bc70015c4e18,2017-03-11 19:55:57,5,浙江,注册会员,70060黑色,36\n10203810598,11242420873,4113c7e0-4556-4aa1-b441-2334bd5419d4,2017-03-11 19:49:51,5,安徽,注册会员,70060黑色,36\n10203802320,11242420873,38a65bba-5284-4190-83f2-1a6a54d57da3,2017-03-11 19:46:57,5,广西,注册会员,70060黑色,36\n```\n\n* `shoe_details.csv`\n```\n10536835318,她芙 单鞋女2017春季新款中跟短靴女时尚女鞋性感尖头细跟单鞋深口裸靴防水台高跟鞋 黑色 37-标准码,卡曼鞋类专营店,9.72|9.75|9.65|9.63\n1587186408,雅诗莱雅休闲鞋女 圆头深口低帮鞋 拼色厚底女鞋 系带防水台女鞋子 GH852Q0红色 37,宏嘉男鞋专营店,9.79|9.80|9.74|9.76\n10536835318,她芙 单鞋女2017春季新款中跟短靴女时尚女鞋性感尖头细跟单鞋深口裸靴防水台高跟鞋 黑色 37-标准码,卡曼鞋类专营店,9.72|9.75|9.65|9.63\n11242420873,百芙蓉单鞋女中跟2017春季新款粗跟英伦风小皮鞋女春季新款圆头深口妈妈工作韩版潮厚底 70060黑色 36,百芙蓉鞋类旗舰店,9.88|9.81|9.83|9.84\n11157498264,圆头深口低帮鞋2017年秋冬新款纯色系带坡跟女鞋防水台女鞋子 1343黑色 36,马登尔鞋靴专营店,9.78|9.81|9.75|9.76\n10638093860,爱思图牛津鞋英伦风皮鞋女中跟秋季女鞋粗跟单鞋大头皮鞋圆头学生鞋小皮鞋平底鞋潮妈妈鞋女生鞋子 黑色ML6X303 36,爱思图旗舰店,9.72|9.76|9.71|9.70\n10574081025,佩尼泰深口单鞋女头层牛皮尖头单鞋中跟粗跟 OL工作职业鞋大小码女鞋春季新款 灰色 38,佩尼泰旗舰店,9.68|9.73|9.67|9.66\n10459020322,瑞蓓妮真皮女鞋2017新款魔术贴深口单鞋女平底舒适休闲鞋大码防滑中老年妈妈鞋 黑色单鞋 38,瑞蓓妮旗舰店,9.70|9.75|9.65|9.65\n11273711543,细跟高跟鞋女2017春季新款尖头单鞋女深口高跟女士英伦厚底防水台工作女鞋 红色 37,家兴福鞋业专营店,9.87|9.82|9.80|9.81\n11226902308,粗跟单鞋女2017春季新款女鞋OL尖头高跟鞋深口工作鞋女士皮鞋水钻百搭鞋子女 DH3658黑色 37,彬度鸟鞋靴旗舰店,9.89|9.83|9.83|9.84\n11210447351,她芙 单鞋女2017春季新款单鞋粗跟女鞋子系带厚底高跟鞋深口学生休闲低帮鞋 绿色 37,她芙旗舰店,9.77|9.77|9.67|9.68\n11239261516,AUSDU休闲鞋女圆头平底深口单鞋粗跟厚底2017春款韩版百搭舒适女鞋妈妈绑带学生 70030黑色 36,AUSDU鞋类旗舰店,9.87|9.80|9.81|9.82\n11267204558,丹芭莎春季女鞋2017新品纯色深口鞋女韩版圆头高跟鞋粗跟防水台单鞋女潮鞋 M70050黑色 37,丹芭莎旗舰店,9.84|9.81|9.79|9.80\n10687936751,fullmir内增高休闲鞋女士小白鞋2016秋季新款厚底鞋韩版潮流低帮学生运动鞋子单鞋 红 色 37,fullmir鞋类旗舰店,9.61|9.66|9.58|9.58\n11167186789,新款单鞋女2017秋季时尚漆皮圆头低帮休闲鞋秋鞋 工作鞋套脚欧美低跟皮鞋 黑色6119 34,艾琳艺鞋类专营店,9.67|9.79|9.67|9.69\n11227438800,意米思时尚女鞋圆头高跟鞋粗跟妈妈鞋深口单鞋女2017春秋新款韩版百搭小皮鞋防水台鞋子女 莫70050黑色 36,意米思旗舰店,9.72|9.81|9.79|9.80\n11250120847,邻家天使细跟单鞋2017春季新款尖头欧美皮鞋深口高跟女鞋春秋款鞋子 LJ619黑色 39标码,邻家天使鞋类旗舰店,9.69|9.74|9.65|9.66\n11193717829,单鞋女2017春季新款韩版高跟防水台粗跟女鞋尖头深口水钻通勤OL工作小皮鞋女 邻1231黑色 37,NEB ANGEL梓赢专卖店,9.78|9.78|9.74|9.75\n11166169416,金丝兔尖头单鞋女2017春季新品深口金属超高跟鞋欧美时尚细跟女鞋百搭小皮鞋工作鞋 黑色 36,金丝兔广汇达专卖店,9.89|9.83|9.83|9.84\n10617152040,ZHR小皮鞋真皮小白鞋女深口单鞋平底护士工作鞋潮 白色 39,零邦鞋靴专营店,9.69|9.68|9.69|9.69\n1471841136,宝思特2017春季新款真皮平底平跟休闲女单鞋软牛皮软底妈妈鞋花朵跳舞鞋加大码女鞋子 黑色 39,宝思特旗舰店,9.75|9.74|9.65|9.65\n11204372265,霍尔世家 深口单鞋女粗跟高跟鞋2017春季新款英伦风真皮尖头女鞋防水台 黑色 37,霍尔世家旗舰店,9.64|9.70|9.63|9.64\n```\n\n至此，我们完成了整个数据的爬取工作。\n\n# 接下来的工作\n\n有经验的读者可以看出来，本文完成的爬虫是较为基础的爬虫，不涉及到Scrapy高级的特性，也不涉及到反爬虫的内容，对于感兴趣的读者，可以从以下几个方面继续深入。\n1. 由于京东对爬虫爬取评论并没有反爬措施，所以本文没有涉及到反爬的内容，不过在编写该爬虫的时候有考虑到这部分内容，所以编写了中间件来完成`User-Agent`的随机设置以及使用代理池来分散请求等简单的反爬措施，有兴趣的读者可以查阅Github源代码。\n2. 对于较大的爬取工作，可以考虑使用`scrapy-redis`等工具来构建分布式爬虫，以增加爬取效率。\n3. 在获得大量的数据之后，可以使用`matplotlib`等工具对数据进行可视化分析。\n\n以上就是本文的全部内容，有兴趣的读者可以查阅Github并下载源码，该项目地址: [https://github.com/Time1ess/MyCodes/tree/master/scrapy/jd](https://github.com/Time1ess/MyCodes/tree/master/scrapy/jd)","source":"_posts/Python-A-JD-spider-based-on-scrapy.md","raw":"---\ntitle: 基于Scrapy的京东商品评论爬虫\ndate: 2017-03-12 22:07:57\ntags: [Python,爬虫,Scrapy]\ncategories: Python\n---\n今天想跟大家分享的是关于网络爬虫的相关知识，网络爬虫是一种根据一定的规则，自动地对互联网上相关内容进行抓取的程序或者脚本，本文的内容主要是通过分析京东评论的加载过程，获取相关API，然后通过使用基于Python语言的开源网络爬虫框架——Scrapy，大量获取相关评论内容。\n\n<div class=\"tip\">\n本文假定读者具有一定的Python编程经验，具有少量HTTP协议和HTML的相关知识，对爬虫的工作原理有一定了解。\n</div>\n\n<!-- more -->\n\n# API获取\n\n在开始编写爬虫之前，我们需要获得启动爬虫所需要的相关链接。在本文，我们将以对京东鞋类评论爬取为例，进行说明(其他种类爬取流程类似，区别只在于数据处理)。\n首先打开京东，搜索“鞋”，打开任意一件商品，并切换到“商品评价”标签页，如图所示。\n\n![comments_tab](item_shoe_comments_tab.png)\n\n启用浏览器的网页分析功能，以Safari浏览器为例，右键点击网页任意部分，选择”检查元素“，切换到“网络”标签下，如果有其他内容的话，可以点击右侧的垃圾桶图标清空历史，如图所示。\n\n![console_network_before](console_network_before.png)\n\n然后我们点击评论区的换页按钮，切换到任意一页新的评论，此时可以发现浏览器对本次点击产生的数据交换过程进行了记录，我们发现其中有一条名为\"productPageComments.action\"的记录，对其进行分析可以看到对应的完整URL，如图所示。\n\n![console_network_after](console_network_after.png)\n\n其完整URL为:`https://club.jd.com/comment/productPageComments.action?callback=fetchJSON_comment98vv6630&productId=10353518575&score=0&sortType=5&page=1&pageSize=10&isShadowSku=0`\n\n显而易见，评论的加载是通过GET请求实现，对我们来说，该URL中最关键的GET参数为`productID`和`page`，它们分别定义了对应的商品编号以及评论页码。通过访问该URL，我们可以得到内容如图所示。\n\n![comments_json_1](comments_json_1.png)\n\n可以看到，该URL返回的内容为json数据包，同时以请求中`callback`定义的函数名对其进行包裹，这一点从整个数据包最前方可以看出。我们将GET请求中callback参数去掉以后即可得到原始的json数据包，如图所示。\n\n![comments_json_2](comments_json_2.png)\n\n因此，在不考虑其他参数的情况下，我们需要的API格式为:`https://club.jd.com/comment/productPageComments.action?productId={}&score=0&sortType=5&page={}&pageSize=10&isShadowSku=0`\n\n\n至此，我们获得了返回任意商品的任意评论页的API，下面我们将对API返回数据本身的内容进行分析。\n\n# API返回字典分析\n\n从前面图中可以看出，API返回数据应该是一个字典，我们通过使用requests获得API返回字典以及Python的json模块进行分析。\n\n```Python\n>>> import requests\n>>> import json\n>>> url = 'https://club.jd.com/comment/productPageComments.action?productId=10353518575&score=0&sortType=5&page=1&pageSize=10&isShadowSku=0'\n>>> html = requests.get(url)\n>>> data = json.loads(html.text)\n>>> print(data.keys())\ndict_keys(['productAttr', 'productCommentSummary', 'hotCommentTagStatistics',\n'jwotestProduct', 'maxPage', 'score', 'soType', 'imageListCount',\n'vTagStatistics', 'comments'])\n```\n\n其中对我们来说最重要的是键`comments`所对应的值，值为一个列表，其中每个元素为一个字典，存放的是每一条评论的相关信息。\n\n```Python\n>>> print(type(data['comments']))\n<class 'list'>\n>>> import pprint\n>>> pprint(data['comments'][0])\n{'afterDays': 0,\n 'anonymousFlag': 1,\n 'commentTags': [{'commentId': 1927838458,\n                  'created': '2016-10-19 18:26:50',\n                  'id': 12373951,\n                  'modified': '2016-10-19 18:26:50',\n                  'name': '穿上很舒服',\n                  'pin': '',\n                  'productId': 10353518575,\n                  'rid': 11632,\n                  'status': 0}],\n 'content': '鞋子很不错，弹性很不错，材质很轻。穿上很舒服。透气性好，而且又长高了两厘米。',\n 'creationTime': '2016-10-19 18:26:20',\n 'days': 8,\n 'firstCategory': 1318,\n 'guid': 'cc2fec79-304b-48c5-a263-151bf7d098d2',\n 'id': 1927838458,\n 'integral': -20,\n 'isMobile': False,\n 'isReplyGrade': False,\n 'isTop': False,\n 'nickname': 'j***k',\n 'orderId': 0,\n 'plusAvailable': 0,\n 'productColor': '黑/安踏白',\n 'productSales': [],\n 'productSize': '8(男41)',\n 'recommend': True,\n 'referenceId': '10353518575',\n 'referenceImage': 'jfs/t3073/150/7342609081/176958/b211c3f7/58b4c73cN9621804d.jpg',\n 'referenceName': '安踏男鞋 易弯折科技跑步鞋 2017新款透气网面运动鞋 黑/安踏白-1 8(男41)',\n 'referenceTime': '2016-10-11 20:03:00',\n 'referenceType': 'Product',\n 'referenceTypeId': 0,\n 'replyCount': 0,\n 'score': 5,\n 'secondCategory': 12099,\n 'status': 1,\n 'thirdCategory': 9756,\n 'title': '',\n 'usefulVoteCount': 1,\n 'uselessVoteCount': 0,\n 'userClient': 0,\n 'userClientShow': '',\n 'userImage': 'misc.360buyimg.com/lib/img/u/b56.gif',\n 'userImageUrl': 'misc.360buyimg.com/lib/img/u/b56.gif',\n 'userImgFlag': 0,\n 'userLevelColor': '#666666',\n 'userLevelId': '56',\n 'userLevelName': '铜牌会员',\n 'userProvince': '',\n 'viewCount': 0}\n```\n\n根据实际需要，在本次实现中选取了以下信息:\n\n* guid\t\t\t\t--> 评论用户id\n* id\t\t\t\t--> 该评论id\n* referenceId\t\t--> 评论商品id\n* creationTime\t--> 评论时间\n* score\t\t\t--> 评论评分\n* userProvince\t--> 评论用户归属地\n* userLevelName\t--> 评论用户会员级别\n* productColor\t--> 评论用户购买颜色\n* productSize\t\t--> 评论用户购买尺寸\n\n至此，我们完成了对API返回字典的分析，在构建Scrapy爬虫之前，我们还需要对商品列表进行分析。\n\n# 商品列表分析\n\n我们已经拥有对任意给定的商品id,获取其所有评论的API，但在构建爬虫之前，我们还有最后一个问题，如何获得商品id?\n我们可以很容易的获得并格式化京东的搜索链接:`https://search.jd.com/Search?keyword={}&enc=utf-8&page={}`，根据该格式化链接，我们只需要填写搜索关键字以及搜索页码就能得到对应页的搜索结果。通过对网页源代码进行分析，可以发现每个商品都处于`class=\"gl-item\"`的`li`元素下，如图所示。\n\n![console_item_list](console_item_list.png)\n![console_item_list_2](console_item_list_2.png)\n\n我们只需要对`class=\"gl-item\"`的`li`元素下`class=\"p-img\"`的`div`元素下的`a`元素的`href`属性进行提取处理即可得到商品id，如图中的`10353518575`。\n\n至此，我们完成了对商品列表的分析工作，接下来我们将构建基于Scrapy的爬虫来完成对评论的爬取工作。\n\n# (可选)商品详细信息\n\n我们在上节中获得了商品的详细信息链接，如:`https://item.jd.com/10353518575.html`，我们可以对该页面内容进行爬取以获得更全面的商品信息。在这部分需要注意的是，很多内容是通过JavaScript进行动态加载的，在爬取时需要注意，否则得到的数据并不符合需要。通过启用浏览器的“停用JavaScript\"功能，可以看到在不执行JavaScript时的页面是什么样的，如图所示。\n\n![item_detail_no_js](item_detail_no_js.png)\n\n可以看到，商品的价格等信息是没有进行加载的，所以如果需要对价格进行爬取，需要使用到selenium等工具来完成浏览器的模拟或者进一步分析JavaScript的执行逻辑。\n\n# Scrapy爬虫\n\nScrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。其最初是为了网络抓取所设计的，也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。\n\n要使用Scrapy，首先得建立项目:\n\n```\n$ scrapy startproject jd\nNew Scrapy project 'jd', using template directory '/usr/local/lib/python3.6/site-packages/scrapy/templates/project', created in:\n    /private/tmp/jd\n\nYou can start your first spider with:\n    cd jd\n    scrapy genspider example example.com\n```\n\n在建好的`jd`文件夹下，有一个`jd`文件夹以及一个`scrapy.cfg`文件，进入前者，可以看到以下内容:\n\n```\n$ ls\n__init__.py    items.py       pipelines.py   spiders\n__pycache__    middlewares.py settings.py\n```\n\n其中:\n\n* items.py \t\t--> 完成数据容器Item的定义\n\t爬取的主要目标就是从非结构性的数据源提取结构性数据，例如网页。Scrapy提供 Item 类来满足这样的需求。Item 对象是种简单的容器，保存了爬取到得数据。 其提供了 类似于词典(dictionary-like) 的API以及用于声明可用字段的简单语法。\n* pipelines.py\t--> 完成对Item处理流水线的定义\n\t当Item在Spider中被收集之后，它将会被传递到Item Pipeline，一些组件会按照一定的顺序执行对Item的处理。每个item pipeline组件(有时称之为“Item Pipeline”)是实现了简单方法的Python类。他们接收到Item并通过它执行一些行为，同时也决定此Item是否继续通过pipeline，或是被丢弃而不再进行处理。\n\t以下是item pipeline的一些典型应用：\n\t* 清理HTML数据\n\t* 验证爬取的数据(检查item包含某些字段)\n\t* 查重(并丢弃)\n\t* 将爬取结果保存到数据库中\n* middlewares.py\t--> 完成Spider中间件的定义\n\tSpider中间件是介入到Scrapy的spider处理机制的钩子框架，通过定义并使用中间件，可以对发送给Spiders的response以及Spiders产生的Request对象进行处理。\n* settings.py\t\t--> 完成对爬虫的控制\n\tScrapy settings提供了定制Scrapy组件的方法。通过修改settings.py，可以控制包括核心(core)，插件(extension)，pipeline及spider组件。settings为代码提供了提取以key-value映射的配置值的的全局命名空间(namespace)。settings同时也是选择当前激活的Scrapy项目的方法。\n* spiders\t\t\t--> 完成对爬虫Spider的定义\n\tSpider类定义了如何爬取某个(或某些)网站。包括了爬取的动作(例如:是否跟进链接)以及如何从网页的内容中提取结构化数据(爬取item)。换句话说，Spider就是定义爬取的动作及分析某个网页(或者是有些网页)的地方。\n\n#### 定义数据容器items\n```Python\nimport scrapy\n\n\nclass ShoeCommentItem(scrapy.Item):\n    # define the fields for your item here like:\n    # name = scrapy.Field()\n    _id = scrapy.Field()\n    iid = scrapy.Field()\n    uid = scrapy.Field()\n    creation_time = scrapy.Field()\n    score = scrapy.Field()\n    user_province = scrapy.Field()\n    user_level = scrapy.Field()\n    color = scrapy.Field()\n    size = scrapy.Field()\n\nclass ShoeDetailItem(scrapy.Item):\n    iid = scrapy.Field()\n    name = scrapy.Field()\n    shop = scrapy.Field()\n    scores = scrapy.Field()\n```\n\n#### 定义爬虫类\n\n创建爬虫类的命令为:`scrapy genspider [爬虫名] [允许爬取域名]`\n\n```\n$ scrapy genspider shoes jd.com\nCreated spider 'shoes' using template 'basic' in module:\n  jd.spiders.shoes\n```\n\n接着打开`spiders`文件夹下的`shoes.py`文件进行编辑:\n* 首先我们需要定义一些变量，比如包含搜索关键字的列表、格式化搜索链接、格式化评论API链接等:\n```Python\nshoe_cates = [\n    '女深口单鞋', '工装鞋', '女鞋', '正装鞋', '平底鞋', '平底女鞋',\n    '功能鞋', '中跟单鞋', '女拖鞋', '凉鞋', '拖鞋', '帆布鞋', '人字拖',\n    '马丁靴', '商务休闲鞋', '传统布鞋', '休闲鞋', '鞋', '棉鞋', '定制鞋',\n    '男靴', '坡跟单鞋', '短靴', '雨鞋', '平板鞋', '尖头单鞋', '军靴', '女靴',\n    '皮鞋', '小白鞋', '雪地靴', '女豆豆鞋', '妈妈鞋', '增高鞋', '劳保鞋',\n    '豆豆鞋', '踝靴', '沙滩鞋', '鞋 女', '深口单鞋', '板鞋', '高帮鞋',\n    '人字拖鞋', '内增高', '发光鞋', '运动鞋', '高跟鞋', '雨靴', '鞋 男',\n    '乐福鞋', '内增高休闲鞋', '老人鞋', '男鞋', '平底单鞋', '浅口单鞋', '单鞋']\nshoe_list_url = 'https://search.jd.com/Search?keyword={}&enc=utf-8&page={}'\ncomment_url_api = ('https://club.jd.com/comment/productPageComments.action?'\n    'productId={}&score=0&sortType=5&page={}&pageSize=10&isShadowSku=0')\nnum_pat = re.compile('(\\d*?)')\n```\n\n* 然后编辑`ShoesSpider`类:\n```Python\nclass ShoesSpider(Spider):\n    name = 'shoes'\n    allowed_domains = ['jd.com']\n    start_urls = [shoe_list_url.format(cate, page) for cate in shoe_cates\n                  for page in range(1, 101)]\n\n    def parse(self, response):\n        item_urls = response.xpath('//li[@class=\"gl-item\"]/div')\n        for item_xpath in item_urls:\n            url = item_xpath.xpath('div[@class=\"p-img\"]/a'\n                                   '/@href').extract_first()\n            if not url or 'ccc-x' in url:\n                continue\n            iid = url[url.rfind('/')+1:-5]\n            detail_url = 'http:' + url\n            yield Request(\n                detail_url,\n                callback=self.parse_detail,\n                meta={'iid': iid})\n            yield Request(\n                comment_url_api.format(iid, 1),\n                callback=self.parse_comment,\n                meta={'page': 1, 'iid': iid, 'retry': 0})\n\n    def parse_detail(self, response):\n        iid = int(response.meta['iid'])\n        name = response.xpath('//div[@class=\"sku-name\"]'\n                              '/text()').extract_first().strip('\\n ')\n        xpath_aside = response.xpath('//div[@class=\"aside\"]')\n        shop = xpath_aside.xpath('//div[@class=\"mt\"]/'\n                                 'h3/a/@title').extract_first().strip('\\n ')\n        scores = xpath_aside.xpath('//div[@class=\"mc\"]/div/'\n                                   'a//text()').extract()\n        scores = [s for s in scores if s.strip('\\n ')][::2]\n\n        sd = ShoeDetailItem(iid=iid, name=name, shop=shop,\n                            scores='|'.join(scores))\n        yield sd\n\n    def parse_comment(self, response):\n        iid = response.meta['iid']\n        page = int(response.meta['page'])\n        retry = int(response.meta['retry'])\n        try:\n            json_data = json.loads(response.text)\n        except Exception as e:\n            if retry < 10:\n                yield Request(\n                    comment_url_api.format(iid, page),\n                    callback=self.parse_comment,\n                    meta={'page': page, 'iid': iid, 'retry': retry+1})\n            return\n\n        if not json_data['comments']:\n            return\n        for cd in json_data['comments']:\n            d = {}\n            d['_id'] = cd['id']\n            d['iid'] = cd['referenceId']\n            d['uid'] = cd['guid']\n            d['creation_time'] = cd['creationTime']\n            d['score'] = cd['score']\n            d['user_province'] = cd['userProvince']\n            d['user_level'] = cd['userLevelName']\n            d['color'] = cd['productColor']\n            d['size'] = cd['productSize']\n            sc = ShoeCommentItem(d)\n            yield sc\n        yield Request(\n            comment_url_api.format(iid, page+1),\n            callback=self.parse_comment,\n            meta={'page': page+1, 'iid': iid, 'retry': 0})\n```\n\n详细分析下这段代码:\n* 类`ShoesSpider`继承自`Spider`，其余可继承的类还有`CrawlSpider`、`XMLFeedSpider`、`SitemapSpider`，在这里我们使用了最基本的`Spider`。\n* 属性`name`定义了该爬虫的名字，在启动爬虫的步骤中需要提供爬虫名字。\n* 属性`allowed_domains`定义了一个列表，可以包含一个或多个域名，爬虫只会对该域名下的链接进行爬取。\n* 属性`start_urls`定义了一个列表，spider启动时将从中获取链接进行爬取。\n* 实例方法`parse`定义了对商品列表页面进行处理的相关逻辑:\n\t* 接收一个`response`参数，该`response`对象为爬虫根据`Request`对象请求获得的结果。\n\t* 根据前面几节的描述，`parse`方法针对商品列表页面使用xpath进行分析。\n\t* 在提取到商品`iid`后，对该页面下所有商品`iid`进行遍历，分别为商品详细页面(可选)以及商品评论页面构建`Request`请求，注意使用了`yield`，因为我们需要返回多个请求而不是一个请求。\n\t* 对每个`Request`请求，我们指定了相关参数，比如链接、回调函数，以及通过`meta`关键字保存上下文信息字典，这可以在回调函数中访问`Response`的`meta`属性获得。\n* 实例方法`parse_detail`定义了对商品详细页面进行处理的相关逻辑:\n\t* 我们依然通过xpath进行分析，获得了商品名、商家名、商家评分等信息，使用其实例化`ShoeDetailItem`类并返回该实例。\n* 实例方法`parse_comment`定义了对商品评论进行处理的相关逻辑:\n\t* 根据在`Request`对象中设置`meta`属性，我们可以很方便地获得当前物品id、当前评论页码、以及访问重试次数。\n\t* 我们需要对`response`对象的`text`属性使用`json.loads`进行格式化，但是由于各种原因可能会失败，所以我们设置了方式重试次数这一变量来控制重试，当本次`json.loads`格式化失败，我们会再次进行尝试访问该评论链接，直到达到最大重试次数10次，然后放弃。\n\t* 如果解析成功，判断解析后的字典中键`comments`所对应的内容是否为空，为空代表已经没有更多评论，则返回。\n\t* 否则，对每条评论进行遍历，使用其中的参数实例化`ShoeCommentItem`类并返回该实例。\n\t* 在结束评论遍历后，尝试对评论下一页发出`Request`请求。\n\n至此，我们完成了爬虫的工作逻辑，接下来需要对流水线进行定义，完成数据的查重以及保存等操作。\n\n#### 定义pipeline流水线\n\n对于各个`parse`方法返回的`Item`对象，它们将会被传递到在`pipelines.py`中定义以及`settings.py`中启用的流水线中进行处理。\n在本文中我们需要对每个`Item`对象做两件事，去重以及保存。对于`ShoeCommentItem`的流水线定义如下:\n\n\n```Python\nclass ShoeCommentPipeline(object):\n    seen_ids = set()\n\n    @classmethod\n    def from_crawler(cls, crawler):\n        pipe = cls()\n        if not os.path.exists('shoe_comments.csv'):\n            return pipe\n        pat = re.compile('^\\d+?,')\n        with open('shoe_comments.csv', 'r') as f:\n            for line in f:\n                _id = pat.findall(line)\n                if _id:\n                    pipe.seen_ids.add(_id[0])\n        return pipe\n\n    def process_item(self, item, spider):\n        if not isinstance(item, ShoeCommentItem):\n            return item\n\n        _id = item['_id']\n        if _id in self.seen_ids:\n            raise DropItem('{} Have been processed.'.format(_id))\n        self.seen_ids.add(_id)\n\n        key_values = list(item.items())\n        key_values.sort(key=lambda x: val_indices[x[0]])\n        values = [str(val) for key, val in key_values]\n        with open('shoe_comments.csv', 'a') as f:\n            f.write(','.join(values)+'\\n')\n        return item\n```\n\n需要解释的是类方法`from_crawler`和实例方法`process_item`，前者在初始化时会被调用，后者在出现`Item`对象时被调用。\n对于`from_crawler`方法:\n* 我们需要忽略之前已经处理过的评论，因此采用了一个`set`来存储已经处理过的`id`\n* 在初始化时，打开之前保存的评论文件`shoe_comments.csv`，从中获取`id`并对`seen_ids`进行填充\n* 这是一个类方法，需要在最后返回类的实例\n\n对于`process_item`方法:\n* 方法接收两个参数，前一个是返回的`Item`对象，后一个是返回该对象的对应`Spider`对象\n* 首先判断了该`Item`是否是类`ShoeCommentItem`实例，如果不是的话不进行处理直接返回该对象\n* 提取该对象的`id`并判断该对象是否已经处理过，已经处理过的话抛出`DropItem`异常，停止后续流水线的处理\n* 将该对象`id`加入`seen_ids`，并根据`val_indices`定义的顺序将其排序及格式化字符串并追加到`shoe_comments.csv`中\n* 返回该对象\n\n> 需要特别注意的是，`process_item`方法必须返回一个`Item`(或任何继承类)对象或者是抛出`DropItem`异常，被丢弃的item将不会被之后的pipeline组件所处理，而正常返回的会。\n\n同理我们可以定义`ShoeDetailItem`的流水线:\n\n```Python\nclass ShoeDetailPipeline(object):\n    seen_ids = set()\n\n    @classmethod\n    def from_crawler(cls, crawler):\n        pipe = cls()\n        if not os.path.exists('shoe_details.csv'):\n            return pipe\n        pat = re.compile('^\\d+?,')\n        with open('shoe_details.csv', 'r') as f:\n            for line in f:\n                iid = pat.findall(line)\n                if iid:\n                    pipe.seen_ids.add(iid[0])\n        return pipe\n\n    def process_item(self, item, spider):\n        if not isinstance(item, ShoeDetailItem):\n            return item\n\n        iid = item['iid']\n        if iid in self.seen_ids:\n            raise DropItem('{} detail have been processed.'.format(iid))\n        self.seen_ids.add(iid)\n\n        key_values = list(item.items())\n        key_values.sort(key=lambda x: detail_indices[x[0]])\n        values = [str(val) for key, val in key_values]\n        with open('shoe_details.csv', 'a') as f:\n            f.write(','.join(values)+'\\n')\n        return item\n```\n\n该流水线逻辑与前一个类似，在此不再赘述。\n\n#### settings.py的配置\n\n我们还需要对`settings.py`进行配置。\n其中关键的几个设置是:\n* CONCURRENT_REQUESTS(并发请求数): 100\n* COOKIES_ENABLED(启用cookies): False\n* ITEM_PIPELINES(item流水线): {'jd.pipelines.ShoeCommentPipeline': 300, 'jd.pipelines.ShoeDetailPipeline': 301}\n\n具体设置可以根据自己的需求进行设置，以上只是一个示例。\n\n#### 启动\n\n最后，让我们启动这个爬虫:\n\n```\n$ scrapy crawl shoes\n```\n\n可以在控制台看到输出:\n\n```\n2017-03-13 19:21:12 [scrapy.utils.log] INFO: Scrapy 1.3.0 started (bot: jd)\n2017-03-13 19:21:12 [scrapy.utils.log] INFO: Overridden settings: {'BOT_NAME': 'jd', 'CONCURRENT_REQUESTS': 100, 'COOKIES_ENABLED': False, 'DOWNLOAD_DELAY': 0.01, 'NEWSPIDER_MODULE': 'jd.spiders', 'SPIDER_MODULES': ['jd.spiders']}\n2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled extensions:\n['scrapy.extensions.corestats.CoreStats',\n 'scrapy.extensions.telnet.TelnetConsole',\n 'scrapy.extensions.logstats.LogStats']\n2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled downloader middlewares:\n['scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware',\n 'scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware',\n 'scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware',\n 'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware',\n 'jd.middlewares.RandomUserAgentMiddleware',\n 'jd.middlewares.ProxyMiddleware',\n 'scrapy.downloadermiddlewares.retry.RetryMiddleware',\n 'scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware',\n 'scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware',\n 'scrapy.downloadermiddlewares.redirect.RedirectMiddleware',\n 'scrapy.downloadermiddlewares.stats.DownloaderStats']\n2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled spider middlewares:\n['scrapy.spidermiddlewares.httperror.HttpErrorMiddleware',\n 'scrapy.spidermiddlewares.offsite.OffsiteMiddleware',\n 'scrapy.spidermiddlewares.referer.RefererMiddleware',\n 'scrapy.spidermiddlewares.urllength.UrlLengthMiddleware',\n 'scrapy.spidermiddlewares.depth.DepthMiddleware']\n2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled item pipelines:\n['jd.pipelines.ShoeCommentPipeline', 'jd.pipelines.ShoeDetailPipeline']\n2017-03-13 19:21:12 [scrapy.core.engine] INFO: Spider opened\n2017-03-13 19:21:12 [scrapy.extensions.logstats] INFO: Crawled 0 pages (at 0 pages/min), scraped 0 items (at 0 items/min)\n2017-03-13 19:21:12 [scrapy.extensions.telnet] DEBUG: Telnet console listening on 127.0.0.1:6023\n2017-03-13 19:21:13 [scrapy.core.engine] DEBUG: Crawled (200) <GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=3> (referer: None)\n2017-03-13 19:21:13 [scrapy.core.engine] DEBUG: Crawled (200) <GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=7> (referer: None)\n2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) <GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=6> (referer: None)\n2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) <GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=9> (referer: None)\n2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) <GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=5> (referer: None)\n2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) <GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=10> (referer: None)\n2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) <GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=2> (referer: None)\n2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) <GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=1> (referer: None)\n2017-03-13 19:21:16 [scrapy.dupefilters] DEBUG: Filtered duplicate request: <GET http://item.jd.com/10536835318.html> - no more duplicates will be shown (see DUPEFILTER_DEBUG to show all duplicates)\n2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) <GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=8> (referer: None)\n2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) <GET http://item.jd.com/10536835318.html> (referer: https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=6)\n2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) <GET https://club.jd.com/comment/productPageComments.action?productId=10589923020&score=0&sortType=5&page=1&pageSize=10&isShadowSku=0> (referer: https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&enc=utf-8&page=7)\n2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from <200 http://item.jd.com/10536835318.html>\n{'iid': 10536835318,\n 'name': '她芙 单鞋女2017春季新款中跟短靴女时尚女鞋性感尖头细跟单鞋深口裸靴防水台高跟鞋 黑色 37-标准码',\n 'scores': '9.72|9.75|9.65|9.63',\n 'shop': '卡曼鞋类专营店'}\n2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from <200 https://club.jd.com/comment/productPageComments.action?productId=10589923020&score=0&sortType=5&page=1&pageSize=10&isShadowSku=0>\n{'_id': 10199823376,\n 'color': '金黑色.',\n 'creation_time': '2017-03-10 13:59:31',\n 'iid': '10589923020',\n 'score': 5,\n 'size': '36',\n 'uid': '069d0baa-022b-421b-a43a-584f5aa3921e',\n 'user_level': '铜牌会员',\n 'user_province': ''}\n2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from <200 https://club.jd.com/comment/productPageComments.action?productId=10589923020&score=0&sortType=5&page=1&pageSize=10&isShadowSku=0>\n{'_id': 10175008135,\n 'color': '金黑色.',\n 'creation_time': '2017-03-02 12:18:57',\n 'iid': '10589923020',\n 'score': 5,\n 'size': '36',\n 'uid': '28dfd6c2-caf2-427d-9927-cf088d3099ea',\n 'user_level': '铜牌会员',\n 'user_province': '湖南'}\n2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from <200 https://club.jd.com/comment/productPageComments.action?productId=10589923020&score=0&sortType=5&page=1&pageSize=10&isShadowSku=0>\n{'_id': 10163486837,\n 'color': '金黑色.',\n 'creation_time': '2017-02-26 15:28:14',\n 'iid': '10589923020',\n 'score': 5,\n 'size': '36',\n 'uid': '736ad5a4-9470-4dcc-832d-b59094cf84f4',\n 'user_level': '铜牌会员',\n 'user_province': '云南'}\n ```\n\n在运行一段时间后，查看`shoe_comments.csv`和`shoe_details.csv`内容:\n\n* `shoe_comments.csv`\n```\n10199823376,10589923020,069d0baa-022b-421b-a43a-584f5aa3921e,2017-03-10 13:59:31,5,,铜牌会员,金黑色.,36\n10175008135,10589923020,28dfd6c2-caf2-427d-9927-cf088d3099ea,2017-03-02 12:18:57,5,湖南,铜牌会员,金黑色.,36\n10163486837,10589923020,736ad5a4-9470-4dcc-832d-b59094cf84f4,2017-02-26 15:28:14,5,云南,铜牌会员,金黑色.,36\n10205838152,10589923020,93f35818-129f-4aaa-8ea9-549c28a4f791,2017-03-12 14:37:59,5,,注册会员,金黑色.,36\n10175298549,10589923020,fe1a26e0-8cae-43c3-b0d4-c99bf1d961cf,2017-03-02 13:49:07,5,,铜牌会员,金黑色.,36\n10205858068,10589923020,65a7243e-7116-4075-b64a-6e8d8d8382a4,2017-03-12 14:44:29,5,,铜牌会员,金黑色.,36\n10206280836,10589923020,1d9b5332-5ca6-40be-b408-250606f68c17,2017-03-12 17:00:48,5,,注册会员,金黑色.,36\n10200243913,10589923020,966cda26-ce10-432a-8309-95199ad1903e,2017-03-10 16:15:02,5,,铜牌会员,金黑色.,36\n10164313667,10589923020,d09eab89-ed53-47a3-abd1-c897a8bcf694,2017-02-26 20:15:01,5,北京,铜牌会员,金黑色.,36\n10162862191,10589923020,ddb58374-f48b-45f9-a2a6-e5e60d53d4ce,2017-02-26 11:42:58,5,,铜牌会员,金黑色.,36\n10149921178,11242420873,5f410ce9-fc38-4736-8465-88bbdd7da347,2017-02-21 19:45:56,5,上海,铜牌会员,70060黑色,36\n10143787582,11242420873,3f15f14f-1d37-4ccb-befa-9acccd22a3d1,2017-02-19 19:07:20,5,海南,铜牌会员,70060黑色,36\n10150729539,11242420873,a601a457-1cef-41c4-955b-3df3dd2646ec,2017-02-22 07:32:52,5,新疆,铜牌会员,70060黑色,36\n10147517331,11242420873,b50e1e32-e1fe-4084-b95a-71be8a720950,2017-02-20 23:29:52,5,北京,铜牌会员,70060黑色,36\n10147357719,11242420873,fe6ec9de-c39b-4d5e-9cee-bf5926abb465,2017-02-20 22:18:46,5,湖南,铜牌会员,70060黑色,36\n10187242860,11242420873,f12f02f7-b378-457f-a501-cdd81f69de6c,2017-03-06 13:53:31,5,云南,铜牌会员,70060黑色,36\n10203999129,11242420873,f61e40df-f919-43a2-b876-e81176d59cf9,2017-03-11 20:55:40,5,内蒙古,注册会员,70060黑色,36\n10203827884,11242420873,4a73b3d7-b489-4880-8f8a-bc70015c4e18,2017-03-11 19:55:57,5,浙江,注册会员,70060黑色,36\n10203810598,11242420873,4113c7e0-4556-4aa1-b441-2334bd5419d4,2017-03-11 19:49:51,5,安徽,注册会员,70060黑色,36\n10203802320,11242420873,38a65bba-5284-4190-83f2-1a6a54d57da3,2017-03-11 19:46:57,5,广西,注册会员,70060黑色,36\n```\n\n* `shoe_details.csv`\n```\n10536835318,她芙 单鞋女2017春季新款中跟短靴女时尚女鞋性感尖头细跟单鞋深口裸靴防水台高跟鞋 黑色 37-标准码,卡曼鞋类专营店,9.72|9.75|9.65|9.63\n1587186408,雅诗莱雅休闲鞋女 圆头深口低帮鞋 拼色厚底女鞋 系带防水台女鞋子 GH852Q0红色 37,宏嘉男鞋专营店,9.79|9.80|9.74|9.76\n10536835318,她芙 单鞋女2017春季新款中跟短靴女时尚女鞋性感尖头细跟单鞋深口裸靴防水台高跟鞋 黑色 37-标准码,卡曼鞋类专营店,9.72|9.75|9.65|9.63\n11242420873,百芙蓉单鞋女中跟2017春季新款粗跟英伦风小皮鞋女春季新款圆头深口妈妈工作韩版潮厚底 70060黑色 36,百芙蓉鞋类旗舰店,9.88|9.81|9.83|9.84\n11157498264,圆头深口低帮鞋2017年秋冬新款纯色系带坡跟女鞋防水台女鞋子 1343黑色 36,马登尔鞋靴专营店,9.78|9.81|9.75|9.76\n10638093860,爱思图牛津鞋英伦风皮鞋女中跟秋季女鞋粗跟单鞋大头皮鞋圆头学生鞋小皮鞋平底鞋潮妈妈鞋女生鞋子 黑色ML6X303 36,爱思图旗舰店,9.72|9.76|9.71|9.70\n10574081025,佩尼泰深口单鞋女头层牛皮尖头单鞋中跟粗跟 OL工作职业鞋大小码女鞋春季新款 灰色 38,佩尼泰旗舰店,9.68|9.73|9.67|9.66\n10459020322,瑞蓓妮真皮女鞋2017新款魔术贴深口单鞋女平底舒适休闲鞋大码防滑中老年妈妈鞋 黑色单鞋 38,瑞蓓妮旗舰店,9.70|9.75|9.65|9.65\n11273711543,细跟高跟鞋女2017春季新款尖头单鞋女深口高跟女士英伦厚底防水台工作女鞋 红色 37,家兴福鞋业专营店,9.87|9.82|9.80|9.81\n11226902308,粗跟单鞋女2017春季新款女鞋OL尖头高跟鞋深口工作鞋女士皮鞋水钻百搭鞋子女 DH3658黑色 37,彬度鸟鞋靴旗舰店,9.89|9.83|9.83|9.84\n11210447351,她芙 单鞋女2017春季新款单鞋粗跟女鞋子系带厚底高跟鞋深口学生休闲低帮鞋 绿色 37,她芙旗舰店,9.77|9.77|9.67|9.68\n11239261516,AUSDU休闲鞋女圆头平底深口单鞋粗跟厚底2017春款韩版百搭舒适女鞋妈妈绑带学生 70030黑色 36,AUSDU鞋类旗舰店,9.87|9.80|9.81|9.82\n11267204558,丹芭莎春季女鞋2017新品纯色深口鞋女韩版圆头高跟鞋粗跟防水台单鞋女潮鞋 M70050黑色 37,丹芭莎旗舰店,9.84|9.81|9.79|9.80\n10687936751,fullmir内增高休闲鞋女士小白鞋2016秋季新款厚底鞋韩版潮流低帮学生运动鞋子单鞋 红 色 37,fullmir鞋类旗舰店,9.61|9.66|9.58|9.58\n11167186789,新款单鞋女2017秋季时尚漆皮圆头低帮休闲鞋秋鞋 工作鞋套脚欧美低跟皮鞋 黑色6119 34,艾琳艺鞋类专营店,9.67|9.79|9.67|9.69\n11227438800,意米思时尚女鞋圆头高跟鞋粗跟妈妈鞋深口单鞋女2017春秋新款韩版百搭小皮鞋防水台鞋子女 莫70050黑色 36,意米思旗舰店,9.72|9.81|9.79|9.80\n11250120847,邻家天使细跟单鞋2017春季新款尖头欧美皮鞋深口高跟女鞋春秋款鞋子 LJ619黑色 39标码,邻家天使鞋类旗舰店,9.69|9.74|9.65|9.66\n11193717829,单鞋女2017春季新款韩版高跟防水台粗跟女鞋尖头深口水钻通勤OL工作小皮鞋女 邻1231黑色 37,NEB ANGEL梓赢专卖店,9.78|9.78|9.74|9.75\n11166169416,金丝兔尖头单鞋女2017春季新品深口金属超高跟鞋欧美时尚细跟女鞋百搭小皮鞋工作鞋 黑色 36,金丝兔广汇达专卖店,9.89|9.83|9.83|9.84\n10617152040,ZHR小皮鞋真皮小白鞋女深口单鞋平底护士工作鞋潮 白色 39,零邦鞋靴专营店,9.69|9.68|9.69|9.69\n1471841136,宝思特2017春季新款真皮平底平跟休闲女单鞋软牛皮软底妈妈鞋花朵跳舞鞋加大码女鞋子 黑色 39,宝思特旗舰店,9.75|9.74|9.65|9.65\n11204372265,霍尔世家 深口单鞋女粗跟高跟鞋2017春季新款英伦风真皮尖头女鞋防水台 黑色 37,霍尔世家旗舰店,9.64|9.70|9.63|9.64\n```\n\n至此，我们完成了整个数据的爬取工作。\n\n# 接下来的工作\n\n有经验的读者可以看出来，本文完成的爬虫是较为基础的爬虫，不涉及到Scrapy高级的特性，也不涉及到反爬虫的内容，对于感兴趣的读者，可以从以下几个方面继续深入。\n1. 由于京东对爬虫爬取评论并没有反爬措施，所以本文没有涉及到反爬的内容，不过在编写该爬虫的时候有考虑到这部分内容，所以编写了中间件来完成`User-Agent`的随机设置以及使用代理池来分散请求等简单的反爬措施，有兴趣的读者可以查阅Github源代码。\n2. 对于较大的爬取工作，可以考虑使用`scrapy-redis`等工具来构建分布式爬虫，以增加爬取效率。\n3. 在获得大量的数据之后，可以使用`matplotlib`等工具对数据进行可视化分析。\n\n以上就是本文的全部内容，有兴趣的读者可以查阅Github并下载源码，该项目地址: [https://github.com/Time1ess/MyCodes/tree/master/scrapy/jd](https://github.com/Time1ess/MyCodes/tree/master/scrapy/jd)","slug":"Python-A-JD-spider-based-on-scrapy","published":1,"updated":"2018-01-15T01:18:04.489Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgvnqml4000qw628phqqr7if","content":"<p>今天想跟大家分享的是关于网络爬虫的相关知识，网络爬虫是一种根据一定的规则，自动地对互联网上相关内容进行抓取的程序或者脚本，本文的内容主要是通过分析京东评论的加载过程，获取相关API，然后通过使用基于Python语言的开源网络爬虫框架——Scrapy，大量获取相关评论内容。</p>\n<div class=\"tip\"><br>本文假定读者具有一定的Python编程经验，具有少量HTTP协议和HTML的相关知识，对爬虫的工作原理有一定了解。<br></div>\n\n<a id=\"more\"></a>\n<h1 id=\"API获取\"><a href=\"#API获取\" class=\"headerlink\" title=\"API获取\"></a>API获取</h1><p>在开始编写爬虫之前，我们需要获得启动爬虫所需要的相关链接。在本文，我们将以对京东鞋类评论爬取为例，进行说明(其他种类爬取流程类似，区别只在于数据处理)。<br>首先打开京东，搜索“鞋”，打开任意一件商品，并切换到“商品评价”标签页，如图所示。</p>\n<p><img src=\"/2017/03/12/Python-A-JD-spider-based-on-scrapy/item_shoe_comments_tab.png\" alt=\"comments_tab\"></p>\n<p>启用浏览器的网页分析功能，以Safari浏览器为例，右键点击网页任意部分，选择”检查元素“，切换到“网络”标签下，如果有其他内容的话，可以点击右侧的垃圾桶图标清空历史，如图所示。</p>\n<p><img src=\"/2017/03/12/Python-A-JD-spider-based-on-scrapy/console_network_before.png\" alt=\"console_network_before\"></p>\n<p>然后我们点击评论区的换页按钮，切换到任意一页新的评论，此时可以发现浏览器对本次点击产生的数据交换过程进行了记录，我们发现其中有一条名为”productPageComments.action”的记录，对其进行分析可以看到对应的完整URL，如图所示。</p>\n<p><img src=\"/2017/03/12/Python-A-JD-spider-based-on-scrapy/console_network_after.png\" alt=\"console_network_after\"></p>\n<p>其完整URL为:<code>https://club.jd.com/comment/productPageComments.action?callback=fetchJSON_comment98vv6630&amp;productId=10353518575&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0</code></p>\n<p>显而易见，评论的加载是通过GET请求实现，对我们来说，该URL中最关键的GET参数为<code>productID</code>和<code>page</code>，它们分别定义了对应的商品编号以及评论页码。通过访问该URL，我们可以得到内容如图所示。</p>\n<p><img src=\"/2017/03/12/Python-A-JD-spider-based-on-scrapy/comments_json_1.png\" alt=\"comments_json_1\"></p>\n<p>可以看到，该URL返回的内容为json数据包，同时以请求中<code>callback</code>定义的函数名对其进行包裹，这一点从整个数据包最前方可以看出。我们将GET请求中callback参数去掉以后即可得到原始的json数据包，如图所示。</p>\n<p><img src=\"/2017/03/12/Python-A-JD-spider-based-on-scrapy/comments_json_2.png\" alt=\"comments_json_2\"></p>\n<p>因此，在不考虑其他参数的情况下，我们需要的API格式为:<code>https://club.jd.com/comment/productPageComments.action?productId={}&amp;score=0&amp;sortType=5&amp;page={}&amp;pageSize=10&amp;isShadowSku=0</code></p>\n<p>至此，我们获得了返回任意商品的任意评论页的API，下面我们将对API返回数据本身的内容进行分析。</p>\n<h1 id=\"API返回字典分析\"><a href=\"#API返回字典分析\" class=\"headerlink\" title=\"API返回字典分析\"></a>API返回字典分析</h1><p>从前面图中可以看出，API返回数据应该是一个字典，我们通过使用requests获得API返回字典以及Python的json模块进行分析。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>url = <span class=\"string\">'https://club.jd.com/comment/productPageComments.action?productId=10353518575&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>html = requests.get(url)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>data = json.loads(html.text)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(data.keys())</span><br><span class=\"line\">dict_keys([<span class=\"string\">'productAttr'</span>, <span class=\"string\">'productCommentSummary'</span>, <span class=\"string\">'hotCommentTagStatistics'</span>,</span><br><span class=\"line\"><span class=\"string\">'jwotestProduct'</span>, <span class=\"string\">'maxPage'</span>, <span class=\"string\">'score'</span>, <span class=\"string\">'soType'</span>, <span class=\"string\">'imageListCount'</span>,</span><br><span class=\"line\"><span class=\"string\">'vTagStatistics'</span>, <span class=\"string\">'comments'</span>])</span><br></pre></td></tr></table></figure>\n<p>其中对我们来说最重要的是键<code>comments</code>所对应的值，值为一个列表，其中每个元素为一个字典，存放的是每一条评论的相关信息。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(type(data[<span class=\"string\">'comments'</span>]))</span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">list</span>'&gt;</span></span><br><span class=\"line\"><span class=\"class\">&gt;&gt;&gt; <span class=\"title\">import</span> <span class=\"title\">pprint</span></span></span><br><span class=\"line\"><span class=\"class\">&gt;&gt;&gt; <span class=\"title\">pprint</span><span class=\"params\">(data[<span class=\"string\">'comments'</span>][<span class=\"number\">0</span>])</span></span></span><br><span class=\"line\">&#123;'afterDays': 0,</span><br><span class=\"line\"> <span class=\"string\">'anonymousFlag'</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\"> <span class=\"string\">'commentTags'</span>: [&#123;<span class=\"string\">'commentId'</span>: <span class=\"number\">1927838458</span>,</span><br><span class=\"line\">                  <span class=\"string\">'created'</span>: <span class=\"string\">'2016-10-19 18:26:50'</span>,</span><br><span class=\"line\">                  <span class=\"string\">'id'</span>: <span class=\"number\">12373951</span>,</span><br><span class=\"line\">                  <span class=\"string\">'modified'</span>: <span class=\"string\">'2016-10-19 18:26:50'</span>,</span><br><span class=\"line\">                  <span class=\"string\">'name'</span>: <span class=\"string\">'穿上很舒服'</span>,</span><br><span class=\"line\">                  <span class=\"string\">'pin'</span>: <span class=\"string\">''</span>,</span><br><span class=\"line\">                  <span class=\"string\">'productId'</span>: <span class=\"number\">10353518575</span>,</span><br><span class=\"line\">                  <span class=\"string\">'rid'</span>: <span class=\"number\">11632</span>,</span><br><span class=\"line\">                  <span class=\"string\">'status'</span>: <span class=\"number\">0</span>&#125;],</span><br><span class=\"line\"> <span class=\"string\">'content'</span>: <span class=\"string\">'鞋子很不错，弹性很不错，材质很轻。穿上很舒服。透气性好，而且又长高了两厘米。'</span>,</span><br><span class=\"line\"> <span class=\"string\">'creationTime'</span>: <span class=\"string\">'2016-10-19 18:26:20'</span>,</span><br><span class=\"line\"> <span class=\"string\">'days'</span>: <span class=\"number\">8</span>,</span><br><span class=\"line\"> <span class=\"string\">'firstCategory'</span>: <span class=\"number\">1318</span>,</span><br><span class=\"line\"> <span class=\"string\">'guid'</span>: <span class=\"string\">'cc2fec79-304b-48c5-a263-151bf7d098d2'</span>,</span><br><span class=\"line\"> <span class=\"string\">'id'</span>: <span class=\"number\">1927838458</span>,</span><br><span class=\"line\"> <span class=\"string\">'integral'</span>: <span class=\"number\">-20</span>,</span><br><span class=\"line\"> <span class=\"string\">'isMobile'</span>: <span class=\"keyword\">False</span>,</span><br><span class=\"line\"> <span class=\"string\">'isReplyGrade'</span>: <span class=\"keyword\">False</span>,</span><br><span class=\"line\"> <span class=\"string\">'isTop'</span>: <span class=\"keyword\">False</span>,</span><br><span class=\"line\"> <span class=\"string\">'nickname'</span>: <span class=\"string\">'j***k'</span>,</span><br><span class=\"line\"> <span class=\"string\">'orderId'</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">'plusAvailable'</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">'productColor'</span>: <span class=\"string\">'黑/安踏白'</span>,</span><br><span class=\"line\"> <span class=\"string\">'productSales'</span>: [],</span><br><span class=\"line\"> <span class=\"string\">'productSize'</span>: <span class=\"string\">'8(男41)'</span>,</span><br><span class=\"line\"> <span class=\"string\">'recommend'</span>: <span class=\"keyword\">True</span>,</span><br><span class=\"line\"> <span class=\"string\">'referenceId'</span>: <span class=\"string\">'10353518575'</span>,</span><br><span class=\"line\"> <span class=\"string\">'referenceImage'</span>: <span class=\"string\">'jfs/t3073/150/7342609081/176958/b211c3f7/58b4c73cN9621804d.jpg'</span>,</span><br><span class=\"line\"> <span class=\"string\">'referenceName'</span>: <span class=\"string\">'安踏男鞋 易弯折科技跑步鞋 2017新款透气网面运动鞋 黑/安踏白-1 8(男41)'</span>,</span><br><span class=\"line\"> <span class=\"string\">'referenceTime'</span>: <span class=\"string\">'2016-10-11 20:03:00'</span>,</span><br><span class=\"line\"> <span class=\"string\">'referenceType'</span>: <span class=\"string\">'Product'</span>,</span><br><span class=\"line\"> <span class=\"string\">'referenceTypeId'</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">'replyCount'</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">'score'</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\"> <span class=\"string\">'secondCategory'</span>: <span class=\"number\">12099</span>,</span><br><span class=\"line\"> <span class=\"string\">'status'</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\"> <span class=\"string\">'thirdCategory'</span>: <span class=\"number\">9756</span>,</span><br><span class=\"line\"> <span class=\"string\">'title'</span>: <span class=\"string\">''</span>,</span><br><span class=\"line\"> <span class=\"string\">'usefulVoteCount'</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\"> <span class=\"string\">'uselessVoteCount'</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">'userClient'</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">'userClientShow'</span>: <span class=\"string\">''</span>,</span><br><span class=\"line\"> <span class=\"string\">'userImage'</span>: <span class=\"string\">'misc.360buyimg.com/lib/img/u/b56.gif'</span>,</span><br><span class=\"line\"> <span class=\"string\">'userImageUrl'</span>: <span class=\"string\">'misc.360buyimg.com/lib/img/u/b56.gif'</span>,</span><br><span class=\"line\"> <span class=\"string\">'userImgFlag'</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">'userLevelColor'</span>: <span class=\"string\">'#666666'</span>,</span><br><span class=\"line\"> <span class=\"string\">'userLevelId'</span>: <span class=\"string\">'56'</span>,</span><br><span class=\"line\"> <span class=\"string\">'userLevelName'</span>: <span class=\"string\">'铜牌会员'</span>,</span><br><span class=\"line\"> <span class=\"string\">'userProvince'</span>: <span class=\"string\">''</span>,</span><br><span class=\"line\"> <span class=\"string\">'viewCount'</span>: <span class=\"number\">0</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>根据实际需要，在本次实现中选取了以下信息:</p>\n<ul>\n<li>guid                –&gt; 评论用户id</li>\n<li>id                –&gt; 该评论id</li>\n<li>referenceId        –&gt; 评论商品id</li>\n<li>creationTime    –&gt; 评论时间</li>\n<li>score            –&gt; 评论评分</li>\n<li>userProvince    –&gt; 评论用户归属地</li>\n<li>userLevelName    –&gt; 评论用户会员级别</li>\n<li>productColor    –&gt; 评论用户购买颜色</li>\n<li>productSize        –&gt; 评论用户购买尺寸</li>\n</ul>\n<p>至此，我们完成了对API返回字典的分析，在构建Scrapy爬虫之前，我们还需要对商品列表进行分析。</p>\n<h1 id=\"商品列表分析\"><a href=\"#商品列表分析\" class=\"headerlink\" title=\"商品列表分析\"></a>商品列表分析</h1><p>我们已经拥有对任意给定的商品id,获取其所有评论的API，但在构建爬虫之前，我们还有最后一个问题，如何获得商品id?<br>我们可以很容易的获得并格式化京东的搜索链接:<code>https://search.jd.com/Search?keyword={}&amp;enc=utf-8&amp;page={}</code>，根据该格式化链接，我们只需要填写搜索关键字以及搜索页码就能得到对应页的搜索结果。通过对网页源代码进行分析，可以发现每个商品都处于<code>class=&quot;gl-item&quot;</code>的<code>li</code>元素下，如图所示。</p>\n<p><img src=\"/2017/03/12/Python-A-JD-spider-based-on-scrapy/console_item_list.png\" alt=\"console_item_list\"><br><img src=\"/2017/03/12/Python-A-JD-spider-based-on-scrapy/console_item_list_2.png\" alt=\"console_item_list_2\"></p>\n<p>我们只需要对<code>class=&quot;gl-item&quot;</code>的<code>li</code>元素下<code>class=&quot;p-img&quot;</code>的<code>div</code>元素下的<code>a</code>元素的<code>href</code>属性进行提取处理即可得到商品id，如图中的<code>10353518575</code>。</p>\n<p>至此，我们完成了对商品列表的分析工作，接下来我们将构建基于Scrapy的爬虫来完成对评论的爬取工作。</p>\n<h1 id=\"可选-商品详细信息\"><a href=\"#可选-商品详细信息\" class=\"headerlink\" title=\"(可选)商品详细信息\"></a>(可选)商品详细信息</h1><p>我们在上节中获得了商品的详细信息链接，如:<code>https://item.jd.com/10353518575.html</code>，我们可以对该页面内容进行爬取以获得更全面的商品信息。在这部分需要注意的是，很多内容是通过JavaScript进行动态加载的，在爬取时需要注意，否则得到的数据并不符合需要。通过启用浏览器的“停用JavaScript”功能，可以看到在不执行JavaScript时的页面是什么样的，如图所示。</p>\n<p><img src=\"/2017/03/12/Python-A-JD-spider-based-on-scrapy/item_detail_no_js.png\" alt=\"item_detail_no_js\"></p>\n<p>可以看到，商品的价格等信息是没有进行加载的，所以如果需要对价格进行爬取，需要使用到selenium等工具来完成浏览器的模拟或者进一步分析JavaScript的执行逻辑。</p>\n<h1 id=\"Scrapy爬虫\"><a href=\"#Scrapy爬虫\" class=\"headerlink\" title=\"Scrapy爬虫\"></a>Scrapy爬虫</h1><p>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。其最初是为了网络抓取所设计的，也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。</p>\n<p>要使用Scrapy，首先得建立项目:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ scrapy startproject jd</span><br><span class=\"line\">New Scrapy project &apos;jd&apos;, using template directory &apos;/usr/local/lib/python3.6/site-packages/scrapy/templates/project&apos;, created in:</span><br><span class=\"line\">    /private/tmp/jd</span><br><span class=\"line\"></span><br><span class=\"line\">You can start your first spider with:</span><br><span class=\"line\">    cd jd</span><br><span class=\"line\">    scrapy genspider example example.com</span><br></pre></td></tr></table></figure>\n<p>在建好的<code>jd</code>文件夹下，有一个<code>jd</code>文件夹以及一个<code>scrapy.cfg</code>文件，进入前者，可以看到以下内容:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ls</span><br><span class=\"line\">__init__.py    items.py       pipelines.py   spiders</span><br><span class=\"line\">__pycache__    middlewares.py settings.py</span><br></pre></td></tr></table></figure>\n<p>其中:</p>\n<ul>\n<li>items.py         –&gt; 完成数据容器Item的定义<br>  爬取的主要目标就是从非结构性的数据源提取结构性数据，例如网页。Scrapy提供 Item 类来满足这样的需求。Item 对象是种简单的容器，保存了爬取到得数据。 其提供了 类似于词典(dictionary-like) 的API以及用于声明可用字段的简单语法。</li>\n<li>pipelines.py    –&gt; 完成对Item处理流水线的定义<br>  当Item在Spider中被收集之后，它将会被传递到Item Pipeline，一些组件会按照一定的顺序执行对Item的处理。每个item pipeline组件(有时称之为“Item Pipeline”)是实现了简单方法的Python类。他们接收到Item并通过它执行一些行为，同时也决定此Item是否继续通过pipeline，或是被丢弃而不再进行处理。<br>  以下是item pipeline的一些典型应用：<ul>\n<li>清理HTML数据</li>\n<li>验证爬取的数据(检查item包含某些字段)</li>\n<li>查重(并丢弃)</li>\n<li>将爬取结果保存到数据库中</li>\n</ul>\n</li>\n<li>middlewares.py    –&gt; 完成Spider中间件的定义<br>  Spider中间件是介入到Scrapy的spider处理机制的钩子框架，通过定义并使用中间件，可以对发送给Spiders的response以及Spiders产生的Request对象进行处理。</li>\n<li>settings.py        –&gt; 完成对爬虫的控制<br>  Scrapy settings提供了定制Scrapy组件的方法。通过修改settings.py，可以控制包括核心(core)，插件(extension)，pipeline及spider组件。settings为代码提供了提取以key-value映射的配置值的的全局命名空间(namespace)。settings同时也是选择当前激活的Scrapy项目的方法。</li>\n<li>spiders            –&gt; 完成对爬虫Spider的定义<br>  Spider类定义了如何爬取某个(或某些)网站。包括了爬取的动作(例如:是否跟进链接)以及如何从网页的内容中提取结构化数据(爬取item)。换句话说，Spider就是定义爬取的动作及分析某个网页(或者是有些网页)的地方。</li>\n</ul>\n<h4 id=\"定义数据容器items\"><a href=\"#定义数据容器items\" class=\"headerlink\" title=\"定义数据容器items\"></a>定义数据容器items</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShoeCommentItem</span><span class=\"params\">(scrapy.Item)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># define the fields for your item here like:</span></span><br><span class=\"line\">    <span class=\"comment\"># name = scrapy.Field()</span></span><br><span class=\"line\">    _id = scrapy.Field()</span><br><span class=\"line\">    iid = scrapy.Field()</span><br><span class=\"line\">    uid = scrapy.Field()</span><br><span class=\"line\">    creation_time = scrapy.Field()</span><br><span class=\"line\">    score = scrapy.Field()</span><br><span class=\"line\">    user_province = scrapy.Field()</span><br><span class=\"line\">    user_level = scrapy.Field()</span><br><span class=\"line\">    color = scrapy.Field()</span><br><span class=\"line\">    size = scrapy.Field()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShoeDetailItem</span><span class=\"params\">(scrapy.Item)</span>:</span></span><br><span class=\"line\">    iid = scrapy.Field()</span><br><span class=\"line\">    name = scrapy.Field()</span><br><span class=\"line\">    shop = scrapy.Field()</span><br><span class=\"line\">    scores = scrapy.Field()</span><br></pre></td></tr></table></figure>\n<h4 id=\"定义爬虫类\"><a href=\"#定义爬虫类\" class=\"headerlink\" title=\"定义爬虫类\"></a>定义爬虫类</h4><p>创建爬虫类的命令为:<code>scrapy genspider [爬虫名] [允许爬取域名]</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ scrapy genspider shoes jd.com</span><br><span class=\"line\">Created spider &apos;shoes&apos; using template &apos;basic&apos; in module:</span><br><span class=\"line\">  jd.spiders.shoes</span><br></pre></td></tr></table></figure>\n<p>接着打开<code>spiders</code>文件夹下的<code>shoes.py</code>文件进行编辑:</p>\n<ul>\n<li><p>首先我们需要定义一些变量，比如包含搜索关键字的列表、格式化搜索链接、格式化评论API链接等:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shoe_cates = [</span><br><span class=\"line\">    <span class=\"string\">'女深口单鞋'</span>, <span class=\"string\">'工装鞋'</span>, <span class=\"string\">'女鞋'</span>, <span class=\"string\">'正装鞋'</span>, <span class=\"string\">'平底鞋'</span>, <span class=\"string\">'平底女鞋'</span>,</span><br><span class=\"line\">    <span class=\"string\">'功能鞋'</span>, <span class=\"string\">'中跟单鞋'</span>, <span class=\"string\">'女拖鞋'</span>, <span class=\"string\">'凉鞋'</span>, <span class=\"string\">'拖鞋'</span>, <span class=\"string\">'帆布鞋'</span>, <span class=\"string\">'人字拖'</span>,</span><br><span class=\"line\">    <span class=\"string\">'马丁靴'</span>, <span class=\"string\">'商务休闲鞋'</span>, <span class=\"string\">'传统布鞋'</span>, <span class=\"string\">'休闲鞋'</span>, <span class=\"string\">'鞋'</span>, <span class=\"string\">'棉鞋'</span>, <span class=\"string\">'定制鞋'</span>,</span><br><span class=\"line\">    <span class=\"string\">'男靴'</span>, <span class=\"string\">'坡跟单鞋'</span>, <span class=\"string\">'短靴'</span>, <span class=\"string\">'雨鞋'</span>, <span class=\"string\">'平板鞋'</span>, <span class=\"string\">'尖头单鞋'</span>, <span class=\"string\">'军靴'</span>, <span class=\"string\">'女靴'</span>,</span><br><span class=\"line\">    <span class=\"string\">'皮鞋'</span>, <span class=\"string\">'小白鞋'</span>, <span class=\"string\">'雪地靴'</span>, <span class=\"string\">'女豆豆鞋'</span>, <span class=\"string\">'妈妈鞋'</span>, <span class=\"string\">'增高鞋'</span>, <span class=\"string\">'劳保鞋'</span>,</span><br><span class=\"line\">    <span class=\"string\">'豆豆鞋'</span>, <span class=\"string\">'踝靴'</span>, <span class=\"string\">'沙滩鞋'</span>, <span class=\"string\">'鞋 女'</span>, <span class=\"string\">'深口单鞋'</span>, <span class=\"string\">'板鞋'</span>, <span class=\"string\">'高帮鞋'</span>,</span><br><span class=\"line\">    <span class=\"string\">'人字拖鞋'</span>, <span class=\"string\">'内增高'</span>, <span class=\"string\">'发光鞋'</span>, <span class=\"string\">'运动鞋'</span>, <span class=\"string\">'高跟鞋'</span>, <span class=\"string\">'雨靴'</span>, <span class=\"string\">'鞋 男'</span>,</span><br><span class=\"line\">    <span class=\"string\">'乐福鞋'</span>, <span class=\"string\">'内增高休闲鞋'</span>, <span class=\"string\">'老人鞋'</span>, <span class=\"string\">'男鞋'</span>, <span class=\"string\">'平底单鞋'</span>, <span class=\"string\">'浅口单鞋'</span>, <span class=\"string\">'单鞋'</span>]</span><br><span class=\"line\">shoe_list_url = <span class=\"string\">'https://search.jd.com/Search?keyword=&#123;&#125;&amp;enc=utf-8&amp;page=&#123;&#125;'</span></span><br><span class=\"line\">comment_url_api = (<span class=\"string\">'https://club.jd.com/comment/productPageComments.action?'</span></span><br><span class=\"line\">    <span class=\"string\">'productId=&#123;&#125;&amp;score=0&amp;sortType=5&amp;page=&#123;&#125;&amp;pageSize=10&amp;isShadowSku=0'</span>)</span><br><span class=\"line\">num_pat = re.compile(<span class=\"string\">'(\\d*?)'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后编辑<code>ShoesSpider</code>类:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShoesSpider</span><span class=\"params\">(Spider)</span>:</span></span><br><span class=\"line\">    name = <span class=\"string\">'shoes'</span></span><br><span class=\"line\">    allowed_domains = [<span class=\"string\">'jd.com'</span>]</span><br><span class=\"line\">    start_urls = [shoe_list_url.format(cate, page) <span class=\"keyword\">for</span> cate <span class=\"keyword\">in</span> shoe_cates</span><br><span class=\"line\">                  <span class=\"keyword\">for</span> page <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">101</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        item_urls = response.xpath(<span class=\"string\">'//li[@class=\"gl-item\"]/div'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> item_xpath <span class=\"keyword\">in</span> item_urls:</span><br><span class=\"line\">            url = item_xpath.xpath(<span class=\"string\">'div[@class=\"p-img\"]/a'</span></span><br><span class=\"line\">                                   <span class=\"string\">'/@href'</span>).extract_first()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> url <span class=\"keyword\">or</span> <span class=\"string\">'ccc-x'</span> <span class=\"keyword\">in</span> url:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            iid = url[url.rfind(<span class=\"string\">'/'</span>)+<span class=\"number\">1</span>:<span class=\"number\">-5</span>]</span><br><span class=\"line\">            detail_url = <span class=\"string\">'http:'</span> + url</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> Request(</span><br><span class=\"line\">                detail_url,</span><br><span class=\"line\">                callback=self.parse_detail,</span><br><span class=\"line\">                meta=&#123;<span class=\"string\">'iid'</span>: iid&#125;)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> Request(</span><br><span class=\"line\">                comment_url_api.format(iid, <span class=\"number\">1</span>),</span><br><span class=\"line\">                callback=self.parse_comment,</span><br><span class=\"line\">                meta=&#123;<span class=\"string\">'page'</span>: <span class=\"number\">1</span>, <span class=\"string\">'iid'</span>: iid, <span class=\"string\">'retry'</span>: <span class=\"number\">0</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_detail</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        iid = int(response.meta[<span class=\"string\">'iid'</span>])</span><br><span class=\"line\">        name = response.xpath(<span class=\"string\">'//div[@class=\"sku-name\"]'</span></span><br><span class=\"line\">                              <span class=\"string\">'/text()'</span>).extract_first().strip(<span class=\"string\">'\\n '</span>)</span><br><span class=\"line\">        xpath_aside = response.xpath(<span class=\"string\">'//div[@class=\"aside\"]'</span>)</span><br><span class=\"line\">        shop = xpath_aside.xpath(<span class=\"string\">'//div[@class=\"mt\"]/'</span></span><br><span class=\"line\">                                 <span class=\"string\">'h3/a/@title'</span>).extract_first().strip(<span class=\"string\">'\\n '</span>)</span><br><span class=\"line\">        scores = xpath_aside.xpath(<span class=\"string\">'//div[@class=\"mc\"]/div/'</span></span><br><span class=\"line\">                                   <span class=\"string\">'a//text()'</span>).extract()</span><br><span class=\"line\">        scores = [s <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> scores <span class=\"keyword\">if</span> s.strip(<span class=\"string\">'\\n '</span>)][::<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        sd = ShoeDetailItem(iid=iid, name=name, shop=shop,</span><br><span class=\"line\">                            scores=<span class=\"string\">'|'</span>.join(scores))</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> sd</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_comment</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        iid = response.meta[<span class=\"string\">'iid'</span>]</span><br><span class=\"line\">        page = int(response.meta[<span class=\"string\">'page'</span>])</span><br><span class=\"line\">        retry = int(response.meta[<span class=\"string\">'retry'</span>])</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            json_data = json.loads(response.text)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> retry &lt; <span class=\"number\">10</span>:</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> Request(</span><br><span class=\"line\">                    comment_url_api.format(iid, page),</span><br><span class=\"line\">                    callback=self.parse_comment,</span><br><span class=\"line\">                    meta=&#123;<span class=\"string\">'page'</span>: page, <span class=\"string\">'iid'</span>: iid, <span class=\"string\">'retry'</span>: retry+<span class=\"number\">1</span>&#125;)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> json_data[<span class=\"string\">'comments'</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> cd <span class=\"keyword\">in</span> json_data[<span class=\"string\">'comments'</span>]:</span><br><span class=\"line\">            d = &#123;&#125;</span><br><span class=\"line\">            d[<span class=\"string\">'_id'</span>] = cd[<span class=\"string\">'id'</span>]</span><br><span class=\"line\">            d[<span class=\"string\">'iid'</span>] = cd[<span class=\"string\">'referenceId'</span>]</span><br><span class=\"line\">            d[<span class=\"string\">'uid'</span>] = cd[<span class=\"string\">'guid'</span>]</span><br><span class=\"line\">            d[<span class=\"string\">'creation_time'</span>] = cd[<span class=\"string\">'creationTime'</span>]</span><br><span class=\"line\">            d[<span class=\"string\">'score'</span>] = cd[<span class=\"string\">'score'</span>]</span><br><span class=\"line\">            d[<span class=\"string\">'user_province'</span>] = cd[<span class=\"string\">'userProvince'</span>]</span><br><span class=\"line\">            d[<span class=\"string\">'user_level'</span>] = cd[<span class=\"string\">'userLevelName'</span>]</span><br><span class=\"line\">            d[<span class=\"string\">'color'</span>] = cd[<span class=\"string\">'productColor'</span>]</span><br><span class=\"line\">            d[<span class=\"string\">'size'</span>] = cd[<span class=\"string\">'productSize'</span>]</span><br><span class=\"line\">            sc = ShoeCommentItem(d)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> sc</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> Request(</span><br><span class=\"line\">            comment_url_api.format(iid, page+<span class=\"number\">1</span>),</span><br><span class=\"line\">            callback=self.parse_comment,</span><br><span class=\"line\">            meta=&#123;<span class=\"string\">'page'</span>: page+<span class=\"number\">1</span>, <span class=\"string\">'iid'</span>: iid, <span class=\"string\">'retry'</span>: <span class=\"number\">0</span>&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>详细分析下这段代码:</p>\n<ul>\n<li>类<code>ShoesSpider</code>继承自<code>Spider</code>，其余可继承的类还有<code>CrawlSpider</code>、<code>XMLFeedSpider</code>、<code>SitemapSpider</code>，在这里我们使用了最基本的<code>Spider</code>。</li>\n<li>属性<code>name</code>定义了该爬虫的名字，在启动爬虫的步骤中需要提供爬虫名字。</li>\n<li>属性<code>allowed_domains</code>定义了一个列表，可以包含一个或多个域名，爬虫只会对该域名下的链接进行爬取。</li>\n<li>属性<code>start_urls</code>定义了一个列表，spider启动时将从中获取链接进行爬取。</li>\n<li>实例方法<code>parse</code>定义了对商品列表页面进行处理的相关逻辑:<ul>\n<li>接收一个<code>response</code>参数，该<code>response</code>对象为爬虫根据<code>Request</code>对象请求获得的结果。</li>\n<li>根据前面几节的描述，<code>parse</code>方法针对商品列表页面使用xpath进行分析。</li>\n<li>在提取到商品<code>iid</code>后，对该页面下所有商品<code>iid</code>进行遍历，分别为商品详细页面(可选)以及商品评论页面构建<code>Request</code>请求，注意使用了<code>yield</code>，因为我们需要返回多个请求而不是一个请求。</li>\n<li>对每个<code>Request</code>请求，我们指定了相关参数，比如链接、回调函数，以及通过<code>meta</code>关键字保存上下文信息字典，这可以在回调函数中访问<code>Response</code>的<code>meta</code>属性获得。</li>\n</ul>\n</li>\n<li>实例方法<code>parse_detail</code>定义了对商品详细页面进行处理的相关逻辑:<ul>\n<li>我们依然通过xpath进行分析，获得了商品名、商家名、商家评分等信息，使用其实例化<code>ShoeDetailItem</code>类并返回该实例。</li>\n</ul>\n</li>\n<li>实例方法<code>parse_comment</code>定义了对商品评论进行处理的相关逻辑:<ul>\n<li>根据在<code>Request</code>对象中设置<code>meta</code>属性，我们可以很方便地获得当前物品id、当前评论页码、以及访问重试次数。</li>\n<li>我们需要对<code>response</code>对象的<code>text</code>属性使用<code>json.loads</code>进行格式化，但是由于各种原因可能会失败，所以我们设置了方式重试次数这一变量来控制重试，当本次<code>json.loads</code>格式化失败，我们会再次进行尝试访问该评论链接，直到达到最大重试次数10次，然后放弃。</li>\n<li>如果解析成功，判断解析后的字典中键<code>comments</code>所对应的内容是否为空，为空代表已经没有更多评论，则返回。</li>\n<li>否则，对每条评论进行遍历，使用其中的参数实例化<code>ShoeCommentItem</code>类并返回该实例。</li>\n<li>在结束评论遍历后，尝试对评论下一页发出<code>Request</code>请求。</li>\n</ul>\n</li>\n</ul>\n<p>至此，我们完成了爬虫的工作逻辑，接下来需要对流水线进行定义，完成数据的查重以及保存等操作。</p>\n<h4 id=\"定义pipeline流水线\"><a href=\"#定义pipeline流水线\" class=\"headerlink\" title=\"定义pipeline流水线\"></a>定义pipeline流水线</h4><p>对于各个<code>parse</code>方法返回的<code>Item</code>对象，它们将会被传递到在<code>pipelines.py</code>中定义以及<code>settings.py</code>中启用的流水线中进行处理。<br>在本文中我们需要对每个<code>Item</code>对象做两件事，去重以及保存。对于<code>ShoeCommentItem</code>的流水线定义如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShoeCommentPipeline</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    seen_ids = set()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">from_crawler</span><span class=\"params\">(cls, crawler)</span>:</span></span><br><span class=\"line\">        pipe = cls()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(<span class=\"string\">'shoe_comments.csv'</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> pipe</span><br><span class=\"line\">        pat = re.compile(<span class=\"string\">'^\\d+?,'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">with</span> open(<span class=\"string\">'shoe_comments.csv'</span>, <span class=\"string\">'r'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> f:</span><br><span class=\"line\">                _id = pat.findall(line)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> _id:</span><br><span class=\"line\">                    pipe.seen_ids.add(_id[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pipe</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_item</span><span class=\"params\">(self, item, spider)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> isinstance(item, ShoeCommentItem):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> item</span><br><span class=\"line\"></span><br><span class=\"line\">        _id = item[<span class=\"string\">'_id'</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> _id <span class=\"keyword\">in</span> self.seen_ids:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> DropItem(<span class=\"string\">'&#123;&#125; Have been processed.'</span>.format(_id))</span><br><span class=\"line\">        self.seen_ids.add(_id)</span><br><span class=\"line\"></span><br><span class=\"line\">        key_values = list(item.items())</span><br><span class=\"line\">        key_values.sort(key=<span class=\"keyword\">lambda</span> x: val_indices[x[<span class=\"number\">0</span>]])</span><br><span class=\"line\">        values = [str(val) <span class=\"keyword\">for</span> key, val <span class=\"keyword\">in</span> key_values]</span><br><span class=\"line\">        <span class=\"keyword\">with</span> open(<span class=\"string\">'shoe_comments.csv'</span>, <span class=\"string\">'a'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            f.write(<span class=\"string\">','</span>.join(values)+<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> item</span><br></pre></td></tr></table></figure>\n<p>需要解释的是类方法<code>from_crawler</code>和实例方法<code>process_item</code>，前者在初始化时会被调用，后者在出现<code>Item</code>对象时被调用。<br>对于<code>from_crawler</code>方法:</p>\n<ul>\n<li>我们需要忽略之前已经处理过的评论，因此采用了一个<code>set</code>来存储已经处理过的<code>id</code></li>\n<li>在初始化时，打开之前保存的评论文件<code>shoe_comments.csv</code>，从中获取<code>id</code>并对<code>seen_ids</code>进行填充</li>\n<li>这是一个类方法，需要在最后返回类的实例</li>\n</ul>\n<p>对于<code>process_item</code>方法:</p>\n<ul>\n<li>方法接收两个参数，前一个是返回的<code>Item</code>对象，后一个是返回该对象的对应<code>Spider</code>对象</li>\n<li>首先判断了该<code>Item</code>是否是类<code>ShoeCommentItem</code>实例，如果不是的话不进行处理直接返回该对象</li>\n<li>提取该对象的<code>id</code>并判断该对象是否已经处理过，已经处理过的话抛出<code>DropItem</code>异常，停止后续流水线的处理</li>\n<li>将该对象<code>id</code>加入<code>seen_ids</code>，并根据<code>val_indices</code>定义的顺序将其排序及格式化字符串并追加到<code>shoe_comments.csv</code>中</li>\n<li>返回该对象</li>\n</ul>\n<blockquote>\n<p>需要特别注意的是，<code>process_item</code>方法必须返回一个<code>Item</code>(或任何继承类)对象或者是抛出<code>DropItem</code>异常，被丢弃的item将不会被之后的pipeline组件所处理，而正常返回的会。</p>\n</blockquote>\n<p>同理我们可以定义<code>ShoeDetailItem</code>的流水线:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShoeDetailPipeline</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    seen_ids = set()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">from_crawler</span><span class=\"params\">(cls, crawler)</span>:</span></span><br><span class=\"line\">        pipe = cls()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(<span class=\"string\">'shoe_details.csv'</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> pipe</span><br><span class=\"line\">        pat = re.compile(<span class=\"string\">'^\\d+?,'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">with</span> open(<span class=\"string\">'shoe_details.csv'</span>, <span class=\"string\">'r'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> f:</span><br><span class=\"line\">                iid = pat.findall(line)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> iid:</span><br><span class=\"line\">                    pipe.seen_ids.add(iid[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pipe</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_item</span><span class=\"params\">(self, item, spider)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> isinstance(item, ShoeDetailItem):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> item</span><br><span class=\"line\"></span><br><span class=\"line\">        iid = item[<span class=\"string\">'iid'</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> iid <span class=\"keyword\">in</span> self.seen_ids:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> DropItem(<span class=\"string\">'&#123;&#125; detail have been processed.'</span>.format(iid))</span><br><span class=\"line\">        self.seen_ids.add(iid)</span><br><span class=\"line\"></span><br><span class=\"line\">        key_values = list(item.items())</span><br><span class=\"line\">        key_values.sort(key=<span class=\"keyword\">lambda</span> x: detail_indices[x[<span class=\"number\">0</span>]])</span><br><span class=\"line\">        values = [str(val) <span class=\"keyword\">for</span> key, val <span class=\"keyword\">in</span> key_values]</span><br><span class=\"line\">        <span class=\"keyword\">with</span> open(<span class=\"string\">'shoe_details.csv'</span>, <span class=\"string\">'a'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            f.write(<span class=\"string\">','</span>.join(values)+<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> item</span><br></pre></td></tr></table></figure>\n<p>该流水线逻辑与前一个类似，在此不再赘述。</p>\n<h4 id=\"settings-py的配置\"><a href=\"#settings-py的配置\" class=\"headerlink\" title=\"settings.py的配置\"></a>settings.py的配置</h4><p>我们还需要对<code>settings.py</code>进行配置。<br>其中关键的几个设置是:</p>\n<ul>\n<li>CONCURRENT_REQUESTS(并发请求数): 100</li>\n<li>COOKIES_ENABLED(启用cookies): False</li>\n<li>ITEM_PIPELINES(item流水线): {‘jd.pipelines.ShoeCommentPipeline’: 300, ‘jd.pipelines.ShoeDetailPipeline’: 301}</li>\n</ul>\n<p>具体设置可以根据自己的需求进行设置，以上只是一个示例。</p>\n<h4 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h4><p>最后，让我们启动这个爬虫:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ scrapy crawl shoes</span><br></pre></td></tr></table></figure>\n<p>可以在控制台看到输出:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2017-03-13 19:21:12 [scrapy.utils.log] INFO: Scrapy 1.3.0 started (bot: jd)</span><br><span class=\"line\">2017-03-13 19:21:12 [scrapy.utils.log] INFO: Overridden settings: &#123;&apos;BOT_NAME&apos;: &apos;jd&apos;, &apos;CONCURRENT_REQUESTS&apos;: 100, &apos;COOKIES_ENABLED&apos;: False, &apos;DOWNLOAD_DELAY&apos;: 0.01, &apos;NEWSPIDER_MODULE&apos;: &apos;jd.spiders&apos;, &apos;SPIDER_MODULES&apos;: [&apos;jd.spiders&apos;]&#125;</span><br><span class=\"line\">2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled extensions:</span><br><span class=\"line\">[&apos;scrapy.extensions.corestats.CoreStats&apos;,</span><br><span class=\"line\"> &apos;scrapy.extensions.telnet.TelnetConsole&apos;,</span><br><span class=\"line\"> &apos;scrapy.extensions.logstats.LogStats&apos;]</span><br><span class=\"line\">2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled downloader middlewares:</span><br><span class=\"line\">[&apos;scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.downloadermiddlewares.useragent.UserAgentMiddleware&apos;,</span><br><span class=\"line\"> &apos;jd.middlewares.RandomUserAgentMiddleware&apos;,</span><br><span class=\"line\"> &apos;jd.middlewares.ProxyMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.downloadermiddlewares.retry.RetryMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.downloadermiddlewares.redirect.RedirectMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.downloadermiddlewares.stats.DownloaderStats&apos;]</span><br><span class=\"line\">2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled spider middlewares:</span><br><span class=\"line\">[&apos;scrapy.spidermiddlewares.httperror.HttpErrorMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.spidermiddlewares.offsite.OffsiteMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.spidermiddlewares.referer.RefererMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.spidermiddlewares.urllength.UrlLengthMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.spidermiddlewares.depth.DepthMiddleware&apos;]</span><br><span class=\"line\">2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled item pipelines:</span><br><span class=\"line\">[&apos;jd.pipelines.ShoeCommentPipeline&apos;, &apos;jd.pipelines.ShoeDetailPipeline&apos;]</span><br><span class=\"line\">2017-03-13 19:21:12 [scrapy.core.engine] INFO: Spider opened</span><br><span class=\"line\">2017-03-13 19:21:12 [scrapy.extensions.logstats] INFO: Crawled 0 pages (at 0 pages/min), scraped 0 items (at 0 items/min)</span><br><span class=\"line\">2017-03-13 19:21:12 [scrapy.extensions.telnet] DEBUG: Telnet console listening on 127.0.0.1:6023</span><br><span class=\"line\">2017-03-13 19:21:13 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=3&gt; (referer: None)</span><br><span class=\"line\">2017-03-13 19:21:13 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=7&gt; (referer: None)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=6&gt; (referer: None)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=9&gt; (referer: None)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=5&gt; (referer: None)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=10&gt; (referer: None)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=2&gt; (referer: None)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=1&gt; (referer: None)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.dupefilters] DEBUG: Filtered duplicate request: &lt;GET http://item.jd.com/10536835318.html&gt; - no more duplicates will be shown (see DUPEFILTER_DEBUG to show all duplicates)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=8&gt; (referer: None)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET http://item.jd.com/10536835318.html&gt; (referer: https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=6)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://club.jd.com/comment/productPageComments.action?productId=10589923020&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0&gt; (referer: https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=7)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 http://item.jd.com/10536835318.html&gt;</span><br><span class=\"line\">&#123;&apos;iid&apos;: 10536835318,</span><br><span class=\"line\"> &apos;name&apos;: &apos;她芙 单鞋女2017春季新款中跟短靴女时尚女鞋性感尖头细跟单鞋深口裸靴防水台高跟鞋 黑色 37-标准码&apos;,</span><br><span class=\"line\"> &apos;scores&apos;: &apos;9.72|9.75|9.65|9.63&apos;,</span><br><span class=\"line\"> &apos;shop&apos;: &apos;卡曼鞋类专营店&apos;&#125;</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 https://club.jd.com/comment/productPageComments.action?productId=10589923020&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0&gt;</span><br><span class=\"line\">&#123;&apos;_id&apos;: 10199823376,</span><br><span class=\"line\"> &apos;color&apos;: &apos;金黑色.&apos;,</span><br><span class=\"line\"> &apos;creation_time&apos;: &apos;2017-03-10 13:59:31&apos;,</span><br><span class=\"line\"> &apos;iid&apos;: &apos;10589923020&apos;,</span><br><span class=\"line\"> &apos;score&apos;: 5,</span><br><span class=\"line\"> &apos;size&apos;: &apos;36&apos;,</span><br><span class=\"line\"> &apos;uid&apos;: &apos;069d0baa-022b-421b-a43a-584f5aa3921e&apos;,</span><br><span class=\"line\"> &apos;user_level&apos;: &apos;铜牌会员&apos;,</span><br><span class=\"line\"> &apos;user_province&apos;: &apos;&apos;&#125;</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 https://club.jd.com/comment/productPageComments.action?productId=10589923020&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0&gt;</span><br><span class=\"line\">&#123;&apos;_id&apos;: 10175008135,</span><br><span class=\"line\"> &apos;color&apos;: &apos;金黑色.&apos;,</span><br><span class=\"line\"> &apos;creation_time&apos;: &apos;2017-03-02 12:18:57&apos;,</span><br><span class=\"line\"> &apos;iid&apos;: &apos;10589923020&apos;,</span><br><span class=\"line\"> &apos;score&apos;: 5,</span><br><span class=\"line\"> &apos;size&apos;: &apos;36&apos;,</span><br><span class=\"line\"> &apos;uid&apos;: &apos;28dfd6c2-caf2-427d-9927-cf088d3099ea&apos;,</span><br><span class=\"line\"> &apos;user_level&apos;: &apos;铜牌会员&apos;,</span><br><span class=\"line\"> &apos;user_province&apos;: &apos;湖南&apos;&#125;</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 https://club.jd.com/comment/productPageComments.action?productId=10589923020&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0&gt;</span><br><span class=\"line\">&#123;&apos;_id&apos;: 10163486837,</span><br><span class=\"line\"> &apos;color&apos;: &apos;金黑色.&apos;,</span><br><span class=\"line\"> &apos;creation_time&apos;: &apos;2017-02-26 15:28:14&apos;,</span><br><span class=\"line\"> &apos;iid&apos;: &apos;10589923020&apos;,</span><br><span class=\"line\"> &apos;score&apos;: 5,</span><br><span class=\"line\"> &apos;size&apos;: &apos;36&apos;,</span><br><span class=\"line\"> &apos;uid&apos;: &apos;736ad5a4-9470-4dcc-832d-b59094cf84f4&apos;,</span><br><span class=\"line\"> &apos;user_level&apos;: &apos;铜牌会员&apos;,</span><br><span class=\"line\"> &apos;user_province&apos;: &apos;云南&apos;&#125;</span><br></pre></td></tr></table></figure>\n<p>在运行一段时间后，查看<code>shoe_comments.csv</code>和<code>shoe_details.csv</code>内容:</p>\n<ul>\n<li><p><code>shoe_comments.csv</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10199823376,10589923020,069d0baa-022b-421b-a43a-584f5aa3921e,2017-03-10 13:59:31,5,,铜牌会员,金黑色.,36</span><br><span class=\"line\">10175008135,10589923020,28dfd6c2-caf2-427d-9927-cf088d3099ea,2017-03-02 12:18:57,5,湖南,铜牌会员,金黑色.,36</span><br><span class=\"line\">10163486837,10589923020,736ad5a4-9470-4dcc-832d-b59094cf84f4,2017-02-26 15:28:14,5,云南,铜牌会员,金黑色.,36</span><br><span class=\"line\">10205838152,10589923020,93f35818-129f-4aaa-8ea9-549c28a4f791,2017-03-12 14:37:59,5,,注册会员,金黑色.,36</span><br><span class=\"line\">10175298549,10589923020,fe1a26e0-8cae-43c3-b0d4-c99bf1d961cf,2017-03-02 13:49:07,5,,铜牌会员,金黑色.,36</span><br><span class=\"line\">10205858068,10589923020,65a7243e-7116-4075-b64a-6e8d8d8382a4,2017-03-12 14:44:29,5,,铜牌会员,金黑色.,36</span><br><span class=\"line\">10206280836,10589923020,1d9b5332-5ca6-40be-b408-250606f68c17,2017-03-12 17:00:48,5,,注册会员,金黑色.,36</span><br><span class=\"line\">10200243913,10589923020,966cda26-ce10-432a-8309-95199ad1903e,2017-03-10 16:15:02,5,,铜牌会员,金黑色.,36</span><br><span class=\"line\">10164313667,10589923020,d09eab89-ed53-47a3-abd1-c897a8bcf694,2017-02-26 20:15:01,5,北京,铜牌会员,金黑色.,36</span><br><span class=\"line\">10162862191,10589923020,ddb58374-f48b-45f9-a2a6-e5e60d53d4ce,2017-02-26 11:42:58,5,,铜牌会员,金黑色.,36</span><br><span class=\"line\">10149921178,11242420873,5f410ce9-fc38-4736-8465-88bbdd7da347,2017-02-21 19:45:56,5,上海,铜牌会员,70060黑色,36</span><br><span class=\"line\">10143787582,11242420873,3f15f14f-1d37-4ccb-befa-9acccd22a3d1,2017-02-19 19:07:20,5,海南,铜牌会员,70060黑色,36</span><br><span class=\"line\">10150729539,11242420873,a601a457-1cef-41c4-955b-3df3dd2646ec,2017-02-22 07:32:52,5,新疆,铜牌会员,70060黑色,36</span><br><span class=\"line\">10147517331,11242420873,b50e1e32-e1fe-4084-b95a-71be8a720950,2017-02-20 23:29:52,5,北京,铜牌会员,70060黑色,36</span><br><span class=\"line\">10147357719,11242420873,fe6ec9de-c39b-4d5e-9cee-bf5926abb465,2017-02-20 22:18:46,5,湖南,铜牌会员,70060黑色,36</span><br><span class=\"line\">10187242860,11242420873,f12f02f7-b378-457f-a501-cdd81f69de6c,2017-03-06 13:53:31,5,云南,铜牌会员,70060黑色,36</span><br><span class=\"line\">10203999129,11242420873,f61e40df-f919-43a2-b876-e81176d59cf9,2017-03-11 20:55:40,5,内蒙古,注册会员,70060黑色,36</span><br><span class=\"line\">10203827884,11242420873,4a73b3d7-b489-4880-8f8a-bc70015c4e18,2017-03-11 19:55:57,5,浙江,注册会员,70060黑色,36</span><br><span class=\"line\">10203810598,11242420873,4113c7e0-4556-4aa1-b441-2334bd5419d4,2017-03-11 19:49:51,5,安徽,注册会员,70060黑色,36</span><br><span class=\"line\">10203802320,11242420873,38a65bba-5284-4190-83f2-1a6a54d57da3,2017-03-11 19:46:57,5,广西,注册会员,70060黑色,36</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>shoe_details.csv</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10536835318,她芙 单鞋女2017春季新款中跟短靴女时尚女鞋性感尖头细跟单鞋深口裸靴防水台高跟鞋 黑色 37-标准码,卡曼鞋类专营店,9.72|9.75|9.65|9.63</span><br><span class=\"line\">1587186408,雅诗莱雅休闲鞋女 圆头深口低帮鞋 拼色厚底女鞋 系带防水台女鞋子 GH852Q0红色 37,宏嘉男鞋专营店,9.79|9.80|9.74|9.76</span><br><span class=\"line\">10536835318,她芙 单鞋女2017春季新款中跟短靴女时尚女鞋性感尖头细跟单鞋深口裸靴防水台高跟鞋 黑色 37-标准码,卡曼鞋类专营店,9.72|9.75|9.65|9.63</span><br><span class=\"line\">11242420873,百芙蓉单鞋女中跟2017春季新款粗跟英伦风小皮鞋女春季新款圆头深口妈妈工作韩版潮厚底 70060黑色 36,百芙蓉鞋类旗舰店,9.88|9.81|9.83|9.84</span><br><span class=\"line\">11157498264,圆头深口低帮鞋2017年秋冬新款纯色系带坡跟女鞋防水台女鞋子 1343黑色 36,马登尔鞋靴专营店,9.78|9.81|9.75|9.76</span><br><span class=\"line\">10638093860,爱思图牛津鞋英伦风皮鞋女中跟秋季女鞋粗跟单鞋大头皮鞋圆头学生鞋小皮鞋平底鞋潮妈妈鞋女生鞋子 黑色ML6X303 36,爱思图旗舰店,9.72|9.76|9.71|9.70</span><br><span class=\"line\">10574081025,佩尼泰深口单鞋女头层牛皮尖头单鞋中跟粗跟 OL工作职业鞋大小码女鞋春季新款 灰色 38,佩尼泰旗舰店,9.68|9.73|9.67|9.66</span><br><span class=\"line\">10459020322,瑞蓓妮真皮女鞋2017新款魔术贴深口单鞋女平底舒适休闲鞋大码防滑中老年妈妈鞋 黑色单鞋 38,瑞蓓妮旗舰店,9.70|9.75|9.65|9.65</span><br><span class=\"line\">11273711543,细跟高跟鞋女2017春季新款尖头单鞋女深口高跟女士英伦厚底防水台工作女鞋 红色 37,家兴福鞋业专营店,9.87|9.82|9.80|9.81</span><br><span class=\"line\">11226902308,粗跟单鞋女2017春季新款女鞋OL尖头高跟鞋深口工作鞋女士皮鞋水钻百搭鞋子女 DH3658黑色 37,彬度鸟鞋靴旗舰店,9.89|9.83|9.83|9.84</span><br><span class=\"line\">11210447351,她芙 单鞋女2017春季新款单鞋粗跟女鞋子系带厚底高跟鞋深口学生休闲低帮鞋 绿色 37,她芙旗舰店,9.77|9.77|9.67|9.68</span><br><span class=\"line\">11239261516,AUSDU休闲鞋女圆头平底深口单鞋粗跟厚底2017春款韩版百搭舒适女鞋妈妈绑带学生 70030黑色 36,AUSDU鞋类旗舰店,9.87|9.80|9.81|9.82</span><br><span class=\"line\">11267204558,丹芭莎春季女鞋2017新品纯色深口鞋女韩版圆头高跟鞋粗跟防水台单鞋女潮鞋 M70050黑色 37,丹芭莎旗舰店,9.84|9.81|9.79|9.80</span><br><span class=\"line\">10687936751,fullmir内增高休闲鞋女士小白鞋2016秋季新款厚底鞋韩版潮流低帮学生运动鞋子单鞋 红 色 37,fullmir鞋类旗舰店,9.61|9.66|9.58|9.58</span><br><span class=\"line\">11167186789,新款单鞋女2017秋季时尚漆皮圆头低帮休闲鞋秋鞋 工作鞋套脚欧美低跟皮鞋 黑色6119 34,艾琳艺鞋类专营店,9.67|9.79|9.67|9.69</span><br><span class=\"line\">11227438800,意米思时尚女鞋圆头高跟鞋粗跟妈妈鞋深口单鞋女2017春秋新款韩版百搭小皮鞋防水台鞋子女 莫70050黑色 36,意米思旗舰店,9.72|9.81|9.79|9.80</span><br><span class=\"line\">11250120847,邻家天使细跟单鞋2017春季新款尖头欧美皮鞋深口高跟女鞋春秋款鞋子 LJ619黑色 39标码,邻家天使鞋类旗舰店,9.69|9.74|9.65|9.66</span><br><span class=\"line\">11193717829,单鞋女2017春季新款韩版高跟防水台粗跟女鞋尖头深口水钻通勤OL工作小皮鞋女 邻1231黑色 37,NEB ANGEL梓赢专卖店,9.78|9.78|9.74|9.75</span><br><span class=\"line\">11166169416,金丝兔尖头单鞋女2017春季新品深口金属超高跟鞋欧美时尚细跟女鞋百搭小皮鞋工作鞋 黑色 36,金丝兔广汇达专卖店,9.89|9.83|9.83|9.84</span><br><span class=\"line\">10617152040,ZHR小皮鞋真皮小白鞋女深口单鞋平底护士工作鞋潮 白色 39,零邦鞋靴专营店,9.69|9.68|9.69|9.69</span><br><span class=\"line\">1471841136,宝思特2017春季新款真皮平底平跟休闲女单鞋软牛皮软底妈妈鞋花朵跳舞鞋加大码女鞋子 黑色 39,宝思特旗舰店,9.75|9.74|9.65|9.65</span><br><span class=\"line\">11204372265,霍尔世家 深口单鞋女粗跟高跟鞋2017春季新款英伦风真皮尖头女鞋防水台 黑色 37,霍尔世家旗舰店,9.64|9.70|9.63|9.64</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>至此，我们完成了整个数据的爬取工作。</p>\n<h1 id=\"接下来的工作\"><a href=\"#接下来的工作\" class=\"headerlink\" title=\"接下来的工作\"></a>接下来的工作</h1><p>有经验的读者可以看出来，本文完成的爬虫是较为基础的爬虫，不涉及到Scrapy高级的特性，也不涉及到反爬虫的内容，对于感兴趣的读者，可以从以下几个方面继续深入。</p>\n<ol>\n<li>由于京东对爬虫爬取评论并没有反爬措施，所以本文没有涉及到反爬的内容，不过在编写该爬虫的时候有考虑到这部分内容，所以编写了中间件来完成<code>User-Agent</code>的随机设置以及使用代理池来分散请求等简单的反爬措施，有兴趣的读者可以查阅Github源代码。</li>\n<li>对于较大的爬取工作，可以考虑使用<code>scrapy-redis</code>等工具来构建分布式爬虫，以增加爬取效率。</li>\n<li>在获得大量的数据之后，可以使用<code>matplotlib</code>等工具对数据进行可视化分析。</li>\n</ol>\n<p>以上就是本文的全部内容，有兴趣的读者可以查阅Github并下载源码，该项目地址: <a href=\"https://github.com/Time1ess/MyCodes/tree/master/scrapy/jd\" target=\"_blank\" rel=\"noopener\">https://github.com/Time1ess/MyCodes/tree/master/scrapy/jd</a></p>\n","site":{"data":{}},"excerpt":"<p>今天想跟大家分享的是关于网络爬虫的相关知识，网络爬虫是一种根据一定的规则，自动地对互联网上相关内容进行抓取的程序或者脚本，本文的内容主要是通过分析京东评论的加载过程，获取相关API，然后通过使用基于Python语言的开源网络爬虫框架——Scrapy，大量获取相关评论内容。</p>\n<div class=\"tip\"><br>本文假定读者具有一定的Python编程经验，具有少量HTTP协议和HTML的相关知识，对爬虫的工作原理有一定了解。<br></div>","more":"<h1 id=\"API获取\"><a href=\"#API获取\" class=\"headerlink\" title=\"API获取\"></a>API获取</h1><p>在开始编写爬虫之前，我们需要获得启动爬虫所需要的相关链接。在本文，我们将以对京东鞋类评论爬取为例，进行说明(其他种类爬取流程类似，区别只在于数据处理)。<br>首先打开京东，搜索“鞋”，打开任意一件商品，并切换到“商品评价”标签页，如图所示。</p>\n<p><img src=\"/2017/03/12/Python-A-JD-spider-based-on-scrapy/item_shoe_comments_tab.png\" alt=\"comments_tab\"></p>\n<p>启用浏览器的网页分析功能，以Safari浏览器为例，右键点击网页任意部分，选择”检查元素“，切换到“网络”标签下，如果有其他内容的话，可以点击右侧的垃圾桶图标清空历史，如图所示。</p>\n<p><img src=\"/2017/03/12/Python-A-JD-spider-based-on-scrapy/console_network_before.png\" alt=\"console_network_before\"></p>\n<p>然后我们点击评论区的换页按钮，切换到任意一页新的评论，此时可以发现浏览器对本次点击产生的数据交换过程进行了记录，我们发现其中有一条名为”productPageComments.action”的记录，对其进行分析可以看到对应的完整URL，如图所示。</p>\n<p><img src=\"/2017/03/12/Python-A-JD-spider-based-on-scrapy/console_network_after.png\" alt=\"console_network_after\"></p>\n<p>其完整URL为:<code>https://club.jd.com/comment/productPageComments.action?callback=fetchJSON_comment98vv6630&amp;productId=10353518575&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0</code></p>\n<p>显而易见，评论的加载是通过GET请求实现，对我们来说，该URL中最关键的GET参数为<code>productID</code>和<code>page</code>，它们分别定义了对应的商品编号以及评论页码。通过访问该URL，我们可以得到内容如图所示。</p>\n<p><img src=\"/2017/03/12/Python-A-JD-spider-based-on-scrapy/comments_json_1.png\" alt=\"comments_json_1\"></p>\n<p>可以看到，该URL返回的内容为json数据包，同时以请求中<code>callback</code>定义的函数名对其进行包裹，这一点从整个数据包最前方可以看出。我们将GET请求中callback参数去掉以后即可得到原始的json数据包，如图所示。</p>\n<p><img src=\"/2017/03/12/Python-A-JD-spider-based-on-scrapy/comments_json_2.png\" alt=\"comments_json_2\"></p>\n<p>因此，在不考虑其他参数的情况下，我们需要的API格式为:<code>https://club.jd.com/comment/productPageComments.action?productId={}&amp;score=0&amp;sortType=5&amp;page={}&amp;pageSize=10&amp;isShadowSku=0</code></p>\n<p>至此，我们获得了返回任意商品的任意评论页的API，下面我们将对API返回数据本身的内容进行分析。</p>\n<h1 id=\"API返回字典分析\"><a href=\"#API返回字典分析\" class=\"headerlink\" title=\"API返回字典分析\"></a>API返回字典分析</h1><p>从前面图中可以看出，API返回数据应该是一个字典，我们通过使用requests获得API返回字典以及Python的json模块进行分析。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>url = <span class=\"string\">'https://club.jd.com/comment/productPageComments.action?productId=10353518575&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>html = requests.get(url)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>data = json.loads(html.text)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(data.keys())</span><br><span class=\"line\">dict_keys([<span class=\"string\">'productAttr'</span>, <span class=\"string\">'productCommentSummary'</span>, <span class=\"string\">'hotCommentTagStatistics'</span>,</span><br><span class=\"line\"><span class=\"string\">'jwotestProduct'</span>, <span class=\"string\">'maxPage'</span>, <span class=\"string\">'score'</span>, <span class=\"string\">'soType'</span>, <span class=\"string\">'imageListCount'</span>,</span><br><span class=\"line\"><span class=\"string\">'vTagStatistics'</span>, <span class=\"string\">'comments'</span>])</span><br></pre></td></tr></table></figure>\n<p>其中对我们来说最重要的是键<code>comments</code>所对应的值，值为一个列表，其中每个元素为一个字典，存放的是每一条评论的相关信息。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(type(data[<span class=\"string\">'comments'</span>]))</span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">list</span>'&gt;</span></span><br><span class=\"line\"><span class=\"class\">&gt;&gt;&gt; <span class=\"title\">import</span> <span class=\"title\">pprint</span></span></span><br><span class=\"line\"><span class=\"class\">&gt;&gt;&gt; <span class=\"title\">pprint</span><span class=\"params\">(data[<span class=\"string\">'comments'</span>][<span class=\"number\">0</span>])</span></span></span><br><span class=\"line\">&#123;'afterDays': 0,</span><br><span class=\"line\"> <span class=\"string\">'anonymousFlag'</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\"> <span class=\"string\">'commentTags'</span>: [&#123;<span class=\"string\">'commentId'</span>: <span class=\"number\">1927838458</span>,</span><br><span class=\"line\">                  <span class=\"string\">'created'</span>: <span class=\"string\">'2016-10-19 18:26:50'</span>,</span><br><span class=\"line\">                  <span class=\"string\">'id'</span>: <span class=\"number\">12373951</span>,</span><br><span class=\"line\">                  <span class=\"string\">'modified'</span>: <span class=\"string\">'2016-10-19 18:26:50'</span>,</span><br><span class=\"line\">                  <span class=\"string\">'name'</span>: <span class=\"string\">'穿上很舒服'</span>,</span><br><span class=\"line\">                  <span class=\"string\">'pin'</span>: <span class=\"string\">''</span>,</span><br><span class=\"line\">                  <span class=\"string\">'productId'</span>: <span class=\"number\">10353518575</span>,</span><br><span class=\"line\">                  <span class=\"string\">'rid'</span>: <span class=\"number\">11632</span>,</span><br><span class=\"line\">                  <span class=\"string\">'status'</span>: <span class=\"number\">0</span>&#125;],</span><br><span class=\"line\"> <span class=\"string\">'content'</span>: <span class=\"string\">'鞋子很不错，弹性很不错，材质很轻。穿上很舒服。透气性好，而且又长高了两厘米。'</span>,</span><br><span class=\"line\"> <span class=\"string\">'creationTime'</span>: <span class=\"string\">'2016-10-19 18:26:20'</span>,</span><br><span class=\"line\"> <span class=\"string\">'days'</span>: <span class=\"number\">8</span>,</span><br><span class=\"line\"> <span class=\"string\">'firstCategory'</span>: <span class=\"number\">1318</span>,</span><br><span class=\"line\"> <span class=\"string\">'guid'</span>: <span class=\"string\">'cc2fec79-304b-48c5-a263-151bf7d098d2'</span>,</span><br><span class=\"line\"> <span class=\"string\">'id'</span>: <span class=\"number\">1927838458</span>,</span><br><span class=\"line\"> <span class=\"string\">'integral'</span>: <span class=\"number\">-20</span>,</span><br><span class=\"line\"> <span class=\"string\">'isMobile'</span>: <span class=\"keyword\">False</span>,</span><br><span class=\"line\"> <span class=\"string\">'isReplyGrade'</span>: <span class=\"keyword\">False</span>,</span><br><span class=\"line\"> <span class=\"string\">'isTop'</span>: <span class=\"keyword\">False</span>,</span><br><span class=\"line\"> <span class=\"string\">'nickname'</span>: <span class=\"string\">'j***k'</span>,</span><br><span class=\"line\"> <span class=\"string\">'orderId'</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">'plusAvailable'</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">'productColor'</span>: <span class=\"string\">'黑/安踏白'</span>,</span><br><span class=\"line\"> <span class=\"string\">'productSales'</span>: [],</span><br><span class=\"line\"> <span class=\"string\">'productSize'</span>: <span class=\"string\">'8(男41)'</span>,</span><br><span class=\"line\"> <span class=\"string\">'recommend'</span>: <span class=\"keyword\">True</span>,</span><br><span class=\"line\"> <span class=\"string\">'referenceId'</span>: <span class=\"string\">'10353518575'</span>,</span><br><span class=\"line\"> <span class=\"string\">'referenceImage'</span>: <span class=\"string\">'jfs/t3073/150/7342609081/176958/b211c3f7/58b4c73cN9621804d.jpg'</span>,</span><br><span class=\"line\"> <span class=\"string\">'referenceName'</span>: <span class=\"string\">'安踏男鞋 易弯折科技跑步鞋 2017新款透气网面运动鞋 黑/安踏白-1 8(男41)'</span>,</span><br><span class=\"line\"> <span class=\"string\">'referenceTime'</span>: <span class=\"string\">'2016-10-11 20:03:00'</span>,</span><br><span class=\"line\"> <span class=\"string\">'referenceType'</span>: <span class=\"string\">'Product'</span>,</span><br><span class=\"line\"> <span class=\"string\">'referenceTypeId'</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">'replyCount'</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">'score'</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\"> <span class=\"string\">'secondCategory'</span>: <span class=\"number\">12099</span>,</span><br><span class=\"line\"> <span class=\"string\">'status'</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\"> <span class=\"string\">'thirdCategory'</span>: <span class=\"number\">9756</span>,</span><br><span class=\"line\"> <span class=\"string\">'title'</span>: <span class=\"string\">''</span>,</span><br><span class=\"line\"> <span class=\"string\">'usefulVoteCount'</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\"> <span class=\"string\">'uselessVoteCount'</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">'userClient'</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">'userClientShow'</span>: <span class=\"string\">''</span>,</span><br><span class=\"line\"> <span class=\"string\">'userImage'</span>: <span class=\"string\">'misc.360buyimg.com/lib/img/u/b56.gif'</span>,</span><br><span class=\"line\"> <span class=\"string\">'userImageUrl'</span>: <span class=\"string\">'misc.360buyimg.com/lib/img/u/b56.gif'</span>,</span><br><span class=\"line\"> <span class=\"string\">'userImgFlag'</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\"> <span class=\"string\">'userLevelColor'</span>: <span class=\"string\">'#666666'</span>,</span><br><span class=\"line\"> <span class=\"string\">'userLevelId'</span>: <span class=\"string\">'56'</span>,</span><br><span class=\"line\"> <span class=\"string\">'userLevelName'</span>: <span class=\"string\">'铜牌会员'</span>,</span><br><span class=\"line\"> <span class=\"string\">'userProvince'</span>: <span class=\"string\">''</span>,</span><br><span class=\"line\"> <span class=\"string\">'viewCount'</span>: <span class=\"number\">0</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>根据实际需要，在本次实现中选取了以下信息:</p>\n<ul>\n<li>guid                –&gt; 评论用户id</li>\n<li>id                –&gt; 该评论id</li>\n<li>referenceId        –&gt; 评论商品id</li>\n<li>creationTime    –&gt; 评论时间</li>\n<li>score            –&gt; 评论评分</li>\n<li>userProvince    –&gt; 评论用户归属地</li>\n<li>userLevelName    –&gt; 评论用户会员级别</li>\n<li>productColor    –&gt; 评论用户购买颜色</li>\n<li>productSize        –&gt; 评论用户购买尺寸</li>\n</ul>\n<p>至此，我们完成了对API返回字典的分析，在构建Scrapy爬虫之前，我们还需要对商品列表进行分析。</p>\n<h1 id=\"商品列表分析\"><a href=\"#商品列表分析\" class=\"headerlink\" title=\"商品列表分析\"></a>商品列表分析</h1><p>我们已经拥有对任意给定的商品id,获取其所有评论的API，但在构建爬虫之前，我们还有最后一个问题，如何获得商品id?<br>我们可以很容易的获得并格式化京东的搜索链接:<code>https://search.jd.com/Search?keyword={}&amp;enc=utf-8&amp;page={}</code>，根据该格式化链接，我们只需要填写搜索关键字以及搜索页码就能得到对应页的搜索结果。通过对网页源代码进行分析，可以发现每个商品都处于<code>class=&quot;gl-item&quot;</code>的<code>li</code>元素下，如图所示。</p>\n<p><img src=\"/2017/03/12/Python-A-JD-spider-based-on-scrapy/console_item_list.png\" alt=\"console_item_list\"><br><img src=\"/2017/03/12/Python-A-JD-spider-based-on-scrapy/console_item_list_2.png\" alt=\"console_item_list_2\"></p>\n<p>我们只需要对<code>class=&quot;gl-item&quot;</code>的<code>li</code>元素下<code>class=&quot;p-img&quot;</code>的<code>div</code>元素下的<code>a</code>元素的<code>href</code>属性进行提取处理即可得到商品id，如图中的<code>10353518575</code>。</p>\n<p>至此，我们完成了对商品列表的分析工作，接下来我们将构建基于Scrapy的爬虫来完成对评论的爬取工作。</p>\n<h1 id=\"可选-商品详细信息\"><a href=\"#可选-商品详细信息\" class=\"headerlink\" title=\"(可选)商品详细信息\"></a>(可选)商品详细信息</h1><p>我们在上节中获得了商品的详细信息链接，如:<code>https://item.jd.com/10353518575.html</code>，我们可以对该页面内容进行爬取以获得更全面的商品信息。在这部分需要注意的是，很多内容是通过JavaScript进行动态加载的，在爬取时需要注意，否则得到的数据并不符合需要。通过启用浏览器的“停用JavaScript”功能，可以看到在不执行JavaScript时的页面是什么样的，如图所示。</p>\n<p><img src=\"/2017/03/12/Python-A-JD-spider-based-on-scrapy/item_detail_no_js.png\" alt=\"item_detail_no_js\"></p>\n<p>可以看到，商品的价格等信息是没有进行加载的，所以如果需要对价格进行爬取，需要使用到selenium等工具来完成浏览器的模拟或者进一步分析JavaScript的执行逻辑。</p>\n<h1 id=\"Scrapy爬虫\"><a href=\"#Scrapy爬虫\" class=\"headerlink\" title=\"Scrapy爬虫\"></a>Scrapy爬虫</h1><p>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。其最初是为了网络抓取所设计的，也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。</p>\n<p>要使用Scrapy，首先得建立项目:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ scrapy startproject jd</span><br><span class=\"line\">New Scrapy project &apos;jd&apos;, using template directory &apos;/usr/local/lib/python3.6/site-packages/scrapy/templates/project&apos;, created in:</span><br><span class=\"line\">    /private/tmp/jd</span><br><span class=\"line\"></span><br><span class=\"line\">You can start your first spider with:</span><br><span class=\"line\">    cd jd</span><br><span class=\"line\">    scrapy genspider example example.com</span><br></pre></td></tr></table></figure>\n<p>在建好的<code>jd</code>文件夹下，有一个<code>jd</code>文件夹以及一个<code>scrapy.cfg</code>文件，进入前者，可以看到以下内容:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ls</span><br><span class=\"line\">__init__.py    items.py       pipelines.py   spiders</span><br><span class=\"line\">__pycache__    middlewares.py settings.py</span><br></pre></td></tr></table></figure>\n<p>其中:</p>\n<ul>\n<li>items.py         –&gt; 完成数据容器Item的定义<br>  爬取的主要目标就是从非结构性的数据源提取结构性数据，例如网页。Scrapy提供 Item 类来满足这样的需求。Item 对象是种简单的容器，保存了爬取到得数据。 其提供了 类似于词典(dictionary-like) 的API以及用于声明可用字段的简单语法。</li>\n<li>pipelines.py    –&gt; 完成对Item处理流水线的定义<br>  当Item在Spider中被收集之后，它将会被传递到Item Pipeline，一些组件会按照一定的顺序执行对Item的处理。每个item pipeline组件(有时称之为“Item Pipeline”)是实现了简单方法的Python类。他们接收到Item并通过它执行一些行为，同时也决定此Item是否继续通过pipeline，或是被丢弃而不再进行处理。<br>  以下是item pipeline的一些典型应用：<ul>\n<li>清理HTML数据</li>\n<li>验证爬取的数据(检查item包含某些字段)</li>\n<li>查重(并丢弃)</li>\n<li>将爬取结果保存到数据库中</li>\n</ul>\n</li>\n<li>middlewares.py    –&gt; 完成Spider中间件的定义<br>  Spider中间件是介入到Scrapy的spider处理机制的钩子框架，通过定义并使用中间件，可以对发送给Spiders的response以及Spiders产生的Request对象进行处理。</li>\n<li>settings.py        –&gt; 完成对爬虫的控制<br>  Scrapy settings提供了定制Scrapy组件的方法。通过修改settings.py，可以控制包括核心(core)，插件(extension)，pipeline及spider组件。settings为代码提供了提取以key-value映射的配置值的的全局命名空间(namespace)。settings同时也是选择当前激活的Scrapy项目的方法。</li>\n<li>spiders            –&gt; 完成对爬虫Spider的定义<br>  Spider类定义了如何爬取某个(或某些)网站。包括了爬取的动作(例如:是否跟进链接)以及如何从网页的内容中提取结构化数据(爬取item)。换句话说，Spider就是定义爬取的动作及分析某个网页(或者是有些网页)的地方。</li>\n</ul>\n<h4 id=\"定义数据容器items\"><a href=\"#定义数据容器items\" class=\"headerlink\" title=\"定义数据容器items\"></a>定义数据容器items</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> scrapy</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShoeCommentItem</span><span class=\"params\">(scrapy.Item)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># define the fields for your item here like:</span></span><br><span class=\"line\">    <span class=\"comment\"># name = scrapy.Field()</span></span><br><span class=\"line\">    _id = scrapy.Field()</span><br><span class=\"line\">    iid = scrapy.Field()</span><br><span class=\"line\">    uid = scrapy.Field()</span><br><span class=\"line\">    creation_time = scrapy.Field()</span><br><span class=\"line\">    score = scrapy.Field()</span><br><span class=\"line\">    user_province = scrapy.Field()</span><br><span class=\"line\">    user_level = scrapy.Field()</span><br><span class=\"line\">    color = scrapy.Field()</span><br><span class=\"line\">    size = scrapy.Field()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShoeDetailItem</span><span class=\"params\">(scrapy.Item)</span>:</span></span><br><span class=\"line\">    iid = scrapy.Field()</span><br><span class=\"line\">    name = scrapy.Field()</span><br><span class=\"line\">    shop = scrapy.Field()</span><br><span class=\"line\">    scores = scrapy.Field()</span><br></pre></td></tr></table></figure>\n<h4 id=\"定义爬虫类\"><a href=\"#定义爬虫类\" class=\"headerlink\" title=\"定义爬虫类\"></a>定义爬虫类</h4><p>创建爬虫类的命令为:<code>scrapy genspider [爬虫名] [允许爬取域名]</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ scrapy genspider shoes jd.com</span><br><span class=\"line\">Created spider &apos;shoes&apos; using template &apos;basic&apos; in module:</span><br><span class=\"line\">  jd.spiders.shoes</span><br></pre></td></tr></table></figure>\n<p>接着打开<code>spiders</code>文件夹下的<code>shoes.py</code>文件进行编辑:</p>\n<ul>\n<li><p>首先我们需要定义一些变量，比如包含搜索关键字的列表、格式化搜索链接、格式化评论API链接等:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shoe_cates = [</span><br><span class=\"line\">    <span class=\"string\">'女深口单鞋'</span>, <span class=\"string\">'工装鞋'</span>, <span class=\"string\">'女鞋'</span>, <span class=\"string\">'正装鞋'</span>, <span class=\"string\">'平底鞋'</span>, <span class=\"string\">'平底女鞋'</span>,</span><br><span class=\"line\">    <span class=\"string\">'功能鞋'</span>, <span class=\"string\">'中跟单鞋'</span>, <span class=\"string\">'女拖鞋'</span>, <span class=\"string\">'凉鞋'</span>, <span class=\"string\">'拖鞋'</span>, <span class=\"string\">'帆布鞋'</span>, <span class=\"string\">'人字拖'</span>,</span><br><span class=\"line\">    <span class=\"string\">'马丁靴'</span>, <span class=\"string\">'商务休闲鞋'</span>, <span class=\"string\">'传统布鞋'</span>, <span class=\"string\">'休闲鞋'</span>, <span class=\"string\">'鞋'</span>, <span class=\"string\">'棉鞋'</span>, <span class=\"string\">'定制鞋'</span>,</span><br><span class=\"line\">    <span class=\"string\">'男靴'</span>, <span class=\"string\">'坡跟单鞋'</span>, <span class=\"string\">'短靴'</span>, <span class=\"string\">'雨鞋'</span>, <span class=\"string\">'平板鞋'</span>, <span class=\"string\">'尖头单鞋'</span>, <span class=\"string\">'军靴'</span>, <span class=\"string\">'女靴'</span>,</span><br><span class=\"line\">    <span class=\"string\">'皮鞋'</span>, <span class=\"string\">'小白鞋'</span>, <span class=\"string\">'雪地靴'</span>, <span class=\"string\">'女豆豆鞋'</span>, <span class=\"string\">'妈妈鞋'</span>, <span class=\"string\">'增高鞋'</span>, <span class=\"string\">'劳保鞋'</span>,</span><br><span class=\"line\">    <span class=\"string\">'豆豆鞋'</span>, <span class=\"string\">'踝靴'</span>, <span class=\"string\">'沙滩鞋'</span>, <span class=\"string\">'鞋 女'</span>, <span class=\"string\">'深口单鞋'</span>, <span class=\"string\">'板鞋'</span>, <span class=\"string\">'高帮鞋'</span>,</span><br><span class=\"line\">    <span class=\"string\">'人字拖鞋'</span>, <span class=\"string\">'内增高'</span>, <span class=\"string\">'发光鞋'</span>, <span class=\"string\">'运动鞋'</span>, <span class=\"string\">'高跟鞋'</span>, <span class=\"string\">'雨靴'</span>, <span class=\"string\">'鞋 男'</span>,</span><br><span class=\"line\">    <span class=\"string\">'乐福鞋'</span>, <span class=\"string\">'内增高休闲鞋'</span>, <span class=\"string\">'老人鞋'</span>, <span class=\"string\">'男鞋'</span>, <span class=\"string\">'平底单鞋'</span>, <span class=\"string\">'浅口单鞋'</span>, <span class=\"string\">'单鞋'</span>]</span><br><span class=\"line\">shoe_list_url = <span class=\"string\">'https://search.jd.com/Search?keyword=&#123;&#125;&amp;enc=utf-8&amp;page=&#123;&#125;'</span></span><br><span class=\"line\">comment_url_api = (<span class=\"string\">'https://club.jd.com/comment/productPageComments.action?'</span></span><br><span class=\"line\">    <span class=\"string\">'productId=&#123;&#125;&amp;score=0&amp;sortType=5&amp;page=&#123;&#125;&amp;pageSize=10&amp;isShadowSku=0'</span>)</span><br><span class=\"line\">num_pat = re.compile(<span class=\"string\">'(\\d*?)'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后编辑<code>ShoesSpider</code>类:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShoesSpider</span><span class=\"params\">(Spider)</span>:</span></span><br><span class=\"line\">    name = <span class=\"string\">'shoes'</span></span><br><span class=\"line\">    allowed_domains = [<span class=\"string\">'jd.com'</span>]</span><br><span class=\"line\">    start_urls = [shoe_list_url.format(cate, page) <span class=\"keyword\">for</span> cate <span class=\"keyword\">in</span> shoe_cates</span><br><span class=\"line\">                  <span class=\"keyword\">for</span> page <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">101</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        item_urls = response.xpath(<span class=\"string\">'//li[@class=\"gl-item\"]/div'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> item_xpath <span class=\"keyword\">in</span> item_urls:</span><br><span class=\"line\">            url = item_xpath.xpath(<span class=\"string\">'div[@class=\"p-img\"]/a'</span></span><br><span class=\"line\">                                   <span class=\"string\">'/@href'</span>).extract_first()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> url <span class=\"keyword\">or</span> <span class=\"string\">'ccc-x'</span> <span class=\"keyword\">in</span> url:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            iid = url[url.rfind(<span class=\"string\">'/'</span>)+<span class=\"number\">1</span>:<span class=\"number\">-5</span>]</span><br><span class=\"line\">            detail_url = <span class=\"string\">'http:'</span> + url</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> Request(</span><br><span class=\"line\">                detail_url,</span><br><span class=\"line\">                callback=self.parse_detail,</span><br><span class=\"line\">                meta=&#123;<span class=\"string\">'iid'</span>: iid&#125;)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> Request(</span><br><span class=\"line\">                comment_url_api.format(iid, <span class=\"number\">1</span>),</span><br><span class=\"line\">                callback=self.parse_comment,</span><br><span class=\"line\">                meta=&#123;<span class=\"string\">'page'</span>: <span class=\"number\">1</span>, <span class=\"string\">'iid'</span>: iid, <span class=\"string\">'retry'</span>: <span class=\"number\">0</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_detail</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        iid = int(response.meta[<span class=\"string\">'iid'</span>])</span><br><span class=\"line\">        name = response.xpath(<span class=\"string\">'//div[@class=\"sku-name\"]'</span></span><br><span class=\"line\">                              <span class=\"string\">'/text()'</span>).extract_first().strip(<span class=\"string\">'\\n '</span>)</span><br><span class=\"line\">        xpath_aside = response.xpath(<span class=\"string\">'//div[@class=\"aside\"]'</span>)</span><br><span class=\"line\">        shop = xpath_aside.xpath(<span class=\"string\">'//div[@class=\"mt\"]/'</span></span><br><span class=\"line\">                                 <span class=\"string\">'h3/a/@title'</span>).extract_first().strip(<span class=\"string\">'\\n '</span>)</span><br><span class=\"line\">        scores = xpath_aside.xpath(<span class=\"string\">'//div[@class=\"mc\"]/div/'</span></span><br><span class=\"line\">                                   <span class=\"string\">'a//text()'</span>).extract()</span><br><span class=\"line\">        scores = [s <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> scores <span class=\"keyword\">if</span> s.strip(<span class=\"string\">'\\n '</span>)][::<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        sd = ShoeDetailItem(iid=iid, name=name, shop=shop,</span><br><span class=\"line\">                            scores=<span class=\"string\">'|'</span>.join(scores))</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> sd</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_comment</span><span class=\"params\">(self, response)</span>:</span></span><br><span class=\"line\">        iid = response.meta[<span class=\"string\">'iid'</span>]</span><br><span class=\"line\">        page = int(response.meta[<span class=\"string\">'page'</span>])</span><br><span class=\"line\">        retry = int(response.meta[<span class=\"string\">'retry'</span>])</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            json_data = json.loads(response.text)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> retry &lt; <span class=\"number\">10</span>:</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> Request(</span><br><span class=\"line\">                    comment_url_api.format(iid, page),</span><br><span class=\"line\">                    callback=self.parse_comment,</span><br><span class=\"line\">                    meta=&#123;<span class=\"string\">'page'</span>: page, <span class=\"string\">'iid'</span>: iid, <span class=\"string\">'retry'</span>: retry+<span class=\"number\">1</span>&#125;)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> json_data[<span class=\"string\">'comments'</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> cd <span class=\"keyword\">in</span> json_data[<span class=\"string\">'comments'</span>]:</span><br><span class=\"line\">            d = &#123;&#125;</span><br><span class=\"line\">            d[<span class=\"string\">'_id'</span>] = cd[<span class=\"string\">'id'</span>]</span><br><span class=\"line\">            d[<span class=\"string\">'iid'</span>] = cd[<span class=\"string\">'referenceId'</span>]</span><br><span class=\"line\">            d[<span class=\"string\">'uid'</span>] = cd[<span class=\"string\">'guid'</span>]</span><br><span class=\"line\">            d[<span class=\"string\">'creation_time'</span>] = cd[<span class=\"string\">'creationTime'</span>]</span><br><span class=\"line\">            d[<span class=\"string\">'score'</span>] = cd[<span class=\"string\">'score'</span>]</span><br><span class=\"line\">            d[<span class=\"string\">'user_province'</span>] = cd[<span class=\"string\">'userProvince'</span>]</span><br><span class=\"line\">            d[<span class=\"string\">'user_level'</span>] = cd[<span class=\"string\">'userLevelName'</span>]</span><br><span class=\"line\">            d[<span class=\"string\">'color'</span>] = cd[<span class=\"string\">'productColor'</span>]</span><br><span class=\"line\">            d[<span class=\"string\">'size'</span>] = cd[<span class=\"string\">'productSize'</span>]</span><br><span class=\"line\">            sc = ShoeCommentItem(d)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> sc</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> Request(</span><br><span class=\"line\">            comment_url_api.format(iid, page+<span class=\"number\">1</span>),</span><br><span class=\"line\">            callback=self.parse_comment,</span><br><span class=\"line\">            meta=&#123;<span class=\"string\">'page'</span>: page+<span class=\"number\">1</span>, <span class=\"string\">'iid'</span>: iid, <span class=\"string\">'retry'</span>: <span class=\"number\">0</span>&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>详细分析下这段代码:</p>\n<ul>\n<li>类<code>ShoesSpider</code>继承自<code>Spider</code>，其余可继承的类还有<code>CrawlSpider</code>、<code>XMLFeedSpider</code>、<code>SitemapSpider</code>，在这里我们使用了最基本的<code>Spider</code>。</li>\n<li>属性<code>name</code>定义了该爬虫的名字，在启动爬虫的步骤中需要提供爬虫名字。</li>\n<li>属性<code>allowed_domains</code>定义了一个列表，可以包含一个或多个域名，爬虫只会对该域名下的链接进行爬取。</li>\n<li>属性<code>start_urls</code>定义了一个列表，spider启动时将从中获取链接进行爬取。</li>\n<li>实例方法<code>parse</code>定义了对商品列表页面进行处理的相关逻辑:<ul>\n<li>接收一个<code>response</code>参数，该<code>response</code>对象为爬虫根据<code>Request</code>对象请求获得的结果。</li>\n<li>根据前面几节的描述，<code>parse</code>方法针对商品列表页面使用xpath进行分析。</li>\n<li>在提取到商品<code>iid</code>后，对该页面下所有商品<code>iid</code>进行遍历，分别为商品详细页面(可选)以及商品评论页面构建<code>Request</code>请求，注意使用了<code>yield</code>，因为我们需要返回多个请求而不是一个请求。</li>\n<li>对每个<code>Request</code>请求，我们指定了相关参数，比如链接、回调函数，以及通过<code>meta</code>关键字保存上下文信息字典，这可以在回调函数中访问<code>Response</code>的<code>meta</code>属性获得。</li>\n</ul>\n</li>\n<li>实例方法<code>parse_detail</code>定义了对商品详细页面进行处理的相关逻辑:<ul>\n<li>我们依然通过xpath进行分析，获得了商品名、商家名、商家评分等信息，使用其实例化<code>ShoeDetailItem</code>类并返回该实例。</li>\n</ul>\n</li>\n<li>实例方法<code>parse_comment</code>定义了对商品评论进行处理的相关逻辑:<ul>\n<li>根据在<code>Request</code>对象中设置<code>meta</code>属性，我们可以很方便地获得当前物品id、当前评论页码、以及访问重试次数。</li>\n<li>我们需要对<code>response</code>对象的<code>text</code>属性使用<code>json.loads</code>进行格式化，但是由于各种原因可能会失败，所以我们设置了方式重试次数这一变量来控制重试，当本次<code>json.loads</code>格式化失败，我们会再次进行尝试访问该评论链接，直到达到最大重试次数10次，然后放弃。</li>\n<li>如果解析成功，判断解析后的字典中键<code>comments</code>所对应的内容是否为空，为空代表已经没有更多评论，则返回。</li>\n<li>否则，对每条评论进行遍历，使用其中的参数实例化<code>ShoeCommentItem</code>类并返回该实例。</li>\n<li>在结束评论遍历后，尝试对评论下一页发出<code>Request</code>请求。</li>\n</ul>\n</li>\n</ul>\n<p>至此，我们完成了爬虫的工作逻辑，接下来需要对流水线进行定义，完成数据的查重以及保存等操作。</p>\n<h4 id=\"定义pipeline流水线\"><a href=\"#定义pipeline流水线\" class=\"headerlink\" title=\"定义pipeline流水线\"></a>定义pipeline流水线</h4><p>对于各个<code>parse</code>方法返回的<code>Item</code>对象，它们将会被传递到在<code>pipelines.py</code>中定义以及<code>settings.py</code>中启用的流水线中进行处理。<br>在本文中我们需要对每个<code>Item</code>对象做两件事，去重以及保存。对于<code>ShoeCommentItem</code>的流水线定义如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShoeCommentPipeline</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    seen_ids = set()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">from_crawler</span><span class=\"params\">(cls, crawler)</span>:</span></span><br><span class=\"line\">        pipe = cls()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(<span class=\"string\">'shoe_comments.csv'</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> pipe</span><br><span class=\"line\">        pat = re.compile(<span class=\"string\">'^\\d+?,'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">with</span> open(<span class=\"string\">'shoe_comments.csv'</span>, <span class=\"string\">'r'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> f:</span><br><span class=\"line\">                _id = pat.findall(line)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> _id:</span><br><span class=\"line\">                    pipe.seen_ids.add(_id[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pipe</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_item</span><span class=\"params\">(self, item, spider)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> isinstance(item, ShoeCommentItem):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> item</span><br><span class=\"line\"></span><br><span class=\"line\">        _id = item[<span class=\"string\">'_id'</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> _id <span class=\"keyword\">in</span> self.seen_ids:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> DropItem(<span class=\"string\">'&#123;&#125; Have been processed.'</span>.format(_id))</span><br><span class=\"line\">        self.seen_ids.add(_id)</span><br><span class=\"line\"></span><br><span class=\"line\">        key_values = list(item.items())</span><br><span class=\"line\">        key_values.sort(key=<span class=\"keyword\">lambda</span> x: val_indices[x[<span class=\"number\">0</span>]])</span><br><span class=\"line\">        values = [str(val) <span class=\"keyword\">for</span> key, val <span class=\"keyword\">in</span> key_values]</span><br><span class=\"line\">        <span class=\"keyword\">with</span> open(<span class=\"string\">'shoe_comments.csv'</span>, <span class=\"string\">'a'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            f.write(<span class=\"string\">','</span>.join(values)+<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> item</span><br></pre></td></tr></table></figure>\n<p>需要解释的是类方法<code>from_crawler</code>和实例方法<code>process_item</code>，前者在初始化时会被调用，后者在出现<code>Item</code>对象时被调用。<br>对于<code>from_crawler</code>方法:</p>\n<ul>\n<li>我们需要忽略之前已经处理过的评论，因此采用了一个<code>set</code>来存储已经处理过的<code>id</code></li>\n<li>在初始化时，打开之前保存的评论文件<code>shoe_comments.csv</code>，从中获取<code>id</code>并对<code>seen_ids</code>进行填充</li>\n<li>这是一个类方法，需要在最后返回类的实例</li>\n</ul>\n<p>对于<code>process_item</code>方法:</p>\n<ul>\n<li>方法接收两个参数，前一个是返回的<code>Item</code>对象，后一个是返回该对象的对应<code>Spider</code>对象</li>\n<li>首先判断了该<code>Item</code>是否是类<code>ShoeCommentItem</code>实例，如果不是的话不进行处理直接返回该对象</li>\n<li>提取该对象的<code>id</code>并判断该对象是否已经处理过，已经处理过的话抛出<code>DropItem</code>异常，停止后续流水线的处理</li>\n<li>将该对象<code>id</code>加入<code>seen_ids</code>，并根据<code>val_indices</code>定义的顺序将其排序及格式化字符串并追加到<code>shoe_comments.csv</code>中</li>\n<li>返回该对象</li>\n</ul>\n<blockquote>\n<p>需要特别注意的是，<code>process_item</code>方法必须返回一个<code>Item</code>(或任何继承类)对象或者是抛出<code>DropItem</code>异常，被丢弃的item将不会被之后的pipeline组件所处理，而正常返回的会。</p>\n</blockquote>\n<p>同理我们可以定义<code>ShoeDetailItem</code>的流水线:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShoeDetailPipeline</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    seen_ids = set()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">from_crawler</span><span class=\"params\">(cls, crawler)</span>:</span></span><br><span class=\"line\">        pipe = cls()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(<span class=\"string\">'shoe_details.csv'</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> pipe</span><br><span class=\"line\">        pat = re.compile(<span class=\"string\">'^\\d+?,'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">with</span> open(<span class=\"string\">'shoe_details.csv'</span>, <span class=\"string\">'r'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> f:</span><br><span class=\"line\">                iid = pat.findall(line)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> iid:</span><br><span class=\"line\">                    pipe.seen_ids.add(iid[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pipe</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_item</span><span class=\"params\">(self, item, spider)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> isinstance(item, ShoeDetailItem):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> item</span><br><span class=\"line\"></span><br><span class=\"line\">        iid = item[<span class=\"string\">'iid'</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> iid <span class=\"keyword\">in</span> self.seen_ids:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> DropItem(<span class=\"string\">'&#123;&#125; detail have been processed.'</span>.format(iid))</span><br><span class=\"line\">        self.seen_ids.add(iid)</span><br><span class=\"line\"></span><br><span class=\"line\">        key_values = list(item.items())</span><br><span class=\"line\">        key_values.sort(key=<span class=\"keyword\">lambda</span> x: detail_indices[x[<span class=\"number\">0</span>]])</span><br><span class=\"line\">        values = [str(val) <span class=\"keyword\">for</span> key, val <span class=\"keyword\">in</span> key_values]</span><br><span class=\"line\">        <span class=\"keyword\">with</span> open(<span class=\"string\">'shoe_details.csv'</span>, <span class=\"string\">'a'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            f.write(<span class=\"string\">','</span>.join(values)+<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> item</span><br></pre></td></tr></table></figure>\n<p>该流水线逻辑与前一个类似，在此不再赘述。</p>\n<h4 id=\"settings-py的配置\"><a href=\"#settings-py的配置\" class=\"headerlink\" title=\"settings.py的配置\"></a>settings.py的配置</h4><p>我们还需要对<code>settings.py</code>进行配置。<br>其中关键的几个设置是:</p>\n<ul>\n<li>CONCURRENT_REQUESTS(并发请求数): 100</li>\n<li>COOKIES_ENABLED(启用cookies): False</li>\n<li>ITEM_PIPELINES(item流水线): {‘jd.pipelines.ShoeCommentPipeline’: 300, ‘jd.pipelines.ShoeDetailPipeline’: 301}</li>\n</ul>\n<p>具体设置可以根据自己的需求进行设置，以上只是一个示例。</p>\n<h4 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h4><p>最后，让我们启动这个爬虫:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ scrapy crawl shoes</span><br></pre></td></tr></table></figure>\n<p>可以在控制台看到输出:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2017-03-13 19:21:12 [scrapy.utils.log] INFO: Scrapy 1.3.0 started (bot: jd)</span><br><span class=\"line\">2017-03-13 19:21:12 [scrapy.utils.log] INFO: Overridden settings: &#123;&apos;BOT_NAME&apos;: &apos;jd&apos;, &apos;CONCURRENT_REQUESTS&apos;: 100, &apos;COOKIES_ENABLED&apos;: False, &apos;DOWNLOAD_DELAY&apos;: 0.01, &apos;NEWSPIDER_MODULE&apos;: &apos;jd.spiders&apos;, &apos;SPIDER_MODULES&apos;: [&apos;jd.spiders&apos;]&#125;</span><br><span class=\"line\">2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled extensions:</span><br><span class=\"line\">[&apos;scrapy.extensions.corestats.CoreStats&apos;,</span><br><span class=\"line\"> &apos;scrapy.extensions.telnet.TelnetConsole&apos;,</span><br><span class=\"line\"> &apos;scrapy.extensions.logstats.LogStats&apos;]</span><br><span class=\"line\">2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled downloader middlewares:</span><br><span class=\"line\">[&apos;scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.downloadermiddlewares.useragent.UserAgentMiddleware&apos;,</span><br><span class=\"line\"> &apos;jd.middlewares.RandomUserAgentMiddleware&apos;,</span><br><span class=\"line\"> &apos;jd.middlewares.ProxyMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.downloadermiddlewares.retry.RetryMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.downloadermiddlewares.redirect.RedirectMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.downloadermiddlewares.stats.DownloaderStats&apos;]</span><br><span class=\"line\">2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled spider middlewares:</span><br><span class=\"line\">[&apos;scrapy.spidermiddlewares.httperror.HttpErrorMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.spidermiddlewares.offsite.OffsiteMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.spidermiddlewares.referer.RefererMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.spidermiddlewares.urllength.UrlLengthMiddleware&apos;,</span><br><span class=\"line\"> &apos;scrapy.spidermiddlewares.depth.DepthMiddleware&apos;]</span><br><span class=\"line\">2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled item pipelines:</span><br><span class=\"line\">[&apos;jd.pipelines.ShoeCommentPipeline&apos;, &apos;jd.pipelines.ShoeDetailPipeline&apos;]</span><br><span class=\"line\">2017-03-13 19:21:12 [scrapy.core.engine] INFO: Spider opened</span><br><span class=\"line\">2017-03-13 19:21:12 [scrapy.extensions.logstats] INFO: Crawled 0 pages (at 0 pages/min), scraped 0 items (at 0 items/min)</span><br><span class=\"line\">2017-03-13 19:21:12 [scrapy.extensions.telnet] DEBUG: Telnet console listening on 127.0.0.1:6023</span><br><span class=\"line\">2017-03-13 19:21:13 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=3&gt; (referer: None)</span><br><span class=\"line\">2017-03-13 19:21:13 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=7&gt; (referer: None)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=6&gt; (referer: None)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=9&gt; (referer: None)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=5&gt; (referer: None)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=10&gt; (referer: None)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=2&gt; (referer: None)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=1&gt; (referer: None)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.dupefilters] DEBUG: Filtered duplicate request: &lt;GET http://item.jd.com/10536835318.html&gt; - no more duplicates will be shown (see DUPEFILTER_DEBUG to show all duplicates)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=8&gt; (referer: None)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET http://item.jd.com/10536835318.html&gt; (referer: https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=6)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://club.jd.com/comment/productPageComments.action?productId=10589923020&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0&gt; (referer: https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=7)</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 http://item.jd.com/10536835318.html&gt;</span><br><span class=\"line\">&#123;&apos;iid&apos;: 10536835318,</span><br><span class=\"line\"> &apos;name&apos;: &apos;她芙 单鞋女2017春季新款中跟短靴女时尚女鞋性感尖头细跟单鞋深口裸靴防水台高跟鞋 黑色 37-标准码&apos;,</span><br><span class=\"line\"> &apos;scores&apos;: &apos;9.72|9.75|9.65|9.63&apos;,</span><br><span class=\"line\"> &apos;shop&apos;: &apos;卡曼鞋类专营店&apos;&#125;</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 https://club.jd.com/comment/productPageComments.action?productId=10589923020&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0&gt;</span><br><span class=\"line\">&#123;&apos;_id&apos;: 10199823376,</span><br><span class=\"line\"> &apos;color&apos;: &apos;金黑色.&apos;,</span><br><span class=\"line\"> &apos;creation_time&apos;: &apos;2017-03-10 13:59:31&apos;,</span><br><span class=\"line\"> &apos;iid&apos;: &apos;10589923020&apos;,</span><br><span class=\"line\"> &apos;score&apos;: 5,</span><br><span class=\"line\"> &apos;size&apos;: &apos;36&apos;,</span><br><span class=\"line\"> &apos;uid&apos;: &apos;069d0baa-022b-421b-a43a-584f5aa3921e&apos;,</span><br><span class=\"line\"> &apos;user_level&apos;: &apos;铜牌会员&apos;,</span><br><span class=\"line\"> &apos;user_province&apos;: &apos;&apos;&#125;</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 https://club.jd.com/comment/productPageComments.action?productId=10589923020&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0&gt;</span><br><span class=\"line\">&#123;&apos;_id&apos;: 10175008135,</span><br><span class=\"line\"> &apos;color&apos;: &apos;金黑色.&apos;,</span><br><span class=\"line\"> &apos;creation_time&apos;: &apos;2017-03-02 12:18:57&apos;,</span><br><span class=\"line\"> &apos;iid&apos;: &apos;10589923020&apos;,</span><br><span class=\"line\"> &apos;score&apos;: 5,</span><br><span class=\"line\"> &apos;size&apos;: &apos;36&apos;,</span><br><span class=\"line\"> &apos;uid&apos;: &apos;28dfd6c2-caf2-427d-9927-cf088d3099ea&apos;,</span><br><span class=\"line\"> &apos;user_level&apos;: &apos;铜牌会员&apos;,</span><br><span class=\"line\"> &apos;user_province&apos;: &apos;湖南&apos;&#125;</span><br><span class=\"line\">2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 https://club.jd.com/comment/productPageComments.action?productId=10589923020&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0&gt;</span><br><span class=\"line\">&#123;&apos;_id&apos;: 10163486837,</span><br><span class=\"line\"> &apos;color&apos;: &apos;金黑色.&apos;,</span><br><span class=\"line\"> &apos;creation_time&apos;: &apos;2017-02-26 15:28:14&apos;,</span><br><span class=\"line\"> &apos;iid&apos;: &apos;10589923020&apos;,</span><br><span class=\"line\"> &apos;score&apos;: 5,</span><br><span class=\"line\"> &apos;size&apos;: &apos;36&apos;,</span><br><span class=\"line\"> &apos;uid&apos;: &apos;736ad5a4-9470-4dcc-832d-b59094cf84f4&apos;,</span><br><span class=\"line\"> &apos;user_level&apos;: &apos;铜牌会员&apos;,</span><br><span class=\"line\"> &apos;user_province&apos;: &apos;云南&apos;&#125;</span><br></pre></td></tr></table></figure>\n<p>在运行一段时间后，查看<code>shoe_comments.csv</code>和<code>shoe_details.csv</code>内容:</p>\n<ul>\n<li><p><code>shoe_comments.csv</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10199823376,10589923020,069d0baa-022b-421b-a43a-584f5aa3921e,2017-03-10 13:59:31,5,,铜牌会员,金黑色.,36</span><br><span class=\"line\">10175008135,10589923020,28dfd6c2-caf2-427d-9927-cf088d3099ea,2017-03-02 12:18:57,5,湖南,铜牌会员,金黑色.,36</span><br><span class=\"line\">10163486837,10589923020,736ad5a4-9470-4dcc-832d-b59094cf84f4,2017-02-26 15:28:14,5,云南,铜牌会员,金黑色.,36</span><br><span class=\"line\">10205838152,10589923020,93f35818-129f-4aaa-8ea9-549c28a4f791,2017-03-12 14:37:59,5,,注册会员,金黑色.,36</span><br><span class=\"line\">10175298549,10589923020,fe1a26e0-8cae-43c3-b0d4-c99bf1d961cf,2017-03-02 13:49:07,5,,铜牌会员,金黑色.,36</span><br><span class=\"line\">10205858068,10589923020,65a7243e-7116-4075-b64a-6e8d8d8382a4,2017-03-12 14:44:29,5,,铜牌会员,金黑色.,36</span><br><span class=\"line\">10206280836,10589923020,1d9b5332-5ca6-40be-b408-250606f68c17,2017-03-12 17:00:48,5,,注册会员,金黑色.,36</span><br><span class=\"line\">10200243913,10589923020,966cda26-ce10-432a-8309-95199ad1903e,2017-03-10 16:15:02,5,,铜牌会员,金黑色.,36</span><br><span class=\"line\">10164313667,10589923020,d09eab89-ed53-47a3-abd1-c897a8bcf694,2017-02-26 20:15:01,5,北京,铜牌会员,金黑色.,36</span><br><span class=\"line\">10162862191,10589923020,ddb58374-f48b-45f9-a2a6-e5e60d53d4ce,2017-02-26 11:42:58,5,,铜牌会员,金黑色.,36</span><br><span class=\"line\">10149921178,11242420873,5f410ce9-fc38-4736-8465-88bbdd7da347,2017-02-21 19:45:56,5,上海,铜牌会员,70060黑色,36</span><br><span class=\"line\">10143787582,11242420873,3f15f14f-1d37-4ccb-befa-9acccd22a3d1,2017-02-19 19:07:20,5,海南,铜牌会员,70060黑色,36</span><br><span class=\"line\">10150729539,11242420873,a601a457-1cef-41c4-955b-3df3dd2646ec,2017-02-22 07:32:52,5,新疆,铜牌会员,70060黑色,36</span><br><span class=\"line\">10147517331,11242420873,b50e1e32-e1fe-4084-b95a-71be8a720950,2017-02-20 23:29:52,5,北京,铜牌会员,70060黑色,36</span><br><span class=\"line\">10147357719,11242420873,fe6ec9de-c39b-4d5e-9cee-bf5926abb465,2017-02-20 22:18:46,5,湖南,铜牌会员,70060黑色,36</span><br><span class=\"line\">10187242860,11242420873,f12f02f7-b378-457f-a501-cdd81f69de6c,2017-03-06 13:53:31,5,云南,铜牌会员,70060黑色,36</span><br><span class=\"line\">10203999129,11242420873,f61e40df-f919-43a2-b876-e81176d59cf9,2017-03-11 20:55:40,5,内蒙古,注册会员,70060黑色,36</span><br><span class=\"line\">10203827884,11242420873,4a73b3d7-b489-4880-8f8a-bc70015c4e18,2017-03-11 19:55:57,5,浙江,注册会员,70060黑色,36</span><br><span class=\"line\">10203810598,11242420873,4113c7e0-4556-4aa1-b441-2334bd5419d4,2017-03-11 19:49:51,5,安徽,注册会员,70060黑色,36</span><br><span class=\"line\">10203802320,11242420873,38a65bba-5284-4190-83f2-1a6a54d57da3,2017-03-11 19:46:57,5,广西,注册会员,70060黑色,36</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>shoe_details.csv</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10536835318,她芙 单鞋女2017春季新款中跟短靴女时尚女鞋性感尖头细跟单鞋深口裸靴防水台高跟鞋 黑色 37-标准码,卡曼鞋类专营店,9.72|9.75|9.65|9.63</span><br><span class=\"line\">1587186408,雅诗莱雅休闲鞋女 圆头深口低帮鞋 拼色厚底女鞋 系带防水台女鞋子 GH852Q0红色 37,宏嘉男鞋专营店,9.79|9.80|9.74|9.76</span><br><span class=\"line\">10536835318,她芙 单鞋女2017春季新款中跟短靴女时尚女鞋性感尖头细跟单鞋深口裸靴防水台高跟鞋 黑色 37-标准码,卡曼鞋类专营店,9.72|9.75|9.65|9.63</span><br><span class=\"line\">11242420873,百芙蓉单鞋女中跟2017春季新款粗跟英伦风小皮鞋女春季新款圆头深口妈妈工作韩版潮厚底 70060黑色 36,百芙蓉鞋类旗舰店,9.88|9.81|9.83|9.84</span><br><span class=\"line\">11157498264,圆头深口低帮鞋2017年秋冬新款纯色系带坡跟女鞋防水台女鞋子 1343黑色 36,马登尔鞋靴专营店,9.78|9.81|9.75|9.76</span><br><span class=\"line\">10638093860,爱思图牛津鞋英伦风皮鞋女中跟秋季女鞋粗跟单鞋大头皮鞋圆头学生鞋小皮鞋平底鞋潮妈妈鞋女生鞋子 黑色ML6X303 36,爱思图旗舰店,9.72|9.76|9.71|9.70</span><br><span class=\"line\">10574081025,佩尼泰深口单鞋女头层牛皮尖头单鞋中跟粗跟 OL工作职业鞋大小码女鞋春季新款 灰色 38,佩尼泰旗舰店,9.68|9.73|9.67|9.66</span><br><span class=\"line\">10459020322,瑞蓓妮真皮女鞋2017新款魔术贴深口单鞋女平底舒适休闲鞋大码防滑中老年妈妈鞋 黑色单鞋 38,瑞蓓妮旗舰店,9.70|9.75|9.65|9.65</span><br><span class=\"line\">11273711543,细跟高跟鞋女2017春季新款尖头单鞋女深口高跟女士英伦厚底防水台工作女鞋 红色 37,家兴福鞋业专营店,9.87|9.82|9.80|9.81</span><br><span class=\"line\">11226902308,粗跟单鞋女2017春季新款女鞋OL尖头高跟鞋深口工作鞋女士皮鞋水钻百搭鞋子女 DH3658黑色 37,彬度鸟鞋靴旗舰店,9.89|9.83|9.83|9.84</span><br><span class=\"line\">11210447351,她芙 单鞋女2017春季新款单鞋粗跟女鞋子系带厚底高跟鞋深口学生休闲低帮鞋 绿色 37,她芙旗舰店,9.77|9.77|9.67|9.68</span><br><span class=\"line\">11239261516,AUSDU休闲鞋女圆头平底深口单鞋粗跟厚底2017春款韩版百搭舒适女鞋妈妈绑带学生 70030黑色 36,AUSDU鞋类旗舰店,9.87|9.80|9.81|9.82</span><br><span class=\"line\">11267204558,丹芭莎春季女鞋2017新品纯色深口鞋女韩版圆头高跟鞋粗跟防水台单鞋女潮鞋 M70050黑色 37,丹芭莎旗舰店,9.84|9.81|9.79|9.80</span><br><span class=\"line\">10687936751,fullmir内增高休闲鞋女士小白鞋2016秋季新款厚底鞋韩版潮流低帮学生运动鞋子单鞋 红 色 37,fullmir鞋类旗舰店,9.61|9.66|9.58|9.58</span><br><span class=\"line\">11167186789,新款单鞋女2017秋季时尚漆皮圆头低帮休闲鞋秋鞋 工作鞋套脚欧美低跟皮鞋 黑色6119 34,艾琳艺鞋类专营店,9.67|9.79|9.67|9.69</span><br><span class=\"line\">11227438800,意米思时尚女鞋圆头高跟鞋粗跟妈妈鞋深口单鞋女2017春秋新款韩版百搭小皮鞋防水台鞋子女 莫70050黑色 36,意米思旗舰店,9.72|9.81|9.79|9.80</span><br><span class=\"line\">11250120847,邻家天使细跟单鞋2017春季新款尖头欧美皮鞋深口高跟女鞋春秋款鞋子 LJ619黑色 39标码,邻家天使鞋类旗舰店,9.69|9.74|9.65|9.66</span><br><span class=\"line\">11193717829,单鞋女2017春季新款韩版高跟防水台粗跟女鞋尖头深口水钻通勤OL工作小皮鞋女 邻1231黑色 37,NEB ANGEL梓赢专卖店,9.78|9.78|9.74|9.75</span><br><span class=\"line\">11166169416,金丝兔尖头单鞋女2017春季新品深口金属超高跟鞋欧美时尚细跟女鞋百搭小皮鞋工作鞋 黑色 36,金丝兔广汇达专卖店,9.89|9.83|9.83|9.84</span><br><span class=\"line\">10617152040,ZHR小皮鞋真皮小白鞋女深口单鞋平底护士工作鞋潮 白色 39,零邦鞋靴专营店,9.69|9.68|9.69|9.69</span><br><span class=\"line\">1471841136,宝思特2017春季新款真皮平底平跟休闲女单鞋软牛皮软底妈妈鞋花朵跳舞鞋加大码女鞋子 黑色 39,宝思特旗舰店,9.75|9.74|9.65|9.65</span><br><span class=\"line\">11204372265,霍尔世家 深口单鞋女粗跟高跟鞋2017春季新款英伦风真皮尖头女鞋防水台 黑色 37,霍尔世家旗舰店,9.64|9.70|9.63|9.64</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>至此，我们完成了整个数据的爬取工作。</p>\n<h1 id=\"接下来的工作\"><a href=\"#接下来的工作\" class=\"headerlink\" title=\"接下来的工作\"></a>接下来的工作</h1><p>有经验的读者可以看出来，本文完成的爬虫是较为基础的爬虫，不涉及到Scrapy高级的特性，也不涉及到反爬虫的内容，对于感兴趣的读者，可以从以下几个方面继续深入。</p>\n<ol>\n<li>由于京东对爬虫爬取评论并没有反爬措施，所以本文没有涉及到反爬的内容，不过在编写该爬虫的时候有考虑到这部分内容，所以编写了中间件来完成<code>User-Agent</code>的随机设置以及使用代理池来分散请求等简单的反爬措施，有兴趣的读者可以查阅Github源代码。</li>\n<li>对于较大的爬取工作，可以考虑使用<code>scrapy-redis</code>等工具来构建分布式爬虫，以增加爬取效率。</li>\n<li>在获得大量的数据之后，可以使用<code>matplotlib</code>等工具对数据进行可视化分析。</li>\n</ol>\n<p>以上就是本文的全部内容，有兴趣的读者可以查阅Github并下载源码，该项目地址: <a href=\"https://github.com/Time1ess/MyCodes/tree/master/scrapy/jd\" target=\"_blank\" rel=\"noopener\">https://github.com/Time1ess/MyCodes/tree/master/scrapy/jd</a></p>"},{"layout":"post","title":"Python中的MRO","date":"2017-01-22T07:23:00.000Z","from":"https://www.python.org/download/releases/2.3/mro","_content":"\n今天我想对Python中的方法解析顺序使用的C3算法进行一个梳理，文章内容主要基于对[The Python 2.3 Method Resolution Order](https://www.python.org/download/releases/2.3/mro/)一文的节选翻译。\n\n首先，需要明白的是C3算法工作于Python 2.2引入的新式类(*new style classes*)，经典类(*classic classes*)中方法的解析仍然保持他们原有的顺序，即`深度优先，从左至右`，在此不进行深一步的讨论。\n\n<!-- more -->\n\n先来看一个例子:\n\n```Python\n>>> O = object\n>>> class X(O): pass\n>>> class Y(O): pass\n>>> class A(X, Y): pass\n>>> class B(Y, X): pass\n```\n\n继承顺序如图:\n![Inheritance](python_inheritance.png)\n\n在这种情况下，通过A和B派生出一个新类C是有问题的，因为在A的继承中X先于Y,而在B中Y先于X，因此C中方法解析顺序会存在歧义。Python 2.3在这种情况下通过抛出异常`TypeError: MRO conflict among bases Y, X`来避免程序员创建有歧义的类。\n\n#### C3算法\n首先介绍一些简易记号来方便接下来的描述。\n> $$C_1C_2...C_n$$\n\n表示一个类的列表`[C1, C2, ..., Cn]`。\n\n列表的`head`为其第一个元素, `tail`为其余下元素:\n> $$\\begin{align}head &= C_1\\\\\\\\tail &= C_2...C_n\\end{align}$$\n\n使用\n> $$C+(C_1C_2...C_n) = CC_1C_2...C_n$$\n\n来表示`[C]+[C1, C2, ..., Cn]`。\n\n线性化(*linearization*)定义:\n> 类C的线性化是指类C加上其父类的线性化以及其父类列表本身得到的和(列表)。\n\n用符号记号来描述:\n> $$L[C(B_1...B_n)] = C + merge(L[B_1]...L[B_n], B_1...B_n)$$\n\n特别的，如果C是`object`类，即不存在父类，其线性化结果为:\n> $$L[object] = object$$\n\n然而，要计算合并顺序需要遵循以下规则:\n> 取第一个列表的`head`，如$L[B_1][0]$；如果该`head`不在其余任一列表的尾部，将其加入类C的线性化结果列表中并将其从所有待合并列表中删除，否则从下一个列表中取出`head`并按上述规则处理。重复上述操作指导所有类都已经被删除或者无法再找到符合要求的`head`。在后者情况下，不可能完成merge操作，Python 2.3将会拒绝创建类C并抛出异常。\n\n下面举例说明，考虑如下继承:\n```Python\n>>> O = object\n>>> class F(O): pass\n>>> class E(O): pass\n>>> class D(O): pass\n>>> class C(D, F): pass\n>>> class B(D, E): pass\n>>> class A(B, C): pass\n```\n\n继承顺序如图:\n![Inheritance2](python_inheritance2.png)\n\nB的线性化计算公式可以表示如下:\n> $$L[B] = B + merge(DO, EO, DE)$$\n\n根据前述规则，我们首先取D作为`head`，待合并列表变成了$merge(O, EO, E)$，由于O不符合条件，我们跳过第一个列表在第二个列表中选择符合条件的E作为`head`，待合并列表变成了$merge(O, O)$，最后我们选择了O,因此:\n> $$L[B] = B D E O$$\n\n同理可以得到C的线性化结果:\n> $$\\begin{align}L[C] &= C + merge(DO, FO, DF)\\\\\\\\&=C+D+merge(O, FO, F)\\\\\\\\&=C+D+F+merge(O, O)\\\\\\\\&=C\\;D\\;F\\;O\\end{align}$$\n\n最后来计算A的线性化结果:\n> $$\\begin{align}L[A] &= A + merge(BDEO, CDFO, BC)\\\\\\\\&=A+B+merge(DEO, CDFO, C)\\\\\\\\&=A+B+C+merge(DEO, DFO)\\\\\\\\&=A+B+C+D+merge(EO, FO)\\\\\\\\&=A+B+C+D+E+merge(O, FO)\\\\\\\\&=A+B+C+D+E+F+merge(O, O)\\\\\\\\&=A\\;B\\;C\\;D\\;E\\;F\\;O\\end{align}$$\n\n在Python 2.2以后，可以直接通过调用`.mro()`方法获得MRO:\n```Python\n>>> A.mro()\n[<class '__main__.A'>, <class '__main__.B'>, <class '__main__.E'>,\n<class '__main__.C'>, <class '__main__.D'>, <class '__main__.F'>,\n<type 'object'>]\n```\n\n最后，让我们回到最初的那个例子，其所有类的线性化结果计算如下:\n> $$\\begin{align}&L[O] = O\\\\\\\\&L[X] = X\\;O\\\\\\\\&L[Y] = Y\\;O\\\\\\\\&L[A] = A\\;X\\;Y\\;O\\\\\\\\&L[B] = B\\;Y\\;X\\;O\\end{align}$$\n\n然而，对于继承自类A和类B的类C来说是无法线性化的:\n> $$\\begin{align}L[C] &= C + merge(AXYO, BYXO, AB)\\\\\\\\&=C+A+merge(XYO, BYXO, B)\\\\\\\\&=C+A+B+merge(XYO, YXO)\\end{align}$$\n\n在此刻，我们无法完成对XYO和YXO的合并，因为X是YXO的尾，同时Y是XYO的尾，因此C3算法停止，Python 2.3将会抛出异常并拒绝创建类C。\n\n#### 不好的MRO\n当一个MRO破坏了局部优先顺序和单调性等基础性质时称其为不好的MRO。\n考虑如下例子:\n```Python\n>>> F=type('Food',(),{'remember2buy':'spam'})\n>>> E=type('Eggs',(F,),{'remember2buy':'eggs'})\n>>> G=type('GoodFood',(F,E),{}) # under Python 2.3 this is an error!\n```\n\n创建了F、E、G三个类，其中类E可表示为`class E(F)`，类G可表示为`class G(F, E)`，我们期望类G的`remember2buy`属性是继承自F而不是E的，然而在Python 2.2中我们会得到\n```Python\n>>> G.remember2buy\n'eggs'\n```\n\n这破坏了局部优先顺序,因为对于类G的继承顺序`(F, E)`,其局部优先顺序并没有在Python 2.2线性化结果中得到保留:\n> $$L[G, P22] = G\\;E\\;F\\;object$$\n\n有人可能会争辩说Python 2.2线性化结果中类F在类E之后的原因是因为类F没有类E更具体，因为类F是类E的父类；尽管如此打破了局部优先顺序会使得代码不直观且容易出错，一个有力的佐证就是其与经典类的不同:\n```Python\n>>> class F: remember2buy='spam'\n>>> class E(F): remember2buy='eggs'\n>>> class G(F,E): pass\n>>> G.remember2buy\n'spam'\n```\n\n回想之前谈到的，经典类的继承顺序为`深度优先，从左至右`，因此类G的MRO为GFEF，在这种情况下局部优先顺序得到了保留。\n简而言之，像之前那种继承方式应该避免，Python 2.3开始通过抛出异常来避免了这种歧义，有力地阻止了程序员来创建有歧义的类继承(通过C3算法失败来完成)。\n\n还有一点相关的，Python 2.3的算法足够智能来发现一些显而易见的错误，比如重复继承同一个父类:\n```Python\n>>> class A(object): pass\n>>> class C(A,A): pass # error\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in ?\nTypeError: duplicate base class A\n```\n\n而这种情况在Python 2.2中(无论是经典类还是新式类)，都不会抛出异常。\n\n最后，有一点十分重要的需要记住:\n* MRO在决定方法解析顺序同时也决定了属性的解析顺序\n\n讨论完了局部优先顺序，下面再来看单调性问题。要证明经典类的MRO是非单调的很容易:\n![Inheritance3](python_inheritance3.png)\n\n> $$\\begin{align}&L[B, P22] = B\\;C\\quad\\\\#\\;B在C之前：类B的方法优先\\\\\\\\&L[D, P22] = D\\;A\\;C\\;B\\;C\\quad\\\\#\\;B在C之后：类C的方法优先\\end{align}$$\n\n另一方面，Python 2.2和Python 2.3的MRO中都不存在问题，都给出了:\n> $$L[D] = D\\;A\\;B\\;C$$\n\nGuido在他的[一篇文章](https://www.python.org/download/releases/2.2.3/descrintro/#mro)指出了经典类的MRO在实际使用中其实并不差，因为它可以使经典类避免钻石型结构。但由于所有新式类都继承自`object`，因此钻石型结果无法避免而且在所有的多继承图中前后矛盾都会出现。\nPython 2.2的MRO使得破坏单调性十分困难，但并非不可能。接下来这个由*Samuele Pedroni*提供的例子，表明了Python 2.2新式类的MRO是非单调的:\n```Python\n>>> class A(object): pass\n>>> class B(object): pass\n>>> class C(object): pass\n>>> class D(object): pass\n>>> class E(object): pass\n>>> class K1(A,B,C): pass\n>>> class K2(D,B,E): pass\n>>> class K3(D,A):   pass\n>>> class Z(K1,K2,K3): pass\n```\n\n![Inheritance4](python_inheritance4.png)\n\n使用C3算法的线性化结果如下:\n> $$\\begin{align}&L[A] = A\\;O\\\\\\\\&L[B] = B\\;O\\\\\\\\&L[C] = C\\;O\\\\\\\\&L[D] = D\\;O\\\\\\\\&L[E] = E\\;O\\\\\\\\&L[K1] = K1\\;A\\;B\\;C\\;O\\\\\\\\&L[K2] = K2\\;D\\;B\\;E\\;O\\\\\\\\&L[K3] = K3\\;D\\;A\\;O\\\\\\\\&L[Z] = Z\\;K1\\;K2\\;K3\\;D\\;A\\;B\\;C\\;E\\;O\\end{align}$$\n\nPython 2.2对于A、B、C、D、E、K1、K2、K3的线性化给出了相同结果，但是对于Z则不同:\n> $$L[Z, P22] = Z\\;K1\\;K3\\;A\\;K2\\;D\\;B\\;C\\;E\\;O$$ \n\n显然这个线性化结果是错的，因为类先于D出现了，而K3的线性化结果中D先于A出现。换句话说，在K3中，从类A继承的方法被从类D继承的方法覆盖了，但是在Z中，作为一个K3的子类，却使用了从类A继承的方法去覆盖从类D继承的方法！这违反了单调性。此外，Python 2.2中类Z的线性化结果与局部优先顺序也不一致，类Z的局部优先列表为`[K1, K2, K3]`(K2在K3之前)，而在线性化结果中K3在K2之前，这些问题解释了为什么2.2中的规则被弃用转投C3规则。\n\n#### super函数\n最后再来看Python 2.2引入的`super`函数，它主要用于初始化父类，避免了直接调用父类的`__init__`函数，减少耦合性，来看以下代码:\n```Python\nclass Base(object):\n    def __init__(self, value):\n        self.value = value\n\nclass TimesFive(Base):\n    def __init__(self, value):\n        super(TimesFive, self).__init__(value)\n        self.value *= 5\n\nclass PlusTwo(Base):\n    def __init__(self, value):\n        super(PlusTwo, self).__init__(value)\n        self.value += 2\n\nclass GoodWay(TimesFive, PlusTwo):\n    def __init__(self, value):\n        super(GoodWay, self).__init__(value)\n\nfoo = GoodWay(5)\n```\n\n它的计算顺序为`5 * (5 + 2)`而不是`(5 * 5) + 2`，原因在于程序的运行顺序与类GoodWay的MRO保持了一致，通过查看`GoodWay.mro()`可以得到:\n```Python\n>>> GoodWay.mro()\n[<class '__main__.GoodWay'>, <class '__main__.TimesFive'>, <class '__main__.PlusTwo'>, <class '__main__.Base'>, <class 'object'>]\n```\n\n调用`GoodWay(5)`的时候，它会调用`TimesFive.__init__`，而`TimesFive.__init__`又会调用`PlusTwo.__init__`，而`PlusTwo.__init__`会调用`Base.__init__`，当到达了钻石体系的顶部之后，所有的初始化方法会按照与刚才那些`__init__`相反的顺序执行，因此`Base.__init__`将value设为5，`PlusTwo.__init__`在此基础上加2，value变为7，最后`TimesFive.__init__`将value乘以5，得到35。\n#### 特别注意\n一看到`super`这个函数很多人第一想法就是父类，但其实`super`工作原理是这样的:\n```Python\ndef super(cls, inst):\n    mro = inst.__class__.mro()\n    return mro[mro.index(cls) + 1]\n```\n\n根据实例inst获得其类的MRO列表，返回cls所在位置的下一个位置的类，其中`inst`永远是最开始那个实例。\n\nPython 3提供了一种不带参数的`super`调用方式，例如:\n```Python\nclass Explicit(Base):\n    def __init__(self, value):\n        super().__init__(value)\n\nclass Implicit(Base):\n    def __init__(self, value):\n        super(__class__, self).__init__(value)\n\nassert Explicit(10).value == Implicit(10).value\n```\n\n由于Python 3程序可以在方法中通过__class__变量准确地引用当前类，所以上面的这种写法能够正常运作，而Python 2中则没有定义__class__，故而不能采用这种写法。可能有人试着用self.__class__做参数来调用`super`,但实际上这么做不行，因为Python 2是用[特殊方式实现super](http://stackoverflow.com/questions/18208683/when-calling-super-in-a-derived-class-can-i-pass-in-self-class)的。","source":"_posts/Python-Method Resolution Order.md","raw":"---\nlayout: post\ntitle: Python中的MRO\ntags: [Python,类,继承]\ncategory: Python\ndate: 2017-01-22 15:23\nfrom: https://www.python.org/download/releases/2.3/mro\n---\n\n今天我想对Python中的方法解析顺序使用的C3算法进行一个梳理，文章内容主要基于对[The Python 2.3 Method Resolution Order](https://www.python.org/download/releases/2.3/mro/)一文的节选翻译。\n\n首先，需要明白的是C3算法工作于Python 2.2引入的新式类(*new style classes*)，经典类(*classic classes*)中方法的解析仍然保持他们原有的顺序，即`深度优先，从左至右`，在此不进行深一步的讨论。\n\n<!-- more -->\n\n先来看一个例子:\n\n```Python\n>>> O = object\n>>> class X(O): pass\n>>> class Y(O): pass\n>>> class A(X, Y): pass\n>>> class B(Y, X): pass\n```\n\n继承顺序如图:\n![Inheritance](python_inheritance.png)\n\n在这种情况下，通过A和B派生出一个新类C是有问题的，因为在A的继承中X先于Y,而在B中Y先于X，因此C中方法解析顺序会存在歧义。Python 2.3在这种情况下通过抛出异常`TypeError: MRO conflict among bases Y, X`来避免程序员创建有歧义的类。\n\n#### C3算法\n首先介绍一些简易记号来方便接下来的描述。\n> $$C_1C_2...C_n$$\n\n表示一个类的列表`[C1, C2, ..., Cn]`。\n\n列表的`head`为其第一个元素, `tail`为其余下元素:\n> $$\\begin{align}head &= C_1\\\\\\\\tail &= C_2...C_n\\end{align}$$\n\n使用\n> $$C+(C_1C_2...C_n) = CC_1C_2...C_n$$\n\n来表示`[C]+[C1, C2, ..., Cn]`。\n\n线性化(*linearization*)定义:\n> 类C的线性化是指类C加上其父类的线性化以及其父类列表本身得到的和(列表)。\n\n用符号记号来描述:\n> $$L[C(B_1...B_n)] = C + merge(L[B_1]...L[B_n], B_1...B_n)$$\n\n特别的，如果C是`object`类，即不存在父类，其线性化结果为:\n> $$L[object] = object$$\n\n然而，要计算合并顺序需要遵循以下规则:\n> 取第一个列表的`head`，如$L[B_1][0]$；如果该`head`不在其余任一列表的尾部，将其加入类C的线性化结果列表中并将其从所有待合并列表中删除，否则从下一个列表中取出`head`并按上述规则处理。重复上述操作指导所有类都已经被删除或者无法再找到符合要求的`head`。在后者情况下，不可能完成merge操作，Python 2.3将会拒绝创建类C并抛出异常。\n\n下面举例说明，考虑如下继承:\n```Python\n>>> O = object\n>>> class F(O): pass\n>>> class E(O): pass\n>>> class D(O): pass\n>>> class C(D, F): pass\n>>> class B(D, E): pass\n>>> class A(B, C): pass\n```\n\n继承顺序如图:\n![Inheritance2](python_inheritance2.png)\n\nB的线性化计算公式可以表示如下:\n> $$L[B] = B + merge(DO, EO, DE)$$\n\n根据前述规则，我们首先取D作为`head`，待合并列表变成了$merge(O, EO, E)$，由于O不符合条件，我们跳过第一个列表在第二个列表中选择符合条件的E作为`head`，待合并列表变成了$merge(O, O)$，最后我们选择了O,因此:\n> $$L[B] = B D E O$$\n\n同理可以得到C的线性化结果:\n> $$\\begin{align}L[C] &= C + merge(DO, FO, DF)\\\\\\\\&=C+D+merge(O, FO, F)\\\\\\\\&=C+D+F+merge(O, O)\\\\\\\\&=C\\;D\\;F\\;O\\end{align}$$\n\n最后来计算A的线性化结果:\n> $$\\begin{align}L[A] &= A + merge(BDEO, CDFO, BC)\\\\\\\\&=A+B+merge(DEO, CDFO, C)\\\\\\\\&=A+B+C+merge(DEO, DFO)\\\\\\\\&=A+B+C+D+merge(EO, FO)\\\\\\\\&=A+B+C+D+E+merge(O, FO)\\\\\\\\&=A+B+C+D+E+F+merge(O, O)\\\\\\\\&=A\\;B\\;C\\;D\\;E\\;F\\;O\\end{align}$$\n\n在Python 2.2以后，可以直接通过调用`.mro()`方法获得MRO:\n```Python\n>>> A.mro()\n[<class '__main__.A'>, <class '__main__.B'>, <class '__main__.E'>,\n<class '__main__.C'>, <class '__main__.D'>, <class '__main__.F'>,\n<type 'object'>]\n```\n\n最后，让我们回到最初的那个例子，其所有类的线性化结果计算如下:\n> $$\\begin{align}&L[O] = O\\\\\\\\&L[X] = X\\;O\\\\\\\\&L[Y] = Y\\;O\\\\\\\\&L[A] = A\\;X\\;Y\\;O\\\\\\\\&L[B] = B\\;Y\\;X\\;O\\end{align}$$\n\n然而，对于继承自类A和类B的类C来说是无法线性化的:\n> $$\\begin{align}L[C] &= C + merge(AXYO, BYXO, AB)\\\\\\\\&=C+A+merge(XYO, BYXO, B)\\\\\\\\&=C+A+B+merge(XYO, YXO)\\end{align}$$\n\n在此刻，我们无法完成对XYO和YXO的合并，因为X是YXO的尾，同时Y是XYO的尾，因此C3算法停止，Python 2.3将会抛出异常并拒绝创建类C。\n\n#### 不好的MRO\n当一个MRO破坏了局部优先顺序和单调性等基础性质时称其为不好的MRO。\n考虑如下例子:\n```Python\n>>> F=type('Food',(),{'remember2buy':'spam'})\n>>> E=type('Eggs',(F,),{'remember2buy':'eggs'})\n>>> G=type('GoodFood',(F,E),{}) # under Python 2.3 this is an error!\n```\n\n创建了F、E、G三个类，其中类E可表示为`class E(F)`，类G可表示为`class G(F, E)`，我们期望类G的`remember2buy`属性是继承自F而不是E的，然而在Python 2.2中我们会得到\n```Python\n>>> G.remember2buy\n'eggs'\n```\n\n这破坏了局部优先顺序,因为对于类G的继承顺序`(F, E)`,其局部优先顺序并没有在Python 2.2线性化结果中得到保留:\n> $$L[G, P22] = G\\;E\\;F\\;object$$\n\n有人可能会争辩说Python 2.2线性化结果中类F在类E之后的原因是因为类F没有类E更具体，因为类F是类E的父类；尽管如此打破了局部优先顺序会使得代码不直观且容易出错，一个有力的佐证就是其与经典类的不同:\n```Python\n>>> class F: remember2buy='spam'\n>>> class E(F): remember2buy='eggs'\n>>> class G(F,E): pass\n>>> G.remember2buy\n'spam'\n```\n\n回想之前谈到的，经典类的继承顺序为`深度优先，从左至右`，因此类G的MRO为GFEF，在这种情况下局部优先顺序得到了保留。\n简而言之，像之前那种继承方式应该避免，Python 2.3开始通过抛出异常来避免了这种歧义，有力地阻止了程序员来创建有歧义的类继承(通过C3算法失败来完成)。\n\n还有一点相关的，Python 2.3的算法足够智能来发现一些显而易见的错误，比如重复继承同一个父类:\n```Python\n>>> class A(object): pass\n>>> class C(A,A): pass # error\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in ?\nTypeError: duplicate base class A\n```\n\n而这种情况在Python 2.2中(无论是经典类还是新式类)，都不会抛出异常。\n\n最后，有一点十分重要的需要记住:\n* MRO在决定方法解析顺序同时也决定了属性的解析顺序\n\n讨论完了局部优先顺序，下面再来看单调性问题。要证明经典类的MRO是非单调的很容易:\n![Inheritance3](python_inheritance3.png)\n\n> $$\\begin{align}&L[B, P22] = B\\;C\\quad\\\\#\\;B在C之前：类B的方法优先\\\\\\\\&L[D, P22] = D\\;A\\;C\\;B\\;C\\quad\\\\#\\;B在C之后：类C的方法优先\\end{align}$$\n\n另一方面，Python 2.2和Python 2.3的MRO中都不存在问题，都给出了:\n> $$L[D] = D\\;A\\;B\\;C$$\n\nGuido在他的[一篇文章](https://www.python.org/download/releases/2.2.3/descrintro/#mro)指出了经典类的MRO在实际使用中其实并不差，因为它可以使经典类避免钻石型结构。但由于所有新式类都继承自`object`，因此钻石型结果无法避免而且在所有的多继承图中前后矛盾都会出现。\nPython 2.2的MRO使得破坏单调性十分困难，但并非不可能。接下来这个由*Samuele Pedroni*提供的例子，表明了Python 2.2新式类的MRO是非单调的:\n```Python\n>>> class A(object): pass\n>>> class B(object): pass\n>>> class C(object): pass\n>>> class D(object): pass\n>>> class E(object): pass\n>>> class K1(A,B,C): pass\n>>> class K2(D,B,E): pass\n>>> class K3(D,A):   pass\n>>> class Z(K1,K2,K3): pass\n```\n\n![Inheritance4](python_inheritance4.png)\n\n使用C3算法的线性化结果如下:\n> $$\\begin{align}&L[A] = A\\;O\\\\\\\\&L[B] = B\\;O\\\\\\\\&L[C] = C\\;O\\\\\\\\&L[D] = D\\;O\\\\\\\\&L[E] = E\\;O\\\\\\\\&L[K1] = K1\\;A\\;B\\;C\\;O\\\\\\\\&L[K2] = K2\\;D\\;B\\;E\\;O\\\\\\\\&L[K3] = K3\\;D\\;A\\;O\\\\\\\\&L[Z] = Z\\;K1\\;K2\\;K3\\;D\\;A\\;B\\;C\\;E\\;O\\end{align}$$\n\nPython 2.2对于A、B、C、D、E、K1、K2、K3的线性化给出了相同结果，但是对于Z则不同:\n> $$L[Z, P22] = Z\\;K1\\;K3\\;A\\;K2\\;D\\;B\\;C\\;E\\;O$$ \n\n显然这个线性化结果是错的，因为类先于D出现了，而K3的线性化结果中D先于A出现。换句话说，在K3中，从类A继承的方法被从类D继承的方法覆盖了，但是在Z中，作为一个K3的子类，却使用了从类A继承的方法去覆盖从类D继承的方法！这违反了单调性。此外，Python 2.2中类Z的线性化结果与局部优先顺序也不一致，类Z的局部优先列表为`[K1, K2, K3]`(K2在K3之前)，而在线性化结果中K3在K2之前，这些问题解释了为什么2.2中的规则被弃用转投C3规则。\n\n#### super函数\n最后再来看Python 2.2引入的`super`函数，它主要用于初始化父类，避免了直接调用父类的`__init__`函数，减少耦合性，来看以下代码:\n```Python\nclass Base(object):\n    def __init__(self, value):\n        self.value = value\n\nclass TimesFive(Base):\n    def __init__(self, value):\n        super(TimesFive, self).__init__(value)\n        self.value *= 5\n\nclass PlusTwo(Base):\n    def __init__(self, value):\n        super(PlusTwo, self).__init__(value)\n        self.value += 2\n\nclass GoodWay(TimesFive, PlusTwo):\n    def __init__(self, value):\n        super(GoodWay, self).__init__(value)\n\nfoo = GoodWay(5)\n```\n\n它的计算顺序为`5 * (5 + 2)`而不是`(5 * 5) + 2`，原因在于程序的运行顺序与类GoodWay的MRO保持了一致，通过查看`GoodWay.mro()`可以得到:\n```Python\n>>> GoodWay.mro()\n[<class '__main__.GoodWay'>, <class '__main__.TimesFive'>, <class '__main__.PlusTwo'>, <class '__main__.Base'>, <class 'object'>]\n```\n\n调用`GoodWay(5)`的时候，它会调用`TimesFive.__init__`，而`TimesFive.__init__`又会调用`PlusTwo.__init__`，而`PlusTwo.__init__`会调用`Base.__init__`，当到达了钻石体系的顶部之后，所有的初始化方法会按照与刚才那些`__init__`相反的顺序执行，因此`Base.__init__`将value设为5，`PlusTwo.__init__`在此基础上加2，value变为7，最后`TimesFive.__init__`将value乘以5，得到35。\n#### 特别注意\n一看到`super`这个函数很多人第一想法就是父类，但其实`super`工作原理是这样的:\n```Python\ndef super(cls, inst):\n    mro = inst.__class__.mro()\n    return mro[mro.index(cls) + 1]\n```\n\n根据实例inst获得其类的MRO列表，返回cls所在位置的下一个位置的类，其中`inst`永远是最开始那个实例。\n\nPython 3提供了一种不带参数的`super`调用方式，例如:\n```Python\nclass Explicit(Base):\n    def __init__(self, value):\n        super().__init__(value)\n\nclass Implicit(Base):\n    def __init__(self, value):\n        super(__class__, self).__init__(value)\n\nassert Explicit(10).value == Implicit(10).value\n```\n\n由于Python 3程序可以在方法中通过__class__变量准确地引用当前类，所以上面的这种写法能够正常运作，而Python 2中则没有定义__class__，故而不能采用这种写法。可能有人试着用self.__class__做参数来调用`super`,但实际上这么做不行，因为Python 2是用[特殊方式实现super](http://stackoverflow.com/questions/18208683/when-calling-super-in-a-derived-class-can-i-pass-in-self-class)的。","slug":"Python-Method Resolution Order","published":1,"updated":"2018-01-15T01:17:45.671Z","comments":1,"photos":[],"link":"","_id":"cjgvnqml5000tw628a1af1zp4","content":"<p>今天我想对Python中的方法解析顺序使用的C3算法进行一个梳理，文章内容主要基于对<a href=\"https://www.python.org/download/releases/2.3/mro/\" target=\"_blank\" rel=\"noopener\">The Python 2.3 Method Resolution Order</a>一文的节选翻译。</p>\n<p>首先，需要明白的是C3算法工作于Python 2.2引入的新式类(<em>new style classes</em>)，经典类(<em>classic classes</em>)中方法的解析仍然保持他们原有的顺序，即<code>深度优先，从左至右</code>，在此不进行深一步的讨论。</p>\n<a id=\"more\"></a>\n<p>先来看一个例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>O = object</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span><span class=\"params\">(O)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Y</span><span class=\"params\">(O)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(X, Y)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(Y, X)</span>:</span> <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>继承顺序如图:<br><img src=\"/2017/01/22/Python-Method Resolution Order/python_inheritance.png\" alt=\"Inheritance\"></p>\n<p>在这种情况下，通过A和B派生出一个新类C是有问题的，因为在A的继承中X先于Y,而在B中Y先于X，因此C中方法解析顺序会存在歧义。Python 2.3在这种情况下通过抛出异常<code>TypeError: MRO conflict among bases Y, X</code>来避免程序员创建有歧义的类。</p>\n<h4 id=\"C3算法\"><a href=\"#C3算法\" class=\"headerlink\" title=\"C3算法\"></a>C3算法</h4><p>首先介绍一些简易记号来方便接下来的描述。</p>\n<blockquote>\n<p>$$C_1C_2…C_n$$</p>\n</blockquote>\n<p>表示一个类的列表<code>[C1, C2, ..., Cn]</code>。</p>\n<p>列表的<code>head</code>为其第一个元素, <code>tail</code>为其余下元素:</p>\n<blockquote>\n<p>$$\\begin{align}head &amp;= C_1\\\\tail &amp;= C_2…C_n\\end{align}$$</p>\n</blockquote>\n<p>使用</p>\n<blockquote>\n<p>$$C+(C_1C_2…C_n) = CC_1C_2…C_n$$</p>\n</blockquote>\n<p>来表示<code>[C]+[C1, C2, ..., Cn]</code>。</p>\n<p>线性化(<em>linearization</em>)定义:</p>\n<blockquote>\n<p>类C的线性化是指类C加上其父类的线性化以及其父类列表本身得到的和(列表)。</p>\n</blockquote>\n<p>用符号记号来描述:</p>\n<blockquote>\n<p>$$L[C(B_1…B_n)] = C + merge(L[B_1]…L[B_n], B_1…B_n)$$</p>\n</blockquote>\n<p>特别的，如果C是<code>object</code>类，即不存在父类，其线性化结果为:</p>\n<blockquote>\n<p>$$L[object] = object$$</p>\n</blockquote>\n<p>然而，要计算合并顺序需要遵循以下规则:</p>\n<blockquote>\n<p>取第一个列表的<code>head</code>，如$L[B_1][0]$；如果该<code>head</code>不在其余任一列表的尾部，将其加入类C的线性化结果列表中并将其从所有待合并列表中删除，否则从下一个列表中取出<code>head</code>并按上述规则处理。重复上述操作指导所有类都已经被删除或者无法再找到符合要求的<code>head</code>。在后者情况下，不可能完成merge操作，Python 2.3将会拒绝创建类C并抛出异常。</p>\n</blockquote>\n<p>下面举例说明，考虑如下继承:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>O = object</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">F</span><span class=\"params\">(O)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">E</span><span class=\"params\">(O)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span><span class=\"params\">(O)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(D, F)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(D, E)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(B, C)</span>:</span> <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure></p>\n<p>继承顺序如图:<br><img src=\"/2017/01/22/Python-Method Resolution Order/python_inheritance2.png\" alt=\"Inheritance2\"></p>\n<p>B的线性化计算公式可以表示如下:</p>\n<blockquote>\n<p>$$L[B] = B + merge(DO, EO, DE)$$</p>\n</blockquote>\n<p>根据前述规则，我们首先取D作为<code>head</code>，待合并列表变成了$merge(O, EO, E)$，由于O不符合条件，我们跳过第一个列表在第二个列表中选择符合条件的E作为<code>head</code>，待合并列表变成了$merge(O, O)$，最后我们选择了O,因此:</p>\n<blockquote>\n<p>$$L[B] = B D E O$$</p>\n</blockquote>\n<p>同理可以得到C的线性化结果:</p>\n<blockquote>\n<p>$$\\begin{align}L[C] &amp;= C + merge(DO, FO, DF)\\\\&amp;=C+D+merge(O, FO, F)\\\\&amp;=C+D+F+merge(O, O)\\\\&amp;=C\\;D\\;F\\;O\\end{align}$$</p>\n</blockquote>\n<p>最后来计算A的线性化结果:</p>\n<blockquote>\n<p>$$\\begin{align}L[A] &amp;= A + merge(BDEO, CDFO, BC)\\\\&amp;=A+B+merge(DEO, CDFO, C)\\\\&amp;=A+B+C+merge(DEO, DFO)\\\\&amp;=A+B+C+D+merge(EO, FO)\\\\&amp;=A+B+C+D+E+merge(O, FO)\\\\&amp;=A+B+C+D+E+F+merge(O, O)\\\\&amp;=A\\;B\\;C\\;D\\;E\\;F\\;O\\end{align}$$</p>\n</blockquote>\n<p>在Python 2.2以后，可以直接通过调用<code>.mro()</code>方法获得MRO:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>A.mro()</span><br><span class=\"line\">[&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;,</span><br><span class=\"line\">&lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.F'&gt;,</span><br><span class=\"line\">&lt;type <span class=\"string\">'object'</span>&gt;]</span><br></pre></td></tr></table></figure></p>\n<p>最后，让我们回到最初的那个例子，其所有类的线性化结果计算如下:</p>\n<blockquote>\n<p>$$\\begin{align}&amp;L[O] = O\\\\&amp;L[X] = X\\;O\\\\&amp;L[Y] = Y\\;O\\\\&amp;L[A] = A\\;X\\;Y\\;O\\\\&amp;L[B] = B\\;Y\\;X\\;O\\end{align}$$</p>\n</blockquote>\n<p>然而，对于继承自类A和类B的类C来说是无法线性化的:</p>\n<blockquote>\n<p>$$\\begin{align}L[C] &amp;= C + merge(AXYO, BYXO, AB)\\\\&amp;=C+A+merge(XYO, BYXO, B)\\\\&amp;=C+A+B+merge(XYO, YXO)\\end{align}$$</p>\n</blockquote>\n<p>在此刻，我们无法完成对XYO和YXO的合并，因为X是YXO的尾，同时Y是XYO的尾，因此C3算法停止，Python 2.3将会抛出异常并拒绝创建类C。</p>\n<h4 id=\"不好的MRO\"><a href=\"#不好的MRO\" class=\"headerlink\" title=\"不好的MRO\"></a>不好的MRO</h4><p>当一个MRO破坏了局部优先顺序和单调性等基础性质时称其为不好的MRO。<br>考虑如下例子:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>F=type(<span class=\"string\">'Food'</span>,(),&#123;<span class=\"string\">'remember2buy'</span>:<span class=\"string\">'spam'</span>&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>E=type(<span class=\"string\">'Eggs'</span>,(F,),&#123;<span class=\"string\">'remember2buy'</span>:<span class=\"string\">'eggs'</span>&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>G=type(<span class=\"string\">'GoodFood'</span>,(F,E),&#123;&#125;) <span class=\"comment\"># under Python 2.3 this is an error!</span></span><br></pre></td></tr></table></figure></p>\n<p>创建了F、E、G三个类，其中类E可表示为<code>class E(F)</code>，类G可表示为<code>class G(F, E)</code>，我们期望类G的<code>remember2buy</code>属性是继承自F而不是E的，然而在Python 2.2中我们会得到<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>G.remember2buy</span><br><span class=\"line\"><span class=\"string\">'eggs'</span></span><br></pre></td></tr></table></figure></p>\n<p>这破坏了局部优先顺序,因为对于类G的继承顺序<code>(F, E)</code>,其局部优先顺序并没有在Python 2.2线性化结果中得到保留:</p>\n<blockquote>\n<p>$$L[G, P22] = G\\;E\\;F\\;object$$</p>\n</blockquote>\n<p>有人可能会争辩说Python 2.2线性化结果中类F在类E之后的原因是因为类F没有类E更具体，因为类F是类E的父类；尽管如此打破了局部优先顺序会使得代码不直观且容易出错，一个有力的佐证就是其与经典类的不同:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">F</span>:</span> remember2buy=<span class=\"string\">'spam'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">E</span><span class=\"params\">(F)</span>:</span> remember2buy=<span class=\"string\">'eggs'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">G</span><span class=\"params\">(F,E)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>G.remember2buy</span><br><span class=\"line\"><span class=\"string\">'spam'</span></span><br></pre></td></tr></table></figure></p>\n<p>回想之前谈到的，经典类的继承顺序为<code>深度优先，从左至右</code>，因此类G的MRO为GFEF，在这种情况下局部优先顺序得到了保留。<br>简而言之，像之前那种继承方式应该避免，Python 2.3开始通过抛出异常来避免了这种歧义，有力地阻止了程序员来创建有歧义的类继承(通过C3算法失败来完成)。</p>\n<p>还有一点相关的，Python 2.3的算法足够智能来发现一些显而易见的错误，比如重复继承同一个父类:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(object)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(A,A)</span>:</span> <span class=\"keyword\">pass</span> <span class=\"comment\"># error</span></span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File \"&lt;stdin&gt;\", line 1, in ?</span><br><span class=\"line\">TypeError: duplicate base <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br></pre></td></tr></table></figure></p>\n<p>而这种情况在Python 2.2中(无论是经典类还是新式类)，都不会抛出异常。</p>\n<p>最后，有一点十分重要的需要记住:</p>\n<ul>\n<li>MRO在决定方法解析顺序同时也决定了属性的解析顺序</li>\n</ul>\n<p>讨论完了局部优先顺序，下面再来看单调性问题。要证明经典类的MRO是非单调的很容易:<br><img src=\"/2017/01/22/Python-Method Resolution Order/python_inheritance3.png\" alt=\"Inheritance3\"></p>\n<blockquote>\n<p>$$\\begin{align}&amp;L[B, P22] = B\\;C\\quad\\#\\;B在C之前：类B的方法优先\\\\&amp;L[D, P22] = D\\;A\\;C\\;B\\;C\\quad\\#\\;B在C之后：类C的方法优先\\end{align}$$</p>\n</blockquote>\n<p>另一方面，Python 2.2和Python 2.3的MRO中都不存在问题，都给出了:</p>\n<blockquote>\n<p>$$L[D] = D\\;A\\;B\\;C$$</p>\n</blockquote>\n<p>Guido在他的<a href=\"https://www.python.org/download/releases/2.2.3/descrintro/#mro\" target=\"_blank\" rel=\"noopener\">一篇文章</a>指出了经典类的MRO在实际使用中其实并不差，因为它可以使经典类避免钻石型结构。但由于所有新式类都继承自<code>object</code>，因此钻石型结果无法避免而且在所有的多继承图中前后矛盾都会出现。<br>Python 2.2的MRO使得破坏单调性十分困难，但并非不可能。接下来这个由<em>Samuele Pedroni</em>提供的例子，表明了Python 2.2新式类的MRO是非单调的:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(object)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(object)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(object)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span><span class=\"params\">(object)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">E</span><span class=\"params\">(object)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">K1</span><span class=\"params\">(A,B,C)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">K2</span><span class=\"params\">(D,B,E)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">K3</span><span class=\"params\">(D,A)</span>:</span>   <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Z</span><span class=\"params\">(K1,K2,K3)</span>:</span> <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/2017/01/22/Python-Method Resolution Order/python_inheritance4.png\" alt=\"Inheritance4\"></p>\n<p>使用C3算法的线性化结果如下:</p>\n<blockquote>\n<p>$$\\begin{align}&amp;L[A] = A\\;O\\\\&amp;L[B] = B\\;O\\\\&amp;L[C] = C\\;O\\\\&amp;L[D] = D\\;O\\\\&amp;L[E] = E\\;O\\\\&amp;L[K1] = K1\\;A\\;B\\;C\\;O\\\\&amp;L[K2] = K2\\;D\\;B\\;E\\;O\\\\&amp;L[K3] = K3\\;D\\;A\\;O\\\\&amp;L[Z] = Z\\;K1\\;K2\\;K3\\;D\\;A\\;B\\;C\\;E\\;O\\end{align}$$</p>\n</blockquote>\n<p>Python 2.2对于A、B、C、D、E、K1、K2、K3的线性化给出了相同结果，但是对于Z则不同:</p>\n<blockquote>\n<p>$$L[Z, P22] = Z\\;K1\\;K3\\;A\\;K2\\;D\\;B\\;C\\;E\\;O$$ </p>\n</blockquote>\n<p>显然这个线性化结果是错的，因为类先于D出现了，而K3的线性化结果中D先于A出现。换句话说，在K3中，从类A继承的方法被从类D继承的方法覆盖了，但是在Z中，作为一个K3的子类，却使用了从类A继承的方法去覆盖从类D继承的方法！这违反了单调性。此外，Python 2.2中类Z的线性化结果与局部优先顺序也不一致，类Z的局部优先列表为<code>[K1, K2, K3]</code>(K2在K3之前)，而在线性化结果中K3在K2之前，这些问题解释了为什么2.2中的规则被弃用转投C3规则。</p>\n<h4 id=\"super函数\"><a href=\"#super函数\" class=\"headerlink\" title=\"super函数\"></a>super函数</h4><p>最后再来看Python 2.2引入的<code>super</code>函数，它主要用于初始化父类，避免了直接调用父类的<code>__init__</code>函数，减少耦合性，来看以下代码:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, value)</span>:</span></span><br><span class=\"line\">        self.value = value</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimesFive</span><span class=\"params\">(Base)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, value)</span>:</span></span><br><span class=\"line\">        super(TimesFive, self).__init__(value)</span><br><span class=\"line\">        self.value *= <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlusTwo</span><span class=\"params\">(Base)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, value)</span>:</span></span><br><span class=\"line\">        super(PlusTwo, self).__init__(value)</span><br><span class=\"line\">        self.value += <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GoodWay</span><span class=\"params\">(TimesFive, PlusTwo)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, value)</span>:</span></span><br><span class=\"line\">        super(GoodWay, self).__init__(value)</span><br><span class=\"line\"></span><br><span class=\"line\">foo = GoodWay(<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure></p>\n<p>它的计算顺序为<code>5 * (5 + 2)</code>而不是<code>(5 * 5) + 2</code>，原因在于程序的运行顺序与类GoodWay的MRO保持了一致，通过查看<code>GoodWay.mro()</code>可以得到:<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>GoodWay.mro()</span><br><span class=\"line\">[&lt;class '__main__.GoodWay'&gt;, &lt;class '__main__.TimesFive'&gt;, &lt;class '__main__.PlusTwo'&gt;, &lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;]</span><br></pre></td></tr></table></figure></p>\n<p>调用<code>GoodWay(5)</code>的时候，它会调用<code>TimesFive.__init__</code>，而<code>TimesFive.__init__</code>又会调用<code>PlusTwo.__init__</code>，而<code>PlusTwo.__init__</code>会调用<code>Base.__init__</code>，当到达了钻石体系的顶部之后，所有的初始化方法会按照与刚才那些<code>__init__</code>相反的顺序执行，因此<code>Base.__init__</code>将value设为5，<code>PlusTwo.__init__</code>在此基础上加2，value变为7，最后<code>TimesFive.__init__</code>将value乘以5，得到35。</p>\n<h4 id=\"特别注意\"><a href=\"#特别注意\" class=\"headerlink\" title=\"特别注意\"></a>特别注意</h4><p>一看到<code>super</code>这个函数很多人第一想法就是父类，但其实<code>super</code>工作原理是这样的:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">super</span><span class=\"params\">(cls, inst)</span>:</span></span><br><span class=\"line\">    mro = inst.__class__.mro()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mro[mro.index(cls) + <span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure></p>\n<p>根据实例inst获得其类的MRO列表，返回cls所在位置的下一个位置的类，其中<code>inst</code>永远是最开始那个实例。</p>\n<p>Python 3提供了一种不带参数的<code>super</code>调用方式，例如:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Explicit</span><span class=\"params\">(Base)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, value)</span>:</span></span><br><span class=\"line\">        super().__init__(value)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Implicit</span><span class=\"params\">(Base)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, value)</span>:</span></span><br><span class=\"line\">        super(__class__, self).__init__(value)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span> Explicit(<span class=\"number\">10</span>).value == Implicit(<span class=\"number\">10</span>).value</span><br></pre></td></tr></table></figure></p>\n<p>由于Python 3程序可以在方法中通过<strong>class</strong>变量准确地引用当前类，所以上面的这种写法能够正常运作，而Python 2中则没有定义<strong>class</strong>，故而不能采用这种写法。可能有人试着用self.<strong>class</strong>做参数来调用<code>super</code>,但实际上这么做不行，因为Python 2是用<a href=\"http://stackoverflow.com/questions/18208683/when-calling-super-in-a-derived-class-can-i-pass-in-self-class\" target=\"_blank\" rel=\"noopener\">特殊方式实现super</a>的。</p>\n","site":{"data":{}},"excerpt":"<p>今天我想对Python中的方法解析顺序使用的C3算法进行一个梳理，文章内容主要基于对<a href=\"https://www.python.org/download/releases/2.3/mro/\" target=\"_blank\" rel=\"noopener\">The Python 2.3 Method Resolution Order</a>一文的节选翻译。</p>\n<p>首先，需要明白的是C3算法工作于Python 2.2引入的新式类(<em>new style classes</em>)，经典类(<em>classic classes</em>)中方法的解析仍然保持他们原有的顺序，即<code>深度优先，从左至右</code>，在此不进行深一步的讨论。</p>","more":"<p>先来看一个例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>O = object</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span><span class=\"params\">(O)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Y</span><span class=\"params\">(O)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(X, Y)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(Y, X)</span>:</span> <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>继承顺序如图:<br><img src=\"/2017/01/22/Python-Method Resolution Order/python_inheritance.png\" alt=\"Inheritance\"></p>\n<p>在这种情况下，通过A和B派生出一个新类C是有问题的，因为在A的继承中X先于Y,而在B中Y先于X，因此C中方法解析顺序会存在歧义。Python 2.3在这种情况下通过抛出异常<code>TypeError: MRO conflict among bases Y, X</code>来避免程序员创建有歧义的类。</p>\n<h4 id=\"C3算法\"><a href=\"#C3算法\" class=\"headerlink\" title=\"C3算法\"></a>C3算法</h4><p>首先介绍一些简易记号来方便接下来的描述。</p>\n<blockquote>\n<p>$$C_1C_2…C_n$$</p>\n</blockquote>\n<p>表示一个类的列表<code>[C1, C2, ..., Cn]</code>。</p>\n<p>列表的<code>head</code>为其第一个元素, <code>tail</code>为其余下元素:</p>\n<blockquote>\n<p>$$\\begin{align}head &amp;= C_1\\\\tail &amp;= C_2…C_n\\end{align}$$</p>\n</blockquote>\n<p>使用</p>\n<blockquote>\n<p>$$C+(C_1C_2…C_n) = CC_1C_2…C_n$$</p>\n</blockquote>\n<p>来表示<code>[C]+[C1, C2, ..., Cn]</code>。</p>\n<p>线性化(<em>linearization</em>)定义:</p>\n<blockquote>\n<p>类C的线性化是指类C加上其父类的线性化以及其父类列表本身得到的和(列表)。</p>\n</blockquote>\n<p>用符号记号来描述:</p>\n<blockquote>\n<p>$$L[C(B_1…B_n)] = C + merge(L[B_1]…L[B_n], B_1…B_n)$$</p>\n</blockquote>\n<p>特别的，如果C是<code>object</code>类，即不存在父类，其线性化结果为:</p>\n<blockquote>\n<p>$$L[object] = object$$</p>\n</blockquote>\n<p>然而，要计算合并顺序需要遵循以下规则:</p>\n<blockquote>\n<p>取第一个列表的<code>head</code>，如$L[B_1][0]$；如果该<code>head</code>不在其余任一列表的尾部，将其加入类C的线性化结果列表中并将其从所有待合并列表中删除，否则从下一个列表中取出<code>head</code>并按上述规则处理。重复上述操作指导所有类都已经被删除或者无法再找到符合要求的<code>head</code>。在后者情况下，不可能完成merge操作，Python 2.3将会拒绝创建类C并抛出异常。</p>\n</blockquote>\n<p>下面举例说明，考虑如下继承:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>O = object</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">F</span><span class=\"params\">(O)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">E</span><span class=\"params\">(O)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span><span class=\"params\">(O)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(D, F)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(D, E)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(B, C)</span>:</span> <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure></p>\n<p>继承顺序如图:<br><img src=\"/2017/01/22/Python-Method Resolution Order/python_inheritance2.png\" alt=\"Inheritance2\"></p>\n<p>B的线性化计算公式可以表示如下:</p>\n<blockquote>\n<p>$$L[B] = B + merge(DO, EO, DE)$$</p>\n</blockquote>\n<p>根据前述规则，我们首先取D作为<code>head</code>，待合并列表变成了$merge(O, EO, E)$，由于O不符合条件，我们跳过第一个列表在第二个列表中选择符合条件的E作为<code>head</code>，待合并列表变成了$merge(O, O)$，最后我们选择了O,因此:</p>\n<blockquote>\n<p>$$L[B] = B D E O$$</p>\n</blockquote>\n<p>同理可以得到C的线性化结果:</p>\n<blockquote>\n<p>$$\\begin{align}L[C] &amp;= C + merge(DO, FO, DF)\\\\&amp;=C+D+merge(O, FO, F)\\\\&amp;=C+D+F+merge(O, O)\\\\&amp;=C\\;D\\;F\\;O\\end{align}$$</p>\n</blockquote>\n<p>最后来计算A的线性化结果:</p>\n<blockquote>\n<p>$$\\begin{align}L[A] &amp;= A + merge(BDEO, CDFO, BC)\\\\&amp;=A+B+merge(DEO, CDFO, C)\\\\&amp;=A+B+C+merge(DEO, DFO)\\\\&amp;=A+B+C+D+merge(EO, FO)\\\\&amp;=A+B+C+D+E+merge(O, FO)\\\\&amp;=A+B+C+D+E+F+merge(O, O)\\\\&amp;=A\\;B\\;C\\;D\\;E\\;F\\;O\\end{align}$$</p>\n</blockquote>\n<p>在Python 2.2以后，可以直接通过调用<code>.mro()</code>方法获得MRO:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>A.mro()</span><br><span class=\"line\">[&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;,</span><br><span class=\"line\">&lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.F'&gt;,</span><br><span class=\"line\">&lt;type <span class=\"string\">'object'</span>&gt;]</span><br></pre></td></tr></table></figure></p>\n<p>最后，让我们回到最初的那个例子，其所有类的线性化结果计算如下:</p>\n<blockquote>\n<p>$$\\begin{align}&amp;L[O] = O\\\\&amp;L[X] = X\\;O\\\\&amp;L[Y] = Y\\;O\\\\&amp;L[A] = A\\;X\\;Y\\;O\\\\&amp;L[B] = B\\;Y\\;X\\;O\\end{align}$$</p>\n</blockquote>\n<p>然而，对于继承自类A和类B的类C来说是无法线性化的:</p>\n<blockquote>\n<p>$$\\begin{align}L[C] &amp;= C + merge(AXYO, BYXO, AB)\\\\&amp;=C+A+merge(XYO, BYXO, B)\\\\&amp;=C+A+B+merge(XYO, YXO)\\end{align}$$</p>\n</blockquote>\n<p>在此刻，我们无法完成对XYO和YXO的合并，因为X是YXO的尾，同时Y是XYO的尾，因此C3算法停止，Python 2.3将会抛出异常并拒绝创建类C。</p>\n<h4 id=\"不好的MRO\"><a href=\"#不好的MRO\" class=\"headerlink\" title=\"不好的MRO\"></a>不好的MRO</h4><p>当一个MRO破坏了局部优先顺序和单调性等基础性质时称其为不好的MRO。<br>考虑如下例子:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>F=type(<span class=\"string\">'Food'</span>,(),&#123;<span class=\"string\">'remember2buy'</span>:<span class=\"string\">'spam'</span>&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>E=type(<span class=\"string\">'Eggs'</span>,(F,),&#123;<span class=\"string\">'remember2buy'</span>:<span class=\"string\">'eggs'</span>&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>G=type(<span class=\"string\">'GoodFood'</span>,(F,E),&#123;&#125;) <span class=\"comment\"># under Python 2.3 this is an error!</span></span><br></pre></td></tr></table></figure></p>\n<p>创建了F、E、G三个类，其中类E可表示为<code>class E(F)</code>，类G可表示为<code>class G(F, E)</code>，我们期望类G的<code>remember2buy</code>属性是继承自F而不是E的，然而在Python 2.2中我们会得到<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>G.remember2buy</span><br><span class=\"line\"><span class=\"string\">'eggs'</span></span><br></pre></td></tr></table></figure></p>\n<p>这破坏了局部优先顺序,因为对于类G的继承顺序<code>(F, E)</code>,其局部优先顺序并没有在Python 2.2线性化结果中得到保留:</p>\n<blockquote>\n<p>$$L[G, P22] = G\\;E\\;F\\;object$$</p>\n</blockquote>\n<p>有人可能会争辩说Python 2.2线性化结果中类F在类E之后的原因是因为类F没有类E更具体，因为类F是类E的父类；尽管如此打破了局部优先顺序会使得代码不直观且容易出错，一个有力的佐证就是其与经典类的不同:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">F</span>:</span> remember2buy=<span class=\"string\">'spam'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">E</span><span class=\"params\">(F)</span>:</span> remember2buy=<span class=\"string\">'eggs'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">G</span><span class=\"params\">(F,E)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>G.remember2buy</span><br><span class=\"line\"><span class=\"string\">'spam'</span></span><br></pre></td></tr></table></figure></p>\n<p>回想之前谈到的，经典类的继承顺序为<code>深度优先，从左至右</code>，因此类G的MRO为GFEF，在这种情况下局部优先顺序得到了保留。<br>简而言之，像之前那种继承方式应该避免，Python 2.3开始通过抛出异常来避免了这种歧义，有力地阻止了程序员来创建有歧义的类继承(通过C3算法失败来完成)。</p>\n<p>还有一点相关的，Python 2.3的算法足够智能来发现一些显而易见的错误，比如重复继承同一个父类:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(object)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(A,A)</span>:</span> <span class=\"keyword\">pass</span> <span class=\"comment\"># error</span></span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File \"&lt;stdin&gt;\", line 1, in ?</span><br><span class=\"line\">TypeError: duplicate base <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br></pre></td></tr></table></figure></p>\n<p>而这种情况在Python 2.2中(无论是经典类还是新式类)，都不会抛出异常。</p>\n<p>最后，有一点十分重要的需要记住:</p>\n<ul>\n<li>MRO在决定方法解析顺序同时也决定了属性的解析顺序</li>\n</ul>\n<p>讨论完了局部优先顺序，下面再来看单调性问题。要证明经典类的MRO是非单调的很容易:<br><img src=\"/2017/01/22/Python-Method Resolution Order/python_inheritance3.png\" alt=\"Inheritance3\"></p>\n<blockquote>\n<p>$$\\begin{align}&amp;L[B, P22] = B\\;C\\quad\\#\\;B在C之前：类B的方法优先\\\\&amp;L[D, P22] = D\\;A\\;C\\;B\\;C\\quad\\#\\;B在C之后：类C的方法优先\\end{align}$$</p>\n</blockquote>\n<p>另一方面，Python 2.2和Python 2.3的MRO中都不存在问题，都给出了:</p>\n<blockquote>\n<p>$$L[D] = D\\;A\\;B\\;C$$</p>\n</blockquote>\n<p>Guido在他的<a href=\"https://www.python.org/download/releases/2.2.3/descrintro/#mro\" target=\"_blank\" rel=\"noopener\">一篇文章</a>指出了经典类的MRO在实际使用中其实并不差，因为它可以使经典类避免钻石型结构。但由于所有新式类都继承自<code>object</code>，因此钻石型结果无法避免而且在所有的多继承图中前后矛盾都会出现。<br>Python 2.2的MRO使得破坏单调性十分困难，但并非不可能。接下来这个由<em>Samuele Pedroni</em>提供的例子，表明了Python 2.2新式类的MRO是非单调的:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(object)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(object)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(object)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span><span class=\"params\">(object)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">E</span><span class=\"params\">(object)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">K1</span><span class=\"params\">(A,B,C)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">K2</span><span class=\"params\">(D,B,E)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">K3</span><span class=\"params\">(D,A)</span>:</span>   <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Z</span><span class=\"params\">(K1,K2,K3)</span>:</span> <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"/2017/01/22/Python-Method Resolution Order/python_inheritance4.png\" alt=\"Inheritance4\"></p>\n<p>使用C3算法的线性化结果如下:</p>\n<blockquote>\n<p>$$\\begin{align}&amp;L[A] = A\\;O\\\\&amp;L[B] = B\\;O\\\\&amp;L[C] = C\\;O\\\\&amp;L[D] = D\\;O\\\\&amp;L[E] = E\\;O\\\\&amp;L[K1] = K1\\;A\\;B\\;C\\;O\\\\&amp;L[K2] = K2\\;D\\;B\\;E\\;O\\\\&amp;L[K3] = K3\\;D\\;A\\;O\\\\&amp;L[Z] = Z\\;K1\\;K2\\;K3\\;D\\;A\\;B\\;C\\;E\\;O\\end{align}$$</p>\n</blockquote>\n<p>Python 2.2对于A、B、C、D、E、K1、K2、K3的线性化给出了相同结果，但是对于Z则不同:</p>\n<blockquote>\n<p>$$L[Z, P22] = Z\\;K1\\;K3\\;A\\;K2\\;D\\;B\\;C\\;E\\;O$$ </p>\n</blockquote>\n<p>显然这个线性化结果是错的，因为类先于D出现了，而K3的线性化结果中D先于A出现。换句话说，在K3中，从类A继承的方法被从类D继承的方法覆盖了，但是在Z中，作为一个K3的子类，却使用了从类A继承的方法去覆盖从类D继承的方法！这违反了单调性。此外，Python 2.2中类Z的线性化结果与局部优先顺序也不一致，类Z的局部优先列表为<code>[K1, K2, K3]</code>(K2在K3之前)，而在线性化结果中K3在K2之前，这些问题解释了为什么2.2中的规则被弃用转投C3规则。</p>\n<h4 id=\"super函数\"><a href=\"#super函数\" class=\"headerlink\" title=\"super函数\"></a>super函数</h4><p>最后再来看Python 2.2引入的<code>super</code>函数，它主要用于初始化父类，避免了直接调用父类的<code>__init__</code>函数，减少耦合性，来看以下代码:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, value)</span>:</span></span><br><span class=\"line\">        self.value = value</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimesFive</span><span class=\"params\">(Base)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, value)</span>:</span></span><br><span class=\"line\">        super(TimesFive, self).__init__(value)</span><br><span class=\"line\">        self.value *= <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlusTwo</span><span class=\"params\">(Base)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, value)</span>:</span></span><br><span class=\"line\">        super(PlusTwo, self).__init__(value)</span><br><span class=\"line\">        self.value += <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GoodWay</span><span class=\"params\">(TimesFive, PlusTwo)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, value)</span>:</span></span><br><span class=\"line\">        super(GoodWay, self).__init__(value)</span><br><span class=\"line\"></span><br><span class=\"line\">foo = GoodWay(<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure></p>\n<p>它的计算顺序为<code>5 * (5 + 2)</code>而不是<code>(5 * 5) + 2</code>，原因在于程序的运行顺序与类GoodWay的MRO保持了一致，通过查看<code>GoodWay.mro()</code>可以得到:<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>GoodWay.mro()</span><br><span class=\"line\">[&lt;class '__main__.GoodWay'&gt;, &lt;class '__main__.TimesFive'&gt;, &lt;class '__main__.PlusTwo'&gt;, &lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;]</span><br></pre></td></tr></table></figure></p>\n<p>调用<code>GoodWay(5)</code>的时候，它会调用<code>TimesFive.__init__</code>，而<code>TimesFive.__init__</code>又会调用<code>PlusTwo.__init__</code>，而<code>PlusTwo.__init__</code>会调用<code>Base.__init__</code>，当到达了钻石体系的顶部之后，所有的初始化方法会按照与刚才那些<code>__init__</code>相反的顺序执行，因此<code>Base.__init__</code>将value设为5，<code>PlusTwo.__init__</code>在此基础上加2，value变为7，最后<code>TimesFive.__init__</code>将value乘以5，得到35。</p>\n<h4 id=\"特别注意\"><a href=\"#特别注意\" class=\"headerlink\" title=\"特别注意\"></a>特别注意</h4><p>一看到<code>super</code>这个函数很多人第一想法就是父类，但其实<code>super</code>工作原理是这样的:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">super</span><span class=\"params\">(cls, inst)</span>:</span></span><br><span class=\"line\">    mro = inst.__class__.mro()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mro[mro.index(cls) + <span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure></p>\n<p>根据实例inst获得其类的MRO列表，返回cls所在位置的下一个位置的类，其中<code>inst</code>永远是最开始那个实例。</p>\n<p>Python 3提供了一种不带参数的<code>super</code>调用方式，例如:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Explicit</span><span class=\"params\">(Base)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, value)</span>:</span></span><br><span class=\"line\">        super().__init__(value)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Implicit</span><span class=\"params\">(Base)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, value)</span>:</span></span><br><span class=\"line\">        super(__class__, self).__init__(value)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span> Explicit(<span class=\"number\">10</span>).value == Implicit(<span class=\"number\">10</span>).value</span><br></pre></td></tr></table></figure></p>\n<p>由于Python 3程序可以在方法中通过<strong>class</strong>变量准确地引用当前类，所以上面的这种写法能够正常运作，而Python 2中则没有定义<strong>class</strong>，故而不能采用这种写法。可能有人试着用self.<strong>class</strong>做参数来调用<code>super</code>,但实际上这么做不行，因为Python 2是用<a href=\"http://stackoverflow.com/questions/18208683/when-calling-super-in-a-derived-class-can-i-pass-in-self-class\" target=\"_blank\" rel=\"noopener\">特殊方式实现super</a>的。</p>"},{"title":"Python中yield的作用","date":"2017-02-10T02:42:13.000Z","from":"http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do","_content":"最近在[StackOverflow](http://stackoverflow.com)上看的问题回答比较多，今天这篇是关于介绍Python生成器的相关思想以及其中关键字`yield`用法的翻译内容。\n\n为了搞清楚`yield`是用来做什么的，你首先得知道Python中***生成器***的相关概念，而为了了解生成器的相关概念，你需要知道什么是***迭代器***。\n\n<!-- more -->\n<div class=\"tip\">\n本篇中的Python除了特殊说明外都是Python 2.x\n</div>\n\n#### 迭代器\n当你创建一个了列表，你可以逐个遍历列表中的元素，而这个过程便叫做***迭代***:\n\n```Python\n>>> mylist = [1, 2, 3]\n>>> for i in mylist:\n...    print(i)\n1\n2\n3\n```\n\n而`mylist`是一个***可迭代对象***。当你使用列表推导式的时候，创建了一个列表，他也是可迭代对象:\n\n```Python\n>>> mylist = [x*x for x in range(3)]\n>>> for i in mylist:\n...    print(i)\n0\n1\n4\n```\n\n所有能够接受`for...in...`操作的对象都是可迭代对象，如列表、字符串、文件等。这些可迭代对象用起来都十分顺手因为你可以按照你的想法去访问它们，但是你把所有数据都保存在了内存中，而当你有大量数据的时候这可能并不是你想要的结果。\n\n#### 生成器\n生成器也是迭代器，但是**你只能对它们进行一次迭代**，原因在于它们并没有将所有数据存储在内存中，而是即时生成这些数据:\n\n```Python\n>>> mygenerator = (x*x for x in range(3))\n>>> for i in mygenerator:\n...    print(i)\n0\n1\n4\n```\n\n这一段代码和上面那段很相似，唯一不同的地方是使用了`()`代替`[]`。但是，这样的后果是你无法对`mygenerator`进行第二次`for i in mygenerator`，因为生成器只能被使用一次:它首先计算出结果0，然后忘记它再计算出1，最后是4，一个接一个。\n\n#### Yield\n`yield`是一个用法跟`return`很相似的关键字，不同在于函数返回的是一个生成器。\n\n```Python\n>>> def createGenerator():\n...    mylist = range(3)\n...    for i in mylist:\n...        yield i*i\n...\n>>> mygenerator = createGenerator() # create a generator\n>>> print(mygenerator) # mygenerator is an object!\n<generator object createGenerator at 0xb7555c34>\n>>> for i in mygenerator:\n...     print(i)\n0\n1\n4\n```\n\n这是一个没有什么用的例子，但是用来让你了解当你知道你的函数会返回一个只会被遍历1次的巨大数据集合该怎么做的时候十分方便。为了掌握`yield`，你必须了解**当你调用这个函数的时候，你在函数体中写的代码并没有被执行**，而是只返回了一个生成器对象，这个需要特别注意。然后，你的代码将会在每次`for`使用这个生成器的时候被执行。最后，最困难的部分:\n> `for`第一次调用通过你函数创建的生成器对象的时候，它将会从你函数的开头执行代码，一直到到达`yield`，然后它将会返回循环中的第一个值。然后，其他每次调用都会再一次执行你在函数中写的那段循环，并返回下一个值，直到没有值可以返回。\n\n生成器在函数执行了却没有到达`yield`的时候将被认为是空的，原因在于循环到达了终点，或者不再满足`if/else`条件。\n\n#### 处理生成器耗尽\n考虑以下代码:\n\n```Python\n>>> class Bank(): # let's create a bank, building ATMs\n...    crisis = False\n...    def create_atm(self):\n...        while not self.crisis:\n...            yield \"$100\"\n\n>>> hsbc = Bank() # when everything's ok the ATM gives you as much as you want\n>>> corner_street_atm = hsbc.create_atm()\n>>> print(corner_street_atm.next())\n$100\n>>> print(corner_street_atm.next())\n$100\n>>> print([corner_street_atm.next() for cash in range(5)])\n['$100', '$100', '$100', '$100', '$100']\n\n>>> hsbc.crisis = True # crisis is coming, no more money!\n>>> print(corner_street_atm.next())\n<type 'exceptions.StopIteration'>\n>>> wall_street_atm = hsbc.create_atm() # it's even true for new ATMs\n>>> print(wall_street_atm.next())\n<type 'exceptions.StopIteration'>\n>>> hsbc.crisis = False # trouble is, even post-crisis the ATM remains empty\n>>> print(corner_street_atm.next())\n<type 'exceptions.StopIteration'>\n>>> brand_new_atm = hsbc.create_atm() # build a new one to get back in business\n>>> for cash in brand_new_atm:\n...    print cash\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n...\n```\n\n首先看生成器的`next`方法，它用来执行代码并从生成器中获取下一个元素(在Python 3.x中生成器已经没有next方法，而是使用next(iterator)代替)。在`crisis`未被置为`True`的时候，`create_atm`函数中的`while`循环可以看做是无尽的，当`crisis`为`True`的时候，跳出了`while`循环，所有迭代器将会到达函数尾部，此时再次访问`next`将会抛出`StopIteration`异常，而此时就算将`crisis`设置为`False`，这些生成器仍然处在函数尾部，访问会继续抛出`StopIteration`异常。\n\n将以上例子用来控制访问资源等用途的时候十分有用。\n\n#### `itertools`，你的好朋友\n`itertools`模块包含了许多用来操作可迭代对象的函数。想复制一个生成器？向连接两个生成器？想把多个值组合到一个嵌套列表里面？使用`map/zip`而不用重新创建一个列表？那么就:`import itertools`吧。\n\n让我们来看看四匹马赛跑可能的到达结果:\n\n```Python\n>>> horses = [1, 2, 3, 4]\n>>> races = itertools.permutations(horses)\n>>> print(races)\n<itertools.permutations object at 0xb754f1dc>\n>>> print(list(itertools.permutations(horses)))\n[(1, 2, 3, 4),\n (1, 2, 4, 3),\n (1, 3, 2, 4),\n (1, 3, 4, 2),\n (1, 4, 2, 3),\n (1, 4, 3, 2),\n (2, 1, 3, 4),\n (2, 1, 4, 3),\n (2, 3, 1, 4),\n (2, 3, 4, 1),\n (2, 4, 1, 3),\n (2, 4, 3, 1),\n (3, 1, 2, 4),\n (3, 1, 4, 2),\n (3, 2, 1, 4),\n (3, 2, 4, 1),\n (3, 4, 1, 2),\n (3, 4, 2, 1),\n (4, 1, 2, 3),\n (4, 1, 3, 2),\n (4, 2, 1, 3),\n (4, 2, 3, 1),\n (4, 3, 1, 2),\n (4, 3, 2, 1)]\n```\n\n#### 迭代的内部机理\n迭代是一个依赖于可迭代对象(需要实现`__iter__()`方法)和迭代器(需要实现`__next__()`方法)的过程。\n> 可迭代对象是任意你可以从中得到一个迭代器的对象。\n  \n> 迭代器是让你可以对可迭代对象进行迭代的对象。\n\n#### 总结\n`yield`语句将你的函数转化成一个能够生成一种能够包装你原函数体的名叫***生成器***的特殊对象的工厂。当生成器被迭代，它将会起始位置开始执行函数一直到到达下一个`yield`，然后挂起执行，计算返回传递给`yield`的值，它将会在每次迭代的时候重复这个过程直到函数执行到达函数的尾部，举例来说:\n\n```Python\ndef simple_generator():\n    yield 'one'\n    yield 'two'\n    yield 'three'\n\nfor i in simple_generator():\n    print i\n```\n\n输出结果为:\n\n```\none\ntwo\nthree\n```\n\n这种效果的产生是由于在循环中使用了可以产生序列的生成器，生成器在每次循环时执行代码到下一个`yield`，并计算返回结果，这样生成器即时生成了一个列表，这对于特别是大型计算来说内存节省十分有效。\n\n假设你想实现自己的可以产生一个可迭代一定范围数的`range`函数(特指Python 2.x中的`range`)，你可以这样做和使用:\n\n```Python\ndef myRangeNaive(i):\n    n = 0\n    range = []\n    while n < i:\n        range.append(n)\n        n = n + 1\n    return range\n\nfor i in myRangeNaive(10):\n    print i\n```\n\n但是这样并不高效，原因1：你创建了一个你只会使用一次的列表；原因2：这段代码实际上循环了两次。\n由于Guido和他的团队很慷慨地开发了生成器因此我们可以这样做:\n\n```Python\ndef myRangeSmart(i):\n    n = 0\n    while n < i:\n       yield n\n       n = n + 1\n    return\n\nfor i in myRangeSmart(10):\n    print i\n```\n\n现在，每次对生成器迭代将会调用`next()`来执行函数体直到到达`yield`语句，然后停止执行，并计算返回结果，或者是到达函数体尾部。在这种情况下，第一次的调用`next()`将会执行到`yield n`并返回`n`，下一次的`next()`将会执行自增操作，然后回到`while`的判断，如果满足条件，则再一次停止并返回`n`，它将会以这种方式执行一直到不满足`while`条件，使得生成器到达函数体尾部。\n\n","source":"_posts/Python-What-does-yield-do.md","raw":"---\ntitle: Python中yield的作用\ndate: 2017-02-10 10:42:13\ntags: [Python,生成器,迭代器]\ncategories: Python\nfrom: http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do\n---\n最近在[StackOverflow](http://stackoverflow.com)上看的问题回答比较多，今天这篇是关于介绍Python生成器的相关思想以及其中关键字`yield`用法的翻译内容。\n\n为了搞清楚`yield`是用来做什么的，你首先得知道Python中***生成器***的相关概念，而为了了解生成器的相关概念，你需要知道什么是***迭代器***。\n\n<!-- more -->\n<div class=\"tip\">\n本篇中的Python除了特殊说明外都是Python 2.x\n</div>\n\n#### 迭代器\n当你创建一个了列表，你可以逐个遍历列表中的元素，而这个过程便叫做***迭代***:\n\n```Python\n>>> mylist = [1, 2, 3]\n>>> for i in mylist:\n...    print(i)\n1\n2\n3\n```\n\n而`mylist`是一个***可迭代对象***。当你使用列表推导式的时候，创建了一个列表，他也是可迭代对象:\n\n```Python\n>>> mylist = [x*x for x in range(3)]\n>>> for i in mylist:\n...    print(i)\n0\n1\n4\n```\n\n所有能够接受`for...in...`操作的对象都是可迭代对象，如列表、字符串、文件等。这些可迭代对象用起来都十分顺手因为你可以按照你的想法去访问它们，但是你把所有数据都保存在了内存中，而当你有大量数据的时候这可能并不是你想要的结果。\n\n#### 生成器\n生成器也是迭代器，但是**你只能对它们进行一次迭代**，原因在于它们并没有将所有数据存储在内存中，而是即时生成这些数据:\n\n```Python\n>>> mygenerator = (x*x for x in range(3))\n>>> for i in mygenerator:\n...    print(i)\n0\n1\n4\n```\n\n这一段代码和上面那段很相似，唯一不同的地方是使用了`()`代替`[]`。但是，这样的后果是你无法对`mygenerator`进行第二次`for i in mygenerator`，因为生成器只能被使用一次:它首先计算出结果0，然后忘记它再计算出1，最后是4，一个接一个。\n\n#### Yield\n`yield`是一个用法跟`return`很相似的关键字，不同在于函数返回的是一个生成器。\n\n```Python\n>>> def createGenerator():\n...    mylist = range(3)\n...    for i in mylist:\n...        yield i*i\n...\n>>> mygenerator = createGenerator() # create a generator\n>>> print(mygenerator) # mygenerator is an object!\n<generator object createGenerator at 0xb7555c34>\n>>> for i in mygenerator:\n...     print(i)\n0\n1\n4\n```\n\n这是一个没有什么用的例子，但是用来让你了解当你知道你的函数会返回一个只会被遍历1次的巨大数据集合该怎么做的时候十分方便。为了掌握`yield`，你必须了解**当你调用这个函数的时候，你在函数体中写的代码并没有被执行**，而是只返回了一个生成器对象，这个需要特别注意。然后，你的代码将会在每次`for`使用这个生成器的时候被执行。最后，最困难的部分:\n> `for`第一次调用通过你函数创建的生成器对象的时候，它将会从你函数的开头执行代码，一直到到达`yield`，然后它将会返回循环中的第一个值。然后，其他每次调用都会再一次执行你在函数中写的那段循环，并返回下一个值，直到没有值可以返回。\n\n生成器在函数执行了却没有到达`yield`的时候将被认为是空的，原因在于循环到达了终点，或者不再满足`if/else`条件。\n\n#### 处理生成器耗尽\n考虑以下代码:\n\n```Python\n>>> class Bank(): # let's create a bank, building ATMs\n...    crisis = False\n...    def create_atm(self):\n...        while not self.crisis:\n...            yield \"$100\"\n\n>>> hsbc = Bank() # when everything's ok the ATM gives you as much as you want\n>>> corner_street_atm = hsbc.create_atm()\n>>> print(corner_street_atm.next())\n$100\n>>> print(corner_street_atm.next())\n$100\n>>> print([corner_street_atm.next() for cash in range(5)])\n['$100', '$100', '$100', '$100', '$100']\n\n>>> hsbc.crisis = True # crisis is coming, no more money!\n>>> print(corner_street_atm.next())\n<type 'exceptions.StopIteration'>\n>>> wall_street_atm = hsbc.create_atm() # it's even true for new ATMs\n>>> print(wall_street_atm.next())\n<type 'exceptions.StopIteration'>\n>>> hsbc.crisis = False # trouble is, even post-crisis the ATM remains empty\n>>> print(corner_street_atm.next())\n<type 'exceptions.StopIteration'>\n>>> brand_new_atm = hsbc.create_atm() # build a new one to get back in business\n>>> for cash in brand_new_atm:\n...    print cash\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n...\n```\n\n首先看生成器的`next`方法，它用来执行代码并从生成器中获取下一个元素(在Python 3.x中生成器已经没有next方法，而是使用next(iterator)代替)。在`crisis`未被置为`True`的时候，`create_atm`函数中的`while`循环可以看做是无尽的，当`crisis`为`True`的时候，跳出了`while`循环，所有迭代器将会到达函数尾部，此时再次访问`next`将会抛出`StopIteration`异常，而此时就算将`crisis`设置为`False`，这些生成器仍然处在函数尾部，访问会继续抛出`StopIteration`异常。\n\n将以上例子用来控制访问资源等用途的时候十分有用。\n\n#### `itertools`，你的好朋友\n`itertools`模块包含了许多用来操作可迭代对象的函数。想复制一个生成器？向连接两个生成器？想把多个值组合到一个嵌套列表里面？使用`map/zip`而不用重新创建一个列表？那么就:`import itertools`吧。\n\n让我们来看看四匹马赛跑可能的到达结果:\n\n```Python\n>>> horses = [1, 2, 3, 4]\n>>> races = itertools.permutations(horses)\n>>> print(races)\n<itertools.permutations object at 0xb754f1dc>\n>>> print(list(itertools.permutations(horses)))\n[(1, 2, 3, 4),\n (1, 2, 4, 3),\n (1, 3, 2, 4),\n (1, 3, 4, 2),\n (1, 4, 2, 3),\n (1, 4, 3, 2),\n (2, 1, 3, 4),\n (2, 1, 4, 3),\n (2, 3, 1, 4),\n (2, 3, 4, 1),\n (2, 4, 1, 3),\n (2, 4, 3, 1),\n (3, 1, 2, 4),\n (3, 1, 4, 2),\n (3, 2, 1, 4),\n (3, 2, 4, 1),\n (3, 4, 1, 2),\n (3, 4, 2, 1),\n (4, 1, 2, 3),\n (4, 1, 3, 2),\n (4, 2, 1, 3),\n (4, 2, 3, 1),\n (4, 3, 1, 2),\n (4, 3, 2, 1)]\n```\n\n#### 迭代的内部机理\n迭代是一个依赖于可迭代对象(需要实现`__iter__()`方法)和迭代器(需要实现`__next__()`方法)的过程。\n> 可迭代对象是任意你可以从中得到一个迭代器的对象。\n  \n> 迭代器是让你可以对可迭代对象进行迭代的对象。\n\n#### 总结\n`yield`语句将你的函数转化成一个能够生成一种能够包装你原函数体的名叫***生成器***的特殊对象的工厂。当生成器被迭代，它将会起始位置开始执行函数一直到到达下一个`yield`，然后挂起执行，计算返回传递给`yield`的值，它将会在每次迭代的时候重复这个过程直到函数执行到达函数的尾部，举例来说:\n\n```Python\ndef simple_generator():\n    yield 'one'\n    yield 'two'\n    yield 'three'\n\nfor i in simple_generator():\n    print i\n```\n\n输出结果为:\n\n```\none\ntwo\nthree\n```\n\n这种效果的产生是由于在循环中使用了可以产生序列的生成器，生成器在每次循环时执行代码到下一个`yield`，并计算返回结果，这样生成器即时生成了一个列表，这对于特别是大型计算来说内存节省十分有效。\n\n假设你想实现自己的可以产生一个可迭代一定范围数的`range`函数(特指Python 2.x中的`range`)，你可以这样做和使用:\n\n```Python\ndef myRangeNaive(i):\n    n = 0\n    range = []\n    while n < i:\n        range.append(n)\n        n = n + 1\n    return range\n\nfor i in myRangeNaive(10):\n    print i\n```\n\n但是这样并不高效，原因1：你创建了一个你只会使用一次的列表；原因2：这段代码实际上循环了两次。\n由于Guido和他的团队很慷慨地开发了生成器因此我们可以这样做:\n\n```Python\ndef myRangeSmart(i):\n    n = 0\n    while n < i:\n       yield n\n       n = n + 1\n    return\n\nfor i in myRangeSmart(10):\n    print i\n```\n\n现在，每次对生成器迭代将会调用`next()`来执行函数体直到到达`yield`语句，然后停止执行，并计算返回结果，或者是到达函数体尾部。在这种情况下，第一次的调用`next()`将会执行到`yield n`并返回`n`，下一次的`next()`将会执行自增操作，然后回到`while`的判断，如果满足条件，则再一次停止并返回`n`，它将会以这种方式执行一直到不满足`while`条件，使得生成器到达函数体尾部。\n\n","slug":"Python-What-does-yield-do","published":1,"updated":"2018-01-13T00:50:39.866Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgvnqml7000xw6281wkd7h77","content":"<p>最近在<a href=\"http://stackoverflow.com\" target=\"_blank\" rel=\"noopener\">StackOverflow</a>上看的问题回答比较多，今天这篇是关于介绍Python生成器的相关思想以及其中关键字<code>yield</code>用法的翻译内容。</p>\n<p>为了搞清楚<code>yield</code>是用来做什么的，你首先得知道Python中<strong><em>生成器</em></strong>的相关概念，而为了了解生成器的相关概念，你需要知道什么是<strong><em>迭代器</em></strong>。</p>\n<a id=\"more\"></a>\n<div class=\"tip\"><br>本篇中的Python除了特殊说明外都是Python 2.x<br></div>\n\n<h4 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h4><p>当你创建一个了列表，你可以逐个遍历列表中的元素，而这个过程便叫做<strong><em>迭代</em></strong>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mylist = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> mylist:</span><br><span class=\"line\"><span class=\"meta\">... </span>   print(i)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>而<code>mylist</code>是一个<strong><em>可迭代对象</em></strong>。当你使用列表推导式的时候，创建了一个列表，他也是可迭代对象:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mylist = [x*x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>)]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> mylist:</span><br><span class=\"line\"><span class=\"meta\">... </span>   print(i)</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>所有能够接受<code>for...in...</code>操作的对象都是可迭代对象，如列表、字符串、文件等。这些可迭代对象用起来都十分顺手因为你可以按照你的想法去访问它们，但是你把所有数据都保存在了内存中，而当你有大量数据的时候这可能并不是你想要的结果。</p>\n<h4 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h4><p>生成器也是迭代器，但是<strong>你只能对它们进行一次迭代</strong>，原因在于它们并没有将所有数据存储在内存中，而是即时生成这些数据:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mygenerator = (x*x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>))</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> mygenerator:</span><br><span class=\"line\"><span class=\"meta\">... </span>   print(i)</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>这一段代码和上面那段很相似，唯一不同的地方是使用了<code>()</code>代替<code>[]</code>。但是，这样的后果是你无法对<code>mygenerator</code>进行第二次<code>for i in mygenerator</code>，因为生成器只能被使用一次:它首先计算出结果0，然后忘记它再计算出1，最后是4，一个接一个。</p>\n<h4 id=\"Yield\"><a href=\"#Yield\" class=\"headerlink\" title=\"Yield\"></a>Yield</h4><p><code>yield</code>是一个用法跟<code>return</code>很相似的关键字，不同在于函数返回的是一个生成器。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">createGenerator</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>   mylist = range(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"meta\">... </span>   <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> mylist:</span><br><span class=\"line\"><span class=\"meta\">... </span>       <span class=\"keyword\">yield</span> i*i</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mygenerator = createGenerator() <span class=\"comment\"># create a generator</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(mygenerator) <span class=\"comment\"># mygenerator is an object!</span></span><br><span class=\"line\">&lt;generator object createGenerator at <span class=\"number\">0xb7555c34</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> mygenerator:</span><br><span class=\"line\"><span class=\"meta\">... </span>    print(i)</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>这是一个没有什么用的例子，但是用来让你了解当你知道你的函数会返回一个只会被遍历1次的巨大数据集合该怎么做的时候十分方便。为了掌握<code>yield</code>，你必须了解<strong>当你调用这个函数的时候，你在函数体中写的代码并没有被执行</strong>，而是只返回了一个生成器对象，这个需要特别注意。然后，你的代码将会在每次<code>for</code>使用这个生成器的时候被执行。最后，最困难的部分:</p>\n<blockquote>\n<p><code>for</code>第一次调用通过你函数创建的生成器对象的时候，它将会从你函数的开头执行代码，一直到到达<code>yield</code>，然后它将会返回循环中的第一个值。然后，其他每次调用都会再一次执行你在函数中写的那段循环，并返回下一个值，直到没有值可以返回。</p>\n</blockquote>\n<p>生成器在函数执行了却没有到达<code>yield</code>的时候将被认为是空的，原因在于循环到达了终点，或者不再满足<code>if/else</code>条件。</p>\n<h4 id=\"处理生成器耗尽\"><a href=\"#处理生成器耗尽\" class=\"headerlink\" title=\"处理生成器耗尽\"></a>处理生成器耗尽</h4><p>考虑以下代码:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bank</span><span class=\"params\">()</span>:</span> <span class=\"comment\"># let's create a bank, building ATMs</span></span><br><span class=\"line\"><span class=\"meta\">... </span>   crisis = <span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"meta\">... </span>   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_atm</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>       <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> self.crisis:</span><br><span class=\"line\"><span class=\"meta\">... </span>           <span class=\"keyword\">yield</span> <span class=\"string\">\"$100\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hsbc = Bank() <span class=\"comment\"># when everything's ok the ATM gives you as much as you want</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>corner_street_atm = hsbc.create_atm()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print([corner_street_atm.next() <span class=\"keyword\">for</span> cash <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>)])</span><br><span class=\"line\">[<span class=\"string\">'$100'</span>, <span class=\"string\">'$100'</span>, <span class=\"string\">'$100'</span>, <span class=\"string\">'$100'</span>, <span class=\"string\">'$100'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hsbc.crisis = <span class=\"keyword\">True</span> <span class=\"comment\"># crisis is coming, no more money!</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class=\"line\">&lt;type <span class=\"string\">'exceptions.StopIteration'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>wall_street_atm = hsbc.create_atm() <span class=\"comment\"># it's even true for new ATMs</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(wall_street_atm.next())</span><br><span class=\"line\">&lt;type <span class=\"string\">'exceptions.StopIteration'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hsbc.crisis = <span class=\"keyword\">False</span> <span class=\"comment\"># trouble is, even post-crisis the ATM remains empty</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class=\"line\">&lt;type <span class=\"string\">'exceptions.StopIteration'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>brand_new_atm = hsbc.create_atm() <span class=\"comment\"># build a new one to get back in business</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> cash <span class=\"keyword\">in</span> brand_new_atm:</span><br><span class=\"line\"><span class=\"meta\">... </span>   <span class=\"keyword\">print</span> cash</span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>首先看生成器的<code>next</code>方法，它用来执行代码并从生成器中获取下一个元素(在Python 3.x中生成器已经没有next方法，而是使用next(iterator)代替)。在<code>crisis</code>未被置为<code>True</code>的时候，<code>create_atm</code>函数中的<code>while</code>循环可以看做是无尽的，当<code>crisis</code>为<code>True</code>的时候，跳出了<code>while</code>循环，所有迭代器将会到达函数尾部，此时再次访问<code>next</code>将会抛出<code>StopIteration</code>异常，而此时就算将<code>crisis</code>设置为<code>False</code>，这些生成器仍然处在函数尾部，访问会继续抛出<code>StopIteration</code>异常。</p>\n<p>将以上例子用来控制访问资源等用途的时候十分有用。</p>\n<h4 id=\"itertools，你的好朋友\"><a href=\"#itertools，你的好朋友\" class=\"headerlink\" title=\"itertools，你的好朋友\"></a><code>itertools</code>，你的好朋友</h4><p><code>itertools</code>模块包含了许多用来操作可迭代对象的函数。想复制一个生成器？向连接两个生成器？想把多个值组合到一个嵌套列表里面？使用<code>map/zip</code>而不用重新创建一个列表？那么就:<code>import itertools</code>吧。</p>\n<p>让我们来看看四匹马赛跑可能的到达结果:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>horses = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>races = itertools.permutations(horses)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(races)</span><br><span class=\"line\">&lt;itertools.permutations object at <span class=\"number\">0xb754f1dc</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(list(itertools.permutations(horses)))</span><br><span class=\"line\">[(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>),</span><br><span class=\"line\"> (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>),</span><br><span class=\"line\"> (<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>),</span><br><span class=\"line\"> (<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>),</span><br><span class=\"line\"> (<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>),</span><br><span class=\"line\"> (<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>),</span><br><span class=\"line\"> (<span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>),</span><br><span class=\"line\"> (<span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>),</span><br><span class=\"line\"> (<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>),</span><br><span class=\"line\"> (<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>),</span><br><span class=\"line\"> (<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>),</span><br><span class=\"line\"> (<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>),</span><br><span class=\"line\"> (<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>),</span><br><span class=\"line\"> (<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>),</span><br><span class=\"line\"> (<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>),</span><br><span class=\"line\"> (<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>),</span><br><span class=\"line\"> (<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>),</span><br><span class=\"line\"> (<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>),</span><br><span class=\"line\"> (<span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>),</span><br><span class=\"line\"> (<span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>),</span><br><span class=\"line\"> (<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>),</span><br><span class=\"line\"> (<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>),</span><br><span class=\"line\"> (<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>),</span><br><span class=\"line\"> (<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>)]</span><br></pre></td></tr></table></figure>\n<h4 id=\"迭代的内部机理\"><a href=\"#迭代的内部机理\" class=\"headerlink\" title=\"迭代的内部机理\"></a>迭代的内部机理</h4><p>迭代是一个依赖于可迭代对象(需要实现<code>__iter__()</code>方法)和迭代器(需要实现<code>__next__()</code>方法)的过程。</p>\n<blockquote>\n<p>可迭代对象是任意你可以从中得到一个迭代器的对象。</p>\n<p>迭代器是让你可以对可迭代对象进行迭代的对象。</p>\n</blockquote>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p><code>yield</code>语句将你的函数转化成一个能够生成一种能够包装你原函数体的名叫<strong><em>生成器</em></strong>的特殊对象的工厂。当生成器被迭代，它将会起始位置开始执行函数一直到到达下一个<code>yield</code>，然后挂起执行，计算返回传递给<code>yield</code>的值，它将会在每次迭代的时候重复这个过程直到函数执行到达函数的尾部，举例来说:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">simple_generator</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'one'</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'two'</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'three'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> simple_generator():</span><br><span class=\"line\">    <span class=\"keyword\">print</span> i</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">one</span><br><span class=\"line\">two</span><br><span class=\"line\">three</span><br></pre></td></tr></table></figure>\n<p>这种效果的产生是由于在循环中使用了可以产生序列的生成器，生成器在每次循环时执行代码到下一个<code>yield</code>，并计算返回结果，这样生成器即时生成了一个列表，这对于特别是大型计算来说内存节省十分有效。</p>\n<p>假设你想实现自己的可以产生一个可迭代一定范围数的<code>range</code>函数(特指Python 2.x中的<code>range</code>)，你可以这样做和使用:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myRangeNaive</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">    n = <span class=\"number\">0</span></span><br><span class=\"line\">    range = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &lt; i:</span><br><span class=\"line\">        range.append(n)</span><br><span class=\"line\">        n = n + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> range</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> myRangeNaive(<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">print</span> i</span><br></pre></td></tr></table></figure>\n<p>但是这样并不高效，原因1：你创建了一个你只会使用一次的列表；原因2：这段代码实际上循环了两次。<br>由于Guido和他的团队很慷慨地开发了生成器因此我们可以这样做:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myRangeSmart</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">    n = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &lt; i:</span><br><span class=\"line\">       <span class=\"keyword\">yield</span> n</span><br><span class=\"line\">       n = n + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> myRangeSmart(<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">print</span> i</span><br></pre></td></tr></table></figure>\n<p>现在，每次对生成器迭代将会调用<code>next()</code>来执行函数体直到到达<code>yield</code>语句，然后停止执行，并计算返回结果，或者是到达函数体尾部。在这种情况下，第一次的调用<code>next()</code>将会执行到<code>yield n</code>并返回<code>n</code>，下一次的<code>next()</code>将会执行自增操作，然后回到<code>while</code>的判断，如果满足条件，则再一次停止并返回<code>n</code>，它将会以这种方式执行一直到不满足<code>while</code>条件，使得生成器到达函数体尾部。</p>\n","site":{"data":{}},"excerpt":"<p>最近在<a href=\"http://stackoverflow.com\" target=\"_blank\" rel=\"noopener\">StackOverflow</a>上看的问题回答比较多，今天这篇是关于介绍Python生成器的相关思想以及其中关键字<code>yield</code>用法的翻译内容。</p>\n<p>为了搞清楚<code>yield</code>是用来做什么的，你首先得知道Python中<strong><em>生成器</em></strong>的相关概念，而为了了解生成器的相关概念，你需要知道什么是<strong><em>迭代器</em></strong>。</p>","more":"<div class=\"tip\"><br>本篇中的Python除了特殊说明外都是Python 2.x<br></div>\n\n<h4 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h4><p>当你创建一个了列表，你可以逐个遍历列表中的元素，而这个过程便叫做<strong><em>迭代</em></strong>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mylist = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> mylist:</span><br><span class=\"line\"><span class=\"meta\">... </span>   print(i)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>而<code>mylist</code>是一个<strong><em>可迭代对象</em></strong>。当你使用列表推导式的时候，创建了一个列表，他也是可迭代对象:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mylist = [x*x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>)]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> mylist:</span><br><span class=\"line\"><span class=\"meta\">... </span>   print(i)</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>所有能够接受<code>for...in...</code>操作的对象都是可迭代对象，如列表、字符串、文件等。这些可迭代对象用起来都十分顺手因为你可以按照你的想法去访问它们，但是你把所有数据都保存在了内存中，而当你有大量数据的时候这可能并不是你想要的结果。</p>\n<h4 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h4><p>生成器也是迭代器，但是<strong>你只能对它们进行一次迭代</strong>，原因在于它们并没有将所有数据存储在内存中，而是即时生成这些数据:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mygenerator = (x*x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>))</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> mygenerator:</span><br><span class=\"line\"><span class=\"meta\">... </span>   print(i)</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>这一段代码和上面那段很相似，唯一不同的地方是使用了<code>()</code>代替<code>[]</code>。但是，这样的后果是你无法对<code>mygenerator</code>进行第二次<code>for i in mygenerator</code>，因为生成器只能被使用一次:它首先计算出结果0，然后忘记它再计算出1，最后是4，一个接一个。</p>\n<h4 id=\"Yield\"><a href=\"#Yield\" class=\"headerlink\" title=\"Yield\"></a>Yield</h4><p><code>yield</code>是一个用法跟<code>return</code>很相似的关键字，不同在于函数返回的是一个生成器。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">createGenerator</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>   mylist = range(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"meta\">... </span>   <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> mylist:</span><br><span class=\"line\"><span class=\"meta\">... </span>       <span class=\"keyword\">yield</span> i*i</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mygenerator = createGenerator() <span class=\"comment\"># create a generator</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(mygenerator) <span class=\"comment\"># mygenerator is an object!</span></span><br><span class=\"line\">&lt;generator object createGenerator at <span class=\"number\">0xb7555c34</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> mygenerator:</span><br><span class=\"line\"><span class=\"meta\">... </span>    print(i)</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>这是一个没有什么用的例子，但是用来让你了解当你知道你的函数会返回一个只会被遍历1次的巨大数据集合该怎么做的时候十分方便。为了掌握<code>yield</code>，你必须了解<strong>当你调用这个函数的时候，你在函数体中写的代码并没有被执行</strong>，而是只返回了一个生成器对象，这个需要特别注意。然后，你的代码将会在每次<code>for</code>使用这个生成器的时候被执行。最后，最困难的部分:</p>\n<blockquote>\n<p><code>for</code>第一次调用通过你函数创建的生成器对象的时候，它将会从你函数的开头执行代码，一直到到达<code>yield</code>，然后它将会返回循环中的第一个值。然后，其他每次调用都会再一次执行你在函数中写的那段循环，并返回下一个值，直到没有值可以返回。</p>\n</blockquote>\n<p>生成器在函数执行了却没有到达<code>yield</code>的时候将被认为是空的，原因在于循环到达了终点，或者不再满足<code>if/else</code>条件。</p>\n<h4 id=\"处理生成器耗尽\"><a href=\"#处理生成器耗尽\" class=\"headerlink\" title=\"处理生成器耗尽\"></a>处理生成器耗尽</h4><p>考虑以下代码:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bank</span><span class=\"params\">()</span>:</span> <span class=\"comment\"># let's create a bank, building ATMs</span></span><br><span class=\"line\"><span class=\"meta\">... </span>   crisis = <span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"meta\">... </span>   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_atm</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>       <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> self.crisis:</span><br><span class=\"line\"><span class=\"meta\">... </span>           <span class=\"keyword\">yield</span> <span class=\"string\">\"$100\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hsbc = Bank() <span class=\"comment\"># when everything's ok the ATM gives you as much as you want</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>corner_street_atm = hsbc.create_atm()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print([corner_street_atm.next() <span class=\"keyword\">for</span> cash <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>)])</span><br><span class=\"line\">[<span class=\"string\">'$100'</span>, <span class=\"string\">'$100'</span>, <span class=\"string\">'$100'</span>, <span class=\"string\">'$100'</span>, <span class=\"string\">'$100'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hsbc.crisis = <span class=\"keyword\">True</span> <span class=\"comment\"># crisis is coming, no more money!</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class=\"line\">&lt;type <span class=\"string\">'exceptions.StopIteration'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>wall_street_atm = hsbc.create_atm() <span class=\"comment\"># it's even true for new ATMs</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(wall_street_atm.next())</span><br><span class=\"line\">&lt;type <span class=\"string\">'exceptions.StopIteration'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hsbc.crisis = <span class=\"keyword\">False</span> <span class=\"comment\"># trouble is, even post-crisis the ATM remains empty</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class=\"line\">&lt;type <span class=\"string\">'exceptions.StopIteration'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>brand_new_atm = hsbc.create_atm() <span class=\"comment\"># build a new one to get back in business</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> cash <span class=\"keyword\">in</span> brand_new_atm:</span><br><span class=\"line\"><span class=\"meta\">... </span>   <span class=\"keyword\">print</span> cash</span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\">$<span class=\"number\">100</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>首先看生成器的<code>next</code>方法，它用来执行代码并从生成器中获取下一个元素(在Python 3.x中生成器已经没有next方法，而是使用next(iterator)代替)。在<code>crisis</code>未被置为<code>True</code>的时候，<code>create_atm</code>函数中的<code>while</code>循环可以看做是无尽的，当<code>crisis</code>为<code>True</code>的时候，跳出了<code>while</code>循环，所有迭代器将会到达函数尾部，此时再次访问<code>next</code>将会抛出<code>StopIteration</code>异常，而此时就算将<code>crisis</code>设置为<code>False</code>，这些生成器仍然处在函数尾部，访问会继续抛出<code>StopIteration</code>异常。</p>\n<p>将以上例子用来控制访问资源等用途的时候十分有用。</p>\n<h4 id=\"itertools，你的好朋友\"><a href=\"#itertools，你的好朋友\" class=\"headerlink\" title=\"itertools，你的好朋友\"></a><code>itertools</code>，你的好朋友</h4><p><code>itertools</code>模块包含了许多用来操作可迭代对象的函数。想复制一个生成器？向连接两个生成器？想把多个值组合到一个嵌套列表里面？使用<code>map/zip</code>而不用重新创建一个列表？那么就:<code>import itertools</code>吧。</p>\n<p>让我们来看看四匹马赛跑可能的到达结果:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>horses = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>races = itertools.permutations(horses)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(races)</span><br><span class=\"line\">&lt;itertools.permutations object at <span class=\"number\">0xb754f1dc</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(list(itertools.permutations(horses)))</span><br><span class=\"line\">[(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>),</span><br><span class=\"line\"> (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>),</span><br><span class=\"line\"> (<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>),</span><br><span class=\"line\"> (<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>),</span><br><span class=\"line\"> (<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>),</span><br><span class=\"line\"> (<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>),</span><br><span class=\"line\"> (<span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>),</span><br><span class=\"line\"> (<span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>),</span><br><span class=\"line\"> (<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>),</span><br><span class=\"line\"> (<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>),</span><br><span class=\"line\"> (<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>),</span><br><span class=\"line\"> (<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>),</span><br><span class=\"line\"> (<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>),</span><br><span class=\"line\"> (<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>),</span><br><span class=\"line\"> (<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>),</span><br><span class=\"line\"> (<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>),</span><br><span class=\"line\"> (<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>),</span><br><span class=\"line\"> (<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>),</span><br><span class=\"line\"> (<span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>),</span><br><span class=\"line\"> (<span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>),</span><br><span class=\"line\"> (<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>),</span><br><span class=\"line\"> (<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>),</span><br><span class=\"line\"> (<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>),</span><br><span class=\"line\"> (<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>)]</span><br></pre></td></tr></table></figure>\n<h4 id=\"迭代的内部机理\"><a href=\"#迭代的内部机理\" class=\"headerlink\" title=\"迭代的内部机理\"></a>迭代的内部机理</h4><p>迭代是一个依赖于可迭代对象(需要实现<code>__iter__()</code>方法)和迭代器(需要实现<code>__next__()</code>方法)的过程。</p>\n<blockquote>\n<p>可迭代对象是任意你可以从中得到一个迭代器的对象。</p>\n<p>迭代器是让你可以对可迭代对象进行迭代的对象。</p>\n</blockquote>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p><code>yield</code>语句将你的函数转化成一个能够生成一种能够包装你原函数体的名叫<strong><em>生成器</em></strong>的特殊对象的工厂。当生成器被迭代，它将会起始位置开始执行函数一直到到达下一个<code>yield</code>，然后挂起执行，计算返回传递给<code>yield</code>的值，它将会在每次迭代的时候重复这个过程直到函数执行到达函数的尾部，举例来说:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">simple_generator</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'one'</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'two'</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'three'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> simple_generator():</span><br><span class=\"line\">    <span class=\"keyword\">print</span> i</span><br></pre></td></tr></table></figure>\n<p>输出结果为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">one</span><br><span class=\"line\">two</span><br><span class=\"line\">three</span><br></pre></td></tr></table></figure>\n<p>这种效果的产生是由于在循环中使用了可以产生序列的生成器，生成器在每次循环时执行代码到下一个<code>yield</code>，并计算返回结果，这样生成器即时生成了一个列表，这对于特别是大型计算来说内存节省十分有效。</p>\n<p>假设你想实现自己的可以产生一个可迭代一定范围数的<code>range</code>函数(特指Python 2.x中的<code>range</code>)，你可以这样做和使用:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myRangeNaive</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">    n = <span class=\"number\">0</span></span><br><span class=\"line\">    range = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &lt; i:</span><br><span class=\"line\">        range.append(n)</span><br><span class=\"line\">        n = n + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> range</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> myRangeNaive(<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">print</span> i</span><br></pre></td></tr></table></figure>\n<p>但是这样并不高效，原因1：你创建了一个你只会使用一次的列表；原因2：这段代码实际上循环了两次。<br>由于Guido和他的团队很慷慨地开发了生成器因此我们可以这样做:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myRangeSmart</span><span class=\"params\">(i)</span>:</span></span><br><span class=\"line\">    n = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &lt; i:</span><br><span class=\"line\">       <span class=\"keyword\">yield</span> n</span><br><span class=\"line\">       n = n + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> myRangeSmart(<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">print</span> i</span><br></pre></td></tr></table></figure>\n<p>现在，每次对生成器迭代将会调用<code>next()</code>来执行函数体直到到达<code>yield</code>语句，然后停止执行，并计算返回结果，或者是到达函数体尾部。在这种情况下，第一次的调用<code>next()</code>将会执行到<code>yield n</code>并返回<code>n</code>，下一次的<code>next()</code>将会执行自增操作，然后回到<code>while</code>的判断，如果满足条件，则再一次停止并返回<code>n</code>，它将会以这种方式执行一直到不满足<code>while</code>条件，使得生成器到达函数体尾部。</p>"},{"title":"Python中yield from的用法","date":"2017-02-10T05:22:58.000Z","from":"http://stackoverflow.com/a/26109157/331785","_content":"\n上一篇中谈到了迭代器、生成器以及`yield`的相关内容，而Python 3.3中，引入了在[PEP 380 -- Syntax for Delegating to a Subgenerator](https://www.python.org/dev/peps/pep-0380/)中提出的`yield from`关键字，大幅简化了Python程序员在使用协程的时候的编程过程。\n\n<div class=\"tip\">\n本文内容除特殊说明外均基于Python 3.3以上版本。\n</div>\n\n首先需要声明的是，`yield from g`并不完全等于`for v in g: yield v`。而是应该将`yield from`看成为**调用者(caller)**和**子生成器(sub-generator)**之间提供了一种**透明地双向通道**。这包括了从子生成器中获取数据并向子生成器发送数据。\n\n<!-- more -->\n\n#### 使用`yield from`从生成器中获得数据\n考虑以下代码:\n\n```Python\ndef reader():\n    \"\"\"A generator that fakes a read from a file, socket, etc.\"\"\"\n    for i in range(4):\n        yield '<< %s' % i\n\ndef reader_wrapper(g):\n    # Manually iterate over data produced by reader\n    for v in g:\n        yield v\n\nwrap = reader_wrapper(reader())\nfor i in wrap:\n    print(i)\n\n# Result\n<< 0\n<< 1\n<< 2\n<< 3\n```\n\n我们其实可以使用`yield from`来代替亲自迭代`reader()`:\n\n```Python\ndef reader_wrapper(g):\n    yield from g\n```\n\n这可以很好的工作而且减少了一行代码，而且可能使得我们的意图更加明确。\n\n#### 使用`yield from`向生成器发送数据\n现在让我们做些更有趣的。首先创建一个名叫`writer`的协程，它可以接收发送给它的数据并写给套接字、文件描述符等等:\n\n```Python\ndef writer():\n    \"\"\"A coroutine that writes data *sent* to it to fd, socket, etc.\"\"\"\n    while True:\n        w = (yield)\n        print('>> ', w)\n```\n\n现在的问题是，包装函数`wrapper`如何处理将数据发送给`writer`，使得发送给包装函数的数据能够透明地发送给`writer()`？\n\n```Python\ndef writer_wrapper(coro):\n    # TBD\n    pass\n\nw = writer()\nwrap = writer_wrapper(w)\nwrap.send(None)  # \"prime\" the coroutine\nfor i in range(4):\n    wrap.send(i)\n\n# Expected result\n>>  0\n>>  1\n>>  2\n>>  3\n```\n\n包装函数需要接受发送给它的数据(显而易见地)而且应该在循环结束的时候处理`StopIteration`异常。很明显只是完成`for x in coro: yield x`的话不能胜任这项工作。下面是一个能够工作的版本:\n\n```Python\ndef writer_wrapper(coro):\n    coro.send(None)  # prime the coro\n    while True:\n        try:\n            x = (yield)  # Capture the value that's sent\n            coro.send(x)  # and pass it to the writer\n        except StopIteration:\n            pass\n```\n\n或者，我们可以这样做:\n\n```Python\ndef writer_wrapper(coro):\n    yield from coro\n```\n\n这节省了6行代码，而且使得代码更加清晰易读，最关键的是，它可行！\n\n#### 使用`yield from`向生成器发送数据——异常处理\n让我们使这个例子更复杂点，假设我们的`writer`需要处理异常呢？比如`writer`捕获`SpamException`异常并且在遇到这个的时候打印`***`。\n\n```Python\nclass SpamException(Exception):\n    pass\n\ndef writer():\n    while True:\n        try:\n            w = (yield)\n        except SpamException:\n            print('***')\n        else:\n            print('>> ', w)\n```\n\n如果我们使用原始版本的`writer_wrapper`，会怎样？\n\n```Python\n# writer_wrapper same as above\n\nw = writer()\nwrap = writer_wrapper(w)\nwrap.send(None)  # \"prime\" the coroutine\nfor i in [0, 1, 2, 'spam', 4]:\n    if i == 'spam':\n        wrap.throw(SpamException)\n    else:\n        wrap.send(i)\n\n# Expected Result\n>>  0\n>>  1\n>>  2\n***\n>>  4\n\n# Actual Result\n>>  0\n>>  1\n>>  2\nTraceback (most recent call last):\n  ... redacted ...\n  File ... in writer_wrapper\n    x = (yield)\n__main__.SpamException\n```\n\n不能正常工作的原因是因为`x = (yield)`抛出了这个异常所以导致了程序崩溃。要使得其正常工作的话，我们需要亲自捕获异常并将它传递给子生成器(`writer`)：\n\n```Python\ndef writer_wrapper(coro):\n    \"\"\"Works. Manually catches exceptions and throws them\"\"\"\n    coro.send(None)  # prime the coro\n    while True:\n        try:\n            try:\n                x = (yield)\n            except Exception as e:   # This catches the SpamException\n                coro.throw(e)\n            else:\n                coro.send(x)\n        except StopIteration:\n            pass\n\n...\n# Result\n>>  0\n>>  1\n>>  2\n***\n>>  4\n```\n\n这可以正常工作，但是假设我们这样呢:\n\n```Python\ndef writer_wrapper(coro):\n    yield from coro\n```\n\n`yield from`语句透明地将数据或者异常发送给子生成器。\n\n以上仍然没有覆盖所有的特殊情况。如果外部生成器关闭了会怎样？子生成器返回了一个值会怎样(Python 3里生成器可以返回值)？返回值会怎样被处理？而`yield from`很好的处理了以上所有情况。\n\n#### 总结\n<div class=\"tip\">\n`yield from`是**调用者**和**子生成器**之间的一个**双向透明通道**。\n</div>\n\n更多关于`yield from`的内容可以阅读[PEP 380 -- Syntax for Delegating to a Subgenerator](https://www.python.org/dev/peps/pep-0380/)。\n","source":"_posts/Python-main-use-for-yield-from.md","raw":"---\ntitle: Python中yield from的用法\ndate: 2017-02-10 13:22:58\ntags: [Python,生成器,迭代器]\ncategories: Python\nfrom: http://stackoverflow.com/a/26109157/331785\n---\n\n上一篇中谈到了迭代器、生成器以及`yield`的相关内容，而Python 3.3中，引入了在[PEP 380 -- Syntax for Delegating to a Subgenerator](https://www.python.org/dev/peps/pep-0380/)中提出的`yield from`关键字，大幅简化了Python程序员在使用协程的时候的编程过程。\n\n<div class=\"tip\">\n本文内容除特殊说明外均基于Python 3.3以上版本。\n</div>\n\n首先需要声明的是，`yield from g`并不完全等于`for v in g: yield v`。而是应该将`yield from`看成为**调用者(caller)**和**子生成器(sub-generator)**之间提供了一种**透明地双向通道**。这包括了从子生成器中获取数据并向子生成器发送数据。\n\n<!-- more -->\n\n#### 使用`yield from`从生成器中获得数据\n考虑以下代码:\n\n```Python\ndef reader():\n    \"\"\"A generator that fakes a read from a file, socket, etc.\"\"\"\n    for i in range(4):\n        yield '<< %s' % i\n\ndef reader_wrapper(g):\n    # Manually iterate over data produced by reader\n    for v in g:\n        yield v\n\nwrap = reader_wrapper(reader())\nfor i in wrap:\n    print(i)\n\n# Result\n<< 0\n<< 1\n<< 2\n<< 3\n```\n\n我们其实可以使用`yield from`来代替亲自迭代`reader()`:\n\n```Python\ndef reader_wrapper(g):\n    yield from g\n```\n\n这可以很好的工作而且减少了一行代码，而且可能使得我们的意图更加明确。\n\n#### 使用`yield from`向生成器发送数据\n现在让我们做些更有趣的。首先创建一个名叫`writer`的协程，它可以接收发送给它的数据并写给套接字、文件描述符等等:\n\n```Python\ndef writer():\n    \"\"\"A coroutine that writes data *sent* to it to fd, socket, etc.\"\"\"\n    while True:\n        w = (yield)\n        print('>> ', w)\n```\n\n现在的问题是，包装函数`wrapper`如何处理将数据发送给`writer`，使得发送给包装函数的数据能够透明地发送给`writer()`？\n\n```Python\ndef writer_wrapper(coro):\n    # TBD\n    pass\n\nw = writer()\nwrap = writer_wrapper(w)\nwrap.send(None)  # \"prime\" the coroutine\nfor i in range(4):\n    wrap.send(i)\n\n# Expected result\n>>  0\n>>  1\n>>  2\n>>  3\n```\n\n包装函数需要接受发送给它的数据(显而易见地)而且应该在循环结束的时候处理`StopIteration`异常。很明显只是完成`for x in coro: yield x`的话不能胜任这项工作。下面是一个能够工作的版本:\n\n```Python\ndef writer_wrapper(coro):\n    coro.send(None)  # prime the coro\n    while True:\n        try:\n            x = (yield)  # Capture the value that's sent\n            coro.send(x)  # and pass it to the writer\n        except StopIteration:\n            pass\n```\n\n或者，我们可以这样做:\n\n```Python\ndef writer_wrapper(coro):\n    yield from coro\n```\n\n这节省了6行代码，而且使得代码更加清晰易读，最关键的是，它可行！\n\n#### 使用`yield from`向生成器发送数据——异常处理\n让我们使这个例子更复杂点，假设我们的`writer`需要处理异常呢？比如`writer`捕获`SpamException`异常并且在遇到这个的时候打印`***`。\n\n```Python\nclass SpamException(Exception):\n    pass\n\ndef writer():\n    while True:\n        try:\n            w = (yield)\n        except SpamException:\n            print('***')\n        else:\n            print('>> ', w)\n```\n\n如果我们使用原始版本的`writer_wrapper`，会怎样？\n\n```Python\n# writer_wrapper same as above\n\nw = writer()\nwrap = writer_wrapper(w)\nwrap.send(None)  # \"prime\" the coroutine\nfor i in [0, 1, 2, 'spam', 4]:\n    if i == 'spam':\n        wrap.throw(SpamException)\n    else:\n        wrap.send(i)\n\n# Expected Result\n>>  0\n>>  1\n>>  2\n***\n>>  4\n\n# Actual Result\n>>  0\n>>  1\n>>  2\nTraceback (most recent call last):\n  ... redacted ...\n  File ... in writer_wrapper\n    x = (yield)\n__main__.SpamException\n```\n\n不能正常工作的原因是因为`x = (yield)`抛出了这个异常所以导致了程序崩溃。要使得其正常工作的话，我们需要亲自捕获异常并将它传递给子生成器(`writer`)：\n\n```Python\ndef writer_wrapper(coro):\n    \"\"\"Works. Manually catches exceptions and throws them\"\"\"\n    coro.send(None)  # prime the coro\n    while True:\n        try:\n            try:\n                x = (yield)\n            except Exception as e:   # This catches the SpamException\n                coro.throw(e)\n            else:\n                coro.send(x)\n        except StopIteration:\n            pass\n\n...\n# Result\n>>  0\n>>  1\n>>  2\n***\n>>  4\n```\n\n这可以正常工作，但是假设我们这样呢:\n\n```Python\ndef writer_wrapper(coro):\n    yield from coro\n```\n\n`yield from`语句透明地将数据或者异常发送给子生成器。\n\n以上仍然没有覆盖所有的特殊情况。如果外部生成器关闭了会怎样？子生成器返回了一个值会怎样(Python 3里生成器可以返回值)？返回值会怎样被处理？而`yield from`很好的处理了以上所有情况。\n\n#### 总结\n<div class=\"tip\">\n`yield from`是**调用者**和**子生成器**之间的一个**双向透明通道**。\n</div>\n\n更多关于`yield from`的内容可以阅读[PEP 380 -- Syntax for Delegating to a Subgenerator](https://www.python.org/dev/peps/pep-0380/)。\n","slug":"Python-main-use-for-yield-from","published":1,"updated":"2018-01-15T01:17:23.609Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgvnqml80011w628lhozngx0","content":"<p>上一篇中谈到了迭代器、生成器以及<code>yield</code>的相关内容，而Python 3.3中，引入了在<a href=\"https://www.python.org/dev/peps/pep-0380/\" target=\"_blank\" rel=\"noopener\">PEP 380 – Syntax for Delegating to a Subgenerator</a>中提出的<code>yield from</code>关键字，大幅简化了Python程序员在使用协程的时候的编程过程。</p>\n<div class=\"tip\"><br>本文内容除特殊说明外均基于Python 3.3以上版本。<br></div>\n\n<p>首先需要声明的是，<code>yield from g</code>并不完全等于<code>for v in g: yield v</code>。而是应该将<code>yield from</code>看成为<strong>调用者(caller)</strong>和<strong>子生成器(sub-generator)</strong>之间提供了一种<strong>透明地双向通道</strong>。这包括了从子生成器中获取数据并向子生成器发送数据。</p>\n<a id=\"more\"></a>\n<h4 id=\"使用yield-from从生成器中获得数据\"><a href=\"#使用yield-from从生成器中获得数据\" class=\"headerlink\" title=\"使用yield from从生成器中获得数据\"></a>使用<code>yield from</code>从生成器中获得数据</h4><p>考虑以下代码:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reader</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"A generator that fakes a read from a file, socket, etc.\"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"string\">'&lt;&lt; %s'</span> % i</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reader_wrapper</span><span class=\"params\">(g)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># Manually iterate over data produced by reader</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> v <span class=\"keyword\">in</span> g:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> v</span><br><span class=\"line\"></span><br><span class=\"line\">wrap = reader_wrapper(reader())</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> wrap:</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Result</span></span><br><span class=\"line\">&lt;&lt; <span class=\"number\">0</span></span><br><span class=\"line\">&lt;&lt; <span class=\"number\">1</span></span><br><span class=\"line\">&lt;&lt; <span class=\"number\">2</span></span><br><span class=\"line\">&lt;&lt; <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>我们其实可以使用<code>yield from</code>来代替亲自迭代<code>reader()</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reader_wrapper</span><span class=\"params\">(g)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> g</span><br></pre></td></tr></table></figure>\n<p>这可以很好的工作而且减少了一行代码，而且可能使得我们的意图更加明确。</p>\n<h4 id=\"使用yield-from向生成器发送数据\"><a href=\"#使用yield-from向生成器发送数据\" class=\"headerlink\" title=\"使用yield from向生成器发送数据\"></a>使用<code>yield from</code>向生成器发送数据</h4><p>现在让我们做些更有趣的。首先创建一个名叫<code>writer</code>的协程，它可以接收发送给它的数据并写给套接字、文件描述符等等:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">writer</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"A coroutine that writes data *sent* to it to fd, socket, etc.\"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">        w = (<span class=\"keyword\">yield</span>)</span><br><span class=\"line\">        print(<span class=\"string\">'&gt;&gt; '</span>, w)</span><br></pre></td></tr></table></figure>\n<p>现在的问题是，包装函数<code>wrapper</code>如何处理将数据发送给<code>writer</code>，使得发送给包装函数的数据能够透明地发送给<code>writer()</code>？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">writer_wrapper</span><span class=\"params\">(coro)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># TBD</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">w = writer()</span><br><span class=\"line\">wrap = writer_wrapper(w)</span><br><span class=\"line\">wrap.send(<span class=\"keyword\">None</span>)  <span class=\"comment\"># \"prime\" the coroutine</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">    wrap.send(i)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Expected result</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">0</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">1</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">2</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>包装函数需要接受发送给它的数据(显而易见地)而且应该在循环结束的时候处理<code>StopIteration</code>异常。很明显只是完成<code>for x in coro: yield x</code>的话不能胜任这项工作。下面是一个能够工作的版本:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">writer_wrapper</span><span class=\"params\">(coro)</span>:</span></span><br><span class=\"line\">    coro.send(<span class=\"keyword\">None</span>)  <span class=\"comment\"># prime the coro</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            x = (<span class=\"keyword\">yield</span>)  <span class=\"comment\"># Capture the value that's sent</span></span><br><span class=\"line\">            coro.send(x)  <span class=\"comment\"># and pass it to the writer</span></span><br><span class=\"line\">        <span class=\"keyword\">except</span> StopIteration:</span><br><span class=\"line\">            <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>或者，我们可以这样做:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">writer_wrapper</span><span class=\"params\">(coro)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> coro</span><br></pre></td></tr></table></figure>\n<p>这节省了6行代码，而且使得代码更加清晰易读，最关键的是，它可行！</p>\n<h4 id=\"使用yield-from向生成器发送数据——异常处理\"><a href=\"#使用yield-from向生成器发送数据——异常处理\" class=\"headerlink\" title=\"使用yield from向生成器发送数据——异常处理\"></a>使用<code>yield from</code>向生成器发送数据——异常处理</h4><p>让我们使这个例子更复杂点，假设我们的<code>writer</code>需要处理异常呢？比如<code>writer</code>捕获<code>SpamException</code>异常并且在遇到这个的时候打印<code>***</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpamException</span><span class=\"params\">(Exception)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">writer</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            w = (<span class=\"keyword\">yield</span>)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> SpamException:</span><br><span class=\"line\">            print(<span class=\"string\">'***'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            print(<span class=\"string\">'&gt;&gt; '</span>, w)</span><br></pre></td></tr></table></figure>\n<p>如果我们使用原始版本的<code>writer_wrapper</code>，会怎样？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># writer_wrapper same as above</span></span><br><span class=\"line\"></span><br><span class=\"line\">w = writer()</span><br><span class=\"line\">wrap = writer_wrapper(w)</span><br><span class=\"line\">wrap.send(<span class=\"keyword\">None</span>)  <span class=\"comment\"># \"prime\" the coroutine</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'spam'</span>, <span class=\"number\">4</span>]:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == <span class=\"string\">'spam'</span>:</span><br><span class=\"line\">        wrap.throw(SpamException)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        wrap.send(i)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Expected Result</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">0</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">1</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">2</span></span><br><span class=\"line\">***</span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Actual Result</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">0</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">1</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">2</span></span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  ... redacted ...</span><br><span class=\"line\">  File ... <span class=\"keyword\">in</span> writer_wrapper</span><br><span class=\"line\">    x = (<span class=\"keyword\">yield</span>)</span><br><span class=\"line\">__main__.SpamException</span><br></pre></td></tr></table></figure>\n<p>不能正常工作的原因是因为<code>x = (yield)</code>抛出了这个异常所以导致了程序崩溃。要使得其正常工作的话，我们需要亲自捕获异常并将它传递给子生成器(<code>writer</code>)：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">writer_wrapper</span><span class=\"params\">(coro)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"Works. Manually catches exceptions and throws them\"\"\"</span></span><br><span class=\"line\">    coro.send(<span class=\"keyword\">None</span>)  <span class=\"comment\"># prime the coro</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                x = (<span class=\"keyword\">yield</span>)</span><br><span class=\"line\">            <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:   <span class=\"comment\"># This catches the SpamException</span></span><br><span class=\"line\">                coro.throw(e)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                coro.send(x)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> StopIteration:</span><br><span class=\"line\">            <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\"># Result</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">0</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">1</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">2</span></span><br><span class=\"line\">***</span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>这可以正常工作，但是假设我们这样呢:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">writer_wrapper</span><span class=\"params\">(coro)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> coro</span><br></pre></td></tr></table></figure>\n<p><code>yield from</code>语句透明地将数据或者异常发送给子生成器。</p>\n<p>以上仍然没有覆盖所有的特殊情况。如果外部生成器关闭了会怎样？子生成器返回了一个值会怎样(Python 3里生成器可以返回值)？返回值会怎样被处理？而<code>yield from</code>很好的处理了以上所有情况。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><div class=\"tip\"><br><code>yield from</code>是<strong>调用者</strong>和<strong>子生成器</strong>之间的一个<strong>双向透明通道</strong>。<br></div>\n\n<p>更多关于<code>yield from</code>的内容可以阅读<a href=\"https://www.python.org/dev/peps/pep-0380/\" target=\"_blank\" rel=\"noopener\">PEP 380 – Syntax for Delegating to a Subgenerator</a>。</p>\n","site":{"data":{}},"excerpt":"<p>上一篇中谈到了迭代器、生成器以及<code>yield</code>的相关内容，而Python 3.3中，引入了在<a href=\"https://www.python.org/dev/peps/pep-0380/\" target=\"_blank\" rel=\"noopener\">PEP 380 – Syntax for Delegating to a Subgenerator</a>中提出的<code>yield from</code>关键字，大幅简化了Python程序员在使用协程的时候的编程过程。</p>\n<div class=\"tip\"><br>本文内容除特殊说明外均基于Python 3.3以上版本。<br></div>\n\n<p>首先需要声明的是，<code>yield from g</code>并不完全等于<code>for v in g: yield v</code>。而是应该将<code>yield from</code>看成为<strong>调用者(caller)</strong>和<strong>子生成器(sub-generator)</strong>之间提供了一种<strong>透明地双向通道</strong>。这包括了从子生成器中获取数据并向子生成器发送数据。</p>","more":"<h4 id=\"使用yield-from从生成器中获得数据\"><a href=\"#使用yield-from从生成器中获得数据\" class=\"headerlink\" title=\"使用yield from从生成器中获得数据\"></a>使用<code>yield from</code>从生成器中获得数据</h4><p>考虑以下代码:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reader</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"A generator that fakes a read from a file, socket, etc.\"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"string\">'&lt;&lt; %s'</span> % i</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reader_wrapper</span><span class=\"params\">(g)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># Manually iterate over data produced by reader</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> v <span class=\"keyword\">in</span> g:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> v</span><br><span class=\"line\"></span><br><span class=\"line\">wrap = reader_wrapper(reader())</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> wrap:</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Result</span></span><br><span class=\"line\">&lt;&lt; <span class=\"number\">0</span></span><br><span class=\"line\">&lt;&lt; <span class=\"number\">1</span></span><br><span class=\"line\">&lt;&lt; <span class=\"number\">2</span></span><br><span class=\"line\">&lt;&lt; <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>我们其实可以使用<code>yield from</code>来代替亲自迭代<code>reader()</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reader_wrapper</span><span class=\"params\">(g)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> g</span><br></pre></td></tr></table></figure>\n<p>这可以很好的工作而且减少了一行代码，而且可能使得我们的意图更加明确。</p>\n<h4 id=\"使用yield-from向生成器发送数据\"><a href=\"#使用yield-from向生成器发送数据\" class=\"headerlink\" title=\"使用yield from向生成器发送数据\"></a>使用<code>yield from</code>向生成器发送数据</h4><p>现在让我们做些更有趣的。首先创建一个名叫<code>writer</code>的协程，它可以接收发送给它的数据并写给套接字、文件描述符等等:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">writer</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"A coroutine that writes data *sent* to it to fd, socket, etc.\"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">        w = (<span class=\"keyword\">yield</span>)</span><br><span class=\"line\">        print(<span class=\"string\">'&gt;&gt; '</span>, w)</span><br></pre></td></tr></table></figure>\n<p>现在的问题是，包装函数<code>wrapper</code>如何处理将数据发送给<code>writer</code>，使得发送给包装函数的数据能够透明地发送给<code>writer()</code>？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">writer_wrapper</span><span class=\"params\">(coro)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># TBD</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">w = writer()</span><br><span class=\"line\">wrap = writer_wrapper(w)</span><br><span class=\"line\">wrap.send(<span class=\"keyword\">None</span>)  <span class=\"comment\"># \"prime\" the coroutine</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">4</span>):</span><br><span class=\"line\">    wrap.send(i)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Expected result</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">0</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">1</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">2</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>包装函数需要接受发送给它的数据(显而易见地)而且应该在循环结束的时候处理<code>StopIteration</code>异常。很明显只是完成<code>for x in coro: yield x</code>的话不能胜任这项工作。下面是一个能够工作的版本:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">writer_wrapper</span><span class=\"params\">(coro)</span>:</span></span><br><span class=\"line\">    coro.send(<span class=\"keyword\">None</span>)  <span class=\"comment\"># prime the coro</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            x = (<span class=\"keyword\">yield</span>)  <span class=\"comment\"># Capture the value that's sent</span></span><br><span class=\"line\">            coro.send(x)  <span class=\"comment\"># and pass it to the writer</span></span><br><span class=\"line\">        <span class=\"keyword\">except</span> StopIteration:</span><br><span class=\"line\">            <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>或者，我们可以这样做:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">writer_wrapper</span><span class=\"params\">(coro)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> coro</span><br></pre></td></tr></table></figure>\n<p>这节省了6行代码，而且使得代码更加清晰易读，最关键的是，它可行！</p>\n<h4 id=\"使用yield-from向生成器发送数据——异常处理\"><a href=\"#使用yield-from向生成器发送数据——异常处理\" class=\"headerlink\" title=\"使用yield from向生成器发送数据——异常处理\"></a>使用<code>yield from</code>向生成器发送数据——异常处理</h4><p>让我们使这个例子更复杂点，假设我们的<code>writer</code>需要处理异常呢？比如<code>writer</code>捕获<code>SpamException</code>异常并且在遇到这个的时候打印<code>***</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpamException</span><span class=\"params\">(Exception)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">writer</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            w = (<span class=\"keyword\">yield</span>)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> SpamException:</span><br><span class=\"line\">            print(<span class=\"string\">'***'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            print(<span class=\"string\">'&gt;&gt; '</span>, w)</span><br></pre></td></tr></table></figure>\n<p>如果我们使用原始版本的<code>writer_wrapper</code>，会怎样？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># writer_wrapper same as above</span></span><br><span class=\"line\"></span><br><span class=\"line\">w = writer()</span><br><span class=\"line\">wrap = writer_wrapper(w)</span><br><span class=\"line\">wrap.send(<span class=\"keyword\">None</span>)  <span class=\"comment\"># \"prime\" the coroutine</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'spam'</span>, <span class=\"number\">4</span>]:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == <span class=\"string\">'spam'</span>:</span><br><span class=\"line\">        wrap.throw(SpamException)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        wrap.send(i)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Expected Result</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">0</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">1</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">2</span></span><br><span class=\"line\">***</span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Actual Result</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">0</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">1</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">2</span></span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  ... redacted ...</span><br><span class=\"line\">  File ... <span class=\"keyword\">in</span> writer_wrapper</span><br><span class=\"line\">    x = (<span class=\"keyword\">yield</span>)</span><br><span class=\"line\">__main__.SpamException</span><br></pre></td></tr></table></figure>\n<p>不能正常工作的原因是因为<code>x = (yield)</code>抛出了这个异常所以导致了程序崩溃。要使得其正常工作的话，我们需要亲自捕获异常并将它传递给子生成器(<code>writer</code>)：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">writer_wrapper</span><span class=\"params\">(coro)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"Works. Manually catches exceptions and throws them\"\"\"</span></span><br><span class=\"line\">    coro.send(<span class=\"keyword\">None</span>)  <span class=\"comment\"># prime the coro</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                x = (<span class=\"keyword\">yield</span>)</span><br><span class=\"line\">            <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:   <span class=\"comment\"># This catches the SpamException</span></span><br><span class=\"line\">                coro.throw(e)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                coro.send(x)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> StopIteration:</span><br><span class=\"line\">            <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\"># Result</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">0</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">1</span></span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">2</span></span><br><span class=\"line\">***</span><br><span class=\"line\">&gt;&gt;  <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>这可以正常工作，但是假设我们这样呢:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">writer_wrapper</span><span class=\"params\">(coro)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> coro</span><br></pre></td></tr></table></figure>\n<p><code>yield from</code>语句透明地将数据或者异常发送给子生成器。</p>\n<p>以上仍然没有覆盖所有的特殊情况。如果外部生成器关闭了会怎样？子生成器返回了一个值会怎样(Python 3里生成器可以返回值)？返回值会怎样被处理？而<code>yield from</code>很好的处理了以上所有情况。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><div class=\"tip\"><br><code>yield from</code>是<strong>调用者</strong>和<strong>子生成器</strong>之间的一个<strong>双向透明通道</strong>。<br></div>\n\n<p>更多关于<code>yield from</code>的内容可以阅读<a href=\"https://www.python.org/dev/peps/pep-0380/\" target=\"_blank\" rel=\"noopener\">PEP 380 – Syntax for Delegating to a Subgenerator</a>。</p>"},{"layout":"post","title":"multiprocessing中pool实现","date":"2017-01-17T00:52:00.000Z","_content":"\n终于有时间来整理整理之前自己的一些心得，今天想分享的是之前梳理的`Python`中`multiprocessing`模块的线程池与进程池实现。\n\n<!-- more -->\n\nmultiprocessing.pool类包含taskqueue、inqueue、outqueue三个队列，其中：\n\n* taskqueue采用`Queue.Queue`实现，通过apply、apply_async、map、map_async等函数向pool类提交任务。\n* inqueue、outqueue采用`SimpleQueue`实现，本质上是带锁的pipe\n* inqueue负责存放待完成任务，outqueue负责存放已完成任务\n\nmultiprocessing.pool类包含worker_handler、task_handler、result_handler三个handler，均在threading.Thread上工作，均为`Daemon Thread`，其中：\n\n* worker_handler负责回收已经完成任务的worker，同时根据回收数量使用process函数重新生成足够的worker，在生命周期中维护整个pool中worker的数量:\n```python\n    def _maintain_pool(self):\n        \"\"\"Clean up any exited workers and start replacements for them.\n        \"\"\"\n        if self._join_exited_workers():\n            self._repopulate_pool()\n\n    @staticmethod\n    def _handle_workers(pool):\n        thread = threading.current_thread()\n\n        # Keep maintaining workers until the cache gets drained, unless the pool\n        # is terminated.\n        while thread._state == RUN or (pool._cache and thread._state != TERMINATE):\n            pool._maintain_pool()\n            time.sleep(0.1)\n        # send sentinel to stop workers\n        pool._taskqueue.put(None)\n        util.debug('worker handler exiting')\n\n```\n* task_handler负责从taskqueue中按先后顺序阻塞获取待完成任务，更新pool的任务cache，并提交至inqueue中等待worker处理\n* result_handler负责从outqueue中按先后顺序阻塞获取已完成任务，更新pool的任务cache，如果存在回调函数则进行回调操作\n\nmultiprocessing.pool类包含1个(未实现情况下)或多个(未提供数量，cpu_count()个)或指定数量的worker，其中：\n\n* worker的维护由worker_handerler负责，在一个worker任务完成后由worker_handler负责回收并重新生成新的worker\n* worker包含对inqueue.get和outqueue.put的引用\n* worker从inqueue从获取待完成任务，并负责执行该任务，并将执行结果提交至outqueue中等待处理:\n```python\ndef worker(inqueue, outqueue, initializer=None, initargs=(), maxtasks=None,\n           wrap_exception=False):\n    assert maxtasks is None or (type(maxtasks) == int and maxtasks > 0)\n    put = outqueue.put\n    get = inqueue.get\n    if hasattr(inqueue, '_writer'):\n        inqueue._writer.close()\n        outqueue._reader.close()\n\n    if initializer is not None:\n        initializer(*initargs)\n\n    completed = 0\n    while maxtasks is None or (maxtasks and completed < maxtasks):\n        try:\n            task = get()\n        except (EOFError, OSError):\n            util.debug('worker got EOFError or OSError -- exiting')\n            break\n\n        if task is None:\n            util.debug('worker got sentinel -- exiting')\n            break\n\n        job, i, func, args, kwds = task\n        try:\n            result = (True, func(*args, **kwds))\n        except Exception as e:\n            if wrap_exception:\n                e = ExceptionWithTraceback(e, e.__traceback__)\n            result = (False, e)\n        try:\n            put((job, i, result))\n        except Exception as e:\n            wrapped = MaybeEncodingError(e, result[1])\n            util.debug(\"Possible encoding error while sending result: %s\" % (\n                wrapped))\n            put((job, i, (False, wrapped)))\n        completed += 1\n    util.debug('worker exiting after %d tasks' % completed)\n\n```\n\nPS：\n> multiprocessing.ThreadPool是pool的thread-level级实现，以multiprocessing.dummy中的DummyProcess替换了pool的默认process，DummyProcess继承至threading.Thread，因此ThreadPool的实现是thread-level级的。\n\n实现用图来表示如下:\n\n![multiprocessing_pool](python_multiprocessing_pool.png)","source":"_posts/Python-multiprocessing pool.md","raw":"---\nlayout: post\ntitle: multiprocessing中pool实现\ntags: [Python,多进程,进程池]\ncategory: Python\ndate: 2017-01-17 08:52\n---\n\n终于有时间来整理整理之前自己的一些心得，今天想分享的是之前梳理的`Python`中`multiprocessing`模块的线程池与进程池实现。\n\n<!-- more -->\n\nmultiprocessing.pool类包含taskqueue、inqueue、outqueue三个队列，其中：\n\n* taskqueue采用`Queue.Queue`实现，通过apply、apply_async、map、map_async等函数向pool类提交任务。\n* inqueue、outqueue采用`SimpleQueue`实现，本质上是带锁的pipe\n* inqueue负责存放待完成任务，outqueue负责存放已完成任务\n\nmultiprocessing.pool类包含worker_handler、task_handler、result_handler三个handler，均在threading.Thread上工作，均为`Daemon Thread`，其中：\n\n* worker_handler负责回收已经完成任务的worker，同时根据回收数量使用process函数重新生成足够的worker，在生命周期中维护整个pool中worker的数量:\n```python\n    def _maintain_pool(self):\n        \"\"\"Clean up any exited workers and start replacements for them.\n        \"\"\"\n        if self._join_exited_workers():\n            self._repopulate_pool()\n\n    @staticmethod\n    def _handle_workers(pool):\n        thread = threading.current_thread()\n\n        # Keep maintaining workers until the cache gets drained, unless the pool\n        # is terminated.\n        while thread._state == RUN or (pool._cache and thread._state != TERMINATE):\n            pool._maintain_pool()\n            time.sleep(0.1)\n        # send sentinel to stop workers\n        pool._taskqueue.put(None)\n        util.debug('worker handler exiting')\n\n```\n* task_handler负责从taskqueue中按先后顺序阻塞获取待完成任务，更新pool的任务cache，并提交至inqueue中等待worker处理\n* result_handler负责从outqueue中按先后顺序阻塞获取已完成任务，更新pool的任务cache，如果存在回调函数则进行回调操作\n\nmultiprocessing.pool类包含1个(未实现情况下)或多个(未提供数量，cpu_count()个)或指定数量的worker，其中：\n\n* worker的维护由worker_handerler负责，在一个worker任务完成后由worker_handler负责回收并重新生成新的worker\n* worker包含对inqueue.get和outqueue.put的引用\n* worker从inqueue从获取待完成任务，并负责执行该任务，并将执行结果提交至outqueue中等待处理:\n```python\ndef worker(inqueue, outqueue, initializer=None, initargs=(), maxtasks=None,\n           wrap_exception=False):\n    assert maxtasks is None or (type(maxtasks) == int and maxtasks > 0)\n    put = outqueue.put\n    get = inqueue.get\n    if hasattr(inqueue, '_writer'):\n        inqueue._writer.close()\n        outqueue._reader.close()\n\n    if initializer is not None:\n        initializer(*initargs)\n\n    completed = 0\n    while maxtasks is None or (maxtasks and completed < maxtasks):\n        try:\n            task = get()\n        except (EOFError, OSError):\n            util.debug('worker got EOFError or OSError -- exiting')\n            break\n\n        if task is None:\n            util.debug('worker got sentinel -- exiting')\n            break\n\n        job, i, func, args, kwds = task\n        try:\n            result = (True, func(*args, **kwds))\n        except Exception as e:\n            if wrap_exception:\n                e = ExceptionWithTraceback(e, e.__traceback__)\n            result = (False, e)\n        try:\n            put((job, i, result))\n        except Exception as e:\n            wrapped = MaybeEncodingError(e, result[1])\n            util.debug(\"Possible encoding error while sending result: %s\" % (\n                wrapped))\n            put((job, i, (False, wrapped)))\n        completed += 1\n    util.debug('worker exiting after %d tasks' % completed)\n\n```\n\nPS：\n> multiprocessing.ThreadPool是pool的thread-level级实现，以multiprocessing.dummy中的DummyProcess替换了pool的默认process，DummyProcess继承至threading.Thread，因此ThreadPool的实现是thread-level级的。\n\n实现用图来表示如下:\n\n![multiprocessing_pool](python_multiprocessing_pool.png)","slug":"Python-multiprocessing pool","published":1,"updated":"2018-01-13T00:50:39.867Z","comments":1,"photos":[],"link":"","_id":"cjgvnqml90015w628ld33u3f4","content":"<p>终于有时间来整理整理之前自己的一些心得，今天想分享的是之前梳理的<code>Python</code>中<code>multiprocessing</code>模块的线程池与进程池实现。</p>\n<a id=\"more\"></a>\n<p>multiprocessing.pool类包含taskqueue、inqueue、outqueue三个队列，其中：</p>\n<ul>\n<li>taskqueue采用<code>Queue.Queue</code>实现，通过apply、apply_async、map、map_async等函数向pool类提交任务。</li>\n<li>inqueue、outqueue采用<code>SimpleQueue</code>实现，本质上是带锁的pipe</li>\n<li>inqueue负责存放待完成任务，outqueue负责存放已完成任务</li>\n</ul>\n<p>multiprocessing.pool类包含worker_handler、task_handler、result_handler三个handler，均在threading.Thread上工作，均为<code>Daemon Thread</code>，其中：</p>\n<ul>\n<li><p>worker_handler负责回收已经完成任务的worker，同时根据回收数量使用process函数重新生成足够的worker，在生命周期中维护整个pool中worker的数量:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_maintain_pool</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"Clean up any exited workers and start replacements for them.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self._join_exited_workers():</span><br><span class=\"line\">        self._repopulate_pool()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@staticmethod</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_handle_workers</span><span class=\"params\">(pool)</span>:</span></span><br><span class=\"line\">    thread = threading.current_thread()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Keep maintaining workers until the cache gets drained, unless the pool</span></span><br><span class=\"line\">    <span class=\"comment\"># is terminated.</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> thread._state == RUN <span class=\"keyword\">or</span> (pool._cache <span class=\"keyword\">and</span> thread._state != TERMINATE):</span><br><span class=\"line\">        pool._maintain_pool()</span><br><span class=\"line\">        time.sleep(<span class=\"number\">0.1</span>)</span><br><span class=\"line\">    <span class=\"comment\"># send sentinel to stop workers</span></span><br><span class=\"line\">    pool._taskqueue.put(<span class=\"keyword\">None</span>)</span><br><span class=\"line\">    util.debug(<span class=\"string\">'worker handler exiting'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>task_handler负责从taskqueue中按先后顺序阻塞获取待完成任务，更新pool的任务cache，并提交至inqueue中等待worker处理</p>\n</li>\n<li>result_handler负责从outqueue中按先后顺序阻塞获取已完成任务，更新pool的任务cache，如果存在回调函数则进行回调操作</li>\n</ul>\n<p>multiprocessing.pool类包含1个(未实现情况下)或多个(未提供数量，cpu_count()个)或指定数量的worker，其中：</p>\n<ul>\n<li>worker的维护由worker_handerler负责，在一个worker任务完成后由worker_handler负责回收并重新生成新的worker</li>\n<li>worker包含对inqueue.get和outqueue.put的引用</li>\n<li>worker从inqueue从获取待完成任务，并负责执行该任务，并将执行结果提交至outqueue中等待处理:<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">worker</span><span class=\"params\">(inqueue, outqueue, initializer=None, initargs=<span class=\"params\">()</span>, maxtasks=None,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           wrap_exception=False)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> maxtasks <span class=\"keyword\">is</span> <span class=\"keyword\">None</span> <span class=\"keyword\">or</span> (type(maxtasks) == int <span class=\"keyword\">and</span> maxtasks &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    put = outqueue.put</span><br><span class=\"line\">    get = inqueue.get</span><br><span class=\"line\">    <span class=\"keyword\">if</span> hasattr(inqueue, <span class=\"string\">'_writer'</span>):</span><br><span class=\"line\">        inqueue._writer.close()</span><br><span class=\"line\">        outqueue._reader.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> initializer <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        initializer(*initargs)</span><br><span class=\"line\"></span><br><span class=\"line\">    completed = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> maxtasks <span class=\"keyword\">is</span> <span class=\"keyword\">None</span> <span class=\"keyword\">or</span> (maxtasks <span class=\"keyword\">and</span> completed &lt; maxtasks):</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            task = get()</span><br><span class=\"line\">        <span class=\"keyword\">except</span> (EOFError, OSError):</span><br><span class=\"line\">            util.debug(<span class=\"string\">'worker got EOFError or OSError -- exiting'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> task <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            util.debug(<span class=\"string\">'worker got sentinel -- exiting'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">        job, i, func, args, kwds = task</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            result = (<span class=\"keyword\">True</span>, func(*args, **kwds))</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> wrap_exception:</span><br><span class=\"line\">                e = ExceptionWithTraceback(e, e.__traceback__)</span><br><span class=\"line\">            result = (<span class=\"keyword\">False</span>, e)</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            put((job, i, result))</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">            wrapped = MaybeEncodingError(e, result[<span class=\"number\">1</span>])</span><br><span class=\"line\">            util.debug(<span class=\"string\">\"Possible encoding error while sending result: %s\"</span> % (</span><br><span class=\"line\">                wrapped))</span><br><span class=\"line\">            put((job, i, (<span class=\"keyword\">False</span>, wrapped)))</span><br><span class=\"line\">        completed += <span class=\"number\">1</span></span><br><span class=\"line\">    util.debug(<span class=\"string\">'worker exiting after %d tasks'</span> % completed)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>PS：</p>\n<blockquote>\n<p>multiprocessing.ThreadPool是pool的thread-level级实现，以multiprocessing.dummy中的DummyProcess替换了pool的默认process，DummyProcess继承至threading.Thread，因此ThreadPool的实现是thread-level级的。</p>\n</blockquote>\n<p>实现用图来表示如下:</p>\n<p><img src=\"/2017/01/17/Python-multiprocessing pool/python_multiprocessing_pool.png\" alt=\"multiprocessing_pool\"></p>\n","site":{"data":{}},"excerpt":"<p>终于有时间来整理整理之前自己的一些心得，今天想分享的是之前梳理的<code>Python</code>中<code>multiprocessing</code>模块的线程池与进程池实现。</p>","more":"<p>multiprocessing.pool类包含taskqueue、inqueue、outqueue三个队列，其中：</p>\n<ul>\n<li>taskqueue采用<code>Queue.Queue</code>实现，通过apply、apply_async、map、map_async等函数向pool类提交任务。</li>\n<li>inqueue、outqueue采用<code>SimpleQueue</code>实现，本质上是带锁的pipe</li>\n<li>inqueue负责存放待完成任务，outqueue负责存放已完成任务</li>\n</ul>\n<p>multiprocessing.pool类包含worker_handler、task_handler、result_handler三个handler，均在threading.Thread上工作，均为<code>Daemon Thread</code>，其中：</p>\n<ul>\n<li><p>worker_handler负责回收已经完成任务的worker，同时根据回收数量使用process函数重新生成足够的worker，在生命周期中维护整个pool中worker的数量:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_maintain_pool</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"Clean up any exited workers and start replacements for them.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self._join_exited_workers():</span><br><span class=\"line\">        self._repopulate_pool()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@staticmethod</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_handle_workers</span><span class=\"params\">(pool)</span>:</span></span><br><span class=\"line\">    thread = threading.current_thread()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Keep maintaining workers until the cache gets drained, unless the pool</span></span><br><span class=\"line\">    <span class=\"comment\"># is terminated.</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> thread._state == RUN <span class=\"keyword\">or</span> (pool._cache <span class=\"keyword\">and</span> thread._state != TERMINATE):</span><br><span class=\"line\">        pool._maintain_pool()</span><br><span class=\"line\">        time.sleep(<span class=\"number\">0.1</span>)</span><br><span class=\"line\">    <span class=\"comment\"># send sentinel to stop workers</span></span><br><span class=\"line\">    pool._taskqueue.put(<span class=\"keyword\">None</span>)</span><br><span class=\"line\">    util.debug(<span class=\"string\">'worker handler exiting'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>task_handler负责从taskqueue中按先后顺序阻塞获取待完成任务，更新pool的任务cache，并提交至inqueue中等待worker处理</p>\n</li>\n<li>result_handler负责从outqueue中按先后顺序阻塞获取已完成任务，更新pool的任务cache，如果存在回调函数则进行回调操作</li>\n</ul>\n<p>multiprocessing.pool类包含1个(未实现情况下)或多个(未提供数量，cpu_count()个)或指定数量的worker，其中：</p>\n<ul>\n<li>worker的维护由worker_handerler负责，在一个worker任务完成后由worker_handler负责回收并重新生成新的worker</li>\n<li>worker包含对inqueue.get和outqueue.put的引用</li>\n<li>worker从inqueue从获取待完成任务，并负责执行该任务，并将执行结果提交至outqueue中等待处理:<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">worker</span><span class=\"params\">(inqueue, outqueue, initializer=None, initargs=<span class=\"params\">()</span>, maxtasks=None,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           wrap_exception=False)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> maxtasks <span class=\"keyword\">is</span> <span class=\"keyword\">None</span> <span class=\"keyword\">or</span> (type(maxtasks) == int <span class=\"keyword\">and</span> maxtasks &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    put = outqueue.put</span><br><span class=\"line\">    get = inqueue.get</span><br><span class=\"line\">    <span class=\"keyword\">if</span> hasattr(inqueue, <span class=\"string\">'_writer'</span>):</span><br><span class=\"line\">        inqueue._writer.close()</span><br><span class=\"line\">        outqueue._reader.close()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> initializer <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        initializer(*initargs)</span><br><span class=\"line\"></span><br><span class=\"line\">    completed = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> maxtasks <span class=\"keyword\">is</span> <span class=\"keyword\">None</span> <span class=\"keyword\">or</span> (maxtasks <span class=\"keyword\">and</span> completed &lt; maxtasks):</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            task = get()</span><br><span class=\"line\">        <span class=\"keyword\">except</span> (EOFError, OSError):</span><br><span class=\"line\">            util.debug(<span class=\"string\">'worker got EOFError or OSError -- exiting'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> task <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            util.debug(<span class=\"string\">'worker got sentinel -- exiting'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">        job, i, func, args, kwds = task</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            result = (<span class=\"keyword\">True</span>, func(*args, **kwds))</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> wrap_exception:</span><br><span class=\"line\">                e = ExceptionWithTraceback(e, e.__traceback__)</span><br><span class=\"line\">            result = (<span class=\"keyword\">False</span>, e)</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            put((job, i, result))</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">            wrapped = MaybeEncodingError(e, result[<span class=\"number\">1</span>])</span><br><span class=\"line\">            util.debug(<span class=\"string\">\"Possible encoding error while sending result: %s\"</span> % (</span><br><span class=\"line\">                wrapped))</span><br><span class=\"line\">            put((job, i, (<span class=\"keyword\">False</span>, wrapped)))</span><br><span class=\"line\">        completed += <span class=\"number\">1</span></span><br><span class=\"line\">    util.debug(<span class=\"string\">'worker exiting after %d tasks'</span> % completed)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>PS：</p>\n<blockquote>\n<p>multiprocessing.ThreadPool是pool的thread-level级实现，以multiprocessing.dummy中的DummyProcess替换了pool的默认process，DummyProcess继承至threading.Thread，因此ThreadPool的实现是thread-level级的。</p>\n</blockquote>\n<p>实现用图来表示如下:</p>\n<p><img src=\"/2017/01/17/Python-multiprocessing pool/python_multiprocessing_pool.png\" alt=\"multiprocessing_pool\"></p>"},{"title":"Python中的metaclass(元类)","date":"2017-02-06T08:11:02.000Z","from":"http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python?answertab=votes#tab-top","_content":"本文根据对[StackOverflow](http://stackoverflow.com)上问题[What is a metaclass in Python?](http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python?answertab=votes#tab-top)的高票回答翻译结合实际例子，试图解释**元类**的意义与用途。\n\n#### 类也是对象\n\n在想了解什么是**元类**之前，需要读者掌握Python中类的基本概念。而恰巧Python对类的定义有着不同于其他语言的解释。在大多数编程语言中，类仅仅只是指示如何生成实例对象的一段代码，这一点在Python中也如此:\n\n<!-- more -->\n```Python\n>>> class ObjectCreator(object):\n...       pass\n... \n\n>>> my_object = ObjectCreator()\n>>> print(my_object)\n<__main__.ObjectCreator object at 0x8974f2c>\n```\n\n但是，Python中的类还远不止如此:\n\n<div class=\"tip\">\n类也是实例对象\n</div>\n\n当程序员使用了关键字`class`时，Python将会执行它并且创建一个对象:\n\n```Python\n>>> class ObjectCreator(object):\n...       pass\n... \n```\n\n上述代码将会在内存中创建一个名叫\"ObjectCreator\"的对象。\n\n<div class=\"tip\">\n这个对象(类)自身拥有创建对象(实例)的能力，因此被称作类\n</div>\n\n即便如此，它仍然是一个对象，因此:\n* 你可以将它赋值给一个变量\n* 你可以复制它\n* 你可以为它添加属性\n* 你可以将它作为函数参数传递\n\n例如,\n使用`print`打印:\n\n```Python\n>>> print(ObjectCreator) # you can print a class because it's an object\n<class '__main__.ObjectCreator'>\n```\n作为函数参数传递:\n\n```Python\n>>> def echo(o):\n...       print(o)\n... \n>>> echo(ObjectCreator) # you can pass a class as a parameter\n<class '__main__.ObjectCreator'>\n```\n添加属性:\n\n```Python\n>>> print(hasattr(ObjectCreator, 'new_attribute'))\nFalse\n>>> ObjectCreator.new_attribute = 'foo' # you can add attributes to a class\n>>> print(hasattr(ObjectCreator, 'new_attribute'))\nTrue\n>>> print(ObjectCreator.new_attribute)\nfoo\n```\n赋值给另一个变量:\n\n```Python\n>>> ObjectCreatorMirror = ObjectCreator # you can assign a class to a variable\n>>> print(ObjectCreatorMirror.new_attribute)\nfoo\n>>> print(ObjectCreatorMirror())\n<__main__.ObjectCreator object at 0x8997b4c>\n```\n\n#### 动态地创建类\n既然类也是对象，那么你可以向创建对象一样快速地创建它们。\n首先，你可以通过使用关键字`class`在函数中创建一个类:\n\n```Python\n>>> def choose_class(name):\n...     if name == 'foo':\n...         class Foo(object):\n...             pass\n...         return Foo # return the class, not an instance\n...     else:\n...         class Bar(object):\n...             pass\n...         return Bar\n...     \n>>> MyClass = choose_class('foo') \n>>> print(MyClass, MyClass()) # the function returns a class, not an instance\n<class '__main__.choose_class.<locals>.Foo'> <__main__.choose_class.<locals>.Foo object at 0x10a7d06a0>\n```\n\n但它并不是很动态，因为你仍然需要亲自编写整个类。由于类是对象，那么它们必然是被某些东西生成的。当你使用关键字`class`时，Python自动地创建了其对象的对象。但就跟Python中大多数东西一样，Python给了你手动操作它的方法。\n还记得函数`type`吗？这个函数能够让你知道一个对象的类型:\n\n```Python\n>>> print(type(1))\n<type 'int'>\n>>> print(type(\"1\"))\n<type 'str'>\n>>> print(type(ObjectCreator))\n<type 'type'>\n>>> print(type(ObjectCreator()))\n<class '__main__.ObjectCreator'>\n```\n\n其实`type`还有一个完全不同的能力，它能够快速地创建类。`type`可以以参数的方式接收对一个类的描述，然后返回一个类。(可能有的人认为同一个函数根据传递不同的参数拥有两种完全不同的用途是一件很傻的事，但这是由于Python的向后兼容留下的问题)\n\n通过`type`创建类的参数描述如下:\n\n\ttype(name of the class, tuple of the parent class (for inheritance, can be empty), dictionary containing attributes names and values)\n\n例如:\n\n```Python\n>>> class MyShinyClass(object):\n...       pass\n```\n\n可以以如下方式手动创建:\n\n```Python\n>>> MyShinyClass = type('MyShinyClass', (), {}) # returns a class object\n>>> print(MyShinyClass, MyShinyClass())\n<class '__main__.MyShinyClass'> <__main__.MyShinyClass object at 0x10a7a5518>\n```\n\n你可能注意到了我们使用了\"MyShinyClass\"作为类的名字同时也作为变量名来保持对类的引用。它们可以不同，但是没有理由使其复杂化。\n`type`接收一个字典来定义类的属性，因此:\n\n```Python\n>>> class Foo(object):\n...       bar = True\n```\n\n可以被翻译成:\n\n```Python\n>>> Foo = type('Foo', (), {'bar': True})\n```\n\n这样定义的类也可以当做普通类使用:\n\n```Python\nprint(Foo)  # <class '__main__.Foo'>\nprint(Foo.bar)  # True\nf = Foo()\nprint(f)  # <__main__.Foo object at 0x8a9b84c>\nprint(f.bar)  # True\n```\n\n当然，你也可以继承自它:\n\n```Python\n>>>   class FooChild(Foo):\n...         pass\n```\n\n将会是:\n\n```Python\n>>> FooChild = type('FooChild', (Foo,), {})\n>>> print(FooChild, FooChild.bar)  # bar is inherited from Foo\n<class '__main__.FooChild'> True\n```\n\n最终你会想为你的类添加一些方法。只需要使用正确的语法定义一个函数然后作为一个属性赋值给类:\n\n```Python\n>>> def echo_bar(self):\n...       print(self.bar)\n... \n>>> FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})\n>>> hasattr(Foo, 'echo_bar')\nFalse\n>>> hasattr(FooChild, 'echo_bar')\nTrue\n>>> my_foo = FooChild()\n>>> my_foo.echo_bar()\nTrue\n```\n\n你甚至可以在动态生成了类之后添加更多的方法，就和向普通生成的类对象添加方法一样:\n\n```Python\n>>> def echo_bar_more(self):\n...       print('yet another method')\n... \n>>> FooChild.echo_bar_more = echo_bar_more\n>>> hasattr(FooChild, 'echo_bar_more')\nTrue\n```\n\n如你所见:在Python中，类是对象，你可以快速动态地创建一个类。这便是当你使用关键字`class`时Python做的工作，它通过使用**元类**来完成这项工作。\n\n#### 什么是元类(终于)\n\n**元类**是创建类的那些\"东西\"。你为了创建对象而定义了类，但是我们知道Python中的类也是对象，因此，元类是用来创建对象的。它们是**类的类**，你可以形象化地理解:\n\n```Python\nMyClass = MetaClass()\nMyObject = MyClass()\n```\n\n你已经知道`type`可以这么用:\n\n```Python\nMyClass = type('MyClass', (), {})\n```\n\n这是因为函数`type`实际上是一个元类，而且是Python用来创建所有类的元类。\n\n<div class=\"tip\">\n 在Python中，所有东西都是对象\n</div>\n\n其中包括但不限于整型、字符串、函数和类。它们都是对象，而且它们都是被类创建的:\n\n```Python\n>>> age = 35\n>>> age.__class__\n<type 'int'>\n>>> name = 'bob'\n>>> name.__class__\n<type 'str'>\n>>> def foo(): pass\n>>> foo.__class__\n<type 'function'>\n>>> class Bar(object): pass\n>>> b = Bar()\n>>> b.__class__\n<class '__main__.Bar'>\n```\n\n现在让我们看看`__class__`的`__class__`:\n\n```Python\n>>> age.__class__.__class__\n<type 'type'>\n>>> name.__class__.__class__\n<type 'type'>\n>>> foo.__class__.__class__\n<type 'type'>\n>>> b.__class__.__class__\n<type 'type'>\n```\n\n由此可见，一个元类正是用来创建所有类的。你也可以称它为\"类工厂\"。`type`是Python使用的内置的元类，当然，你也可以创建你自己的元类。\n\n#### `__metaclass__`属性\n你可以在编写一个类时为其指定`__metaclass__`属性:\n\n```Python\nclass Foo(object):\n    __metaclass__ = something...\n    ...\n```\n\n需要注意的是，上述语法仅适用于Python 2.x版本，在Python 3.x版本中，由新语法替代:\n\n```Python\nclass Foo(object, metaclass=something):\n    pass\n```\n\n当你为类指定了元类以后，Python将会使用该元类来创建类`Foo`。\n特别注意:\n\n<div class=\"tip\">\n类对象在Python调用__metaclass__来创建类之后才会存在。\n</div>\n\n** Python 2.x中的__metaclass__ **\n对Python 2.x来说，即当首先写下了`class Foo(object)`，但是类对象`Foo`还并没有在内存中被创建。Python将会在类定义中查找`__metaclass__`，如果找到了，则用其来创建对象类`Foo`，如果没有找到，Python将会使用`type`来创建该类。\n\n当你这么写:\n\n```Python\nclass Foo(Bar):\n    pass\n```\n\nPython将会这么做:\n1. 类`Foo`有定义`__metaclass__`吗？如果有，则使用指定的`__metaclass__`来创建类对象`Foo`。\n2. 如果没有找到这个属性，它将会在父类`Bar`中找\n3. 这样一直向父类找，直到达到`module`级别才停止。\n4. 如果在任何父类都找不到，那就用`type`创建类对象`Foo`\n\n这里面有几点需要注意:\n1. 为子类指定的`__metaclass__`需要是其所有父类`__metaclass__`的子类。\n2. 在多继承的情况下，如果没有为该类指定`__metaclass__`，则该类将会由MRO中第一个父类的`__metaclass__`和所有父类`__metaclass__`中处于继承最底层的`__metaclass__`生成。\n\nPython 2.x中`__metaclass__`使用如以下代码所示:\n\n```Python\n# Python 2.x\nclass Meta0(type):\n    def __new__(meta, name, bases, cls_dict):\n        cls = type.__new__(meta, name, bases, cls_dict)\n        print(meta, name, bases, cls_dict)\n        return cls\n\n__metaclass__ = Meta0\n\nclass Meta(type):\n    def __new__(meta, name, bases, cls_dict):\n        print(meta, name, bases, cls_dict)\n        cls_dict['meta'] = True\n        cls = type.__new__(meta, name, bases, cls_dict)\n        return cls\n\nclass Meta2(Meta):\n    def __new__(meta, name, bases, cls_dict):\n        print(meta, name, bases, cls_dict)\n        cls_dict['meta2'] = True\n        cls = type.__new__(meta, name, bases, cls_dict)\n        return cls\n\nclass Meta3(Meta2):\n    def __new__(meta, name, bases, cls_dict):\n        print(meta, name, bases, cls_dict)\n        cls_dict['meta3'] = True\n        cls = type.__new__(meta, name, bases, cls_dict)\n        return cls\n\nprint('C1')\nclass C1:\n    pass\n\nprint('C2')\nclass C2:\n    __metaclass__ = Meta\n\nprint('C3')\nclass C3(C2):\n    pass\n\nprint('C4')\nclass C4(C2):\n    __metaclass__ = Meta2\n\nprint('C5')\nclass C5(C2):\n    pass\n\nprint('C6')\nclass C6(C2):\n    __metaclass__ = Meta3\n\nprint('C7')\nclass C7(C4, C6, C5):\n    pass\n```\n\n结果为:\n\n```Python\nC1\n(<class '__main__.Meta0'>, 'C1', (), {'__module__': '__main__'})\nC2\n(<class '__main__.Meta'>, 'C2', (), {'__module__': '__main__', '__metaclass__': <class '__main__.Meta'>})\nC3\n(<class '__main__.Meta'>, 'C3', (<class '__main__.C2'>,), {'__module__': '__main__'})\nC4\n(<class '__main__.Meta2'>, 'C4', (<class '__main__.C2'>,), {'__module__': '__main__', '__metaclass__': <class '__main__.Meta2'>})\nC5\n(<class '__main__.Meta'>, 'C5', (<class '__main__.C2'>,), {'__module__': '__main__'})\nC6\n(<class '__main__.Meta3'>, 'C6', (<class '__main__.C2'>,), {'__module__': '__main__', '__metaclass__': <class '__main__.Meta3'>})\nC7\n(<class '__main__.Meta2'>, 'C7', (<class '__main__.C4'>, <class '__main__.C6'>, <class '__main__.C5'>), {'__module__': '__main__'})\n(<class '__main__.Meta3'>, 'C7', (<class '__main__.C4'>, <class '__main__.C6'>, <class '__main__.C5'>), {'__module__': '__main__', 'meta2': True})\n```\n\n注意到在类`C7`的生成过程中，分别调用了`Meta2`和`Meta3`，调用`Meta2`是由于在`C7`的继承中，类`C4`位于第一位，而`C4`的`__metaclass__`为`Meta2`，所以首先使用`Meta2`，而在`C4`、`C5`和`C6`的`__metaclass__`中，`Meta3`处于继承最底层，所以还会调用`Meta3`来生成类`C7`。(如果类`C6`位于最前面则只会调用`Meta3`)\n这样的多继承以及多元类调用比较复杂，个人认为还是少用较好。\n\n** Python 3.x中的metaclass **\n在Python3.x中，需要通过关键字参数`metaclass`给类指定元类。如:\n\n```Python\nclass C1(metaclass=Meta):\n    pass\n```\n\n关于元类的寻找与Python 2.x类似:\n1. 类`Foo`有定义关键字参数`metaclass`吗？如果有，则使用指定的`metaclass`来创建类对象`Foo`。\n2. 如果没有找到这个属性，它将会在父类`Bar`中找\n3. 如果在任何父类都找不到，那就用`type`创建类对象`Foo`\n\nPython 3.x的metaclass使用注意仍然与Python 2.x类似:\n1. 为子类指定的`metaclass`需要是其所有父类`metaclass`的子类。\n2. 在多继承的情况下，如果没有为该类指定`metaclass`，则该类将会由所有父类`metaclass`中处于继承最底层的`metaclass`生成。如果有指定，则选择前述的`metaclass`和该`metaclass`中继承层次更低的那个来生成。\n\nPython 3.x中`metaclass`使用如以下代码所示:\n\n```Python\n# Python 3.x\nclass Meta(type):\n    def __new__(meta, name, bases, cls_dict):\n        print(meta, name, bases, cls_dict)\n        return type.__new__(meta, name, bases, cls_dict)\n\nclass Meta2(Meta):\n    def __new__(meta, name, bases, cls_dict):\n        print(meta, name, bases, cls_dict)\n        cls_dict['hello'] = True\n        return type.__new__(meta, name, bases, cls_dict)\n\nclass Meta3(Meta2):\n    def __new__(meta, name, bases, cls_dict):\n        print(meta, name, bases, cls_dict)\n        return type.__new__(meta, name, bases, cls_dict)\n\nclass Meta4(Meta3):\n    def __new__(meta, name, bases, cls_dict):\n        print(meta, name, bases, cls_dict)\n        return type.__new__(meta, name, bases, cls_dict)\n\n\nprint('C1')\nclass C1(metaclass=Meta):\n    pass\n\nprint('C2')\nclass C2(C1):\n    pass\n\nprint('C3')\nclass C3(C1, metaclass=Meta2):\n    pass\n\nprint('C4')\nclass C4(C1, metaclass=Meta3):\n    pass\n\nprint('C5')\nclass C5(C3, C4, C2):\n    pass\n\nprint('C6')\nclass C6(C3, C4, C2, metaclass=Meta4):\n    pass\n```\n\n结果为:\n\n```Python\nC1\n<class '__main__.Meta'> C1 () {'__module__': '__main__', '__qualname__': 'C1'}\nC2\n<class '__main__.Meta'> C2 (<class '__main__.C1'>,) {'__module__': '__main__', '__qualname__': 'C2'}\nC3\n<class '__main__.Meta2'> C3 (<class '__main__.C1'>,) {'__module__': '__main__', '__qualname__': 'C3'}\nC4\n<class '__main__.Meta3'> C4 (<class '__main__.C1'>,) {'__module__': '__main__', '__qualname__': 'C4'}\nC5\n<class '__main__.Meta3'> C5 (<class '__main__.C3'>, <class '__main__.C4'>, <class '__main__.C2'>) {'__module__': '__main__', '__qualname__': 'C5'}\nC6\n<class '__main__.Meta4'> C6 (<class '__main__.C3'>, <class '__main__.C4'>, <class '__main__.C2'>) {'__module__': '__main__', '__qualname__': 'C6'}\n```\n\n需要注意一点，为了输出内容的简洁，以上代码在方法`__new__`的最后都使用了`type.__new__`而不是`super().__new__`。改用`super().__new__`后执行仍相同，只是多了对父类的调用。\n\n说了这么多，我们应该给`__metaclass__`赋值什么呢?答案当然是，一个可以创建类的东西。\n那么，什么才能创建一个类呢？\n\n#### 普通的元类\n设计元类的一个很主要的原因就是为了在类被创建的时候进行自动修改，这经常用在API的设计上。\n让我们举一个简单的例子，你决定让你的模块里所有类的属性都是大写形式。要完成这项工作有很多方法，其中一个便是在模块级别上定义`__metaclass__`。这样的话，该模块中所有的类都会通过该元类创建，我们只需要让这个元类完成将所有属性变成大写的工作。\n幸运的是，`__metaclass__`可以是任何可调用(callable)对象，并不一定非要是一个正式的类。所以我们将从一个函数作为元类的例子说起:\n\n```Python\n# Python 2.x\n# the metaclass will automatically get passed the same argument\n# that you usually pass to `type`\ndef upper_attr(future_class_name, future_class_parents, future_class_attr):\n  \"\"\"\n    Return a class object, with the list of its attribute turned \n    into uppercase.\n  \"\"\"\n\n  # pick up any attribute that doesn't start with '__' and uppercase it\n  uppercase_attr = {}\n  for name, val in future_class_attr.items():\n      if not name.startswith('__'):\n          uppercase_attr[name.upper()] = val\n      else:\n          uppercase_attr[name] = val\n\n  # let `type` do the class creation\n  return type(future_class_name, future_class_parents, uppercase_attr)\n\n__metaclass__ = upper_attr # this will affect all classes in the module\n\nclass Foo(): # global __metaclass__ won't work with \"object\" though\n  # but we can define __metaclass__ here instead to affect only this class\n  # and this will work with \"object\" children\n  bar = 'bip'\n\nprint(hasattr(Foo, 'bar'))\n# Out: False\nprint(hasattr(Foo, 'BAR'))\n# Out: True\n\nf = Foo()\nprint(f.BAR)\n# Out: 'bip'\n```\n\n现在，让我们完成同样的工作，但这次我们将会使用一个真正的类作为元类:\n\n```Python\n# Python 2.x\n# remember that `type` is actually a class like `str` and `int`\n# so you can inherit from it\nclass UpperAttrMetaclass(type): \n    # __new__ is the method called before __init__\n    # it's the method that creates the object and returns it\n    # while __init__ just initializes the object passed as parameter\n    # you rarely use __new__, except when you want to control how the object\n    # is created.\n    # here the created object is the class, and we want to customize it\n    # so we override __new__\n    # you can do some stuff in __init__ too if you wish\n    # some advanced use involves overriding __call__ as well, but we won't\n    # see this\n    def __new__(upperattr_metaclass, future_class_name, \n                future_class_parents, future_class_attr):\n\n        uppercase_attr = {}\n        for name, val in future_class_attr.items():\n            if not name.startswith('__'):\n                uppercase_attr[name.upper()] = val\n            else:\n                uppercase_attr[name] = val\n\n        return type(future_class_name, future_class_parents, uppercase_attr)\n```\n\n但是上面这种方法并不是很符合OOP，因为我们直接调用了`type`而且我们没有重写或者调用父类的`__new__`，让我们改为下面这样:\n\n```Python\n# Python 2.x\nclass UpperAttrMetaclass(type): \n\n    def __new__(upperattr_metaclass, future_class_name, \n                future_class_parents, future_class_attr):\n\n        uppercase_attr = {}\n        for name, val in future_class_attr.items():\n            if not name.startswith('__'):\n                uppercase_attr[name.upper()] = val\n            else:\n                uppercase_attr[name] = val\n\n        # reuse the type.__new__ method\n        # this is basic OOP, nothing magic in there\n        return type.__new__(upperattr_metaclass, future_class_name, \n                            future_class_parents, uppercase_attr)\n```\n\n你可能注意到了一个额外的参数`upperattr_metaclass`，它其实并不特别:`__new__`总是将定义它的类作为第一个参数，就和实例方法中使用`self`或类方法中使用`cls`作为方法的第一个参数一样。当然，此处参数所使用的名字只是为了方便明确参数意义，但就跟`self`一样，所有参数都可以简写，因此实际使用中的一个元类可能看起来像这样:\n\n```Python\nclass UpperAttrMetaclass(type): \n\n    def __new__(cls, clsname, bases, dct):\n\n        uppercase_attr = {}\n        for name, val in dct.items():\n            if not name.startswith('__'):\n                uppercase_attr[name.upper()] = val\n            else:\n                uppercase_attr[name] = val\n\n        return type.__new__(cls, clsname, bases, uppercase_attr)\n```\n\n是的，元类在完成一些\"黑魔法\"或者复杂事务的时候很有用，但是对于它们自身来说，其实很简单:\n1. 拦截一个类的创建\n2. 修改这个类\n3. 返回修改后的类\n\n#### 你为什么要使用类而不是函数来作为元类？\n由于`__metaclass__`可以接受任意可调用对象，那为什么你要使用一个明显更复杂的类呢？\n\n有几个原因:\n* 意图明确。当你阅读到`UpperAttrMetaclass(type)`，你知道接下来会怎样\n* 你可以使用OOP。元类可以继承，重写父类方法，甚至可以使用元类\n* 你可以更好地组织里的代码。你不会在一些简单的工作中使用到元类，它通常是为了复杂工作准备的。编写多个方法并且将它们组织到一个类里将会对使代码清晰易读有巨大的帮助。\n* 你可以拦截`__new__`、`__init__`和`__call__`等方法。这将允许你完成不同的工作。即使通常情况下你可以在`__new__`完成所有工作，但仍有许多人更偏爱在`__init__`中完成。\n* 它们叫做metaclass，`class`!\n\n#### 为什么你要使用元类呢？\n现在到了最关键的问题，为什么你要使用一些既复杂又易错的功能呢？\n实际上，通常情况下你不用:\n> Metaclasses are deeper magic that 99% of users should never worry about. If you wonder whether you need them, you don't (the people who actually need them know with certainty that they need them, and don't need an explanation about why).      --- Python Guru Tim Peters\n> 译: 元类是较为高深的技术，99%的用户应该永远不用担心。如果你在犹豫你是否需要它们，那么你不需要(真正需要它们的人会清楚的知道需要它们，而且无须解释)\n\n元类主要的用途是创建一个API。一个典型的例子就是Django的ORM，它允许你这样定义:\n\n```Python\nclass Person(models.Model):\n  name = models.CharField(max_length=30)\n  age = models.IntegerField()\n```\n\n但是如果你这样做:\n\n```Python\nguy = Person(name='bob', age='35')\nprint(guy.age)\n```\n\n它并不会返回一个`IntegerField`对象，而是返回一个`int`。这是因为`models.Model`定义了`__metaclass__`，而该元类将会完成一些工作使得你刚刚定义拥有一些简单语句的`Person`变成复杂的钩子(hook)与数据库字段相连。Django通过引入一个简单的API和使用元类来使一些复杂的事情看起来简单，根据该API重建代码完成实际工作都在幕后进行。\n\n#### 结束语\n首先，你知道了类也是对象，而且可以生成实例。当然，类也是元类的实例。\nPython中的万物都是对象，它们要么是类的实例，要么是元类的实例。`type`除外:\n\n<div class=\"tip\">\n`type`是它自己的元类\n</div>\n\n其次，元类十分复杂。对一个简单类的修改你可能并不会想使用它，而是使用另外两种不同的方式:\n* [Monkey patching](https://en.wikipedia.org/wiki/Monkey_patch)\n* 类装饰器\n\n在99%你需要修改类的情况下，你都最好使用以上两种方法。\n但99%的时间里，你都不需要修改类。","source":"_posts/Python-metaclass.md","raw":"---\ntitle: Python中的metaclass(元类)\ndate: 2017-02-06 16:11:02\ntags: [Python,类,面向对象编程]\ncategories: Python\nfrom: http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python?answertab=votes#tab-top\n---\n本文根据对[StackOverflow](http://stackoverflow.com)上问题[What is a metaclass in Python?](http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python?answertab=votes#tab-top)的高票回答翻译结合实际例子，试图解释**元类**的意义与用途。\n\n#### 类也是对象\n\n在想了解什么是**元类**之前，需要读者掌握Python中类的基本概念。而恰巧Python对类的定义有着不同于其他语言的解释。在大多数编程语言中，类仅仅只是指示如何生成实例对象的一段代码，这一点在Python中也如此:\n\n<!-- more -->\n```Python\n>>> class ObjectCreator(object):\n...       pass\n... \n\n>>> my_object = ObjectCreator()\n>>> print(my_object)\n<__main__.ObjectCreator object at 0x8974f2c>\n```\n\n但是，Python中的类还远不止如此:\n\n<div class=\"tip\">\n类也是实例对象\n</div>\n\n当程序员使用了关键字`class`时，Python将会执行它并且创建一个对象:\n\n```Python\n>>> class ObjectCreator(object):\n...       pass\n... \n```\n\n上述代码将会在内存中创建一个名叫\"ObjectCreator\"的对象。\n\n<div class=\"tip\">\n这个对象(类)自身拥有创建对象(实例)的能力，因此被称作类\n</div>\n\n即便如此，它仍然是一个对象，因此:\n* 你可以将它赋值给一个变量\n* 你可以复制它\n* 你可以为它添加属性\n* 你可以将它作为函数参数传递\n\n例如,\n使用`print`打印:\n\n```Python\n>>> print(ObjectCreator) # you can print a class because it's an object\n<class '__main__.ObjectCreator'>\n```\n作为函数参数传递:\n\n```Python\n>>> def echo(o):\n...       print(o)\n... \n>>> echo(ObjectCreator) # you can pass a class as a parameter\n<class '__main__.ObjectCreator'>\n```\n添加属性:\n\n```Python\n>>> print(hasattr(ObjectCreator, 'new_attribute'))\nFalse\n>>> ObjectCreator.new_attribute = 'foo' # you can add attributes to a class\n>>> print(hasattr(ObjectCreator, 'new_attribute'))\nTrue\n>>> print(ObjectCreator.new_attribute)\nfoo\n```\n赋值给另一个变量:\n\n```Python\n>>> ObjectCreatorMirror = ObjectCreator # you can assign a class to a variable\n>>> print(ObjectCreatorMirror.new_attribute)\nfoo\n>>> print(ObjectCreatorMirror())\n<__main__.ObjectCreator object at 0x8997b4c>\n```\n\n#### 动态地创建类\n既然类也是对象，那么你可以向创建对象一样快速地创建它们。\n首先，你可以通过使用关键字`class`在函数中创建一个类:\n\n```Python\n>>> def choose_class(name):\n...     if name == 'foo':\n...         class Foo(object):\n...             pass\n...         return Foo # return the class, not an instance\n...     else:\n...         class Bar(object):\n...             pass\n...         return Bar\n...     \n>>> MyClass = choose_class('foo') \n>>> print(MyClass, MyClass()) # the function returns a class, not an instance\n<class '__main__.choose_class.<locals>.Foo'> <__main__.choose_class.<locals>.Foo object at 0x10a7d06a0>\n```\n\n但它并不是很动态，因为你仍然需要亲自编写整个类。由于类是对象，那么它们必然是被某些东西生成的。当你使用关键字`class`时，Python自动地创建了其对象的对象。但就跟Python中大多数东西一样，Python给了你手动操作它的方法。\n还记得函数`type`吗？这个函数能够让你知道一个对象的类型:\n\n```Python\n>>> print(type(1))\n<type 'int'>\n>>> print(type(\"1\"))\n<type 'str'>\n>>> print(type(ObjectCreator))\n<type 'type'>\n>>> print(type(ObjectCreator()))\n<class '__main__.ObjectCreator'>\n```\n\n其实`type`还有一个完全不同的能力，它能够快速地创建类。`type`可以以参数的方式接收对一个类的描述，然后返回一个类。(可能有的人认为同一个函数根据传递不同的参数拥有两种完全不同的用途是一件很傻的事，但这是由于Python的向后兼容留下的问题)\n\n通过`type`创建类的参数描述如下:\n\n\ttype(name of the class, tuple of the parent class (for inheritance, can be empty), dictionary containing attributes names and values)\n\n例如:\n\n```Python\n>>> class MyShinyClass(object):\n...       pass\n```\n\n可以以如下方式手动创建:\n\n```Python\n>>> MyShinyClass = type('MyShinyClass', (), {}) # returns a class object\n>>> print(MyShinyClass, MyShinyClass())\n<class '__main__.MyShinyClass'> <__main__.MyShinyClass object at 0x10a7a5518>\n```\n\n你可能注意到了我们使用了\"MyShinyClass\"作为类的名字同时也作为变量名来保持对类的引用。它们可以不同，但是没有理由使其复杂化。\n`type`接收一个字典来定义类的属性，因此:\n\n```Python\n>>> class Foo(object):\n...       bar = True\n```\n\n可以被翻译成:\n\n```Python\n>>> Foo = type('Foo', (), {'bar': True})\n```\n\n这样定义的类也可以当做普通类使用:\n\n```Python\nprint(Foo)  # <class '__main__.Foo'>\nprint(Foo.bar)  # True\nf = Foo()\nprint(f)  # <__main__.Foo object at 0x8a9b84c>\nprint(f.bar)  # True\n```\n\n当然，你也可以继承自它:\n\n```Python\n>>>   class FooChild(Foo):\n...         pass\n```\n\n将会是:\n\n```Python\n>>> FooChild = type('FooChild', (Foo,), {})\n>>> print(FooChild, FooChild.bar)  # bar is inherited from Foo\n<class '__main__.FooChild'> True\n```\n\n最终你会想为你的类添加一些方法。只需要使用正确的语法定义一个函数然后作为一个属性赋值给类:\n\n```Python\n>>> def echo_bar(self):\n...       print(self.bar)\n... \n>>> FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})\n>>> hasattr(Foo, 'echo_bar')\nFalse\n>>> hasattr(FooChild, 'echo_bar')\nTrue\n>>> my_foo = FooChild()\n>>> my_foo.echo_bar()\nTrue\n```\n\n你甚至可以在动态生成了类之后添加更多的方法，就和向普通生成的类对象添加方法一样:\n\n```Python\n>>> def echo_bar_more(self):\n...       print('yet another method')\n... \n>>> FooChild.echo_bar_more = echo_bar_more\n>>> hasattr(FooChild, 'echo_bar_more')\nTrue\n```\n\n如你所见:在Python中，类是对象，你可以快速动态地创建一个类。这便是当你使用关键字`class`时Python做的工作，它通过使用**元类**来完成这项工作。\n\n#### 什么是元类(终于)\n\n**元类**是创建类的那些\"东西\"。你为了创建对象而定义了类，但是我们知道Python中的类也是对象，因此，元类是用来创建对象的。它们是**类的类**，你可以形象化地理解:\n\n```Python\nMyClass = MetaClass()\nMyObject = MyClass()\n```\n\n你已经知道`type`可以这么用:\n\n```Python\nMyClass = type('MyClass', (), {})\n```\n\n这是因为函数`type`实际上是一个元类，而且是Python用来创建所有类的元类。\n\n<div class=\"tip\">\n 在Python中，所有东西都是对象\n</div>\n\n其中包括但不限于整型、字符串、函数和类。它们都是对象，而且它们都是被类创建的:\n\n```Python\n>>> age = 35\n>>> age.__class__\n<type 'int'>\n>>> name = 'bob'\n>>> name.__class__\n<type 'str'>\n>>> def foo(): pass\n>>> foo.__class__\n<type 'function'>\n>>> class Bar(object): pass\n>>> b = Bar()\n>>> b.__class__\n<class '__main__.Bar'>\n```\n\n现在让我们看看`__class__`的`__class__`:\n\n```Python\n>>> age.__class__.__class__\n<type 'type'>\n>>> name.__class__.__class__\n<type 'type'>\n>>> foo.__class__.__class__\n<type 'type'>\n>>> b.__class__.__class__\n<type 'type'>\n```\n\n由此可见，一个元类正是用来创建所有类的。你也可以称它为\"类工厂\"。`type`是Python使用的内置的元类，当然，你也可以创建你自己的元类。\n\n#### `__metaclass__`属性\n你可以在编写一个类时为其指定`__metaclass__`属性:\n\n```Python\nclass Foo(object):\n    __metaclass__ = something...\n    ...\n```\n\n需要注意的是，上述语法仅适用于Python 2.x版本，在Python 3.x版本中，由新语法替代:\n\n```Python\nclass Foo(object, metaclass=something):\n    pass\n```\n\n当你为类指定了元类以后，Python将会使用该元类来创建类`Foo`。\n特别注意:\n\n<div class=\"tip\">\n类对象在Python调用__metaclass__来创建类之后才会存在。\n</div>\n\n** Python 2.x中的__metaclass__ **\n对Python 2.x来说，即当首先写下了`class Foo(object)`，但是类对象`Foo`还并没有在内存中被创建。Python将会在类定义中查找`__metaclass__`，如果找到了，则用其来创建对象类`Foo`，如果没有找到，Python将会使用`type`来创建该类。\n\n当你这么写:\n\n```Python\nclass Foo(Bar):\n    pass\n```\n\nPython将会这么做:\n1. 类`Foo`有定义`__metaclass__`吗？如果有，则使用指定的`__metaclass__`来创建类对象`Foo`。\n2. 如果没有找到这个属性，它将会在父类`Bar`中找\n3. 这样一直向父类找，直到达到`module`级别才停止。\n4. 如果在任何父类都找不到，那就用`type`创建类对象`Foo`\n\n这里面有几点需要注意:\n1. 为子类指定的`__metaclass__`需要是其所有父类`__metaclass__`的子类。\n2. 在多继承的情况下，如果没有为该类指定`__metaclass__`，则该类将会由MRO中第一个父类的`__metaclass__`和所有父类`__metaclass__`中处于继承最底层的`__metaclass__`生成。\n\nPython 2.x中`__metaclass__`使用如以下代码所示:\n\n```Python\n# Python 2.x\nclass Meta0(type):\n    def __new__(meta, name, bases, cls_dict):\n        cls = type.__new__(meta, name, bases, cls_dict)\n        print(meta, name, bases, cls_dict)\n        return cls\n\n__metaclass__ = Meta0\n\nclass Meta(type):\n    def __new__(meta, name, bases, cls_dict):\n        print(meta, name, bases, cls_dict)\n        cls_dict['meta'] = True\n        cls = type.__new__(meta, name, bases, cls_dict)\n        return cls\n\nclass Meta2(Meta):\n    def __new__(meta, name, bases, cls_dict):\n        print(meta, name, bases, cls_dict)\n        cls_dict['meta2'] = True\n        cls = type.__new__(meta, name, bases, cls_dict)\n        return cls\n\nclass Meta3(Meta2):\n    def __new__(meta, name, bases, cls_dict):\n        print(meta, name, bases, cls_dict)\n        cls_dict['meta3'] = True\n        cls = type.__new__(meta, name, bases, cls_dict)\n        return cls\n\nprint('C1')\nclass C1:\n    pass\n\nprint('C2')\nclass C2:\n    __metaclass__ = Meta\n\nprint('C3')\nclass C3(C2):\n    pass\n\nprint('C4')\nclass C4(C2):\n    __metaclass__ = Meta2\n\nprint('C5')\nclass C5(C2):\n    pass\n\nprint('C6')\nclass C6(C2):\n    __metaclass__ = Meta3\n\nprint('C7')\nclass C7(C4, C6, C5):\n    pass\n```\n\n结果为:\n\n```Python\nC1\n(<class '__main__.Meta0'>, 'C1', (), {'__module__': '__main__'})\nC2\n(<class '__main__.Meta'>, 'C2', (), {'__module__': '__main__', '__metaclass__': <class '__main__.Meta'>})\nC3\n(<class '__main__.Meta'>, 'C3', (<class '__main__.C2'>,), {'__module__': '__main__'})\nC4\n(<class '__main__.Meta2'>, 'C4', (<class '__main__.C2'>,), {'__module__': '__main__', '__metaclass__': <class '__main__.Meta2'>})\nC5\n(<class '__main__.Meta'>, 'C5', (<class '__main__.C2'>,), {'__module__': '__main__'})\nC6\n(<class '__main__.Meta3'>, 'C6', (<class '__main__.C2'>,), {'__module__': '__main__', '__metaclass__': <class '__main__.Meta3'>})\nC7\n(<class '__main__.Meta2'>, 'C7', (<class '__main__.C4'>, <class '__main__.C6'>, <class '__main__.C5'>), {'__module__': '__main__'})\n(<class '__main__.Meta3'>, 'C7', (<class '__main__.C4'>, <class '__main__.C6'>, <class '__main__.C5'>), {'__module__': '__main__', 'meta2': True})\n```\n\n注意到在类`C7`的生成过程中，分别调用了`Meta2`和`Meta3`，调用`Meta2`是由于在`C7`的继承中，类`C4`位于第一位，而`C4`的`__metaclass__`为`Meta2`，所以首先使用`Meta2`，而在`C4`、`C5`和`C6`的`__metaclass__`中，`Meta3`处于继承最底层，所以还会调用`Meta3`来生成类`C7`。(如果类`C6`位于最前面则只会调用`Meta3`)\n这样的多继承以及多元类调用比较复杂，个人认为还是少用较好。\n\n** Python 3.x中的metaclass **\n在Python3.x中，需要通过关键字参数`metaclass`给类指定元类。如:\n\n```Python\nclass C1(metaclass=Meta):\n    pass\n```\n\n关于元类的寻找与Python 2.x类似:\n1. 类`Foo`有定义关键字参数`metaclass`吗？如果有，则使用指定的`metaclass`来创建类对象`Foo`。\n2. 如果没有找到这个属性，它将会在父类`Bar`中找\n3. 如果在任何父类都找不到，那就用`type`创建类对象`Foo`\n\nPython 3.x的metaclass使用注意仍然与Python 2.x类似:\n1. 为子类指定的`metaclass`需要是其所有父类`metaclass`的子类。\n2. 在多继承的情况下，如果没有为该类指定`metaclass`，则该类将会由所有父类`metaclass`中处于继承最底层的`metaclass`生成。如果有指定，则选择前述的`metaclass`和该`metaclass`中继承层次更低的那个来生成。\n\nPython 3.x中`metaclass`使用如以下代码所示:\n\n```Python\n# Python 3.x\nclass Meta(type):\n    def __new__(meta, name, bases, cls_dict):\n        print(meta, name, bases, cls_dict)\n        return type.__new__(meta, name, bases, cls_dict)\n\nclass Meta2(Meta):\n    def __new__(meta, name, bases, cls_dict):\n        print(meta, name, bases, cls_dict)\n        cls_dict['hello'] = True\n        return type.__new__(meta, name, bases, cls_dict)\n\nclass Meta3(Meta2):\n    def __new__(meta, name, bases, cls_dict):\n        print(meta, name, bases, cls_dict)\n        return type.__new__(meta, name, bases, cls_dict)\n\nclass Meta4(Meta3):\n    def __new__(meta, name, bases, cls_dict):\n        print(meta, name, bases, cls_dict)\n        return type.__new__(meta, name, bases, cls_dict)\n\n\nprint('C1')\nclass C1(metaclass=Meta):\n    pass\n\nprint('C2')\nclass C2(C1):\n    pass\n\nprint('C3')\nclass C3(C1, metaclass=Meta2):\n    pass\n\nprint('C4')\nclass C4(C1, metaclass=Meta3):\n    pass\n\nprint('C5')\nclass C5(C3, C4, C2):\n    pass\n\nprint('C6')\nclass C6(C3, C4, C2, metaclass=Meta4):\n    pass\n```\n\n结果为:\n\n```Python\nC1\n<class '__main__.Meta'> C1 () {'__module__': '__main__', '__qualname__': 'C1'}\nC2\n<class '__main__.Meta'> C2 (<class '__main__.C1'>,) {'__module__': '__main__', '__qualname__': 'C2'}\nC3\n<class '__main__.Meta2'> C3 (<class '__main__.C1'>,) {'__module__': '__main__', '__qualname__': 'C3'}\nC4\n<class '__main__.Meta3'> C4 (<class '__main__.C1'>,) {'__module__': '__main__', '__qualname__': 'C4'}\nC5\n<class '__main__.Meta3'> C5 (<class '__main__.C3'>, <class '__main__.C4'>, <class '__main__.C2'>) {'__module__': '__main__', '__qualname__': 'C5'}\nC6\n<class '__main__.Meta4'> C6 (<class '__main__.C3'>, <class '__main__.C4'>, <class '__main__.C2'>) {'__module__': '__main__', '__qualname__': 'C6'}\n```\n\n需要注意一点，为了输出内容的简洁，以上代码在方法`__new__`的最后都使用了`type.__new__`而不是`super().__new__`。改用`super().__new__`后执行仍相同，只是多了对父类的调用。\n\n说了这么多，我们应该给`__metaclass__`赋值什么呢?答案当然是，一个可以创建类的东西。\n那么，什么才能创建一个类呢？\n\n#### 普通的元类\n设计元类的一个很主要的原因就是为了在类被创建的时候进行自动修改，这经常用在API的设计上。\n让我们举一个简单的例子，你决定让你的模块里所有类的属性都是大写形式。要完成这项工作有很多方法，其中一个便是在模块级别上定义`__metaclass__`。这样的话，该模块中所有的类都会通过该元类创建，我们只需要让这个元类完成将所有属性变成大写的工作。\n幸运的是，`__metaclass__`可以是任何可调用(callable)对象，并不一定非要是一个正式的类。所以我们将从一个函数作为元类的例子说起:\n\n```Python\n# Python 2.x\n# the metaclass will automatically get passed the same argument\n# that you usually pass to `type`\ndef upper_attr(future_class_name, future_class_parents, future_class_attr):\n  \"\"\"\n    Return a class object, with the list of its attribute turned \n    into uppercase.\n  \"\"\"\n\n  # pick up any attribute that doesn't start with '__' and uppercase it\n  uppercase_attr = {}\n  for name, val in future_class_attr.items():\n      if not name.startswith('__'):\n          uppercase_attr[name.upper()] = val\n      else:\n          uppercase_attr[name] = val\n\n  # let `type` do the class creation\n  return type(future_class_name, future_class_parents, uppercase_attr)\n\n__metaclass__ = upper_attr # this will affect all classes in the module\n\nclass Foo(): # global __metaclass__ won't work with \"object\" though\n  # but we can define __metaclass__ here instead to affect only this class\n  # and this will work with \"object\" children\n  bar = 'bip'\n\nprint(hasattr(Foo, 'bar'))\n# Out: False\nprint(hasattr(Foo, 'BAR'))\n# Out: True\n\nf = Foo()\nprint(f.BAR)\n# Out: 'bip'\n```\n\n现在，让我们完成同样的工作，但这次我们将会使用一个真正的类作为元类:\n\n```Python\n# Python 2.x\n# remember that `type` is actually a class like `str` and `int`\n# so you can inherit from it\nclass UpperAttrMetaclass(type): \n    # __new__ is the method called before __init__\n    # it's the method that creates the object and returns it\n    # while __init__ just initializes the object passed as parameter\n    # you rarely use __new__, except when you want to control how the object\n    # is created.\n    # here the created object is the class, and we want to customize it\n    # so we override __new__\n    # you can do some stuff in __init__ too if you wish\n    # some advanced use involves overriding __call__ as well, but we won't\n    # see this\n    def __new__(upperattr_metaclass, future_class_name, \n                future_class_parents, future_class_attr):\n\n        uppercase_attr = {}\n        for name, val in future_class_attr.items():\n            if not name.startswith('__'):\n                uppercase_attr[name.upper()] = val\n            else:\n                uppercase_attr[name] = val\n\n        return type(future_class_name, future_class_parents, uppercase_attr)\n```\n\n但是上面这种方法并不是很符合OOP，因为我们直接调用了`type`而且我们没有重写或者调用父类的`__new__`，让我们改为下面这样:\n\n```Python\n# Python 2.x\nclass UpperAttrMetaclass(type): \n\n    def __new__(upperattr_metaclass, future_class_name, \n                future_class_parents, future_class_attr):\n\n        uppercase_attr = {}\n        for name, val in future_class_attr.items():\n            if not name.startswith('__'):\n                uppercase_attr[name.upper()] = val\n            else:\n                uppercase_attr[name] = val\n\n        # reuse the type.__new__ method\n        # this is basic OOP, nothing magic in there\n        return type.__new__(upperattr_metaclass, future_class_name, \n                            future_class_parents, uppercase_attr)\n```\n\n你可能注意到了一个额外的参数`upperattr_metaclass`，它其实并不特别:`__new__`总是将定义它的类作为第一个参数，就和实例方法中使用`self`或类方法中使用`cls`作为方法的第一个参数一样。当然，此处参数所使用的名字只是为了方便明确参数意义，但就跟`self`一样，所有参数都可以简写，因此实际使用中的一个元类可能看起来像这样:\n\n```Python\nclass UpperAttrMetaclass(type): \n\n    def __new__(cls, clsname, bases, dct):\n\n        uppercase_attr = {}\n        for name, val in dct.items():\n            if not name.startswith('__'):\n                uppercase_attr[name.upper()] = val\n            else:\n                uppercase_attr[name] = val\n\n        return type.__new__(cls, clsname, bases, uppercase_attr)\n```\n\n是的，元类在完成一些\"黑魔法\"或者复杂事务的时候很有用，但是对于它们自身来说，其实很简单:\n1. 拦截一个类的创建\n2. 修改这个类\n3. 返回修改后的类\n\n#### 你为什么要使用类而不是函数来作为元类？\n由于`__metaclass__`可以接受任意可调用对象，那为什么你要使用一个明显更复杂的类呢？\n\n有几个原因:\n* 意图明确。当你阅读到`UpperAttrMetaclass(type)`，你知道接下来会怎样\n* 你可以使用OOP。元类可以继承，重写父类方法，甚至可以使用元类\n* 你可以更好地组织里的代码。你不会在一些简单的工作中使用到元类，它通常是为了复杂工作准备的。编写多个方法并且将它们组织到一个类里将会对使代码清晰易读有巨大的帮助。\n* 你可以拦截`__new__`、`__init__`和`__call__`等方法。这将允许你完成不同的工作。即使通常情况下你可以在`__new__`完成所有工作，但仍有许多人更偏爱在`__init__`中完成。\n* 它们叫做metaclass，`class`!\n\n#### 为什么你要使用元类呢？\n现在到了最关键的问题，为什么你要使用一些既复杂又易错的功能呢？\n实际上，通常情况下你不用:\n> Metaclasses are deeper magic that 99% of users should never worry about. If you wonder whether you need them, you don't (the people who actually need them know with certainty that they need them, and don't need an explanation about why).      --- Python Guru Tim Peters\n> 译: 元类是较为高深的技术，99%的用户应该永远不用担心。如果你在犹豫你是否需要它们，那么你不需要(真正需要它们的人会清楚的知道需要它们，而且无须解释)\n\n元类主要的用途是创建一个API。一个典型的例子就是Django的ORM，它允许你这样定义:\n\n```Python\nclass Person(models.Model):\n  name = models.CharField(max_length=30)\n  age = models.IntegerField()\n```\n\n但是如果你这样做:\n\n```Python\nguy = Person(name='bob', age='35')\nprint(guy.age)\n```\n\n它并不会返回一个`IntegerField`对象，而是返回一个`int`。这是因为`models.Model`定义了`__metaclass__`，而该元类将会完成一些工作使得你刚刚定义拥有一些简单语句的`Person`变成复杂的钩子(hook)与数据库字段相连。Django通过引入一个简单的API和使用元类来使一些复杂的事情看起来简单，根据该API重建代码完成实际工作都在幕后进行。\n\n#### 结束语\n首先，你知道了类也是对象，而且可以生成实例。当然，类也是元类的实例。\nPython中的万物都是对象，它们要么是类的实例，要么是元类的实例。`type`除外:\n\n<div class=\"tip\">\n`type`是它自己的元类\n</div>\n\n其次，元类十分复杂。对一个简单类的修改你可能并不会想使用它，而是使用另外两种不同的方式:\n* [Monkey patching](https://en.wikipedia.org/wiki/Monkey_patch)\n* 类装饰器\n\n在99%你需要修改类的情况下，你都最好使用以上两种方法。\n但99%的时间里，你都不需要修改类。","slug":"Python-metaclass","published":1,"updated":"2018-01-15T01:17:12.817Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgvnqmla0017w628j2omkd74","content":"<p>本文根据对<a href=\"http://stackoverflow.com\" target=\"_blank\" rel=\"noopener\">StackOverflow</a>上问题<a href=\"http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python?answertab=votes#tab-top\" target=\"_blank\" rel=\"noopener\">What is a metaclass in Python?</a>的高票回答翻译结合实际例子，试图解释<strong>元类</strong>的意义与用途。</p>\n<h4 id=\"类也是对象\"><a href=\"#类也是对象\" class=\"headerlink\" title=\"类也是对象\"></a>类也是对象</h4><p>在想了解什么是<strong>元类</strong>之前，需要读者掌握Python中类的基本概念。而恰巧Python对类的定义有着不同于其他语言的解释。在大多数编程语言中，类仅仅只是指示如何生成实例对象的一段代码，这一点在Python中也如此:</p>\n<a id=\"more\"></a>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObjectCreator</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>      <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">... </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>my_object = ObjectCreator()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(my_object)</span><br><span class=\"line\">&lt;__main__.ObjectCreator object at <span class=\"number\">0x8974f2c</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>但是，Python中的类还远不止如此:</p>\n<div class=\"tip\"><br>类也是实例对象<br></div>\n\n<p>当程序员使用了关键字<code>class</code>时，Python将会执行它并且创建一个对象:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObjectCreator</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>      <span class=\"keyword\">pass</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>上述代码将会在内存中创建一个名叫”ObjectCreator”的对象。</p>\n<div class=\"tip\"><br>这个对象(类)自身拥有创建对象(实例)的能力，因此被称作类<br></div>\n\n<p>即便如此，它仍然是一个对象，因此:</p>\n<ul>\n<li>你可以将它赋值给一个变量</li>\n<li>你可以复制它</li>\n<li>你可以为它添加属性</li>\n<li>你可以将它作为函数参数传递</li>\n</ul>\n<p>例如,<br>使用<code>print</code>打印:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(ObjectCreator) <span class=\"comment\"># you can print a class because it's an object</span></span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">__main__</span>.<span class=\"title\">ObjectCreator</span>'&gt;</span></span><br></pre></td></tr></table></figure>\n<p>作为函数参数传递:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">echo</span><span class=\"params\">(o)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>      print(o)</span><br><span class=\"line\"><span class=\"meta\">... </span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>echo(ObjectCreator) <span class=\"comment\"># you can pass a class as a parameter</span></span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">__main__</span>.<span class=\"title\">ObjectCreator</span>'&gt;</span></span><br></pre></td></tr></table></figure>\n<p>添加属性:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(hasattr(ObjectCreator, <span class=\"string\">'new_attribute'</span>))</span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>ObjectCreator.new_attribute = <span class=\"string\">'foo'</span> <span class=\"comment\"># you can add attributes to a class</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(hasattr(ObjectCreator, <span class=\"string\">'new_attribute'</span>))</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(ObjectCreator.new_attribute)</span><br><span class=\"line\">foo</span><br></pre></td></tr></table></figure>\n<p>赋值给另一个变量:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>ObjectCreatorMirror = ObjectCreator <span class=\"comment\"># you can assign a class to a variable</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(ObjectCreatorMirror.new_attribute)</span><br><span class=\"line\">foo</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(ObjectCreatorMirror())</span><br><span class=\"line\">&lt;__main__.ObjectCreator object at <span class=\"number\">0x8997b4c</span>&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"动态地创建类\"><a href=\"#动态地创建类\" class=\"headerlink\" title=\"动态地创建类\"></a>动态地创建类</h4><p>既然类也是对象，那么你可以向创建对象一样快速地创建它们。<br>首先，你可以通过使用关键字<code>class</code>在函数中创建一个类:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">choose_class</span><span class=\"params\">(name)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">if</span> name == <span class=\"string\">'foo'</span>:</span><br><span class=\"line\"><span class=\"meta\">... </span>        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>            <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">... </span>        <span class=\"keyword\">return</span> Foo <span class=\"comment\"># return the class, not an instance</span></span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">else</span>:</span><br><span class=\"line\"><span class=\"meta\">... </span>        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>            <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">... </span>        <span class=\"keyword\">return</span> Bar</span><br><span class=\"line\"><span class=\"meta\">... </span>    </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>MyClass = choose_class(<span class=\"string\">'foo'</span>) </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(MyClass, MyClass()) <span class=\"comment\"># the function returns a class, not an instance</span></span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">__main__</span>.<span class=\"title\">choose_class</span>.&lt;<span class=\"title\">locals</span>&gt;.<span class=\"title\">Foo</span>'&gt; &lt;<span class=\"title\">__main__</span>.<span class=\"title\">choose_class</span>.&lt;<span class=\"title\">locals</span>&gt;.<span class=\"title\">Foo</span> <span class=\"title\">object</span> <span class=\"title\">at</span> 0<span class=\"title\">x10a7d06a0</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>但它并不是很动态，因为你仍然需要亲自编写整个类。由于类是对象，那么它们必然是被某些东西生成的。当你使用关键字<code>class</code>时，Python自动地创建了其对象的对象。但就跟Python中大多数东西一样，Python给了你手动操作它的方法。<br>还记得函数<code>type</code>吗？这个函数能够让你知道一个对象的类型:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(type(<span class=\"number\">1</span>))</span><br><span class=\"line\">&lt;type <span class=\"string\">'int'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(type(<span class=\"string\">\"1\"</span>))</span><br><span class=\"line\">&lt;type <span class=\"string\">'str'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(type(ObjectCreator))</span><br><span class=\"line\">&lt;type <span class=\"string\">'type'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(type(ObjectCreator()))</span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">__main__</span>.<span class=\"title\">ObjectCreator</span>'&gt;</span></span><br></pre></td></tr></table></figure>\n<p>其实<code>type</code>还有一个完全不同的能力，它能够快速地创建类。<code>type</code>可以以参数的方式接收对一个类的描述，然后返回一个类。(可能有的人认为同一个函数根据传递不同的参数拥有两种完全不同的用途是一件很傻的事，但这是由于Python的向后兼容留下的问题)</p>\n<p>通过<code>type</code>创建类的参数描述如下:</p>\n<pre><code>type(name of the class, tuple of the parent class (for inheritance, can be empty), dictionary containing attributes names and values)\n</code></pre><p>例如:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyShinyClass</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>      <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>可以以如下方式手动创建:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>MyShinyClass = type(<span class=\"string\">'MyShinyClass'</span>, (), &#123;&#125;) <span class=\"comment\"># returns a class object</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(MyShinyClass, MyShinyClass())</span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">__main__</span>.<span class=\"title\">MyShinyClass</span>'&gt; &lt;<span class=\"title\">__main__</span>.<span class=\"title\">MyShinyClass</span> <span class=\"title\">object</span> <span class=\"title\">at</span> 0<span class=\"title\">x10a7a5518</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>你可能注意到了我们使用了”MyShinyClass”作为类的名字同时也作为变量名来保持对类的引用。它们可以不同，但是没有理由使其复杂化。<br><code>type</code>接收一个字典来定义类的属性，因此:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>      bar = <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>可以被翻译成:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Foo = type(<span class=\"string\">'Foo'</span>, (), &#123;<span class=\"string\">'bar'</span>: <span class=\"keyword\">True</span>&#125;)</span><br></pre></td></tr></table></figure>\n<p>这样定义的类也可以当做普通类使用:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(Foo)  <span class=\"comment\"># &lt;class '__main__.Foo'&gt;</span></span><br><span class=\"line\">print(Foo.bar)  <span class=\"comment\"># True</span></span><br><span class=\"line\">f = Foo()</span><br><span class=\"line\">print(f)  <span class=\"comment\"># &lt;__main__.Foo object at 0x8a9b84c&gt;</span></span><br><span class=\"line\">print(f.bar)  <span class=\"comment\"># True</span></span><br></pre></td></tr></table></figure>\n<p>当然，你也可以继承自它:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FooChild</span><span class=\"params\">(Foo)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>        <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>将会是:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>FooChild = type(<span class=\"string\">'FooChild'</span>, (Foo,), &#123;&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(FooChild, FooChild.bar)  <span class=\"comment\"># bar is inherited from Foo</span></span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">__main__</span>.<span class=\"title\">FooChild</span>'&gt; <span class=\"title\">True</span></span></span><br></pre></td></tr></table></figure>\n<p>最终你会想为你的类添加一些方法。只需要使用正确的语法定义一个函数然后作为一个属性赋值给类:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">echo_bar</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>      print(self.bar)</span><br><span class=\"line\"><span class=\"meta\">... </span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>FooChild = type(<span class=\"string\">'FooChild'</span>, (Foo,), &#123;<span class=\"string\">'echo_bar'</span>: echo_bar&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(Foo, <span class=\"string\">'echo_bar'</span>)</span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(FooChild, <span class=\"string\">'echo_bar'</span>)</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>my_foo = FooChild()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>my_foo.echo_bar()</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>你甚至可以在动态生成了类之后添加更多的方法，就和向普通生成的类对象添加方法一样:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">echo_bar_more</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>      print(<span class=\"string\">'yet another method'</span>)</span><br><span class=\"line\"><span class=\"meta\">... </span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>FooChild.echo_bar_more = echo_bar_more</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(FooChild, <span class=\"string\">'echo_bar_more'</span>)</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>如你所见:在Python中，类是对象，你可以快速动态地创建一个类。这便是当你使用关键字<code>class</code>时Python做的工作，它通过使用<strong>元类</strong>来完成这项工作。</p>\n<h4 id=\"什么是元类-终于\"><a href=\"#什么是元类-终于\" class=\"headerlink\" title=\"什么是元类(终于)\"></a>什么是元类(终于)</h4><p><strong>元类</strong>是创建类的那些”东西”。你为了创建对象而定义了类，但是我们知道Python中的类也是对象，因此，元类是用来创建对象的。它们是<strong>类的类</strong>，你可以形象化地理解:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyClass = MetaClass()</span><br><span class=\"line\">MyObject = MyClass()</span><br></pre></td></tr></table></figure>\n<p>你已经知道<code>type</code>可以这么用:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyClass = type(<span class=\"string\">'MyClass'</span>, (), &#123;&#125;)</span><br></pre></td></tr></table></figure>\n<p>这是因为函数<code>type</code>实际上是一个元类，而且是Python用来创建所有类的元类。</p>\n<div class=\"tip\"><br> 在Python中，所有东西都是对象<br></div>\n\n<p>其中包括但不限于整型、字符串、函数和类。它们都是对象，而且它们都是被类创建的:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>age = <span class=\"number\">35</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>age.__class__</span><br><span class=\"line\">&lt;type <span class=\"string\">'int'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name = <span class=\"string\">'bob'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name.__class__</span><br><span class=\"line\">&lt;type <span class=\"string\">'str'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">()</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>foo.__class__</span><br><span class=\"line\">&lt;type <span class=\"string\">'function'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span><span class=\"params\">(object)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = Bar()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b.__class__</span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">__main__</span>.<span class=\"title\">Bar</span>'&gt;</span></span><br></pre></td></tr></table></figure>\n<p>现在让我们看看<code>__class__</code>的<code>__class__</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>age.__class__.__class__</span><br><span class=\"line\">&lt;type <span class=\"string\">'type'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name.__class__.__class__</span><br><span class=\"line\">&lt;type <span class=\"string\">'type'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>foo.__class__.__class__</span><br><span class=\"line\">&lt;type <span class=\"string\">'type'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b.__class__.__class__</span><br><span class=\"line\">&lt;type <span class=\"string\">'type'</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>由此可见，一个元类正是用来创建所有类的。你也可以称它为”类工厂”。<code>type</code>是Python使用的内置的元类，当然，你也可以创建你自己的元类。</p>\n<h4 id=\"metaclass-属性\"><a href=\"#metaclass-属性\" class=\"headerlink\" title=\"__metaclass__属性\"></a><code>__metaclass__</code>属性</h4><p>你可以在编写一个类时为其指定<code>__metaclass__</code>属性:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    __metaclass__ = something...</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，上述语法仅适用于Python 2.x版本，在Python 3.x版本中，由新语法替代:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span><span class=\"params\">(object, metaclass=something)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>当你为类指定了元类以后，Python将会使用该元类来创建类<code>Foo</code>。<br>特别注意:</p>\n<div class=\"tip\"><br>类对象在Python调用<strong>metaclass</strong>来创建类之后才会存在。<br></div>\n\n<p><strong> Python 2.x中的<strong>metaclass</strong> </strong><br>对Python 2.x来说，即当首先写下了<code>class Foo(object)</code>，但是类对象<code>Foo</code>还并没有在内存中被创建。Python将会在类定义中查找<code>__metaclass__</code>，如果找到了，则用其来创建对象类<code>Foo</code>，如果没有找到，Python将会使用<code>type</code>来创建该类。</p>\n<p>当你这么写:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span><span class=\"params\">(Bar)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>Python将会这么做:</p>\n<ol>\n<li>类<code>Foo</code>有定义<code>__metaclass__</code>吗？如果有，则使用指定的<code>__metaclass__</code>来创建类对象<code>Foo</code>。</li>\n<li>如果没有找到这个属性，它将会在父类<code>Bar</code>中找</li>\n<li>这样一直向父类找，直到达到<code>module</code>级别才停止。</li>\n<li>如果在任何父类都找不到，那就用<code>type</code>创建类对象<code>Foo</code></li>\n</ol>\n<p>这里面有几点需要注意:</p>\n<ol>\n<li>为子类指定的<code>__metaclass__</code>需要是其所有父类<code>__metaclass__</code>的子类。</li>\n<li>在多继承的情况下，如果没有为该类指定<code>__metaclass__</code>，则该类将会由MRO中第一个父类的<code>__metaclass__</code>和所有父类<code>__metaclass__</code>中处于继承最底层的<code>__metaclass__</code>生成。</li>\n</ol>\n<p>Python 2.x中<code>__metaclass__</code>使用如以下代码所示:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Python 2.x</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta0</span><span class=\"params\">(type)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(meta, name, bases, cls_dict)</span>:</span></span><br><span class=\"line\">        cls = type.__new__(meta, name, bases, cls_dict)</span><br><span class=\"line\">        print(meta, name, bases, cls_dict)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls</span><br><span class=\"line\"></span><br><span class=\"line\">__metaclass__ = Meta0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span><span class=\"params\">(type)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(meta, name, bases, cls_dict)</span>:</span></span><br><span class=\"line\">        print(meta, name, bases, cls_dict)</span><br><span class=\"line\">        cls_dict[<span class=\"string\">'meta'</span>] = <span class=\"keyword\">True</span></span><br><span class=\"line\">        cls = type.__new__(meta, name, bases, cls_dict)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta2</span><span class=\"params\">(Meta)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(meta, name, bases, cls_dict)</span>:</span></span><br><span class=\"line\">        print(meta, name, bases, cls_dict)</span><br><span class=\"line\">        cls_dict[<span class=\"string\">'meta2'</span>] = <span class=\"keyword\">True</span></span><br><span class=\"line\">        cls = type.__new__(meta, name, bases, cls_dict)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta3</span><span class=\"params\">(Meta2)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(meta, name, bases, cls_dict)</span>:</span></span><br><span class=\"line\">        print(meta, name, bases, cls_dict)</span><br><span class=\"line\">        cls_dict[<span class=\"string\">'meta3'</span>] = <span class=\"keyword\">True</span></span><br><span class=\"line\">        cls = type.__new__(meta, name, bases, cls_dict)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C1'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C1</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C2'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C2</span>:</span></span><br><span class=\"line\">    __metaclass__ = Meta</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C3'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C3</span><span class=\"params\">(C2)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C4'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C4</span><span class=\"params\">(C2)</span>:</span></span><br><span class=\"line\">    __metaclass__ = Meta2</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C5'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C5</span><span class=\"params\">(C2)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C6'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C6</span><span class=\"params\">(C2)</span>:</span></span><br><span class=\"line\">    __metaclass__ = Meta3</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C7'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C7</span><span class=\"params\">(C4, C6, C5)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>结果为:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C1</span><br><span class=\"line\">(&lt;class '__main__.Meta0'&gt;, 'C1', (), &#123;'__module__': '__main__'&#125;)</span><br><span class=\"line\">C2</span><br><span class=\"line\">(&lt;class '__main__.Meta'&gt;, 'C2', (), &#123;'__module__': '__main__', '__metaclass__': &lt;class '__main__.Meta'&gt;&#125;)</span><br><span class=\"line\">C3</span><br><span class=\"line\">(&lt;class '__main__.Meta'&gt;, 'C3', (&lt;class '__main__.C2'&gt;,), &#123;'__module__': '__main__'&#125;)</span><br><span class=\"line\">C4</span><br><span class=\"line\">(&lt;class '__main__.Meta2'&gt;, 'C4', (&lt;class '__main__.C2'&gt;,), &#123;'__module__': '__main__', '__metaclass__': &lt;class '__main__.Meta2'&gt;&#125;)</span><br><span class=\"line\">C5</span><br><span class=\"line\">(&lt;class '__main__.Meta'&gt;, 'C5', (&lt;class '__main__.C2'&gt;,), &#123;'__module__': '__main__'&#125;)</span><br><span class=\"line\">C6</span><br><span class=\"line\">(&lt;class '__main__.Meta3'&gt;, 'C6', (&lt;class '__main__.C2'&gt;,), &#123;'__module__': '__main__', '__metaclass__': &lt;class '__main__.Meta3'&gt;&#125;)</span><br><span class=\"line\">C7</span><br><span class=\"line\">(&lt;class '__main__.Meta2'&gt;, 'C7', (&lt;class '__main__.C4'&gt;, &lt;class '__main__.C6'&gt;, &lt;class '__main__.C5'&gt;), &#123;'__module__': '__main__'&#125;)</span><br><span class=\"line\">(&lt;class '__main__.Meta3'&gt;, 'C7', (&lt;class '__main__.C4'&gt;, &lt;class '__main__.C6'&gt;, &lt;class '__main__.C5'&gt;), &#123;'__module__': '__main__', 'meta2': True&#125;)</span><br></pre></td></tr></table></figure>\n<p>注意到在类<code>C7</code>的生成过程中，分别调用了<code>Meta2</code>和<code>Meta3</code>，调用<code>Meta2</code>是由于在<code>C7</code>的继承中，类<code>C4</code>位于第一位，而<code>C4</code>的<code>__metaclass__</code>为<code>Meta2</code>，所以首先使用<code>Meta2</code>，而在<code>C4</code>、<code>C5</code>和<code>C6</code>的<code>__metaclass__</code>中，<code>Meta3</code>处于继承最底层，所以还会调用<code>Meta3</code>来生成类<code>C7</code>。(如果类<code>C6</code>位于最前面则只会调用<code>Meta3</code>)<br>这样的多继承以及多元类调用比较复杂，个人认为还是少用较好。</p>\n<p><strong> Python 3.x中的metaclass </strong><br>在Python3.x中，需要通过关键字参数<code>metaclass</code>给类指定元类。如:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C1</span><span class=\"params\">(metaclass=Meta)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>关于元类的寻找与Python 2.x类似:</p>\n<ol>\n<li>类<code>Foo</code>有定义关键字参数<code>metaclass</code>吗？如果有，则使用指定的<code>metaclass</code>来创建类对象<code>Foo</code>。</li>\n<li>如果没有找到这个属性，它将会在父类<code>Bar</code>中找</li>\n<li>如果在任何父类都找不到，那就用<code>type</code>创建类对象<code>Foo</code></li>\n</ol>\n<p>Python 3.x的metaclass使用注意仍然与Python 2.x类似:</p>\n<ol>\n<li>为子类指定的<code>metaclass</code>需要是其所有父类<code>metaclass</code>的子类。</li>\n<li>在多继承的情况下，如果没有为该类指定<code>metaclass</code>，则该类将会由所有父类<code>metaclass</code>中处于继承最底层的<code>metaclass</code>生成。如果有指定，则选择前述的<code>metaclass</code>和该<code>metaclass</code>中继承层次更低的那个来生成。</li>\n</ol>\n<p>Python 3.x中<code>metaclass</code>使用如以下代码所示:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Python 3.x</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span><span class=\"params\">(type)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(meta, name, bases, cls_dict)</span>:</span></span><br><span class=\"line\">        print(meta, name, bases, cls_dict)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> type.__new__(meta, name, bases, cls_dict)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta2</span><span class=\"params\">(Meta)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(meta, name, bases, cls_dict)</span>:</span></span><br><span class=\"line\">        print(meta, name, bases, cls_dict)</span><br><span class=\"line\">        cls_dict[<span class=\"string\">'hello'</span>] = <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> type.__new__(meta, name, bases, cls_dict)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta3</span><span class=\"params\">(Meta2)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(meta, name, bases, cls_dict)</span>:</span></span><br><span class=\"line\">        print(meta, name, bases, cls_dict)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> type.__new__(meta, name, bases, cls_dict)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta4</span><span class=\"params\">(Meta3)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(meta, name, bases, cls_dict)</span>:</span></span><br><span class=\"line\">        print(meta, name, bases, cls_dict)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> type.__new__(meta, name, bases, cls_dict)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C1'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C1</span><span class=\"params\">(metaclass=Meta)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C2'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C2</span><span class=\"params\">(C1)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C3'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C3</span><span class=\"params\">(C1, metaclass=Meta2)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C4'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C4</span><span class=\"params\">(C1, metaclass=Meta3)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C5'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C5</span><span class=\"params\">(C3, C4, C2)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C6'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C6</span><span class=\"params\">(C3, C4, C2, metaclass=Meta4)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>结果为:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C1</span><br><span class=\"line\">&lt;class '__main__.Meta'&gt; C1 () &#123;'__module__': '__main__', '__qualname__': 'C1'&#125;</span><br><span class=\"line\">C2</span><br><span class=\"line\">&lt;class '__main__.Meta'&gt; C2 (&lt;class '__main__.C1'&gt;,) &#123;'__module__': '__main__', '__qualname__': 'C2'&#125;</span><br><span class=\"line\">C3</span><br><span class=\"line\">&lt;class '__main__.Meta2'&gt; C3 (&lt;class '__main__.C1'&gt;,) &#123;'__module__': '__main__', '__qualname__': 'C3'&#125;</span><br><span class=\"line\">C4</span><br><span class=\"line\">&lt;class '__main__.Meta3'&gt; C4 (&lt;class '__main__.C1'&gt;,) &#123;'__module__': '__main__', '__qualname__': 'C4'&#125;</span><br><span class=\"line\">C5</span><br><span class=\"line\">&lt;class '__main__.Meta3'&gt; C5 (&lt;class '__main__.C3'&gt;, &lt;class '__main__.C4'&gt;, &lt;class '__main__.C2'&gt;) &#123;'__module__': '__main__', '__qualname__': 'C5'&#125;</span><br><span class=\"line\">C6</span><br><span class=\"line\">&lt;class '__main__.Meta4'&gt; C6 (&lt;class '__main__.C3'&gt;, &lt;class '__main__.C4'&gt;, &lt;class '__main__.C2'&gt;) &#123;'__module__': '__main__', '__qualname__': 'C6'&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意一点，为了输出内容的简洁，以上代码在方法<code>__new__</code>的最后都使用了<code>type.__new__</code>而不是<code>super().__new__</code>。改用<code>super().__new__</code>后执行仍相同，只是多了对父类的调用。</p>\n<p>说了这么多，我们应该给<code>__metaclass__</code>赋值什么呢?答案当然是，一个可以创建类的东西。<br>那么，什么才能创建一个类呢？</p>\n<h4 id=\"普通的元类\"><a href=\"#普通的元类\" class=\"headerlink\" title=\"普通的元类\"></a>普通的元类</h4><p>设计元类的一个很主要的原因就是为了在类被创建的时候进行自动修改，这经常用在API的设计上。<br>让我们举一个简单的例子，你决定让你的模块里所有类的属性都是大写形式。要完成这项工作有很多方法，其中一个便是在模块级别上定义<code>__metaclass__</code>。这样的话，该模块中所有的类都会通过该元类创建，我们只需要让这个元类完成将所有属性变成大写的工作。<br>幸运的是，<code>__metaclass__</code>可以是任何可调用(callable)对象，并不一定非要是一个正式的类。所以我们将从一个函数作为元类的例子说起:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Python 2.x</span></span><br><span class=\"line\"><span class=\"comment\"># the metaclass will automatically get passed the same argument</span></span><br><span class=\"line\"><span class=\"comment\"># that you usually pass to `type`</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">upper_attr</span><span class=\"params\">(future_class_name, future_class_parents, future_class_attr)</span>:</span></span><br><span class=\"line\">  <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    Return a class object, with the list of its attribute turned </span></span><br><span class=\"line\"><span class=\"string\">    into uppercase.</span></span><br><span class=\"line\"><span class=\"string\">  \"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># pick up any attribute that doesn't start with '__' and uppercase it</span></span><br><span class=\"line\">  uppercase_attr = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> name, val <span class=\"keyword\">in</span> future_class_attr.items():</span><br><span class=\"line\">      <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> name.startswith(<span class=\"string\">'__'</span>):</span><br><span class=\"line\">          uppercase_attr[name.upper()] = val</span><br><span class=\"line\">      <span class=\"keyword\">else</span>:</span><br><span class=\"line\">          uppercase_attr[name] = val</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># let `type` do the class creation</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> type(future_class_name, future_class_parents, uppercase_attr)</span><br><span class=\"line\"></span><br><span class=\"line\">__metaclass__ = upper_attr <span class=\"comment\"># this will affect all classes in the module</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span><span class=\"params\">()</span>:</span> <span class=\"comment\"># global __metaclass__ won't work with \"object\" though</span></span><br><span class=\"line\">  <span class=\"comment\"># but we can define __metaclass__ here instead to affect only this class</span></span><br><span class=\"line\">  <span class=\"comment\"># and this will work with \"object\" children</span></span><br><span class=\"line\">  bar = <span class=\"string\">'bip'</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(hasattr(Foo, <span class=\"string\">'bar'</span>))</span><br><span class=\"line\"><span class=\"comment\"># Out: False</span></span><br><span class=\"line\">print(hasattr(Foo, <span class=\"string\">'BAR'</span>))</span><br><span class=\"line\"><span class=\"comment\"># Out: True</span></span><br><span class=\"line\"></span><br><span class=\"line\">f = Foo()</span><br><span class=\"line\">print(f.BAR)</span><br><span class=\"line\"><span class=\"comment\"># Out: 'bip'</span></span><br></pre></td></tr></table></figure>\n<p>现在，让我们完成同样的工作，但这次我们将会使用一个真正的类作为元类:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Python 2.x</span></span><br><span class=\"line\"><span class=\"comment\"># remember that `type` is actually a class like `str` and `int`</span></span><br><span class=\"line\"><span class=\"comment\"># so you can inherit from it</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UpperAttrMetaclass</span><span class=\"params\">(type)</span>:</span> </span><br><span class=\"line\">    <span class=\"comment\"># __new__ is the method called before __init__</span></span><br><span class=\"line\">    <span class=\"comment\"># it's the method that creates the object and returns it</span></span><br><span class=\"line\">    <span class=\"comment\"># while __init__ just initializes the object passed as parameter</span></span><br><span class=\"line\">    <span class=\"comment\"># you rarely use __new__, except when you want to control how the object</span></span><br><span class=\"line\">    <span class=\"comment\"># is created.</span></span><br><span class=\"line\">    <span class=\"comment\"># here the created object is the class, and we want to customize it</span></span><br><span class=\"line\">    <span class=\"comment\"># so we override __new__</span></span><br><span class=\"line\">    <span class=\"comment\"># you can do some stuff in __init__ too if you wish</span></span><br><span class=\"line\">    <span class=\"comment\"># some advanced use involves overriding __call__ as well, but we won't</span></span><br><span class=\"line\">    <span class=\"comment\"># see this</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(upperattr_metaclass, future_class_name, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                future_class_parents, future_class_attr)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">        uppercase_attr = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> name, val <span class=\"keyword\">in</span> future_class_attr.items():</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> name.startswith(<span class=\"string\">'__'</span>):</span><br><span class=\"line\">                uppercase_attr[name.upper()] = val</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                uppercase_attr[name] = val</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> type(future_class_name, future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure>\n<p>但是上面这种方法并不是很符合OOP，因为我们直接调用了<code>type</code>而且我们没有重写或者调用父类的<code>__new__</code>，让我们改为下面这样:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Python 2.x</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UpperAttrMetaclass</span><span class=\"params\">(type)</span>:</span> </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(upperattr_metaclass, future_class_name, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                future_class_parents, future_class_attr)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">        uppercase_attr = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> name, val <span class=\"keyword\">in</span> future_class_attr.items():</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> name.startswith(<span class=\"string\">'__'</span>):</span><br><span class=\"line\">                uppercase_attr[name.upper()] = val</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                uppercase_attr[name] = val</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># reuse the type.__new__ method</span></span><br><span class=\"line\">        <span class=\"comment\"># this is basic OOP, nothing magic in there</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> type.__new__(upperattr_metaclass, future_class_name, </span><br><span class=\"line\">                            future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure>\n<p>你可能注意到了一个额外的参数<code>upperattr_metaclass</code>，它其实并不特别:<code>__new__</code>总是将定义它的类作为第一个参数，就和实例方法中使用<code>self</code>或类方法中使用<code>cls</code>作为方法的第一个参数一样。当然，此处参数所使用的名字只是为了方便明确参数意义，但就跟<code>self</code>一样，所有参数都可以简写，因此实际使用中的一个元类可能看起来像这样:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UpperAttrMetaclass</span><span class=\"params\">(type)</span>:</span> </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(cls, clsname, bases, dct)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">        uppercase_attr = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> name, val <span class=\"keyword\">in</span> dct.items():</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> name.startswith(<span class=\"string\">'__'</span>):</span><br><span class=\"line\">                uppercase_attr[name.upper()] = val</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                uppercase_attr[name] = val</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> type.__new__(cls, clsname, bases, uppercase_attr)</span><br></pre></td></tr></table></figure>\n<p>是的，元类在完成一些”黑魔法”或者复杂事务的时候很有用，但是对于它们自身来说，其实很简单:</p>\n<ol>\n<li>拦截一个类的创建</li>\n<li>修改这个类</li>\n<li>返回修改后的类</li>\n</ol>\n<h4 id=\"你为什么要使用类而不是函数来作为元类？\"><a href=\"#你为什么要使用类而不是函数来作为元类？\" class=\"headerlink\" title=\"你为什么要使用类而不是函数来作为元类？\"></a>你为什么要使用类而不是函数来作为元类？</h4><p>由于<code>__metaclass__</code>可以接受任意可调用对象，那为什么你要使用一个明显更复杂的类呢？</p>\n<p>有几个原因:</p>\n<ul>\n<li>意图明确。当你阅读到<code>UpperAttrMetaclass(type)</code>，你知道接下来会怎样</li>\n<li>你可以使用OOP。元类可以继承，重写父类方法，甚至可以使用元类</li>\n<li>你可以更好地组织里的代码。你不会在一些简单的工作中使用到元类，它通常是为了复杂工作准备的。编写多个方法并且将它们组织到一个类里将会对使代码清晰易读有巨大的帮助。</li>\n<li>你可以拦截<code>__new__</code>、<code>__init__</code>和<code>__call__</code>等方法。这将允许你完成不同的工作。即使通常情况下你可以在<code>__new__</code>完成所有工作，但仍有许多人更偏爱在<code>__init__</code>中完成。</li>\n<li>它们叫做metaclass，<code>class</code>!</li>\n</ul>\n<h4 id=\"为什么你要使用元类呢？\"><a href=\"#为什么你要使用元类呢？\" class=\"headerlink\" title=\"为什么你要使用元类呢？\"></a>为什么你要使用元类呢？</h4><p>现在到了最关键的问题，为什么你要使用一些既复杂又易错的功能呢？<br>实际上，通常情况下你不用:</p>\n<blockquote>\n<p>Metaclasses are deeper magic that 99% of users should never worry about. If you wonder whether you need them, you don’t (the people who actually need them know with certainty that they need them, and don’t need an explanation about why).      — Python Guru Tim Peters<br>译: 元类是较为高深的技术，99%的用户应该永远不用担心。如果你在犹豫你是否需要它们，那么你不需要(真正需要它们的人会清楚的知道需要它们，而且无须解释)</p>\n</blockquote>\n<p>元类主要的用途是创建一个API。一个典型的例子就是Django的ORM，它允许你这样定义:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span><span class=\"params\">(models.Model)</span>:</span></span><br><span class=\"line\">  name = models.CharField(max_length=<span class=\"number\">30</span>)</span><br><span class=\"line\">  age = models.IntegerField()</span><br></pre></td></tr></table></figure>\n<p>但是如果你这样做:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">guy = Person(name=<span class=\"string\">'bob'</span>, age=<span class=\"string\">'35'</span>)</span><br><span class=\"line\">print(guy.age)</span><br></pre></td></tr></table></figure>\n<p>它并不会返回一个<code>IntegerField</code>对象，而是返回一个<code>int</code>。这是因为<code>models.Model</code>定义了<code>__metaclass__</code>，而该元类将会完成一些工作使得你刚刚定义拥有一些简单语句的<code>Person</code>变成复杂的钩子(hook)与数据库字段相连。Django通过引入一个简单的API和使用元类来使一些复杂的事情看起来简单，根据该API重建代码完成实际工作都在幕后进行。</p>\n<h4 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h4><p>首先，你知道了类也是对象，而且可以生成实例。当然，类也是元类的实例。<br>Python中的万物都是对象，它们要么是类的实例，要么是元类的实例。<code>type</code>除外:</p>\n<div class=\"tip\"><br><code>type</code>是它自己的元类<br></div>\n\n<p>其次，元类十分复杂。对一个简单类的修改你可能并不会想使用它，而是使用另外两种不同的方式:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Monkey_patch\" target=\"_blank\" rel=\"noopener\">Monkey patching</a></li>\n<li>类装饰器</li>\n</ul>\n<p>在99%你需要修改类的情况下，你都最好使用以上两种方法。<br>但99%的时间里，你都不需要修改类。</p>\n","site":{"data":{}},"excerpt":"<p>本文根据对<a href=\"http://stackoverflow.com\" target=\"_blank\" rel=\"noopener\">StackOverflow</a>上问题<a href=\"http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python?answertab=votes#tab-top\" target=\"_blank\" rel=\"noopener\">What is a metaclass in Python?</a>的高票回答翻译结合实际例子，试图解释<strong>元类</strong>的意义与用途。</p>\n<h4 id=\"类也是对象\"><a href=\"#类也是对象\" class=\"headerlink\" title=\"类也是对象\"></a>类也是对象</h4><p>在想了解什么是<strong>元类</strong>之前，需要读者掌握Python中类的基本概念。而恰巧Python对类的定义有着不同于其他语言的解释。在大多数编程语言中，类仅仅只是指示如何生成实例对象的一段代码，这一点在Python中也如此:</p>","more":"<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObjectCreator</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>      <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">... </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>my_object = ObjectCreator()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(my_object)</span><br><span class=\"line\">&lt;__main__.ObjectCreator object at <span class=\"number\">0x8974f2c</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>但是，Python中的类还远不止如此:</p>\n<div class=\"tip\"><br>类也是实例对象<br></div>\n\n<p>当程序员使用了关键字<code>class</code>时，Python将会执行它并且创建一个对象:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObjectCreator</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>      <span class=\"keyword\">pass</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>上述代码将会在内存中创建一个名叫”ObjectCreator”的对象。</p>\n<div class=\"tip\"><br>这个对象(类)自身拥有创建对象(实例)的能力，因此被称作类<br></div>\n\n<p>即便如此，它仍然是一个对象，因此:</p>\n<ul>\n<li>你可以将它赋值给一个变量</li>\n<li>你可以复制它</li>\n<li>你可以为它添加属性</li>\n<li>你可以将它作为函数参数传递</li>\n</ul>\n<p>例如,<br>使用<code>print</code>打印:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(ObjectCreator) <span class=\"comment\"># you can print a class because it's an object</span></span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">__main__</span>.<span class=\"title\">ObjectCreator</span>'&gt;</span></span><br></pre></td></tr></table></figure>\n<p>作为函数参数传递:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">echo</span><span class=\"params\">(o)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>      print(o)</span><br><span class=\"line\"><span class=\"meta\">... </span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>echo(ObjectCreator) <span class=\"comment\"># you can pass a class as a parameter</span></span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">__main__</span>.<span class=\"title\">ObjectCreator</span>'&gt;</span></span><br></pre></td></tr></table></figure>\n<p>添加属性:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(hasattr(ObjectCreator, <span class=\"string\">'new_attribute'</span>))</span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>ObjectCreator.new_attribute = <span class=\"string\">'foo'</span> <span class=\"comment\"># you can add attributes to a class</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(hasattr(ObjectCreator, <span class=\"string\">'new_attribute'</span>))</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(ObjectCreator.new_attribute)</span><br><span class=\"line\">foo</span><br></pre></td></tr></table></figure>\n<p>赋值给另一个变量:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>ObjectCreatorMirror = ObjectCreator <span class=\"comment\"># you can assign a class to a variable</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(ObjectCreatorMirror.new_attribute)</span><br><span class=\"line\">foo</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(ObjectCreatorMirror())</span><br><span class=\"line\">&lt;__main__.ObjectCreator object at <span class=\"number\">0x8997b4c</span>&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"动态地创建类\"><a href=\"#动态地创建类\" class=\"headerlink\" title=\"动态地创建类\"></a>动态地创建类</h4><p>既然类也是对象，那么你可以向创建对象一样快速地创建它们。<br>首先，你可以通过使用关键字<code>class</code>在函数中创建一个类:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">choose_class</span><span class=\"params\">(name)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">if</span> name == <span class=\"string\">'foo'</span>:</span><br><span class=\"line\"><span class=\"meta\">... </span>        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>            <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">... </span>        <span class=\"keyword\">return</span> Foo <span class=\"comment\"># return the class, not an instance</span></span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">else</span>:</span><br><span class=\"line\"><span class=\"meta\">... </span>        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>            <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">... </span>        <span class=\"keyword\">return</span> Bar</span><br><span class=\"line\"><span class=\"meta\">... </span>    </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>MyClass = choose_class(<span class=\"string\">'foo'</span>) </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(MyClass, MyClass()) <span class=\"comment\"># the function returns a class, not an instance</span></span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">__main__</span>.<span class=\"title\">choose_class</span>.&lt;<span class=\"title\">locals</span>&gt;.<span class=\"title\">Foo</span>'&gt; &lt;<span class=\"title\">__main__</span>.<span class=\"title\">choose_class</span>.&lt;<span class=\"title\">locals</span>&gt;.<span class=\"title\">Foo</span> <span class=\"title\">object</span> <span class=\"title\">at</span> 0<span class=\"title\">x10a7d06a0</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>但它并不是很动态，因为你仍然需要亲自编写整个类。由于类是对象，那么它们必然是被某些东西生成的。当你使用关键字<code>class</code>时，Python自动地创建了其对象的对象。但就跟Python中大多数东西一样，Python给了你手动操作它的方法。<br>还记得函数<code>type</code>吗？这个函数能够让你知道一个对象的类型:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(type(<span class=\"number\">1</span>))</span><br><span class=\"line\">&lt;type <span class=\"string\">'int'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(type(<span class=\"string\">\"1\"</span>))</span><br><span class=\"line\">&lt;type <span class=\"string\">'str'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(type(ObjectCreator))</span><br><span class=\"line\">&lt;type <span class=\"string\">'type'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(type(ObjectCreator()))</span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">__main__</span>.<span class=\"title\">ObjectCreator</span>'&gt;</span></span><br></pre></td></tr></table></figure>\n<p>其实<code>type</code>还有一个完全不同的能力，它能够快速地创建类。<code>type</code>可以以参数的方式接收对一个类的描述，然后返回一个类。(可能有的人认为同一个函数根据传递不同的参数拥有两种完全不同的用途是一件很傻的事，但这是由于Python的向后兼容留下的问题)</p>\n<p>通过<code>type</code>创建类的参数描述如下:</p>\n<pre><code>type(name of the class, tuple of the parent class (for inheritance, can be empty), dictionary containing attributes names and values)\n</code></pre><p>例如:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyShinyClass</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>      <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>可以以如下方式手动创建:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>MyShinyClass = type(<span class=\"string\">'MyShinyClass'</span>, (), &#123;&#125;) <span class=\"comment\"># returns a class object</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(MyShinyClass, MyShinyClass())</span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">__main__</span>.<span class=\"title\">MyShinyClass</span>'&gt; &lt;<span class=\"title\">__main__</span>.<span class=\"title\">MyShinyClass</span> <span class=\"title\">object</span> <span class=\"title\">at</span> 0<span class=\"title\">x10a7a5518</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>你可能注意到了我们使用了”MyShinyClass”作为类的名字同时也作为变量名来保持对类的引用。它们可以不同，但是没有理由使其复杂化。<br><code>type</code>接收一个字典来定义类的属性，因此:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>      bar = <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>可以被翻译成:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Foo = type(<span class=\"string\">'Foo'</span>, (), &#123;<span class=\"string\">'bar'</span>: <span class=\"keyword\">True</span>&#125;)</span><br></pre></td></tr></table></figure>\n<p>这样定义的类也可以当做普通类使用:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(Foo)  <span class=\"comment\"># &lt;class '__main__.Foo'&gt;</span></span><br><span class=\"line\">print(Foo.bar)  <span class=\"comment\"># True</span></span><br><span class=\"line\">f = Foo()</span><br><span class=\"line\">print(f)  <span class=\"comment\"># &lt;__main__.Foo object at 0x8a9b84c&gt;</span></span><br><span class=\"line\">print(f.bar)  <span class=\"comment\"># True</span></span><br></pre></td></tr></table></figure>\n<p>当然，你也可以继承自它:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FooChild</span><span class=\"params\">(Foo)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>        <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>将会是:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>FooChild = type(<span class=\"string\">'FooChild'</span>, (Foo,), &#123;&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(FooChild, FooChild.bar)  <span class=\"comment\"># bar is inherited from Foo</span></span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">__main__</span>.<span class=\"title\">FooChild</span>'&gt; <span class=\"title\">True</span></span></span><br></pre></td></tr></table></figure>\n<p>最终你会想为你的类添加一些方法。只需要使用正确的语法定义一个函数然后作为一个属性赋值给类:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">echo_bar</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>      print(self.bar)</span><br><span class=\"line\"><span class=\"meta\">... </span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>FooChild = type(<span class=\"string\">'FooChild'</span>, (Foo,), &#123;<span class=\"string\">'echo_bar'</span>: echo_bar&#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(Foo, <span class=\"string\">'echo_bar'</span>)</span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(FooChild, <span class=\"string\">'echo_bar'</span>)</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>my_foo = FooChild()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>my_foo.echo_bar()</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>你甚至可以在动态生成了类之后添加更多的方法，就和向普通生成的类对象添加方法一样:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">echo_bar_more</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>      print(<span class=\"string\">'yet another method'</span>)</span><br><span class=\"line\"><span class=\"meta\">... </span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>FooChild.echo_bar_more = echo_bar_more</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>hasattr(FooChild, <span class=\"string\">'echo_bar_more'</span>)</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>如你所见:在Python中，类是对象，你可以快速动态地创建一个类。这便是当你使用关键字<code>class</code>时Python做的工作，它通过使用<strong>元类</strong>来完成这项工作。</p>\n<h4 id=\"什么是元类-终于\"><a href=\"#什么是元类-终于\" class=\"headerlink\" title=\"什么是元类(终于)\"></a>什么是元类(终于)</h4><p><strong>元类</strong>是创建类的那些”东西”。你为了创建对象而定义了类，但是我们知道Python中的类也是对象，因此，元类是用来创建对象的。它们是<strong>类的类</strong>，你可以形象化地理解:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyClass = MetaClass()</span><br><span class=\"line\">MyObject = MyClass()</span><br></pre></td></tr></table></figure>\n<p>你已经知道<code>type</code>可以这么用:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyClass = type(<span class=\"string\">'MyClass'</span>, (), &#123;&#125;)</span><br></pre></td></tr></table></figure>\n<p>这是因为函数<code>type</code>实际上是一个元类，而且是Python用来创建所有类的元类。</p>\n<div class=\"tip\"><br> 在Python中，所有东西都是对象<br></div>\n\n<p>其中包括但不限于整型、字符串、函数和类。它们都是对象，而且它们都是被类创建的:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>age = <span class=\"number\">35</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>age.__class__</span><br><span class=\"line\">&lt;type <span class=\"string\">'int'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name = <span class=\"string\">'bob'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name.__class__</span><br><span class=\"line\">&lt;type <span class=\"string\">'str'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">()</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>foo.__class__</span><br><span class=\"line\">&lt;type <span class=\"string\">'function'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span><span class=\"params\">(object)</span>:</span> <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = Bar()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b.__class__</span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">__main__</span>.<span class=\"title\">Bar</span>'&gt;</span></span><br></pre></td></tr></table></figure>\n<p>现在让我们看看<code>__class__</code>的<code>__class__</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>age.__class__.__class__</span><br><span class=\"line\">&lt;type <span class=\"string\">'type'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name.__class__.__class__</span><br><span class=\"line\">&lt;type <span class=\"string\">'type'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>foo.__class__.__class__</span><br><span class=\"line\">&lt;type <span class=\"string\">'type'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b.__class__.__class__</span><br><span class=\"line\">&lt;type <span class=\"string\">'type'</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>由此可见，一个元类正是用来创建所有类的。你也可以称它为”类工厂”。<code>type</code>是Python使用的内置的元类，当然，你也可以创建你自己的元类。</p>\n<h4 id=\"metaclass-属性\"><a href=\"#metaclass-属性\" class=\"headerlink\" title=\"__metaclass__属性\"></a><code>__metaclass__</code>属性</h4><p>你可以在编写一个类时为其指定<code>__metaclass__</code>属性:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    __metaclass__ = something...</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，上述语法仅适用于Python 2.x版本，在Python 3.x版本中，由新语法替代:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span><span class=\"params\">(object, metaclass=something)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>当你为类指定了元类以后，Python将会使用该元类来创建类<code>Foo</code>。<br>特别注意:</p>\n<div class=\"tip\"><br>类对象在Python调用<strong>metaclass</strong>来创建类之后才会存在。<br></div>\n\n<p><strong> Python 2.x中的<strong>metaclass</strong> </strong><br>对Python 2.x来说，即当首先写下了<code>class Foo(object)</code>，但是类对象<code>Foo</code>还并没有在内存中被创建。Python将会在类定义中查找<code>__metaclass__</code>，如果找到了，则用其来创建对象类<code>Foo</code>，如果没有找到，Python将会使用<code>type</code>来创建该类。</p>\n<p>当你这么写:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span><span class=\"params\">(Bar)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>Python将会这么做:</p>\n<ol>\n<li>类<code>Foo</code>有定义<code>__metaclass__</code>吗？如果有，则使用指定的<code>__metaclass__</code>来创建类对象<code>Foo</code>。</li>\n<li>如果没有找到这个属性，它将会在父类<code>Bar</code>中找</li>\n<li>这样一直向父类找，直到达到<code>module</code>级别才停止。</li>\n<li>如果在任何父类都找不到，那就用<code>type</code>创建类对象<code>Foo</code></li>\n</ol>\n<p>这里面有几点需要注意:</p>\n<ol>\n<li>为子类指定的<code>__metaclass__</code>需要是其所有父类<code>__metaclass__</code>的子类。</li>\n<li>在多继承的情况下，如果没有为该类指定<code>__metaclass__</code>，则该类将会由MRO中第一个父类的<code>__metaclass__</code>和所有父类<code>__metaclass__</code>中处于继承最底层的<code>__metaclass__</code>生成。</li>\n</ol>\n<p>Python 2.x中<code>__metaclass__</code>使用如以下代码所示:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Python 2.x</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta0</span><span class=\"params\">(type)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(meta, name, bases, cls_dict)</span>:</span></span><br><span class=\"line\">        cls = type.__new__(meta, name, bases, cls_dict)</span><br><span class=\"line\">        print(meta, name, bases, cls_dict)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls</span><br><span class=\"line\"></span><br><span class=\"line\">__metaclass__ = Meta0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span><span class=\"params\">(type)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(meta, name, bases, cls_dict)</span>:</span></span><br><span class=\"line\">        print(meta, name, bases, cls_dict)</span><br><span class=\"line\">        cls_dict[<span class=\"string\">'meta'</span>] = <span class=\"keyword\">True</span></span><br><span class=\"line\">        cls = type.__new__(meta, name, bases, cls_dict)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta2</span><span class=\"params\">(Meta)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(meta, name, bases, cls_dict)</span>:</span></span><br><span class=\"line\">        print(meta, name, bases, cls_dict)</span><br><span class=\"line\">        cls_dict[<span class=\"string\">'meta2'</span>] = <span class=\"keyword\">True</span></span><br><span class=\"line\">        cls = type.__new__(meta, name, bases, cls_dict)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta3</span><span class=\"params\">(Meta2)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(meta, name, bases, cls_dict)</span>:</span></span><br><span class=\"line\">        print(meta, name, bases, cls_dict)</span><br><span class=\"line\">        cls_dict[<span class=\"string\">'meta3'</span>] = <span class=\"keyword\">True</span></span><br><span class=\"line\">        cls = type.__new__(meta, name, bases, cls_dict)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C1'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C1</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C2'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C2</span>:</span></span><br><span class=\"line\">    __metaclass__ = Meta</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C3'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C3</span><span class=\"params\">(C2)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C4'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C4</span><span class=\"params\">(C2)</span>:</span></span><br><span class=\"line\">    __metaclass__ = Meta2</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C5'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C5</span><span class=\"params\">(C2)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C6'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C6</span><span class=\"params\">(C2)</span>:</span></span><br><span class=\"line\">    __metaclass__ = Meta3</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C7'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C7</span><span class=\"params\">(C4, C6, C5)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>结果为:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C1</span><br><span class=\"line\">(&lt;class '__main__.Meta0'&gt;, 'C1', (), &#123;'__module__': '__main__'&#125;)</span><br><span class=\"line\">C2</span><br><span class=\"line\">(&lt;class '__main__.Meta'&gt;, 'C2', (), &#123;'__module__': '__main__', '__metaclass__': &lt;class '__main__.Meta'&gt;&#125;)</span><br><span class=\"line\">C3</span><br><span class=\"line\">(&lt;class '__main__.Meta'&gt;, 'C3', (&lt;class '__main__.C2'&gt;,), &#123;'__module__': '__main__'&#125;)</span><br><span class=\"line\">C4</span><br><span class=\"line\">(&lt;class '__main__.Meta2'&gt;, 'C4', (&lt;class '__main__.C2'&gt;,), &#123;'__module__': '__main__', '__metaclass__': &lt;class '__main__.Meta2'&gt;&#125;)</span><br><span class=\"line\">C5</span><br><span class=\"line\">(&lt;class '__main__.Meta'&gt;, 'C5', (&lt;class '__main__.C2'&gt;,), &#123;'__module__': '__main__'&#125;)</span><br><span class=\"line\">C6</span><br><span class=\"line\">(&lt;class '__main__.Meta3'&gt;, 'C6', (&lt;class '__main__.C2'&gt;,), &#123;'__module__': '__main__', '__metaclass__': &lt;class '__main__.Meta3'&gt;&#125;)</span><br><span class=\"line\">C7</span><br><span class=\"line\">(&lt;class '__main__.Meta2'&gt;, 'C7', (&lt;class '__main__.C4'&gt;, &lt;class '__main__.C6'&gt;, &lt;class '__main__.C5'&gt;), &#123;'__module__': '__main__'&#125;)</span><br><span class=\"line\">(&lt;class '__main__.Meta3'&gt;, 'C7', (&lt;class '__main__.C4'&gt;, &lt;class '__main__.C6'&gt;, &lt;class '__main__.C5'&gt;), &#123;'__module__': '__main__', 'meta2': True&#125;)</span><br></pre></td></tr></table></figure>\n<p>注意到在类<code>C7</code>的生成过程中，分别调用了<code>Meta2</code>和<code>Meta3</code>，调用<code>Meta2</code>是由于在<code>C7</code>的继承中，类<code>C4</code>位于第一位，而<code>C4</code>的<code>__metaclass__</code>为<code>Meta2</code>，所以首先使用<code>Meta2</code>，而在<code>C4</code>、<code>C5</code>和<code>C6</code>的<code>__metaclass__</code>中，<code>Meta3</code>处于继承最底层，所以还会调用<code>Meta3</code>来生成类<code>C7</code>。(如果类<code>C6</code>位于最前面则只会调用<code>Meta3</code>)<br>这样的多继承以及多元类调用比较复杂，个人认为还是少用较好。</p>\n<p><strong> Python 3.x中的metaclass </strong><br>在Python3.x中，需要通过关键字参数<code>metaclass</code>给类指定元类。如:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C1</span><span class=\"params\">(metaclass=Meta)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>关于元类的寻找与Python 2.x类似:</p>\n<ol>\n<li>类<code>Foo</code>有定义关键字参数<code>metaclass</code>吗？如果有，则使用指定的<code>metaclass</code>来创建类对象<code>Foo</code>。</li>\n<li>如果没有找到这个属性，它将会在父类<code>Bar</code>中找</li>\n<li>如果在任何父类都找不到，那就用<code>type</code>创建类对象<code>Foo</code></li>\n</ol>\n<p>Python 3.x的metaclass使用注意仍然与Python 2.x类似:</p>\n<ol>\n<li>为子类指定的<code>metaclass</code>需要是其所有父类<code>metaclass</code>的子类。</li>\n<li>在多继承的情况下，如果没有为该类指定<code>metaclass</code>，则该类将会由所有父类<code>metaclass</code>中处于继承最底层的<code>metaclass</code>生成。如果有指定，则选择前述的<code>metaclass</code>和该<code>metaclass</code>中继承层次更低的那个来生成。</li>\n</ol>\n<p>Python 3.x中<code>metaclass</code>使用如以下代码所示:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Python 3.x</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span><span class=\"params\">(type)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(meta, name, bases, cls_dict)</span>:</span></span><br><span class=\"line\">        print(meta, name, bases, cls_dict)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> type.__new__(meta, name, bases, cls_dict)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta2</span><span class=\"params\">(Meta)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(meta, name, bases, cls_dict)</span>:</span></span><br><span class=\"line\">        print(meta, name, bases, cls_dict)</span><br><span class=\"line\">        cls_dict[<span class=\"string\">'hello'</span>] = <span class=\"keyword\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> type.__new__(meta, name, bases, cls_dict)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta3</span><span class=\"params\">(Meta2)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(meta, name, bases, cls_dict)</span>:</span></span><br><span class=\"line\">        print(meta, name, bases, cls_dict)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> type.__new__(meta, name, bases, cls_dict)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta4</span><span class=\"params\">(Meta3)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(meta, name, bases, cls_dict)</span>:</span></span><br><span class=\"line\">        print(meta, name, bases, cls_dict)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> type.__new__(meta, name, bases, cls_dict)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C1'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C1</span><span class=\"params\">(metaclass=Meta)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C2'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C2</span><span class=\"params\">(C1)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C3'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C3</span><span class=\"params\">(C1, metaclass=Meta2)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C4'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C4</span><span class=\"params\">(C1, metaclass=Meta3)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C5'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C5</span><span class=\"params\">(C3, C4, C2)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'C6'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C6</span><span class=\"params\">(C3, C4, C2, metaclass=Meta4)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>结果为:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C1</span><br><span class=\"line\">&lt;class '__main__.Meta'&gt; C1 () &#123;'__module__': '__main__', '__qualname__': 'C1'&#125;</span><br><span class=\"line\">C2</span><br><span class=\"line\">&lt;class '__main__.Meta'&gt; C2 (&lt;class '__main__.C1'&gt;,) &#123;'__module__': '__main__', '__qualname__': 'C2'&#125;</span><br><span class=\"line\">C3</span><br><span class=\"line\">&lt;class '__main__.Meta2'&gt; C3 (&lt;class '__main__.C1'&gt;,) &#123;'__module__': '__main__', '__qualname__': 'C3'&#125;</span><br><span class=\"line\">C4</span><br><span class=\"line\">&lt;class '__main__.Meta3'&gt; C4 (&lt;class '__main__.C1'&gt;,) &#123;'__module__': '__main__', '__qualname__': 'C4'&#125;</span><br><span class=\"line\">C5</span><br><span class=\"line\">&lt;class '__main__.Meta3'&gt; C5 (&lt;class '__main__.C3'&gt;, &lt;class '__main__.C4'&gt;, &lt;class '__main__.C2'&gt;) &#123;'__module__': '__main__', '__qualname__': 'C5'&#125;</span><br><span class=\"line\">C6</span><br><span class=\"line\">&lt;class '__main__.Meta4'&gt; C6 (&lt;class '__main__.C3'&gt;, &lt;class '__main__.C4'&gt;, &lt;class '__main__.C2'&gt;) &#123;'__module__': '__main__', '__qualname__': 'C6'&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意一点，为了输出内容的简洁，以上代码在方法<code>__new__</code>的最后都使用了<code>type.__new__</code>而不是<code>super().__new__</code>。改用<code>super().__new__</code>后执行仍相同，只是多了对父类的调用。</p>\n<p>说了这么多，我们应该给<code>__metaclass__</code>赋值什么呢?答案当然是，一个可以创建类的东西。<br>那么，什么才能创建一个类呢？</p>\n<h4 id=\"普通的元类\"><a href=\"#普通的元类\" class=\"headerlink\" title=\"普通的元类\"></a>普通的元类</h4><p>设计元类的一个很主要的原因就是为了在类被创建的时候进行自动修改，这经常用在API的设计上。<br>让我们举一个简单的例子，你决定让你的模块里所有类的属性都是大写形式。要完成这项工作有很多方法，其中一个便是在模块级别上定义<code>__metaclass__</code>。这样的话，该模块中所有的类都会通过该元类创建，我们只需要让这个元类完成将所有属性变成大写的工作。<br>幸运的是，<code>__metaclass__</code>可以是任何可调用(callable)对象，并不一定非要是一个正式的类。所以我们将从一个函数作为元类的例子说起:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Python 2.x</span></span><br><span class=\"line\"><span class=\"comment\"># the metaclass will automatically get passed the same argument</span></span><br><span class=\"line\"><span class=\"comment\"># that you usually pass to `type`</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">upper_attr</span><span class=\"params\">(future_class_name, future_class_parents, future_class_attr)</span>:</span></span><br><span class=\"line\">  <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    Return a class object, with the list of its attribute turned </span></span><br><span class=\"line\"><span class=\"string\">    into uppercase.</span></span><br><span class=\"line\"><span class=\"string\">  \"\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># pick up any attribute that doesn't start with '__' and uppercase it</span></span><br><span class=\"line\">  uppercase_attr = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> name, val <span class=\"keyword\">in</span> future_class_attr.items():</span><br><span class=\"line\">      <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> name.startswith(<span class=\"string\">'__'</span>):</span><br><span class=\"line\">          uppercase_attr[name.upper()] = val</span><br><span class=\"line\">      <span class=\"keyword\">else</span>:</span><br><span class=\"line\">          uppercase_attr[name] = val</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># let `type` do the class creation</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> type(future_class_name, future_class_parents, uppercase_attr)</span><br><span class=\"line\"></span><br><span class=\"line\">__metaclass__ = upper_attr <span class=\"comment\"># this will affect all classes in the module</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span><span class=\"params\">()</span>:</span> <span class=\"comment\"># global __metaclass__ won't work with \"object\" though</span></span><br><span class=\"line\">  <span class=\"comment\"># but we can define __metaclass__ here instead to affect only this class</span></span><br><span class=\"line\">  <span class=\"comment\"># and this will work with \"object\" children</span></span><br><span class=\"line\">  bar = <span class=\"string\">'bip'</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(hasattr(Foo, <span class=\"string\">'bar'</span>))</span><br><span class=\"line\"><span class=\"comment\"># Out: False</span></span><br><span class=\"line\">print(hasattr(Foo, <span class=\"string\">'BAR'</span>))</span><br><span class=\"line\"><span class=\"comment\"># Out: True</span></span><br><span class=\"line\"></span><br><span class=\"line\">f = Foo()</span><br><span class=\"line\">print(f.BAR)</span><br><span class=\"line\"><span class=\"comment\"># Out: 'bip'</span></span><br></pre></td></tr></table></figure>\n<p>现在，让我们完成同样的工作，但这次我们将会使用一个真正的类作为元类:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Python 2.x</span></span><br><span class=\"line\"><span class=\"comment\"># remember that `type` is actually a class like `str` and `int`</span></span><br><span class=\"line\"><span class=\"comment\"># so you can inherit from it</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UpperAttrMetaclass</span><span class=\"params\">(type)</span>:</span> </span><br><span class=\"line\">    <span class=\"comment\"># __new__ is the method called before __init__</span></span><br><span class=\"line\">    <span class=\"comment\"># it's the method that creates the object and returns it</span></span><br><span class=\"line\">    <span class=\"comment\"># while __init__ just initializes the object passed as parameter</span></span><br><span class=\"line\">    <span class=\"comment\"># you rarely use __new__, except when you want to control how the object</span></span><br><span class=\"line\">    <span class=\"comment\"># is created.</span></span><br><span class=\"line\">    <span class=\"comment\"># here the created object is the class, and we want to customize it</span></span><br><span class=\"line\">    <span class=\"comment\"># so we override __new__</span></span><br><span class=\"line\">    <span class=\"comment\"># you can do some stuff in __init__ too if you wish</span></span><br><span class=\"line\">    <span class=\"comment\"># some advanced use involves overriding __call__ as well, but we won't</span></span><br><span class=\"line\">    <span class=\"comment\"># see this</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(upperattr_metaclass, future_class_name, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                future_class_parents, future_class_attr)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">        uppercase_attr = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> name, val <span class=\"keyword\">in</span> future_class_attr.items():</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> name.startswith(<span class=\"string\">'__'</span>):</span><br><span class=\"line\">                uppercase_attr[name.upper()] = val</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                uppercase_attr[name] = val</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> type(future_class_name, future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure>\n<p>但是上面这种方法并不是很符合OOP，因为我们直接调用了<code>type</code>而且我们没有重写或者调用父类的<code>__new__</code>，让我们改为下面这样:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Python 2.x</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UpperAttrMetaclass</span><span class=\"params\">(type)</span>:</span> </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(upperattr_metaclass, future_class_name, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                future_class_parents, future_class_attr)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">        uppercase_attr = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> name, val <span class=\"keyword\">in</span> future_class_attr.items():</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> name.startswith(<span class=\"string\">'__'</span>):</span><br><span class=\"line\">                uppercase_attr[name.upper()] = val</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                uppercase_attr[name] = val</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># reuse the type.__new__ method</span></span><br><span class=\"line\">        <span class=\"comment\"># this is basic OOP, nothing magic in there</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> type.__new__(upperattr_metaclass, future_class_name, </span><br><span class=\"line\">                            future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure>\n<p>你可能注意到了一个额外的参数<code>upperattr_metaclass</code>，它其实并不特别:<code>__new__</code>总是将定义它的类作为第一个参数，就和实例方法中使用<code>self</code>或类方法中使用<code>cls</code>作为方法的第一个参数一样。当然，此处参数所使用的名字只是为了方便明确参数意义，但就跟<code>self</code>一样，所有参数都可以简写，因此实际使用中的一个元类可能看起来像这样:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UpperAttrMetaclass</span><span class=\"params\">(type)</span>:</span> </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(cls, clsname, bases, dct)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">        uppercase_attr = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> name, val <span class=\"keyword\">in</span> dct.items():</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> name.startswith(<span class=\"string\">'__'</span>):</span><br><span class=\"line\">                uppercase_attr[name.upper()] = val</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                uppercase_attr[name] = val</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> type.__new__(cls, clsname, bases, uppercase_attr)</span><br></pre></td></tr></table></figure>\n<p>是的，元类在完成一些”黑魔法”或者复杂事务的时候很有用，但是对于它们自身来说，其实很简单:</p>\n<ol>\n<li>拦截一个类的创建</li>\n<li>修改这个类</li>\n<li>返回修改后的类</li>\n</ol>\n<h4 id=\"你为什么要使用类而不是函数来作为元类？\"><a href=\"#你为什么要使用类而不是函数来作为元类？\" class=\"headerlink\" title=\"你为什么要使用类而不是函数来作为元类？\"></a>你为什么要使用类而不是函数来作为元类？</h4><p>由于<code>__metaclass__</code>可以接受任意可调用对象，那为什么你要使用一个明显更复杂的类呢？</p>\n<p>有几个原因:</p>\n<ul>\n<li>意图明确。当你阅读到<code>UpperAttrMetaclass(type)</code>，你知道接下来会怎样</li>\n<li>你可以使用OOP。元类可以继承，重写父类方法，甚至可以使用元类</li>\n<li>你可以更好地组织里的代码。你不会在一些简单的工作中使用到元类，它通常是为了复杂工作准备的。编写多个方法并且将它们组织到一个类里将会对使代码清晰易读有巨大的帮助。</li>\n<li>你可以拦截<code>__new__</code>、<code>__init__</code>和<code>__call__</code>等方法。这将允许你完成不同的工作。即使通常情况下你可以在<code>__new__</code>完成所有工作，但仍有许多人更偏爱在<code>__init__</code>中完成。</li>\n<li>它们叫做metaclass，<code>class</code>!</li>\n</ul>\n<h4 id=\"为什么你要使用元类呢？\"><a href=\"#为什么你要使用元类呢？\" class=\"headerlink\" title=\"为什么你要使用元类呢？\"></a>为什么你要使用元类呢？</h4><p>现在到了最关键的问题，为什么你要使用一些既复杂又易错的功能呢？<br>实际上，通常情况下你不用:</p>\n<blockquote>\n<p>Metaclasses are deeper magic that 99% of users should never worry about. If you wonder whether you need them, you don’t (the people who actually need them know with certainty that they need them, and don’t need an explanation about why).      — Python Guru Tim Peters<br>译: 元类是较为高深的技术，99%的用户应该永远不用担心。如果你在犹豫你是否需要它们，那么你不需要(真正需要它们的人会清楚的知道需要它们，而且无须解释)</p>\n</blockquote>\n<p>元类主要的用途是创建一个API。一个典型的例子就是Django的ORM，它允许你这样定义:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span><span class=\"params\">(models.Model)</span>:</span></span><br><span class=\"line\">  name = models.CharField(max_length=<span class=\"number\">30</span>)</span><br><span class=\"line\">  age = models.IntegerField()</span><br></pre></td></tr></table></figure>\n<p>但是如果你这样做:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">guy = Person(name=<span class=\"string\">'bob'</span>, age=<span class=\"string\">'35'</span>)</span><br><span class=\"line\">print(guy.age)</span><br></pre></td></tr></table></figure>\n<p>它并不会返回一个<code>IntegerField</code>对象，而是返回一个<code>int</code>。这是因为<code>models.Model</code>定义了<code>__metaclass__</code>，而该元类将会完成一些工作使得你刚刚定义拥有一些简单语句的<code>Person</code>变成复杂的钩子(hook)与数据库字段相连。Django通过引入一个简单的API和使用元类来使一些复杂的事情看起来简单，根据该API重建代码完成实际工作都在幕后进行。</p>\n<h4 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h4><p>首先，你知道了类也是对象，而且可以生成实例。当然，类也是元类的实例。<br>Python中的万物都是对象，它们要么是类的实例，要么是元类的实例。<code>type</code>除外:</p>\n<div class=\"tip\"><br><code>type</code>是它自己的元类<br></div>\n\n<p>其次，元类十分复杂。对一个简单类的修改你可能并不会想使用它，而是使用另外两种不同的方式:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Monkey_patch\" target=\"_blank\" rel=\"noopener\">Monkey patching</a></li>\n<li>类装饰器</li>\n</ul>\n<p>在99%你需要修改类的情况下，你都最好使用以上两种方法。<br>但99%的时间里，你都不需要修改类。</p>"},{"title":"Python属性访问","date":"2017-02-04T08:26:07.000Z","from":"https://docs.python.org/2/howto/descriptor.html","_content":"在上一篇中讲到了描述器方法`__get__`、`__set__`和`__delete__`，同时也提到，一个对象具有任意一个方法的就会成为描述器，从而在被当作对象属性的时候会重写默认的查找行为。在本篇中，通过对[Descriptor HowTo Guide](https://docs.python.org/2/howto/descriptor.html)的节选翻译以及笔者的自身的一些实践，对描述器做一个更详细的说明。\n\n如果一个对象同时定义了`__get__`和`__set__`方法，则称它为资料描述器(*data descriptor*)，而仅定义了`__get__`方法的描述器称为非资料描述器(*non-data descriptor*，常用于方法，其他用途也是可以的)。\n\n资料描述器和非资料描述器的区别在于：**相对于实例的字典的优先级**。如果实例字典中有和描述器重名的属性，如果描述器是资料描述器，优先使用资料描述器，如果是非资料描述器，优先使用字典中的属性。这就是为何实例a的方法和属性重名时，比如都叫做`foo`，Python会在访问`a.foo`时优先访问实例字典中的属性，因为实例的方法是个非资料描述器。\n<!-- more -->\n要想制作一个只读的资料描述器需要同时定义`__set__`和`__get__`方法，由于是只读，所以只需要在`__set__`方法中抛出一个`AttributeError`异常即可。\n\n在一般情况下，描述器在属性访问时被自动调用。举例来说，`obj.d`会在`obj`的字典里面查找`d`，如果`d`定义了`__get__`方法，那么`d.__get__(obj)`会依据下面的优先规则被调用。\n\n调用的细节取决于`obj`是一个类还是一个实例，对于对象来讲，方法`object.__getattribute__`将属性访问`a.x`变成了`type(a).__dict__['x'].__get__(a, type(a))`，具体实现依据这样的优先顺序:**资料描述器**优先于**实例变量**，**实例变量**优先于**非资料描述器**，`__getattr__()`方法具有最低优先级；对于类来讲，方法`type.__getattribute__`将`A.x`变成`A.__dict__['x'].__get__(None, A)`。如以下代码:\n```Python\nclass V:\n    v = 0\n    \n    def __init__(self, val=0):\n        self.v = val\n    \n    def __get__(self, inst, owner):\n        return self.v\n        \n    def __set__(self, inst, value):\n        self.v = value\n        \n        \nclass A:\n    k1 = V(1)\n    def k(self):  # non-data descriptor\n        pass\n\na = A()\nprint(a.k)  # <bound method...> *op1*\na.k = 6  # replace non-data descriptor with instance dict  *op2*\nprint(a.k)  # 6  *op3*\n\nprint(a.k1)  # 1\na.__dict__['k1'] = V(2)  # *op4*\nprint(a.k1)  # 1\n```\n这段代码展示了资料描述器、实例变量、非资料描述器在属性访问中的不同优先级，分析如下:类`A`中定义了方法`k`(非资料描述器)，第一次操作对`a.k`的访问将转变为`type(a).__dict__['k'].__get__(a, type(a))`，`type(a)`即类`A`，`A.__dict__`中存储了方法`A.k`，由于方法`A.k`为非资料描述器，因此调用其定义的`__get__()`方法。第二次操作`a.k = 6`本质上是在字典`a.__dict__`中添加了`k`这一变量(注意`a.__dict__`和`A._dict__`的区别)，即新增了实例变量。第三次操作对`a.k`的访问由于**实例变量**优先级高于**非资料描述器**，因此将获得之前的赋值6而不是方法。在第四次操作前后分别访问了`a.k1`属性，由于`k1`是资料描述器，因此即使在`a.__dict__`中新增了实例变量`k1`，对`a.k1`仍然是访问了资料描述器而不是实例变量，与前述的优先级保持一致。\n\n`__getattr__`与`__getattribute__`区别:前者只会在待访问的属性缺失时触发，而后者则会在每次访问属性时触发。\n\n**特别注意:**如果要在`__getattribute__`和`__setattr__`方法中访问实例属性，那么应该直接通过`super()`来做，以避免无限递归。如以下代码就会抛出异常:\n```Python\nclass BrokenAttribute:\n    def __init__(self, data):\n        self._data = data\n    \n    def __getattribute__(self, name):\n        print('Called __getattribute__({0})'.format(name))\n        return self._data[name]\n\n\ndata = BrokenAttribute({'foo': 3})\nprint(data.foo)\n>>>\nRecursionError: maximum recursion depth exceeded while calling a Python object\n```\n\n#### 属性Property\n\n调用`property()`是建立资料描述器的一种简洁方式，从而可以在访问属性时触发相应的方法调用。`property`函数原型:\n```\nproperty(fget=None, fset=None, fdel=None, doc=None) -> property attribute\n```\n\n下面展示了一个典型应用，定义一个托管属性(managed attribute)x:\n\n```Python\nclass C(object):\n    def getx(self): return self.__x\n    def setx(self, value): self.__x = value\n    def delx(self): del self.__x\n    x = property(getx, setx, delx, \"I'm the 'x' property.\")\n```\n\n其等价Python实现为:\n\n```Python\nclass Property(object):\n    \"Emulate PyProperty_Type() in Objects/descrobject.c\"\n\n    def __init__(self, fget=None, fset=None, fdel=None, doc=None):\n        self.fget = fget\n        self.fset = fset\n        self.fdel = fdel\n        self.__doc__ = doc\n\n    def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        if self.fget is None:\n            raise AttributeError, \"unreadable attribute\"\n        return self.fget(obj)\n\n    def __set__(self, obj, value):\n        if self.fset is None:\n            raise AttributeError, \"can't set attribute\"\n        self.fset(obj, value)\n\n    def __delete__(self, obj):\n        if self.fdel is None:\n            raise AttributeError, \"can't delete attribute\"\n        self.fdel(obj)\n```\n\n#### 静态方法与类方法\n\n非资料描述器为将函数绑定成方法这种常见模式提供了一个简单的实现机制。\n简而言之，函数有个方法`__get__()`，当函数被当作属性访问时，它会把函数变成一个实例方法。非资料描述器把实例调用`obj.f(*args)`转换成`f(obj, *args)`(绑定方法)，把类调用`klass.f(*args)`转换成`f(klass, *args)`(非绑定方法)。\n静态方法原样返回函数，调用 c.f 或者 C.f 分别等价于`object.__getattribute__(c, \"f\")`或者`object.__getattribute__(C, \"f\")`。也就是说，无论是从一个对象还是一个类中，这个函数都会同样地访问到。\n利用非资料描述器，`staticmethod()`的等价实现看起来像这样:\n\n```Python\nclass staticmethod(object):\n \"Emulate PyStaticMethod_Type() in Objects/funcobject.c\"\n\n def __init__(self, f):\n      self.f = f\n\n def __get__(self, obj, objtype=None):\n      return self.f\n```\n\n同样的，`classmethod()`等价实现看起来像这样:\n\n```Python\nclass ClassMethod(object):\n     \"Emulate PyClassMethod_Type() in Objects/funcobject.c\"\n\n     def __init__(self, f):\n          self.f = f\n\n     def __get__(self, obj, klass=None):\n          if klass is None:\n               klass = type(obj)\n          def newfunc(*args):\n               return self.f(klass, *args)\n          return newfunc\n```\n\n\n\n\n","source":"_posts/Python-property access.md","raw":"---\ntitle: Python属性访问\ndate: 2017-02-04 16:26:07\ntags: [Python,描述器,属性]\ncategories: Python\nfrom: https://docs.python.org/2/howto/descriptor.html\n---\n在上一篇中讲到了描述器方法`__get__`、`__set__`和`__delete__`，同时也提到，一个对象具有任意一个方法的就会成为描述器，从而在被当作对象属性的时候会重写默认的查找行为。在本篇中，通过对[Descriptor HowTo Guide](https://docs.python.org/2/howto/descriptor.html)的节选翻译以及笔者的自身的一些实践，对描述器做一个更详细的说明。\n\n如果一个对象同时定义了`__get__`和`__set__`方法，则称它为资料描述器(*data descriptor*)，而仅定义了`__get__`方法的描述器称为非资料描述器(*non-data descriptor*，常用于方法，其他用途也是可以的)。\n\n资料描述器和非资料描述器的区别在于：**相对于实例的字典的优先级**。如果实例字典中有和描述器重名的属性，如果描述器是资料描述器，优先使用资料描述器，如果是非资料描述器，优先使用字典中的属性。这就是为何实例a的方法和属性重名时，比如都叫做`foo`，Python会在访问`a.foo`时优先访问实例字典中的属性，因为实例的方法是个非资料描述器。\n<!-- more -->\n要想制作一个只读的资料描述器需要同时定义`__set__`和`__get__`方法，由于是只读，所以只需要在`__set__`方法中抛出一个`AttributeError`异常即可。\n\n在一般情况下，描述器在属性访问时被自动调用。举例来说，`obj.d`会在`obj`的字典里面查找`d`，如果`d`定义了`__get__`方法，那么`d.__get__(obj)`会依据下面的优先规则被调用。\n\n调用的细节取决于`obj`是一个类还是一个实例，对于对象来讲，方法`object.__getattribute__`将属性访问`a.x`变成了`type(a).__dict__['x'].__get__(a, type(a))`，具体实现依据这样的优先顺序:**资料描述器**优先于**实例变量**，**实例变量**优先于**非资料描述器**，`__getattr__()`方法具有最低优先级；对于类来讲，方法`type.__getattribute__`将`A.x`变成`A.__dict__['x'].__get__(None, A)`。如以下代码:\n```Python\nclass V:\n    v = 0\n    \n    def __init__(self, val=0):\n        self.v = val\n    \n    def __get__(self, inst, owner):\n        return self.v\n        \n    def __set__(self, inst, value):\n        self.v = value\n        \n        \nclass A:\n    k1 = V(1)\n    def k(self):  # non-data descriptor\n        pass\n\na = A()\nprint(a.k)  # <bound method...> *op1*\na.k = 6  # replace non-data descriptor with instance dict  *op2*\nprint(a.k)  # 6  *op3*\n\nprint(a.k1)  # 1\na.__dict__['k1'] = V(2)  # *op4*\nprint(a.k1)  # 1\n```\n这段代码展示了资料描述器、实例变量、非资料描述器在属性访问中的不同优先级，分析如下:类`A`中定义了方法`k`(非资料描述器)，第一次操作对`a.k`的访问将转变为`type(a).__dict__['k'].__get__(a, type(a))`，`type(a)`即类`A`，`A.__dict__`中存储了方法`A.k`，由于方法`A.k`为非资料描述器，因此调用其定义的`__get__()`方法。第二次操作`a.k = 6`本质上是在字典`a.__dict__`中添加了`k`这一变量(注意`a.__dict__`和`A._dict__`的区别)，即新增了实例变量。第三次操作对`a.k`的访问由于**实例变量**优先级高于**非资料描述器**，因此将获得之前的赋值6而不是方法。在第四次操作前后分别访问了`a.k1`属性，由于`k1`是资料描述器，因此即使在`a.__dict__`中新增了实例变量`k1`，对`a.k1`仍然是访问了资料描述器而不是实例变量，与前述的优先级保持一致。\n\n`__getattr__`与`__getattribute__`区别:前者只会在待访问的属性缺失时触发，而后者则会在每次访问属性时触发。\n\n**特别注意:**如果要在`__getattribute__`和`__setattr__`方法中访问实例属性，那么应该直接通过`super()`来做，以避免无限递归。如以下代码就会抛出异常:\n```Python\nclass BrokenAttribute:\n    def __init__(self, data):\n        self._data = data\n    \n    def __getattribute__(self, name):\n        print('Called __getattribute__({0})'.format(name))\n        return self._data[name]\n\n\ndata = BrokenAttribute({'foo': 3})\nprint(data.foo)\n>>>\nRecursionError: maximum recursion depth exceeded while calling a Python object\n```\n\n#### 属性Property\n\n调用`property()`是建立资料描述器的一种简洁方式，从而可以在访问属性时触发相应的方法调用。`property`函数原型:\n```\nproperty(fget=None, fset=None, fdel=None, doc=None) -> property attribute\n```\n\n下面展示了一个典型应用，定义一个托管属性(managed attribute)x:\n\n```Python\nclass C(object):\n    def getx(self): return self.__x\n    def setx(self, value): self.__x = value\n    def delx(self): del self.__x\n    x = property(getx, setx, delx, \"I'm the 'x' property.\")\n```\n\n其等价Python实现为:\n\n```Python\nclass Property(object):\n    \"Emulate PyProperty_Type() in Objects/descrobject.c\"\n\n    def __init__(self, fget=None, fset=None, fdel=None, doc=None):\n        self.fget = fget\n        self.fset = fset\n        self.fdel = fdel\n        self.__doc__ = doc\n\n    def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        if self.fget is None:\n            raise AttributeError, \"unreadable attribute\"\n        return self.fget(obj)\n\n    def __set__(self, obj, value):\n        if self.fset is None:\n            raise AttributeError, \"can't set attribute\"\n        self.fset(obj, value)\n\n    def __delete__(self, obj):\n        if self.fdel is None:\n            raise AttributeError, \"can't delete attribute\"\n        self.fdel(obj)\n```\n\n#### 静态方法与类方法\n\n非资料描述器为将函数绑定成方法这种常见模式提供了一个简单的实现机制。\n简而言之，函数有个方法`__get__()`，当函数被当作属性访问时，它会把函数变成一个实例方法。非资料描述器把实例调用`obj.f(*args)`转换成`f(obj, *args)`(绑定方法)，把类调用`klass.f(*args)`转换成`f(klass, *args)`(非绑定方法)。\n静态方法原样返回函数，调用 c.f 或者 C.f 分别等价于`object.__getattribute__(c, \"f\")`或者`object.__getattribute__(C, \"f\")`。也就是说，无论是从一个对象还是一个类中，这个函数都会同样地访问到。\n利用非资料描述器，`staticmethod()`的等价实现看起来像这样:\n\n```Python\nclass staticmethod(object):\n \"Emulate PyStaticMethod_Type() in Objects/funcobject.c\"\n\n def __init__(self, f):\n      self.f = f\n\n def __get__(self, obj, objtype=None):\n      return self.f\n```\n\n同样的，`classmethod()`等价实现看起来像这样:\n\n```Python\nclass ClassMethod(object):\n     \"Emulate PyClassMethod_Type() in Objects/funcobject.c\"\n\n     def __init__(self, f):\n          self.f = f\n\n     def __get__(self, obj, klass=None):\n          if klass is None:\n               klass = type(obj)\n          def newfunc(*args):\n               return self.f(klass, *args)\n          return newfunc\n```\n\n\n\n\n","slug":"Python-property access","published":1,"updated":"2018-01-13T00:50:39.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgvnqmlc001aw628r8tv2z1z","content":"<p>在上一篇中讲到了描述器方法<code>__get__</code>、<code>__set__</code>和<code>__delete__</code>，同时也提到，一个对象具有任意一个方法的就会成为描述器，从而在被当作对象属性的时候会重写默认的查找行为。在本篇中，通过对<a href=\"https://docs.python.org/2/howto/descriptor.html\" target=\"_blank\" rel=\"noopener\">Descriptor HowTo Guide</a>的节选翻译以及笔者的自身的一些实践，对描述器做一个更详细的说明。</p>\n<p>如果一个对象同时定义了<code>__get__</code>和<code>__set__</code>方法，则称它为资料描述器(<em>data descriptor</em>)，而仅定义了<code>__get__</code>方法的描述器称为非资料描述器(<em>non-data descriptor</em>，常用于方法，其他用途也是可以的)。</p>\n<p>资料描述器和非资料描述器的区别在于：<strong>相对于实例的字典的优先级</strong>。如果实例字典中有和描述器重名的属性，如果描述器是资料描述器，优先使用资料描述器，如果是非资料描述器，优先使用字典中的属性。这就是为何实例a的方法和属性重名时，比如都叫做<code>foo</code>，Python会在访问<code>a.foo</code>时优先访问实例字典中的属性，因为实例的方法是个非资料描述器。<br><a id=\"more\"></a><br>要想制作一个只读的资料描述器需要同时定义<code>__set__</code>和<code>__get__</code>方法，由于是只读，所以只需要在<code>__set__</code>方法中抛出一个<code>AttributeError</code>异常即可。</p>\n<p>在一般情况下，描述器在属性访问时被自动调用。举例来说，<code>obj.d</code>会在<code>obj</code>的字典里面查找<code>d</code>，如果<code>d</code>定义了<code>__get__</code>方法，那么<code>d.__get__(obj)</code>会依据下面的优先规则被调用。</p>\n<p>调用的细节取决于<code>obj</code>是一个类还是一个实例，对于对象来讲，方法<code>object.__getattribute__</code>将属性访问<code>a.x</code>变成了<code>type(a).__dict__[&#39;x&#39;].__get__(a, type(a))</code>，具体实现依据这样的优先顺序:<strong>资料描述器</strong>优先于<strong>实例变量</strong>，<strong>实例变量</strong>优先于<strong>非资料描述器</strong>，<code>__getattr__()</code>方法具有最低优先级；对于类来讲，方法<code>type.__getattribute__</code>将<code>A.x</code>变成<code>A.__dict__[&#39;x&#39;].__get__(None, A)</code>。如以下代码:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">V</span>:</span></span><br><span class=\"line\">    v = <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, val=<span class=\"number\">0</span>)</span>:</span></span><br><span class=\"line\">        self.v = val</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__get__</span><span class=\"params\">(self, inst, owner)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.v</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__set__</span><span class=\"params\">(self, inst, value)</span>:</span></span><br><span class=\"line\">        self.v = value</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span></span><br><span class=\"line\">    k1 = V(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">k</span><span class=\"params\">(self)</span>:</span>  <span class=\"comment\"># non-data descriptor</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = A()</span><br><span class=\"line\">print(a.k)  <span class=\"comment\"># &lt;bound method...&gt; *op1*</span></span><br><span class=\"line\">a.k = <span class=\"number\">6</span>  <span class=\"comment\"># replace non-data descriptor with instance dict  *op2*</span></span><br><span class=\"line\">print(a.k)  <span class=\"comment\"># 6  *op3*</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(a.k1)  <span class=\"comment\"># 1</span></span><br><span class=\"line\">a.__dict__[<span class=\"string\">'k1'</span>] = V(<span class=\"number\">2</span>)  <span class=\"comment\"># *op4*</span></span><br><span class=\"line\">print(a.k1)  <span class=\"comment\"># 1</span></span><br></pre></td></tr></table></figure></p>\n<p>这段代码展示了资料描述器、实例变量、非资料描述器在属性访问中的不同优先级，分析如下:类<code>A</code>中定义了方法<code>k</code>(非资料描述器)，第一次操作对<code>a.k</code>的访问将转变为<code>type(a).__dict__[&#39;k&#39;].__get__(a, type(a))</code>，<code>type(a)</code>即类<code>A</code>，<code>A.__dict__</code>中存储了方法<code>A.k</code>，由于方法<code>A.k</code>为非资料描述器，因此调用其定义的<code>__get__()</code>方法。第二次操作<code>a.k = 6</code>本质上是在字典<code>a.__dict__</code>中添加了<code>k</code>这一变量(注意<code>a.__dict__</code>和<code>A._dict__</code>的区别)，即新增了实例变量。第三次操作对<code>a.k</code>的访问由于<strong>实例变量</strong>优先级高于<strong>非资料描述器</strong>，因此将获得之前的赋值6而不是方法。在第四次操作前后分别访问了<code>a.k1</code>属性，由于<code>k1</code>是资料描述器，因此即使在<code>a.__dict__</code>中新增了实例变量<code>k1</code>，对<code>a.k1</code>仍然是访问了资料描述器而不是实例变量，与前述的优先级保持一致。</p>\n<p><code>__getattr__</code>与<code>__getattribute__</code>区别:前者只会在待访问的属性缺失时触发，而后者则会在每次访问属性时触发。</p>\n<p><strong>特别注意:</strong>如果要在<code>__getattribute__</code>和<code>__setattr__</code>方法中访问实例属性，那么应该直接通过<code>super()</code>来做，以避免无限递归。如以下代码就会抛出异常:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BrokenAttribute</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, data)</span>:</span></span><br><span class=\"line\">        self._data = data</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getattribute__</span><span class=\"params\">(self, name)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'Called __getattribute__(&#123;0&#125;)'</span>.format(name))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._data[name]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">data = BrokenAttribute(&#123;<span class=\"string\">'foo'</span>: <span class=\"number\">3</span>&#125;)</span><br><span class=\"line\">print(data.foo)</span><br><span class=\"line\">&gt;&gt;&gt;</span><br><span class=\"line\">RecursionError: maximum recursion depth exceeded <span class=\"keyword\">while</span> calling a Python object</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"属性Property\"><a href=\"#属性Property\" class=\"headerlink\" title=\"属性Property\"></a>属性Property</h4><p>调用<code>property()</code>是建立资料描述器的一种简洁方式，从而可以在访问属性时触发相应的方法调用。<code>property</code>函数原型:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute</span><br></pre></td></tr></table></figure></p>\n<p>下面展示了一个典型应用，定义一个托管属性(managed attribute)x:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getx</span><span class=\"params\">(self)</span>:</span> <span class=\"keyword\">return</span> self.__x</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">setx</span><span class=\"params\">(self, value)</span>:</span> self.__x = value</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">delx</span><span class=\"params\">(self)</span>:</span> <span class=\"keyword\">del</span> self.__x</span><br><span class=\"line\">    x = property(getx, setx, delx, <span class=\"string\">\"I'm the 'x' property.\"</span>)</span><br></pre></td></tr></table></figure>\n<p>其等价Python实现为:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Property</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"Emulate PyProperty_Type() in Objects/descrobject.c\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, fget=None, fset=None, fdel=None, doc=None)</span>:</span></span><br><span class=\"line\">        self.fget = fget</span><br><span class=\"line\">        self.fset = fset</span><br><span class=\"line\">        self.fdel = fdel</span><br><span class=\"line\">        self.__doc__ = doc</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__get__</span><span class=\"params\">(self, obj, objtype=None)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> obj <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.fget <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> AttributeError, <span class=\"string\">\"unreadable attribute\"</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.fget(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__set__</span><span class=\"params\">(self, obj, value)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.fset <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> AttributeError, <span class=\"string\">\"can't set attribute\"</span></span><br><span class=\"line\">        self.fset(obj, value)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__delete__</span><span class=\"params\">(self, obj)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.fdel <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> AttributeError, <span class=\"string\">\"can't delete attribute\"</span></span><br><span class=\"line\">        self.fdel(obj)</span><br></pre></td></tr></table></figure>\n<h4 id=\"静态方法与类方法\"><a href=\"#静态方法与类方法\" class=\"headerlink\" title=\"静态方法与类方法\"></a>静态方法与类方法</h4><p>非资料描述器为将函数绑定成方法这种常见模式提供了一个简单的实现机制。<br>简而言之，函数有个方法<code>__get__()</code>，当函数被当作属性访问时，它会把函数变成一个实例方法。非资料描述器把实例调用<code>obj.f(*args)</code>转换成<code>f(obj, *args)</code>(绑定方法)，把类调用<code>klass.f(*args)</code>转换成<code>f(klass, *args)</code>(非绑定方法)。<br>静态方法原样返回函数，调用 c.f 或者 C.f 分别等价于<code>object.__getattribute__(c, &quot;f&quot;)</code>或者<code>object.__getattribute__(C, &quot;f&quot;)</code>。也就是说，无论是从一个对象还是一个类中，这个函数都会同样地访问到。<br>利用非资料描述器，<code>staticmethod()</code>的等价实现看起来像这样:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">staticmethod</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"> <span class=\"string\">\"Emulate PyStaticMethod_Type() in Objects/funcobject.c\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, f)</span>:</span></span><br><span class=\"line\">      self.f = f</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__get__</span><span class=\"params\">(self, obj, objtype=None)</span>:</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> self.f</span><br></pre></td></tr></table></figure>\n<p>同样的，<code>classmethod()</code>等价实现看起来像这样:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassMethod</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">     <span class=\"string\">\"Emulate PyClassMethod_Type() in Objects/funcobject.c\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, f)</span>:</span></span><br><span class=\"line\">          self.f = f</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__get__</span><span class=\"params\">(self, obj, klass=None)</span>:</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> klass <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">               klass = type(obj)</span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">newfunc</span><span class=\"params\">(*args)</span>:</span></span><br><span class=\"line\">               <span class=\"keyword\">return</span> self.f(klass, *args)</span><br><span class=\"line\">          <span class=\"keyword\">return</span> newfunc</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>在上一篇中讲到了描述器方法<code>__get__</code>、<code>__set__</code>和<code>__delete__</code>，同时也提到，一个对象具有任意一个方法的就会成为描述器，从而在被当作对象属性的时候会重写默认的查找行为。在本篇中，通过对<a href=\"https://docs.python.org/2/howto/descriptor.html\" target=\"_blank\" rel=\"noopener\">Descriptor HowTo Guide</a>的节选翻译以及笔者的自身的一些实践，对描述器做一个更详细的说明。</p>\n<p>如果一个对象同时定义了<code>__get__</code>和<code>__set__</code>方法，则称它为资料描述器(<em>data descriptor</em>)，而仅定义了<code>__get__</code>方法的描述器称为非资料描述器(<em>non-data descriptor</em>，常用于方法，其他用途也是可以的)。</p>\n<p>资料描述器和非资料描述器的区别在于：<strong>相对于实例的字典的优先级</strong>。如果实例字典中有和描述器重名的属性，如果描述器是资料描述器，优先使用资料描述器，如果是非资料描述器，优先使用字典中的属性。这就是为何实例a的方法和属性重名时，比如都叫做<code>foo</code>，Python会在访问<code>a.foo</code>时优先访问实例字典中的属性，因为实例的方法是个非资料描述器。<br></p>","more":"<br>要想制作一个只读的资料描述器需要同时定义<code>__set__</code>和<code>__get__</code>方法，由于是只读，所以只需要在<code>__set__</code>方法中抛出一个<code>AttributeError</code>异常即可。<p></p>\n<p>在一般情况下，描述器在属性访问时被自动调用。举例来说，<code>obj.d</code>会在<code>obj</code>的字典里面查找<code>d</code>，如果<code>d</code>定义了<code>__get__</code>方法，那么<code>d.__get__(obj)</code>会依据下面的优先规则被调用。</p>\n<p>调用的细节取决于<code>obj</code>是一个类还是一个实例，对于对象来讲，方法<code>object.__getattribute__</code>将属性访问<code>a.x</code>变成了<code>type(a).__dict__[&#39;x&#39;].__get__(a, type(a))</code>，具体实现依据这样的优先顺序:<strong>资料描述器</strong>优先于<strong>实例变量</strong>，<strong>实例变量</strong>优先于<strong>非资料描述器</strong>，<code>__getattr__()</code>方法具有最低优先级；对于类来讲，方法<code>type.__getattribute__</code>将<code>A.x</code>变成<code>A.__dict__[&#39;x&#39;].__get__(None, A)</code>。如以下代码:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">V</span>:</span></span><br><span class=\"line\">    v = <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, val=<span class=\"number\">0</span>)</span>:</span></span><br><span class=\"line\">        self.v = val</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__get__</span><span class=\"params\">(self, inst, owner)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.v</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__set__</span><span class=\"params\">(self, inst, value)</span>:</span></span><br><span class=\"line\">        self.v = value</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span></span><br><span class=\"line\">    k1 = V(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">k</span><span class=\"params\">(self)</span>:</span>  <span class=\"comment\"># non-data descriptor</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = A()</span><br><span class=\"line\">print(a.k)  <span class=\"comment\"># &lt;bound method...&gt; *op1*</span></span><br><span class=\"line\">a.k = <span class=\"number\">6</span>  <span class=\"comment\"># replace non-data descriptor with instance dict  *op2*</span></span><br><span class=\"line\">print(a.k)  <span class=\"comment\"># 6  *op3*</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(a.k1)  <span class=\"comment\"># 1</span></span><br><span class=\"line\">a.__dict__[<span class=\"string\">'k1'</span>] = V(<span class=\"number\">2</span>)  <span class=\"comment\"># *op4*</span></span><br><span class=\"line\">print(a.k1)  <span class=\"comment\"># 1</span></span><br></pre></td></tr></table></figure></p>\n<p>这段代码展示了资料描述器、实例变量、非资料描述器在属性访问中的不同优先级，分析如下:类<code>A</code>中定义了方法<code>k</code>(非资料描述器)，第一次操作对<code>a.k</code>的访问将转变为<code>type(a).__dict__[&#39;k&#39;].__get__(a, type(a))</code>，<code>type(a)</code>即类<code>A</code>，<code>A.__dict__</code>中存储了方法<code>A.k</code>，由于方法<code>A.k</code>为非资料描述器，因此调用其定义的<code>__get__()</code>方法。第二次操作<code>a.k = 6</code>本质上是在字典<code>a.__dict__</code>中添加了<code>k</code>这一变量(注意<code>a.__dict__</code>和<code>A._dict__</code>的区别)，即新增了实例变量。第三次操作对<code>a.k</code>的访问由于<strong>实例变量</strong>优先级高于<strong>非资料描述器</strong>，因此将获得之前的赋值6而不是方法。在第四次操作前后分别访问了<code>a.k1</code>属性，由于<code>k1</code>是资料描述器，因此即使在<code>a.__dict__</code>中新增了实例变量<code>k1</code>，对<code>a.k1</code>仍然是访问了资料描述器而不是实例变量，与前述的优先级保持一致。</p>\n<p><code>__getattr__</code>与<code>__getattribute__</code>区别:前者只会在待访问的属性缺失时触发，而后者则会在每次访问属性时触发。</p>\n<p><strong>特别注意:</strong>如果要在<code>__getattribute__</code>和<code>__setattr__</code>方法中访问实例属性，那么应该直接通过<code>super()</code>来做，以避免无限递归。如以下代码就会抛出异常:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BrokenAttribute</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, data)</span>:</span></span><br><span class=\"line\">        self._data = data</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getattribute__</span><span class=\"params\">(self, name)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'Called __getattribute__(&#123;0&#125;)'</span>.format(name))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._data[name]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">data = BrokenAttribute(&#123;<span class=\"string\">'foo'</span>: <span class=\"number\">3</span>&#125;)</span><br><span class=\"line\">print(data.foo)</span><br><span class=\"line\">&gt;&gt;&gt;</span><br><span class=\"line\">RecursionError: maximum recursion depth exceeded <span class=\"keyword\">while</span> calling a Python object</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"属性Property\"><a href=\"#属性Property\" class=\"headerlink\" title=\"属性Property\"></a>属性Property</h4><p>调用<code>property()</code>是建立资料描述器的一种简洁方式，从而可以在访问属性时触发相应的方法调用。<code>property</code>函数原型:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute</span><br></pre></td></tr></table></figure></p>\n<p>下面展示了一个典型应用，定义一个托管属性(managed attribute)x:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getx</span><span class=\"params\">(self)</span>:</span> <span class=\"keyword\">return</span> self.__x</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">setx</span><span class=\"params\">(self, value)</span>:</span> self.__x = value</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">delx</span><span class=\"params\">(self)</span>:</span> <span class=\"keyword\">del</span> self.__x</span><br><span class=\"line\">    x = property(getx, setx, delx, <span class=\"string\">\"I'm the 'x' property.\"</span>)</span><br></pre></td></tr></table></figure>\n<p>其等价Python实现为:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Property</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"Emulate PyProperty_Type() in Objects/descrobject.c\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, fget=None, fset=None, fdel=None, doc=None)</span>:</span></span><br><span class=\"line\">        self.fget = fget</span><br><span class=\"line\">        self.fset = fset</span><br><span class=\"line\">        self.fdel = fdel</span><br><span class=\"line\">        self.__doc__ = doc</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__get__</span><span class=\"params\">(self, obj, objtype=None)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> obj <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.fget <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> AttributeError, <span class=\"string\">\"unreadable attribute\"</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.fget(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__set__</span><span class=\"params\">(self, obj, value)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.fset <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> AttributeError, <span class=\"string\">\"can't set attribute\"</span></span><br><span class=\"line\">        self.fset(obj, value)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__delete__</span><span class=\"params\">(self, obj)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.fdel <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> AttributeError, <span class=\"string\">\"can't delete attribute\"</span></span><br><span class=\"line\">        self.fdel(obj)</span><br></pre></td></tr></table></figure>\n<h4 id=\"静态方法与类方法\"><a href=\"#静态方法与类方法\" class=\"headerlink\" title=\"静态方法与类方法\"></a>静态方法与类方法</h4><p>非资料描述器为将函数绑定成方法这种常见模式提供了一个简单的实现机制。<br>简而言之，函数有个方法<code>__get__()</code>，当函数被当作属性访问时，它会把函数变成一个实例方法。非资料描述器把实例调用<code>obj.f(*args)</code>转换成<code>f(obj, *args)</code>(绑定方法)，把类调用<code>klass.f(*args)</code>转换成<code>f(klass, *args)</code>(非绑定方法)。<br>静态方法原样返回函数，调用 c.f 或者 C.f 分别等价于<code>object.__getattribute__(c, &quot;f&quot;)</code>或者<code>object.__getattribute__(C, &quot;f&quot;)</code>。也就是说，无论是从一个对象还是一个类中，这个函数都会同样地访问到。<br>利用非资料描述器，<code>staticmethod()</code>的等价实现看起来像这样:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">staticmethod</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"> <span class=\"string\">\"Emulate PyStaticMethod_Type() in Objects/funcobject.c\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, f)</span>:</span></span><br><span class=\"line\">      self.f = f</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__get__</span><span class=\"params\">(self, obj, objtype=None)</span>:</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> self.f</span><br></pre></td></tr></table></figure>\n<p>同样的，<code>classmethod()</code>等价实现看起来像这样:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassMethod</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">     <span class=\"string\">\"Emulate PyClassMethod_Type() in Objects/funcobject.c\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, f)</span>:</span></span><br><span class=\"line\">          self.f = f</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__get__</span><span class=\"params\">(self, obj, klass=None)</span>:</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> klass <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">               klass = type(obj)</span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">newfunc</span><span class=\"params\">(*args)</span>:</span></span><br><span class=\"line\">               <span class=\"keyword\">return</span> self.f(klass, *args)</span><br><span class=\"line\">          <span class=\"keyword\">return</span> newfunc</span><br></pre></td></tr></table></figure>"},{"title":"Python属性与描述器","date":"2017-01-24T09:03:27.000Z","_content":"#### `getter`与`setter`\n如果开发者之前有其他语言的开发经验，在转入Python之后，可能会在类中明确地实现类似`getter`和`setter`方法，如:\n```Python\nclass OldResistor:\n    def __init__(self, ohms):\n        self._ohms = ohms\n    \n    def get_ohms(self):\n        return self._homs\n    \n    def set_ohms(self, ohms):\n        self._ohms = ohms\n```\n<!-- more-->\n然而这种方法却并不像Python的编程风格，特别是对于自增的代码来说更是如此:\n```Python\nr = OldResistor(1e3)\nr.set_ohms(r.get_ohms()+1e3)\n```\n\n对于Python语言来说，基本上不需要手工实现`getter`和`setter`方法，而是该先从简单的`public`属性写起:\n```Python\nclass NewResistor:\n    def __init__(self, ohms):\n        self.ohms = ohms\n        \nr = NewResistor(1e3)\nr.ohms += 1e3\n```\n\n但是开发者可能需要在对某个属性操作的时候实现特殊行为，这时候可以改用`@property`修饰器和`setter`方法来做:\n```Python\nclass PropResistor:\n    def __init__(self, ohms):\n        self._ohms = ohms\n    \n    @property\n    def ohms(self):\n        # Do what you want when access ohms\n        return self._ohms\n    \n    @ohms.setter\n    def ohms(self, ohms):\n        # Do what you want when change ohms\n        self._ohms = ohms\n```\n\n通过指定`setter`方法，我们可以在方法里面做类型验证以及数值验证。\n\n但是,考虑下面一种情况:\n> 假设有一个考试成绩(`Exam`)类，由多个科目的小成绩组成，每一科需要单独计分，在进行分数录入的时候，要求对成绩进行验证，保证其在0~100之间\n\n如果使用属性`@property`实现，每添加一项科目，就要重复编写一次`@property`方法，而且还需要重复相关验证逻辑，如:\n```Python\nclass Exam:\n    def __init__(self):\n       self._chinese_grade = 0\n       self._math_grade = 0\n       \n    @staticmethod\n    def _check_grade(value):\n    if not (0 <= value <= 100):\n        raise ValueError('Grade must be between 0 and 100')\n    \n    @property\n    def chinese_grade(self):\n        return self._chinese_grade\n    \n    @chinese_grade.setter\n    def chinese_grade(self, grade):\n        self._check_grade(grade)\n        self._chinese_grade = grade\n        \n    @property\n    def math_grade(self):\n        return self._math_grade\n        \n    @math_grade.setter\n    def math_grade(self, grade):\n        self._check_grade(grade)\n        self._math_grade = grade\n```\n\n实际上，有另外一种更好的方式实现上述功能，那就是采用Python的描述器(*descriptor*)来做。\n\n#### 描述器\n> 一般来说，一个描述器是一个有“绑定行为”的对象属性(object attribute)，它的访问控制被描述器协议方法重写。这些方法是 `__get__()`, `__set__()`, 和 `__delete__()` 。有这些方法的对象叫做描述器。\n\n```Python\ndescr.__get__(self, obj, type=None) --> value\ndescr.__set__(self, obj, value) --> None\ndescr.__delete__(self, obj) --> None\n```\n以上是所有描述器方法。一个对象具有其中任一个方法就会成为描述器，从而在被当作对象属性时重写默认的查找行为。来看一个例子:\n```Python\nclass Grade:\n    def __init__(self):\n        self._value = 0\n        \n    def __get__(self, inst, owner):\n        return self._value\n    \n    def __set__(self, inst, value):\n        if not (0 <= value <= 100):\n            raise ValueError('Grade must be between 0 and 100')\n        self._value = value\n\nclass Exam:\n    math_grade = Grade()\n```\n为属性赋值时:\n```Python\nexam = Exam()\nexam.math_grade = 50\n```\n\nPython会对赋值操作进行转译，`exam.math_grade = 50`将会被转译成:\n```Python\nExam.__dict__['math_grade'].__set__(exam, 40)\n```\n\n同样，访问操作也会被转译，`print(exam.math_grade)`将会被转译成:\n```Python\nprint(Exam.__dict__['math_grade'].__get__(exam, Exam))\n```\n\n但是，上面的代码存在一个问题，由于所有类`Exam`的实例都会共享同一份`math_grade`实例，即程序定义类`Exam`的时候，就会把类`Grade`的`math_grade`实例构建好，以后再创建类`Exam`的实例时，就不再构建Grade了，因此我们需要把每个`Exam`实例所对应的值记录到`Grade`中，因此可以采取字典保存:\n```Python\nclass Grade:\n    def __init__(self):\n        self._values = {}\n        \n    def __get__(self, inst, owner):\n        if inst is None:\n            return self\n        return self._values.get(inst, 0)\n    \n    def __set__(self, inst, value):\n        if not (0 <= value <= 100):\n            raise ValueError('Grade must be between 0 and 100')\n        self._values[inst] = value\n```\n\n这种方式实现简单，而且能够正常运作，但它仍然有一个问题，就是内存泄漏，在程序生命周期类，对于传给`__set__`方法的每个`Exam`实例来说，`_values`字典都会保存一份指向该实例的引用，这就导致该实例的引用计数无法降为0，从而使垃圾收集器无法将其回收，通过使用Python内置的`weakref`模块即可解决此问题。该模块提供了名为`WeakKeyDictionary`的特殊字典，该字典的引用为弱引用，系统能够正确的完成回收:\n```Python\nclass Grade:\n    def __init__(self):\n        self._values = WeakKeyDictionary()\n    # ...\n```","source":"_posts/Python-property and descriptor.md","raw":"---\ntitle: Python属性与描述器\ndate: 2017-01-24 17:03:27\ntags: [Python,属性,描述器]\ncategories: Python\n---\n#### `getter`与`setter`\n如果开发者之前有其他语言的开发经验，在转入Python之后，可能会在类中明确地实现类似`getter`和`setter`方法，如:\n```Python\nclass OldResistor:\n    def __init__(self, ohms):\n        self._ohms = ohms\n    \n    def get_ohms(self):\n        return self._homs\n    \n    def set_ohms(self, ohms):\n        self._ohms = ohms\n```\n<!-- more-->\n然而这种方法却并不像Python的编程风格，特别是对于自增的代码来说更是如此:\n```Python\nr = OldResistor(1e3)\nr.set_ohms(r.get_ohms()+1e3)\n```\n\n对于Python语言来说，基本上不需要手工实现`getter`和`setter`方法，而是该先从简单的`public`属性写起:\n```Python\nclass NewResistor:\n    def __init__(self, ohms):\n        self.ohms = ohms\n        \nr = NewResistor(1e3)\nr.ohms += 1e3\n```\n\n但是开发者可能需要在对某个属性操作的时候实现特殊行为，这时候可以改用`@property`修饰器和`setter`方法来做:\n```Python\nclass PropResistor:\n    def __init__(self, ohms):\n        self._ohms = ohms\n    \n    @property\n    def ohms(self):\n        # Do what you want when access ohms\n        return self._ohms\n    \n    @ohms.setter\n    def ohms(self, ohms):\n        # Do what you want when change ohms\n        self._ohms = ohms\n```\n\n通过指定`setter`方法，我们可以在方法里面做类型验证以及数值验证。\n\n但是,考虑下面一种情况:\n> 假设有一个考试成绩(`Exam`)类，由多个科目的小成绩组成，每一科需要单独计分，在进行分数录入的时候，要求对成绩进行验证，保证其在0~100之间\n\n如果使用属性`@property`实现，每添加一项科目，就要重复编写一次`@property`方法，而且还需要重复相关验证逻辑，如:\n```Python\nclass Exam:\n    def __init__(self):\n       self._chinese_grade = 0\n       self._math_grade = 0\n       \n    @staticmethod\n    def _check_grade(value):\n    if not (0 <= value <= 100):\n        raise ValueError('Grade must be between 0 and 100')\n    \n    @property\n    def chinese_grade(self):\n        return self._chinese_grade\n    \n    @chinese_grade.setter\n    def chinese_grade(self, grade):\n        self._check_grade(grade)\n        self._chinese_grade = grade\n        \n    @property\n    def math_grade(self):\n        return self._math_grade\n        \n    @math_grade.setter\n    def math_grade(self, grade):\n        self._check_grade(grade)\n        self._math_grade = grade\n```\n\n实际上，有另外一种更好的方式实现上述功能，那就是采用Python的描述器(*descriptor*)来做。\n\n#### 描述器\n> 一般来说，一个描述器是一个有“绑定行为”的对象属性(object attribute)，它的访问控制被描述器协议方法重写。这些方法是 `__get__()`, `__set__()`, 和 `__delete__()` 。有这些方法的对象叫做描述器。\n\n```Python\ndescr.__get__(self, obj, type=None) --> value\ndescr.__set__(self, obj, value) --> None\ndescr.__delete__(self, obj) --> None\n```\n以上是所有描述器方法。一个对象具有其中任一个方法就会成为描述器，从而在被当作对象属性时重写默认的查找行为。来看一个例子:\n```Python\nclass Grade:\n    def __init__(self):\n        self._value = 0\n        \n    def __get__(self, inst, owner):\n        return self._value\n    \n    def __set__(self, inst, value):\n        if not (0 <= value <= 100):\n            raise ValueError('Grade must be between 0 and 100')\n        self._value = value\n\nclass Exam:\n    math_grade = Grade()\n```\n为属性赋值时:\n```Python\nexam = Exam()\nexam.math_grade = 50\n```\n\nPython会对赋值操作进行转译，`exam.math_grade = 50`将会被转译成:\n```Python\nExam.__dict__['math_grade'].__set__(exam, 40)\n```\n\n同样，访问操作也会被转译，`print(exam.math_grade)`将会被转译成:\n```Python\nprint(Exam.__dict__['math_grade'].__get__(exam, Exam))\n```\n\n但是，上面的代码存在一个问题，由于所有类`Exam`的实例都会共享同一份`math_grade`实例，即程序定义类`Exam`的时候，就会把类`Grade`的`math_grade`实例构建好，以后再创建类`Exam`的实例时，就不再构建Grade了，因此我们需要把每个`Exam`实例所对应的值记录到`Grade`中，因此可以采取字典保存:\n```Python\nclass Grade:\n    def __init__(self):\n        self._values = {}\n        \n    def __get__(self, inst, owner):\n        if inst is None:\n            return self\n        return self._values.get(inst, 0)\n    \n    def __set__(self, inst, value):\n        if not (0 <= value <= 100):\n            raise ValueError('Grade must be between 0 and 100')\n        self._values[inst] = value\n```\n\n这种方式实现简单，而且能够正常运作，但它仍然有一个问题，就是内存泄漏，在程序生命周期类，对于传给`__set__`方法的每个`Exam`实例来说，`_values`字典都会保存一份指向该实例的引用，这就导致该实例的引用计数无法降为0，从而使垃圾收集器无法将其回收，通过使用Python内置的`weakref`模块即可解决此问题。该模块提供了名为`WeakKeyDictionary`的特殊字典，该字典的引用为弱引用，系统能够正确的完成回收:\n```Python\nclass Grade:\n    def __init__(self):\n        self._values = WeakKeyDictionary()\n    # ...\n```","slug":"Python-property and descriptor","published":1,"updated":"2018-01-13T00:50:39.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgvnqmld001cw628kwijvlce","content":"<h4 id=\"getter与setter\"><a href=\"#getter与setter\" class=\"headerlink\" title=\"getter与setter\"></a><code>getter</code>与<code>setter</code></h4><p>如果开发者之前有其他语言的开发经验，在转入Python之后，可能会在类中明确地实现类似<code>getter</code>和<code>setter</code>方法，如:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OldResistor</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, ohms)</span>:</span></span><br><span class=\"line\">        self._ohms = ohms</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_ohms</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._homs</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_ohms</span><span class=\"params\">(self, ohms)</span>:</span></span><br><span class=\"line\">        self._ohms = ohms</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>然而这种方法却并不像Python的编程风格，特别是对于自增的代码来说更是如此:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r = OldResistor(<span class=\"number\">1e3</span>)</span><br><span class=\"line\">r.set_ohms(r.get_ohms()+<span class=\"number\">1e3</span>)</span><br></pre></td></tr></table></figure></p>\n<p>对于Python语言来说，基本上不需要手工实现<code>getter</code>和<code>setter</code>方法，而是该先从简单的<code>public</code>属性写起:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewResistor</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, ohms)</span>:</span></span><br><span class=\"line\">        self.ohms = ohms</span><br><span class=\"line\">        </span><br><span class=\"line\">r = NewResistor(<span class=\"number\">1e3</span>)</span><br><span class=\"line\">r.ohms += <span class=\"number\">1e3</span></span><br></pre></td></tr></table></figure></p>\n<p>但是开发者可能需要在对某个属性操作的时候实现特殊行为，这时候可以改用<code>@property</code>修饰器和<code>setter</code>方法来做:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PropResistor</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, ohms)</span>:</span></span><br><span class=\"line\">        self._ohms = ohms</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">    @property</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ohms</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># Do what you want when access ohms</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._ohms</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">    @ohms.setter</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ohms</span><span class=\"params\">(self, ohms)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># Do what you want when change ohms</span></span><br><span class=\"line\">        self._ohms = ohms</span><br></pre></td></tr></table></figure></p>\n<p>通过指定<code>setter</code>方法，我们可以在方法里面做类型验证以及数值验证。</p>\n<p>但是,考虑下面一种情况:</p>\n<blockquote>\n<p>假设有一个考试成绩(<code>Exam</code>)类，由多个科目的小成绩组成，每一科需要单独计分，在进行分数录入的时候，要求对成绩进行验证，保证其在0~100之间</p>\n</blockquote>\n<p>如果使用属性<code>@property</code>实现，每添加一项科目，就要重复编写一次<code>@property</code>方法，而且还需要重复相关验证逻辑，如:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Exam</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">       self._chinese_grade = <span class=\"number\">0</span></span><br><span class=\"line\">       self._math_grade = <span class=\"number\">0</span></span><br><span class=\"line\">       </span><br><span class=\"line\"><span class=\"meta\">    @staticmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_check_grade</span><span class=\"params\">(value)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (<span class=\"number\">0</span> &lt;= value &lt;= <span class=\"number\">100</span>):</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'Grade must be between 0 and 100'</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">    @property</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">chinese_grade</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._chinese_grade</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">    @chinese_grade.setter</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">chinese_grade</span><span class=\"params\">(self, grade)</span>:</span></span><br><span class=\"line\">        self._check_grade(grade)</span><br><span class=\"line\">        self._chinese_grade = grade</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"meta\">    @property</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">math_grade</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._math_grade</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"meta\">    @math_grade.setter</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">math_grade</span><span class=\"params\">(self, grade)</span>:</span></span><br><span class=\"line\">        self._check_grade(grade)</span><br><span class=\"line\">        self._math_grade = grade</span><br></pre></td></tr></table></figure></p>\n<p>实际上，有另外一种更好的方式实现上述功能，那就是采用Python的描述器(<em>descriptor</em>)来做。</p>\n<h4 id=\"描述器\"><a href=\"#描述器\" class=\"headerlink\" title=\"描述器\"></a>描述器</h4><blockquote>\n<p>一般来说，一个描述器是一个有“绑定行为”的对象属性(object attribute)，它的访问控制被描述器协议方法重写。这些方法是 <code>__get__()</code>, <code>__set__()</code>, 和 <code>__delete__()</code> 。有这些方法的对象叫做描述器。</p>\n</blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">descr.__get__(self, obj, type=None) --&gt; value</span><br><span class=\"line\">descr.__set__(self, obj, value) --&gt; None</span><br><span class=\"line\">descr.__delete__(self, obj) --&gt; None</span><br></pre></td></tr></table></figure>\n<p>以上是所有描述器方法。一个对象具有其中任一个方法就会成为描述器，从而在被当作对象属性时重写默认的查找行为。来看一个例子:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Grade</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self._value = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__get__</span><span class=\"params\">(self, inst, owner)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._value</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__set__</span><span class=\"params\">(self, inst, value)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (<span class=\"number\">0</span> &lt;= value &lt;= <span class=\"number\">100</span>):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'Grade must be between 0 and 100'</span>)</span><br><span class=\"line\">        self._value = value</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Exam</span>:</span></span><br><span class=\"line\">    math_grade = Grade()</span><br></pre></td></tr></table></figure></p>\n<p>为属性赋值时:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exam = Exam()</span><br><span class=\"line\">exam.math_grade = <span class=\"number\">50</span></span><br></pre></td></tr></table></figure></p>\n<p>Python会对赋值操作进行转译，<code>exam.math_grade = 50</code>将会被转译成:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exam.__dict__[<span class=\"string\">'math_grade'</span>].__set__(exam, <span class=\"number\">40</span>)</span><br></pre></td></tr></table></figure></p>\n<p>同样，访问操作也会被转译，<code>print(exam.math_grade)</code>将会被转译成:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(Exam.__dict__[<span class=\"string\">'math_grade'</span>].__get__(exam, Exam))</span><br></pre></td></tr></table></figure></p>\n<p>但是，上面的代码存在一个问题，由于所有类<code>Exam</code>的实例都会共享同一份<code>math_grade</code>实例，即程序定义类<code>Exam</code>的时候，就会把类<code>Grade</code>的<code>math_grade</code>实例构建好，以后再创建类<code>Exam</code>的实例时，就不再构建Grade了，因此我们需要把每个<code>Exam</code>实例所对应的值记录到<code>Grade</code>中，因此可以采取字典保存:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Grade</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self._values = &#123;&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__get__</span><span class=\"params\">(self, inst, owner)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> inst <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._values.get(inst, <span class=\"number\">0</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__set__</span><span class=\"params\">(self, inst, value)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (<span class=\"number\">0</span> &lt;= value &lt;= <span class=\"number\">100</span>):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'Grade must be between 0 and 100'</span>)</span><br><span class=\"line\">        self._values[inst] = value</span><br></pre></td></tr></table></figure></p>\n<p>这种方式实现简单，而且能够正常运作，但它仍然有一个问题，就是内存泄漏，在程序生命周期类，对于传给<code>__set__</code>方法的每个<code>Exam</code>实例来说，<code>_values</code>字典都会保存一份指向该实例的引用，这就导致该实例的引用计数无法降为0，从而使垃圾收集器无法将其回收，通过使用Python内置的<code>weakref</code>模块即可解决此问题。该模块提供了名为<code>WeakKeyDictionary</code>的特殊字典，该字典的引用为弱引用，系统能够正确的完成回收:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Grade</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self._values = WeakKeyDictionary()</span><br><span class=\"line\">    <span class=\"comment\"># ...</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"getter与setter\"><a href=\"#getter与setter\" class=\"headerlink\" title=\"getter与setter\"></a><code>getter</code>与<code>setter</code></h4><p>如果开发者之前有其他语言的开发经验，在转入Python之后，可能会在类中明确地实现类似<code>getter</code>和<code>setter</code>方法，如:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OldResistor</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, ohms)</span>:</span></span><br><span class=\"line\">        self._ohms = ohms</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_ohms</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._homs</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_ohms</span><span class=\"params\">(self, ohms)</span>:</span></span><br><span class=\"line\">        self._ohms = ohms</span><br></pre></td></tr></table></figure></p>","more":"<p>然而这种方法却并不像Python的编程风格，特别是对于自增的代码来说更是如此:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r = OldResistor(<span class=\"number\">1e3</span>)</span><br><span class=\"line\">r.set_ohms(r.get_ohms()+<span class=\"number\">1e3</span>)</span><br></pre></td></tr></table></figure></p>\n<p>对于Python语言来说，基本上不需要手工实现<code>getter</code>和<code>setter</code>方法，而是该先从简单的<code>public</code>属性写起:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewResistor</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, ohms)</span>:</span></span><br><span class=\"line\">        self.ohms = ohms</span><br><span class=\"line\">        </span><br><span class=\"line\">r = NewResistor(<span class=\"number\">1e3</span>)</span><br><span class=\"line\">r.ohms += <span class=\"number\">1e3</span></span><br></pre></td></tr></table></figure></p>\n<p>但是开发者可能需要在对某个属性操作的时候实现特殊行为，这时候可以改用<code>@property</code>修饰器和<code>setter</code>方法来做:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PropResistor</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, ohms)</span>:</span></span><br><span class=\"line\">        self._ohms = ohms</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">    @property</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ohms</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># Do what you want when access ohms</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._ohms</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">    @ohms.setter</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ohms</span><span class=\"params\">(self, ohms)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># Do what you want when change ohms</span></span><br><span class=\"line\">        self._ohms = ohms</span><br></pre></td></tr></table></figure></p>\n<p>通过指定<code>setter</code>方法，我们可以在方法里面做类型验证以及数值验证。</p>\n<p>但是,考虑下面一种情况:</p>\n<blockquote>\n<p>假设有一个考试成绩(<code>Exam</code>)类，由多个科目的小成绩组成，每一科需要单独计分，在进行分数录入的时候，要求对成绩进行验证，保证其在0~100之间</p>\n</blockquote>\n<p>如果使用属性<code>@property</code>实现，每添加一项科目，就要重复编写一次<code>@property</code>方法，而且还需要重复相关验证逻辑，如:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Exam</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">       self._chinese_grade = <span class=\"number\">0</span></span><br><span class=\"line\">       self._math_grade = <span class=\"number\">0</span></span><br><span class=\"line\">       </span><br><span class=\"line\"><span class=\"meta\">    @staticmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_check_grade</span><span class=\"params\">(value)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (<span class=\"number\">0</span> &lt;= value &lt;= <span class=\"number\">100</span>):</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'Grade must be between 0 and 100'</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">    @property</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">chinese_grade</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._chinese_grade</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"meta\">    @chinese_grade.setter</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">chinese_grade</span><span class=\"params\">(self, grade)</span>:</span></span><br><span class=\"line\">        self._check_grade(grade)</span><br><span class=\"line\">        self._chinese_grade = grade</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"meta\">    @property</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">math_grade</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._math_grade</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"meta\">    @math_grade.setter</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">math_grade</span><span class=\"params\">(self, grade)</span>:</span></span><br><span class=\"line\">        self._check_grade(grade)</span><br><span class=\"line\">        self._math_grade = grade</span><br></pre></td></tr></table></figure></p>\n<p>实际上，有另外一种更好的方式实现上述功能，那就是采用Python的描述器(<em>descriptor</em>)来做。</p>\n<h4 id=\"描述器\"><a href=\"#描述器\" class=\"headerlink\" title=\"描述器\"></a>描述器</h4><blockquote>\n<p>一般来说，一个描述器是一个有“绑定行为”的对象属性(object attribute)，它的访问控制被描述器协议方法重写。这些方法是 <code>__get__()</code>, <code>__set__()</code>, 和 <code>__delete__()</code> 。有这些方法的对象叫做描述器。</p>\n</blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">descr.__get__(self, obj, type=None) --&gt; value</span><br><span class=\"line\">descr.__set__(self, obj, value) --&gt; None</span><br><span class=\"line\">descr.__delete__(self, obj) --&gt; None</span><br></pre></td></tr></table></figure>\n<p>以上是所有描述器方法。一个对象具有其中任一个方法就会成为描述器，从而在被当作对象属性时重写默认的查找行为。来看一个例子:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Grade</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self._value = <span class=\"number\">0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__get__</span><span class=\"params\">(self, inst, owner)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._value</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__set__</span><span class=\"params\">(self, inst, value)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (<span class=\"number\">0</span> &lt;= value &lt;= <span class=\"number\">100</span>):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'Grade must be between 0 and 100'</span>)</span><br><span class=\"line\">        self._value = value</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Exam</span>:</span></span><br><span class=\"line\">    math_grade = Grade()</span><br></pre></td></tr></table></figure></p>\n<p>为属性赋值时:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exam = Exam()</span><br><span class=\"line\">exam.math_grade = <span class=\"number\">50</span></span><br></pre></td></tr></table></figure></p>\n<p>Python会对赋值操作进行转译，<code>exam.math_grade = 50</code>将会被转译成:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exam.__dict__[<span class=\"string\">'math_grade'</span>].__set__(exam, <span class=\"number\">40</span>)</span><br></pre></td></tr></table></figure></p>\n<p>同样，访问操作也会被转译，<code>print(exam.math_grade)</code>将会被转译成:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(Exam.__dict__[<span class=\"string\">'math_grade'</span>].__get__(exam, Exam))</span><br></pre></td></tr></table></figure></p>\n<p>但是，上面的代码存在一个问题，由于所有类<code>Exam</code>的实例都会共享同一份<code>math_grade</code>实例，即程序定义类<code>Exam</code>的时候，就会把类<code>Grade</code>的<code>math_grade</code>实例构建好，以后再创建类<code>Exam</code>的实例时，就不再构建Grade了，因此我们需要把每个<code>Exam</code>实例所对应的值记录到<code>Grade</code>中，因此可以采取字典保存:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Grade</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self._values = &#123;&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__get__</span><span class=\"params\">(self, inst, owner)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> inst <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._values.get(inst, <span class=\"number\">0</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__set__</span><span class=\"params\">(self, inst, value)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> (<span class=\"number\">0</span> &lt;= value &lt;= <span class=\"number\">100</span>):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'Grade must be between 0 and 100'</span>)</span><br><span class=\"line\">        self._values[inst] = value</span><br></pre></td></tr></table></figure></p>\n<p>这种方式实现简单，而且能够正常运作，但它仍然有一个问题，就是内存泄漏，在程序生命周期类，对于传给<code>__set__</code>方法的每个<code>Exam</code>实例来说，<code>_values</code>字典都会保存一份指向该实例的引用，这就导致该实例的引用计数无法降为0，从而使垃圾收集器无法将其回收，通过使用Python内置的<code>weakref</code>模块即可解决此问题。该模块提供了名为<code>WeakKeyDictionary</code>的特殊字典，该字典的引用为弱引用，系统能够正确的完成回收:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Grade</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self._values = WeakKeyDictionary()</span><br><span class=\"line\">    <span class=\"comment\"># ...</span></span><br></pre></td></tr></table></figure></p>"},{"title":"在Python中使用mock进行单元测试","date":"2018-01-15T01:07:28.000Z","_content":"\n在最近开发的项目中进行了单元测试，在测试过程中使用到了`Python 3.3`中加入到标准库的`mock`库(`unittest.mock`)，因此将使用心得整理成一篇博文。\n\n<!-- more -->\n\n`mock`是一个Python中帮助用来提高单元测试效率的工具，在`Python 3.3`之前需要自行安装，`Python 3.3`将`mock`引入了标准库。单元测试的基本思想是测试逻辑集中的一小段函数，但是在实际编程中，随着开发的进行，可能函数之间有相互调用，对当前函数的单元测试不应该受到被调用函数的影响，因此如何屏蔽掉调用函数的影响而单独测试当前函数是必要的，原因有很多:\n\n* 被调用函数的调用可能产生不必要的问题，如调用生产接口\n* 被调用函数的调用过程可能是复杂的，普通的调用无法覆盖所有可能发生的结果\n* 被调用函数的调用条件比较复杂，如需额外搭建服务器等\n\n以上种种，都会使得单元测试的开发效率降低，因此，`Python 3.3`引入了`mock`来简化这些问题。让我们首先来看一个小例子:\n\n\n```Python\nimport json\nimport requests\n\n\ndef retrieve_url(url):\n    resp = requests.get(url)\n    return resp.content\n\ndef download_and_parse_json(url):\n    try:\n        content = retrieve_url(url)\n    except Exception as e:\n        return '[ERROR] ' + str(e)\n    data = json.loads(content)\n    return data\n\njson_url = 'http://www.foo.com/bar'  # Return json response\n\ndata = download_and_parse_json(json_url)\nprint('Parsed:', data)\n```\n\n这段代码中我们编写了两个函数，一个是用来请求url获取响应的函数`retrieve_url`，一个用来下载url内容并尝试解析为`json`格式函数`download_and_parse_json`，假设我们有一个链接`json_url`，该链接正常情况下应该返回一个包含`json`数据的响应，但是在各种环境因素的作用下(网络通信中断，服务器宕机，接口失效)，也可能出现访问失败的情况，因此我们的第二个函数加入了简单的异常处理，在正常情况下返回解析的`json`字典，异常情况下返回错误信息。\n\n# patch\n\n如果我们想在开发过程中对该函数(`download_and_parse_json`)进行单元测试，由于`json_url`对应的接口可能存在前文所说的各种可能原因，因此我们想模拟该部分操作，返回一个`json`格式的字符串或者抛出一个异常，这时候`mock`模块就派上用场了:\n\n```Python\nimport json\nimport requests\n\nfrom unittest.mock import patch\n\n\ndef retrieve_url(url):\n    resp = requests.get(url)\n    return resp.content\n\ndef download_and_parse_json(url):\n    try:\n        content = retrieve_url(url)\n    except Exception as e:\n        return '[ERROR] ' + str(e)\n    data = json.loads(content)\n    return data\n\njson_url = 'http://www.foo.com/bar'  # Return json response\n\nwith patch('__main__.retrieve_url') as mocked_retrieve:\n    mocked_retrieve.return_value = '{\"a\":1,\"b\":[1,3,4]}'\n    data = download_and_parse_json(json_url)\n    print('Parsed:', data)\n\nwith patch('__main__.retrieve_url') as mocked_retrieve:\n    mocked_retrieve.side_effect = requests.exceptions.ConnectionError(\n        'Connection Error')\n    data = download_and_parse_json(json_url)\n    print('Parsed:', data)\n```\n\n注意该段代码和前一段代码的区别，我们首先从`unittest.mock`导入了`patch`，`patch`可作为函数装饰器、类装饰器、上下文管理器使用，而此处我们使用了第三种形式——上下文管理器。`patch`函数至少接收一个参数，即需要模拟的对象的导入路径，如`package.module.ClassName`，此处我们使用了`__main__.retrieve_url`指示了顶层执行代码中的`retrieve_url`函数，当作为上下文管理器使用的时候，`patch`会返回一个`MagicMock`对象，`MagicMock`是`Mock`的子类(关于`Mock`在下一节会介绍)。\n\n经过`patch`后，在上下文作用域里面，`retireve_url`就已经被替换了，因此我们接下来只需要模拟该函数在正常情况下以及非正常情况下的运行结果就行了。\n\n1. 第一个`with`语句中，我们设置了`mocked_retrieve.return_value = '{\"a\":1,\"b\":[1,3,4]}'`，即当该mock对象被调用的时候(执行`content = retrieve_url(url)`的时候)将返回我们设置的属性`return_value`的值，此处即一个`json`字符串。\n2. 第二个`with`语句中，我们设置了`mocked_retrieve.side_effect = requests.exceptions.ConnectionError('Connection Error')`，在`mock`被调用的时候将抛出`ConnectionError`以测试异常捕获相关代码，与`return_value`只能设置成一个值不同，`side_effect`支持赋值一个函数、一个迭代器或者一个异常(类或对象)。\n\t* 函数: 函数将接收与被mock对象相同的参数(如果函数返回`mock.DEFAULT`对象或者不设置函数，`mock`对象将会返回`return_value`)\n\t* 迭代器: 在每次`mock`被调用的时候，将依次逐个返回迭代器中的值\n\t* 异常: 调用`mock`的时候将抛出指定异常\n\n<div class=\"tip\">\n当`patch`作为函数装饰器使用的时候，被创建的`MagicMock`对象将会作为额外参数传给被装饰函数。(关键字参数new没有被指定的情况下)\n</div>\n\n# Mock\n\n前文已经提到了`Mock`与`MagicMock`，那么它们到底有什么作用呢？\n\n简单来说，`Mock`是一类特殊的对象，当访问该类对象上任意不存在的属性的时候，该属性将被自动创建，且该属性也是`Mock`对象，来看一个小例子:\n\n```Python\n>>> from unittest.mock import Mock\n>>> m = Mock()\n>>> m.foo\n<Mock name='mock.foo' id='4404473248'>\n>>> m.bar.return_value = 'hello mock'\n>>> print(m.bar())\n'hello mock'\n```\n\n`m`是一个`Mock`对象，当访问`m`的`foo`属性时，一个新的`Mock`对象被创建了，我们可以使用链式调用来给`Mock`对象添加任意属性，以及设置调用返回值。\n\n官方文档中给出的`Mock`的创建参数如下:\n\n```\nclass unittest.mock.Mock(spec=None, side_effect=None, return_value=DEFAULT, wraps=None, name=None, spec_set=None, unsafe=False, **kwargs)\n```\n\n在实际使用中，目前就使用到了前三者`spec`、`side_effect`、`return_value`，后两者在前文已经介绍到了，这里简单介绍下`spec`参数，该参数用来限制可以被`Mock`的属性的范围，`spec`可以是多个字符串的列表或者一个已存在的对象(类或实例)，当访问`spec`参数指定属性以外属性的时候将抛出`AttributeError`。\n\n`MagicMock`是`Mock`的子类，因此其拥有所有父类的表现，除此之外，使用该子类允许我们很方便的对`magic methods`进行设置，例如:\n\n```Python\n>>> from unittest.mock import MagicMock\n>>> m = MagicMock()\n>>> m.__str__.return_value = 'hello mock'\n>>> print(m)\nhello mock\n```\n\n## 方法与属性\n\n`Mock`对象实现了很多有用的方法以及属性方便开发者在进行单元测试时使用。\n\n* `assert_called`: 用来检验`Mock`对象至少有一次被调用\n\t```Python\n>>> mock = Mock()\n>>> mock.method()\n<Mock name='mock.method()' id='...'>\n>>> mock.method.assert_called()\n\t```\n* `assert_called_once`: 用来检验`Mock`对象恰好有一次被调用\n* `call_count`: 用来表示`Mock`被调用次数\n   ```Python\n>>> mock = Mock(return_value=None)\n>>> mock.call_count\n0\n>>> mock()\n>>> mock()\n>>> mock.call_count\n2\n\t```\n* ...","source":"_posts/Python-unit-testing-with-Mock.md","raw":"---\ntitle: 在Python中使用mock进行单元测试\ndate: 2018-01-15 09:07:28\ntags: [Python,单元测试,mock]\ncategories: Python\n---\n\n在最近开发的项目中进行了单元测试，在测试过程中使用到了`Python 3.3`中加入到标准库的`mock`库(`unittest.mock`)，因此将使用心得整理成一篇博文。\n\n<!-- more -->\n\n`mock`是一个Python中帮助用来提高单元测试效率的工具，在`Python 3.3`之前需要自行安装，`Python 3.3`将`mock`引入了标准库。单元测试的基本思想是测试逻辑集中的一小段函数，但是在实际编程中，随着开发的进行，可能函数之间有相互调用，对当前函数的单元测试不应该受到被调用函数的影响，因此如何屏蔽掉调用函数的影响而单独测试当前函数是必要的，原因有很多:\n\n* 被调用函数的调用可能产生不必要的问题，如调用生产接口\n* 被调用函数的调用过程可能是复杂的，普通的调用无法覆盖所有可能发生的结果\n* 被调用函数的调用条件比较复杂，如需额外搭建服务器等\n\n以上种种，都会使得单元测试的开发效率降低，因此，`Python 3.3`引入了`mock`来简化这些问题。让我们首先来看一个小例子:\n\n\n```Python\nimport json\nimport requests\n\n\ndef retrieve_url(url):\n    resp = requests.get(url)\n    return resp.content\n\ndef download_and_parse_json(url):\n    try:\n        content = retrieve_url(url)\n    except Exception as e:\n        return '[ERROR] ' + str(e)\n    data = json.loads(content)\n    return data\n\njson_url = 'http://www.foo.com/bar'  # Return json response\n\ndata = download_and_parse_json(json_url)\nprint('Parsed:', data)\n```\n\n这段代码中我们编写了两个函数，一个是用来请求url获取响应的函数`retrieve_url`，一个用来下载url内容并尝试解析为`json`格式函数`download_and_parse_json`，假设我们有一个链接`json_url`，该链接正常情况下应该返回一个包含`json`数据的响应，但是在各种环境因素的作用下(网络通信中断，服务器宕机，接口失效)，也可能出现访问失败的情况，因此我们的第二个函数加入了简单的异常处理，在正常情况下返回解析的`json`字典，异常情况下返回错误信息。\n\n# patch\n\n如果我们想在开发过程中对该函数(`download_and_parse_json`)进行单元测试，由于`json_url`对应的接口可能存在前文所说的各种可能原因，因此我们想模拟该部分操作，返回一个`json`格式的字符串或者抛出一个异常，这时候`mock`模块就派上用场了:\n\n```Python\nimport json\nimport requests\n\nfrom unittest.mock import patch\n\n\ndef retrieve_url(url):\n    resp = requests.get(url)\n    return resp.content\n\ndef download_and_parse_json(url):\n    try:\n        content = retrieve_url(url)\n    except Exception as e:\n        return '[ERROR] ' + str(e)\n    data = json.loads(content)\n    return data\n\njson_url = 'http://www.foo.com/bar'  # Return json response\n\nwith patch('__main__.retrieve_url') as mocked_retrieve:\n    mocked_retrieve.return_value = '{\"a\":1,\"b\":[1,3,4]}'\n    data = download_and_parse_json(json_url)\n    print('Parsed:', data)\n\nwith patch('__main__.retrieve_url') as mocked_retrieve:\n    mocked_retrieve.side_effect = requests.exceptions.ConnectionError(\n        'Connection Error')\n    data = download_and_parse_json(json_url)\n    print('Parsed:', data)\n```\n\n注意该段代码和前一段代码的区别，我们首先从`unittest.mock`导入了`patch`，`patch`可作为函数装饰器、类装饰器、上下文管理器使用，而此处我们使用了第三种形式——上下文管理器。`patch`函数至少接收一个参数，即需要模拟的对象的导入路径，如`package.module.ClassName`，此处我们使用了`__main__.retrieve_url`指示了顶层执行代码中的`retrieve_url`函数，当作为上下文管理器使用的时候，`patch`会返回一个`MagicMock`对象，`MagicMock`是`Mock`的子类(关于`Mock`在下一节会介绍)。\n\n经过`patch`后，在上下文作用域里面，`retireve_url`就已经被替换了，因此我们接下来只需要模拟该函数在正常情况下以及非正常情况下的运行结果就行了。\n\n1. 第一个`with`语句中，我们设置了`mocked_retrieve.return_value = '{\"a\":1,\"b\":[1,3,4]}'`，即当该mock对象被调用的时候(执行`content = retrieve_url(url)`的时候)将返回我们设置的属性`return_value`的值，此处即一个`json`字符串。\n2. 第二个`with`语句中，我们设置了`mocked_retrieve.side_effect = requests.exceptions.ConnectionError('Connection Error')`，在`mock`被调用的时候将抛出`ConnectionError`以测试异常捕获相关代码，与`return_value`只能设置成一个值不同，`side_effect`支持赋值一个函数、一个迭代器或者一个异常(类或对象)。\n\t* 函数: 函数将接收与被mock对象相同的参数(如果函数返回`mock.DEFAULT`对象或者不设置函数，`mock`对象将会返回`return_value`)\n\t* 迭代器: 在每次`mock`被调用的时候，将依次逐个返回迭代器中的值\n\t* 异常: 调用`mock`的时候将抛出指定异常\n\n<div class=\"tip\">\n当`patch`作为函数装饰器使用的时候，被创建的`MagicMock`对象将会作为额外参数传给被装饰函数。(关键字参数new没有被指定的情况下)\n</div>\n\n# Mock\n\n前文已经提到了`Mock`与`MagicMock`，那么它们到底有什么作用呢？\n\n简单来说，`Mock`是一类特殊的对象，当访问该类对象上任意不存在的属性的时候，该属性将被自动创建，且该属性也是`Mock`对象，来看一个小例子:\n\n```Python\n>>> from unittest.mock import Mock\n>>> m = Mock()\n>>> m.foo\n<Mock name='mock.foo' id='4404473248'>\n>>> m.bar.return_value = 'hello mock'\n>>> print(m.bar())\n'hello mock'\n```\n\n`m`是一个`Mock`对象，当访问`m`的`foo`属性时，一个新的`Mock`对象被创建了，我们可以使用链式调用来给`Mock`对象添加任意属性，以及设置调用返回值。\n\n官方文档中给出的`Mock`的创建参数如下:\n\n```\nclass unittest.mock.Mock(spec=None, side_effect=None, return_value=DEFAULT, wraps=None, name=None, spec_set=None, unsafe=False, **kwargs)\n```\n\n在实际使用中，目前就使用到了前三者`spec`、`side_effect`、`return_value`，后两者在前文已经介绍到了，这里简单介绍下`spec`参数，该参数用来限制可以被`Mock`的属性的范围，`spec`可以是多个字符串的列表或者一个已存在的对象(类或实例)，当访问`spec`参数指定属性以外属性的时候将抛出`AttributeError`。\n\n`MagicMock`是`Mock`的子类，因此其拥有所有父类的表现，除此之外，使用该子类允许我们很方便的对`magic methods`进行设置，例如:\n\n```Python\n>>> from unittest.mock import MagicMock\n>>> m = MagicMock()\n>>> m.__str__.return_value = 'hello mock'\n>>> print(m)\nhello mock\n```\n\n## 方法与属性\n\n`Mock`对象实现了很多有用的方法以及属性方便开发者在进行单元测试时使用。\n\n* `assert_called`: 用来检验`Mock`对象至少有一次被调用\n\t```Python\n>>> mock = Mock()\n>>> mock.method()\n<Mock name='mock.method()' id='...'>\n>>> mock.method.assert_called()\n\t```\n* `assert_called_once`: 用来检验`Mock`对象恰好有一次被调用\n* `call_count`: 用来表示`Mock`被调用次数\n   ```Python\n>>> mock = Mock(return_value=None)\n>>> mock.call_count\n0\n>>> mock()\n>>> mock()\n>>> mock.call_count\n2\n\t```\n* ...","slug":"Python-unit-testing-with-Mock","published":1,"updated":"2018-01-15T08:35:57.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgvnqmle001fw628yyop8l1l","content":"<p>在最近开发的项目中进行了单元测试，在测试过程中使用到了<code>Python 3.3</code>中加入到标准库的<code>mock</code>库(<code>unittest.mock</code>)，因此将使用心得整理成一篇博文。</p>\n<a id=\"more\"></a>\n<p><code>mock</code>是一个Python中帮助用来提高单元测试效率的工具，在<code>Python 3.3</code>之前需要自行安装，<code>Python 3.3</code>将<code>mock</code>引入了标准库。单元测试的基本思想是测试逻辑集中的一小段函数，但是在实际编程中，随着开发的进行，可能函数之间有相互调用，对当前函数的单元测试不应该受到被调用函数的影响，因此如何屏蔽掉调用函数的影响而单独测试当前函数是必要的，原因有很多:</p>\n<ul>\n<li>被调用函数的调用可能产生不必要的问题，如调用生产接口</li>\n<li>被调用函数的调用过程可能是复杂的，普通的调用无法覆盖所有可能发生的结果</li>\n<li>被调用函数的调用条件比较复杂，如需额外搭建服务器等</li>\n</ul>\n<p>以上种种，都会使得单元测试的开发效率降低，因此，<code>Python 3.3</code>引入了<code>mock</code>来简化这些问题。让我们首先来看一个小例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">retrieve_url</span><span class=\"params\">(url)</span>:</span></span><br><span class=\"line\">    resp = requests.get(url)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resp.content</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">download_and_parse_json</span><span class=\"params\">(url)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        content = retrieve_url(url)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'[ERROR] '</span> + str(e)</span><br><span class=\"line\">    data = json.loads(content)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data</span><br><span class=\"line\"></span><br><span class=\"line\">json_url = <span class=\"string\">'http://www.foo.com/bar'</span>  <span class=\"comment\"># Return json response</span></span><br><span class=\"line\"></span><br><span class=\"line\">data = download_and_parse_json(json_url)</span><br><span class=\"line\">print(<span class=\"string\">'Parsed:'</span>, data)</span><br></pre></td></tr></table></figure>\n<p>这段代码中我们编写了两个函数，一个是用来请求url获取响应的函数<code>retrieve_url</code>，一个用来下载url内容并尝试解析为<code>json</code>格式函数<code>download_and_parse_json</code>，假设我们有一个链接<code>json_url</code>，该链接正常情况下应该返回一个包含<code>json</code>数据的响应，但是在各种环境因素的作用下(网络通信中断，服务器宕机，接口失效)，也可能出现访问失败的情况，因此我们的第二个函数加入了简单的异常处理，在正常情况下返回解析的<code>json</code>字典，异常情况下返回错误信息。</p>\n<h1 id=\"patch\"><a href=\"#patch\" class=\"headerlink\" title=\"patch\"></a>patch</h1><p>如果我们想在开发过程中对该函数(<code>download_and_parse_json</code>)进行单元测试，由于<code>json_url</code>对应的接口可能存在前文所说的各种可能原因，因此我们想模拟该部分操作，返回一个<code>json</code>格式的字符串或者抛出一个异常，这时候<code>mock</code>模块就派上用场了:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> unittest.mock <span class=\"keyword\">import</span> patch</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">retrieve_url</span><span class=\"params\">(url)</span>:</span></span><br><span class=\"line\">    resp = requests.get(url)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resp.content</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">download_and_parse_json</span><span class=\"params\">(url)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        content = retrieve_url(url)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'[ERROR] '</span> + str(e)</span><br><span class=\"line\">    data = json.loads(content)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data</span><br><span class=\"line\"></span><br><span class=\"line\">json_url = <span class=\"string\">'http://www.foo.com/bar'</span>  <span class=\"comment\"># Return json response</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> patch(<span class=\"string\">'__main__.retrieve_url'</span>) <span class=\"keyword\">as</span> mocked_retrieve:</span><br><span class=\"line\">    mocked_retrieve.return_value = <span class=\"string\">'&#123;\"a\":1,\"b\":[1,3,4]&#125;'</span></span><br><span class=\"line\">    data = download_and_parse_json(json_url)</span><br><span class=\"line\">    print(<span class=\"string\">'Parsed:'</span>, data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> patch(<span class=\"string\">'__main__.retrieve_url'</span>) <span class=\"keyword\">as</span> mocked_retrieve:</span><br><span class=\"line\">    mocked_retrieve.side_effect = requests.exceptions.ConnectionError(</span><br><span class=\"line\">        <span class=\"string\">'Connection Error'</span>)</span><br><span class=\"line\">    data = download_and_parse_json(json_url)</span><br><span class=\"line\">    print(<span class=\"string\">'Parsed:'</span>, data)</span><br></pre></td></tr></table></figure>\n<p>注意该段代码和前一段代码的区别，我们首先从<code>unittest.mock</code>导入了<code>patch</code>，<code>patch</code>可作为函数装饰器、类装饰器、上下文管理器使用，而此处我们使用了第三种形式——上下文管理器。<code>patch</code>函数至少接收一个参数，即需要模拟的对象的导入路径，如<code>package.module.ClassName</code>，此处我们使用了<code>__main__.retrieve_url</code>指示了顶层执行代码中的<code>retrieve_url</code>函数，当作为上下文管理器使用的时候，<code>patch</code>会返回一个<code>MagicMock</code>对象，<code>MagicMock</code>是<code>Mock</code>的子类(关于<code>Mock</code>在下一节会介绍)。</p>\n<p>经过<code>patch</code>后，在上下文作用域里面，<code>retireve_url</code>就已经被替换了，因此我们接下来只需要模拟该函数在正常情况下以及非正常情况下的运行结果就行了。</p>\n<ol>\n<li>第一个<code>with</code>语句中，我们设置了<code>mocked_retrieve.return_value = &#39;{&quot;a&quot;:1,&quot;b&quot;:[1,3,4]}&#39;</code>，即当该mock对象被调用的时候(执行<code>content = retrieve_url(url)</code>的时候)将返回我们设置的属性<code>return_value</code>的值，此处即一个<code>json</code>字符串。</li>\n<li>第二个<code>with</code>语句中，我们设置了<code>mocked_retrieve.side_effect = requests.exceptions.ConnectionError(&#39;Connection Error&#39;)</code>，在<code>mock</code>被调用的时候将抛出<code>ConnectionError</code>以测试异常捕获相关代码，与<code>return_value</code>只能设置成一个值不同，<code>side_effect</code>支持赋值一个函数、一个迭代器或者一个异常(类或对象)。<ul>\n<li>函数: 函数将接收与被mock对象相同的参数(如果函数返回<code>mock.DEFAULT</code>对象或者不设置函数，<code>mock</code>对象将会返回<code>return_value</code>)</li>\n<li>迭代器: 在每次<code>mock</code>被调用的时候，将依次逐个返回迭代器中的值</li>\n<li>异常: 调用<code>mock</code>的时候将抛出指定异常</li>\n</ul>\n</li>\n</ol>\n<div class=\"tip\"><br>当<code>patch</code>作为函数装饰器使用的时候，被创建的<code>MagicMock</code>对象将会作为额外参数传给被装饰函数。(关键字参数new没有被指定的情况下)<br></div>\n\n<h1 id=\"Mock\"><a href=\"#Mock\" class=\"headerlink\" title=\"Mock\"></a>Mock</h1><p>前文已经提到了<code>Mock</code>与<code>MagicMock</code>，那么它们到底有什么作用呢？</p>\n<p>简单来说，<code>Mock</code>是一类特殊的对象，当访问该类对象上任意不存在的属性的时候，该属性将被自动创建，且该属性也是<code>Mock</code>对象，来看一个小例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> unittest.mock <span class=\"keyword\">import</span> Mock</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m = Mock()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.foo</span><br><span class=\"line\">&lt;Mock name=<span class=\"string\">'mock.foo'</span> id=<span class=\"string\">'4404473248'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.bar.return_value = <span class=\"string\">'hello mock'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(m.bar())</span><br><span class=\"line\"><span class=\"string\">'hello mock'</span></span><br></pre></td></tr></table></figure>\n<p><code>m</code>是一个<code>Mock</code>对象，当访问<code>m</code>的<code>foo</code>属性时，一个新的<code>Mock</code>对象被创建了，我们可以使用链式调用来给<code>Mock</code>对象添加任意属性，以及设置调用返回值。</p>\n<p>官方文档中给出的<code>Mock</code>的创建参数如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class unittest.mock.Mock(spec=None, side_effect=None, return_value=DEFAULT, wraps=None, name=None, spec_set=None, unsafe=False, **kwargs)</span><br></pre></td></tr></table></figure>\n<p>在实际使用中，目前就使用到了前三者<code>spec</code>、<code>side_effect</code>、<code>return_value</code>，后两者在前文已经介绍到了，这里简单介绍下<code>spec</code>参数，该参数用来限制可以被<code>Mock</code>的属性的范围，<code>spec</code>可以是多个字符串的列表或者一个已存在的对象(类或实例)，当访问<code>spec</code>参数指定属性以外属性的时候将抛出<code>AttributeError</code>。</p>\n<p><code>MagicMock</code>是<code>Mock</code>的子类，因此其拥有所有父类的表现，除此之外，使用该子类允许我们很方便的对<code>magic methods</code>进行设置，例如:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> unittest.mock <span class=\"keyword\">import</span> MagicMock</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m = MagicMock()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.__str__.return_value = <span class=\"string\">'hello mock'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(m)</span><br><span class=\"line\">hello mock</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法与属性\"><a href=\"#方法与属性\" class=\"headerlink\" title=\"方法与属性\"></a>方法与属性</h2><p><code>Mock</code>对象实现了很多有用的方法以及属性方便开发者在进行单元测试时使用。</p>\n<ul>\n<li><p><code>assert_called</code>: 用来检验<code>Mock</code>对象至少有一次被调用</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mock = Mock()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mock.method()</span><br><span class=\"line\">&lt;Mock name=<span class=\"string\">'mock.method()'</span> id=<span class=\"string\">'...'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mock.method.assert_called()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>assert_called_once</code>: 用来检验<code>Mock</code>对象恰好有一次被调用</p>\n</li>\n<li><p><code>call_count</code>: 用来表示<code>Mock</code>被调用次数</p>\n <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mock = Mock(return_value=<span class=\"keyword\">None</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mock.call_count</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mock()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mock()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mock.call_count</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>…</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在最近开发的项目中进行了单元测试，在测试过程中使用到了<code>Python 3.3</code>中加入到标准库的<code>mock</code>库(<code>unittest.mock</code>)，因此将使用心得整理成一篇博文。</p>","more":"<p><code>mock</code>是一个Python中帮助用来提高单元测试效率的工具，在<code>Python 3.3</code>之前需要自行安装，<code>Python 3.3</code>将<code>mock</code>引入了标准库。单元测试的基本思想是测试逻辑集中的一小段函数，但是在实际编程中，随着开发的进行，可能函数之间有相互调用，对当前函数的单元测试不应该受到被调用函数的影响，因此如何屏蔽掉调用函数的影响而单独测试当前函数是必要的，原因有很多:</p>\n<ul>\n<li>被调用函数的调用可能产生不必要的问题，如调用生产接口</li>\n<li>被调用函数的调用过程可能是复杂的，普通的调用无法覆盖所有可能发生的结果</li>\n<li>被调用函数的调用条件比较复杂，如需额外搭建服务器等</li>\n</ul>\n<p>以上种种，都会使得单元测试的开发效率降低，因此，<code>Python 3.3</code>引入了<code>mock</code>来简化这些问题。让我们首先来看一个小例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">retrieve_url</span><span class=\"params\">(url)</span>:</span></span><br><span class=\"line\">    resp = requests.get(url)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resp.content</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">download_and_parse_json</span><span class=\"params\">(url)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        content = retrieve_url(url)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'[ERROR] '</span> + str(e)</span><br><span class=\"line\">    data = json.loads(content)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data</span><br><span class=\"line\"></span><br><span class=\"line\">json_url = <span class=\"string\">'http://www.foo.com/bar'</span>  <span class=\"comment\"># Return json response</span></span><br><span class=\"line\"></span><br><span class=\"line\">data = download_and_parse_json(json_url)</span><br><span class=\"line\">print(<span class=\"string\">'Parsed:'</span>, data)</span><br></pre></td></tr></table></figure>\n<p>这段代码中我们编写了两个函数，一个是用来请求url获取响应的函数<code>retrieve_url</code>，一个用来下载url内容并尝试解析为<code>json</code>格式函数<code>download_and_parse_json</code>，假设我们有一个链接<code>json_url</code>，该链接正常情况下应该返回一个包含<code>json</code>数据的响应，但是在各种环境因素的作用下(网络通信中断，服务器宕机，接口失效)，也可能出现访问失败的情况，因此我们的第二个函数加入了简单的异常处理，在正常情况下返回解析的<code>json</code>字典，异常情况下返回错误信息。</p>\n<h1 id=\"patch\"><a href=\"#patch\" class=\"headerlink\" title=\"patch\"></a>patch</h1><p>如果我们想在开发过程中对该函数(<code>download_and_parse_json</code>)进行单元测试，由于<code>json_url</code>对应的接口可能存在前文所说的各种可能原因，因此我们想模拟该部分操作，返回一个<code>json</code>格式的字符串或者抛出一个异常，这时候<code>mock</code>模块就派上用场了:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> unittest.mock <span class=\"keyword\">import</span> patch</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">retrieve_url</span><span class=\"params\">(url)</span>:</span></span><br><span class=\"line\">    resp = requests.get(url)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resp.content</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">download_and_parse_json</span><span class=\"params\">(url)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        content = retrieve_url(url)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'[ERROR] '</span> + str(e)</span><br><span class=\"line\">    data = json.loads(content)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data</span><br><span class=\"line\"></span><br><span class=\"line\">json_url = <span class=\"string\">'http://www.foo.com/bar'</span>  <span class=\"comment\"># Return json response</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> patch(<span class=\"string\">'__main__.retrieve_url'</span>) <span class=\"keyword\">as</span> mocked_retrieve:</span><br><span class=\"line\">    mocked_retrieve.return_value = <span class=\"string\">'&#123;\"a\":1,\"b\":[1,3,4]&#125;'</span></span><br><span class=\"line\">    data = download_and_parse_json(json_url)</span><br><span class=\"line\">    print(<span class=\"string\">'Parsed:'</span>, data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> patch(<span class=\"string\">'__main__.retrieve_url'</span>) <span class=\"keyword\">as</span> mocked_retrieve:</span><br><span class=\"line\">    mocked_retrieve.side_effect = requests.exceptions.ConnectionError(</span><br><span class=\"line\">        <span class=\"string\">'Connection Error'</span>)</span><br><span class=\"line\">    data = download_and_parse_json(json_url)</span><br><span class=\"line\">    print(<span class=\"string\">'Parsed:'</span>, data)</span><br></pre></td></tr></table></figure>\n<p>注意该段代码和前一段代码的区别，我们首先从<code>unittest.mock</code>导入了<code>patch</code>，<code>patch</code>可作为函数装饰器、类装饰器、上下文管理器使用，而此处我们使用了第三种形式——上下文管理器。<code>patch</code>函数至少接收一个参数，即需要模拟的对象的导入路径，如<code>package.module.ClassName</code>，此处我们使用了<code>__main__.retrieve_url</code>指示了顶层执行代码中的<code>retrieve_url</code>函数，当作为上下文管理器使用的时候，<code>patch</code>会返回一个<code>MagicMock</code>对象，<code>MagicMock</code>是<code>Mock</code>的子类(关于<code>Mock</code>在下一节会介绍)。</p>\n<p>经过<code>patch</code>后，在上下文作用域里面，<code>retireve_url</code>就已经被替换了，因此我们接下来只需要模拟该函数在正常情况下以及非正常情况下的运行结果就行了。</p>\n<ol>\n<li>第一个<code>with</code>语句中，我们设置了<code>mocked_retrieve.return_value = &#39;{&quot;a&quot;:1,&quot;b&quot;:[1,3,4]}&#39;</code>，即当该mock对象被调用的时候(执行<code>content = retrieve_url(url)</code>的时候)将返回我们设置的属性<code>return_value</code>的值，此处即一个<code>json</code>字符串。</li>\n<li>第二个<code>with</code>语句中，我们设置了<code>mocked_retrieve.side_effect = requests.exceptions.ConnectionError(&#39;Connection Error&#39;)</code>，在<code>mock</code>被调用的时候将抛出<code>ConnectionError</code>以测试异常捕获相关代码，与<code>return_value</code>只能设置成一个值不同，<code>side_effect</code>支持赋值一个函数、一个迭代器或者一个异常(类或对象)。<ul>\n<li>函数: 函数将接收与被mock对象相同的参数(如果函数返回<code>mock.DEFAULT</code>对象或者不设置函数，<code>mock</code>对象将会返回<code>return_value</code>)</li>\n<li>迭代器: 在每次<code>mock</code>被调用的时候，将依次逐个返回迭代器中的值</li>\n<li>异常: 调用<code>mock</code>的时候将抛出指定异常</li>\n</ul>\n</li>\n</ol>\n<div class=\"tip\"><br>当<code>patch</code>作为函数装饰器使用的时候，被创建的<code>MagicMock</code>对象将会作为额外参数传给被装饰函数。(关键字参数new没有被指定的情况下)<br></div>\n\n<h1 id=\"Mock\"><a href=\"#Mock\" class=\"headerlink\" title=\"Mock\"></a>Mock</h1><p>前文已经提到了<code>Mock</code>与<code>MagicMock</code>，那么它们到底有什么作用呢？</p>\n<p>简单来说，<code>Mock</code>是一类特殊的对象，当访问该类对象上任意不存在的属性的时候，该属性将被自动创建，且该属性也是<code>Mock</code>对象，来看一个小例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> unittest.mock <span class=\"keyword\">import</span> Mock</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m = Mock()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.foo</span><br><span class=\"line\">&lt;Mock name=<span class=\"string\">'mock.foo'</span> id=<span class=\"string\">'4404473248'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.bar.return_value = <span class=\"string\">'hello mock'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(m.bar())</span><br><span class=\"line\"><span class=\"string\">'hello mock'</span></span><br></pre></td></tr></table></figure>\n<p><code>m</code>是一个<code>Mock</code>对象，当访问<code>m</code>的<code>foo</code>属性时，一个新的<code>Mock</code>对象被创建了，我们可以使用链式调用来给<code>Mock</code>对象添加任意属性，以及设置调用返回值。</p>\n<p>官方文档中给出的<code>Mock</code>的创建参数如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class unittest.mock.Mock(spec=None, side_effect=None, return_value=DEFAULT, wraps=None, name=None, spec_set=None, unsafe=False, **kwargs)</span><br></pre></td></tr></table></figure>\n<p>在实际使用中，目前就使用到了前三者<code>spec</code>、<code>side_effect</code>、<code>return_value</code>，后两者在前文已经介绍到了，这里简单介绍下<code>spec</code>参数，该参数用来限制可以被<code>Mock</code>的属性的范围，<code>spec</code>可以是多个字符串的列表或者一个已存在的对象(类或实例)，当访问<code>spec</code>参数指定属性以外属性的时候将抛出<code>AttributeError</code>。</p>\n<p><code>MagicMock</code>是<code>Mock</code>的子类，因此其拥有所有父类的表现，除此之外，使用该子类允许我们很方便的对<code>magic methods</code>进行设置，例如:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> unittest.mock <span class=\"keyword\">import</span> MagicMock</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m = MagicMock()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m.__str__.return_value = <span class=\"string\">'hello mock'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>print(m)</span><br><span class=\"line\">hello mock</span><br></pre></td></tr></table></figure>\n<h2 id=\"方法与属性\"><a href=\"#方法与属性\" class=\"headerlink\" title=\"方法与属性\"></a>方法与属性</h2><p><code>Mock</code>对象实现了很多有用的方法以及属性方便开发者在进行单元测试时使用。</p>\n<ul>\n<li><p><code>assert_called</code>: 用来检验<code>Mock</code>对象至少有一次被调用</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mock = Mock()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mock.method()</span><br><span class=\"line\">&lt;Mock name=<span class=\"string\">'mock.method()'</span> id=<span class=\"string\">'...'</span>&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mock.method.assert_called()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>assert_called_once</code>: 用来检验<code>Mock</code>对象恰好有一次被调用</p>\n</li>\n<li><p><code>call_count</code>: 用来表示<code>Mock</code>被调用次数</p>\n <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mock = Mock(return_value=<span class=\"keyword\">None</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mock.call_count</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mock()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mock()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mock.call_count</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>…</p>\n</li>\n</ul>"},{"title":"机器学习算法之监督学习算法KNN(K近邻)","date":"2017-10-22T14:07:40.000Z","_content":"今天在学院论坛里面写了关于KNN的一篇解释，顺手就转到自己博客了，毕竟这都又是3个月没更新了，感觉自己学了很多但是就是太懒，不想记下来，这个习惯还是得改改。\n\n<!-- more -->\n\n## Python\n\n首先是原始代码，已经写好非核心代码，只需要补充`L1`、`L2`、`knn`三个函数。\n\n```Python\n#!/usr/bin/env python3\n# coding: UTF-8\n# Author: David\n# Email: youchen.du@gmail.com\n# Created: 2017-10-21 13:06\n# Last modified: 2017-10-21 13:53\n# Filename: knn.py\n# Description:\nimport numpy as np\n\n# ===============================================\n# For reproducibility, DO NOT CHANGE THIS SECTION\nnp.random.seed(1111)\n\nM1 = 500\nM2 = 50\nN = 1024\nS = 10\n\ntrain_x = S * np.random.randn(M1, N)\ntrain_y = np.random.randint(0, 10, M1)\ntest_x = S * np.random.randn(M2, N)\ntarget_l1_y = [\n    4, 4, 9, 9, 6, 4, 9, 5, 3, 2, 9, 4,\n    4, 8, 8, 9, 6, 6, 5, 9, 7, 1, 6, 0,\n    9, 8, 9, 9, 2, 6, 2, 3, 0, 3, 0, 4,\n    1, 9, 8, 2, 2, 4, 2, 1, 2, 4, 7, 3,\n    1, 9]\ntarget_l2_y = [\n    5, 4, 0, 2, 6, 4, 1, 0, 3, 2, 9, 3,\n    9, 1, 8, 9, 1, 0, 0, 9, 7, 1, 6, 0,\n    9, 3, 9, 2, 9, 7, 2, 8, 0, 3, 4, 6,\n    1, 1, 9, 6, 6, 4, 2, 9, 2, 3, 9, 6,\n    1, 5]\n# ==============================================\n\n\ndef L1(x1, x2):\n    # ===================\n    # TODO: Calculate the L1 distance between x1 and x2.\n    # Your code goes here\n    # L1 distance\n    # ===================\n    pass\n\n\ndef L2(x1, x2):\n    # ===================\n    # TODO: Calculate the L2 distance between x1 and x2.\n    # Your code goes here\n    # L2 distance\n    # ===================\n    pass\n\n\ndef knn(train_x, train_y, test_x, sim_func=None, K=10):\n    assert sim_func is not None\n    test_y = np.zeros(M2).astype(int)\n    # TODO:\n    # Instructions:\n    # 1. For each sample(x1) in test_x\n    # 2. Calculate similarity between each sample in train_x and x1\n    # 3. Using the K nearest neighbors to vote for x1\n    # 4. assign y1 to test_y[idx]\n    # -----------\n    # Please Note test_y is a numpy vector, For i-th example in test_x, you\n    # can do like this:\n    # test_y[i] = yi\n    # ===================\n    # Your code goes here\n    # ===================\n    return test_y\n\n\ndef accuracy(output, target):\n    return np.count_nonzero(np.equal(output, target)) / len(output)\n\n\ndef evaluate(func, target):\n    print('Evaluating with your implementation of '\n          '{} distance'.format(func.__name__))\n    test_y = knn(train_x, train_y, test_x, func)\n    acc = accuracy(test_y, target)\n    print('Accuracy: {:.2%}'.format(acc))\n    if np.abs(acc - 1) < 1e-5:\n        print('Conguratulations, Your implementation is correct')\n    else:\n        print('There are some bugs in your implementation, Please check again')\n    print()\n\n\ndef main():\n    evaluate(L1, target_l1_y)\n    evaluate(L2, target_l2_y)\n\n\nif __name__ == '__main__':\n    main()\n\n```\n\n有几点需要注意(对首次接触Python的人):\n\n* Python中以`#`开头的行都是注释，不对程序产生任何影响\n* 与C不同，Python是一门解释型语言，所以大家如果执行一个`.py`文件，解释器会从上到下依次执行语句，如果`.py`文件中只包含了类似`def func(x)`的定义代码，那么执行该文件仅会定义这些函数然后退出，所以如果`.py`文件里面有需要执行的语句，比如使用`print`打印一些内容，则可以直接像这么写:\n\n```Python\n# 该段代码首先定义了一个`hello`函数，该函数接收一个参数`name`，\n# 然后函数的作用是打印'hello, <name>'，最后执行`hello`函数\ndef hello(name):\n    print('hello', name)\n\nhello('david')\n```\n\n* 另外，直接执行一个`.py`文件时，被执行文件的`if __name__ == '__main__':`判断将会为真，在该示例中即会调用`main`函数。\n\n以上是需要注意的几点，具体的Python的语法由于篇幅关系，不再赘述。\n\n## KNN\n\nKNN，即K近邻，是一个监督学习算法，算法本身并不复杂，其基本流程是:\n\n1. 假设给定包含$ M $个样本的训练集$ X\\_{train} $，每个样本包含$ N $个特征，以及对应的类别标签$ Y\\_{train} $，则$ X\\_{train} $可以用一个$ M \\times N $的二维矩阵表示, $ Y\\_{train} $可以用一个$ M \\times 1 $的二维矩阵表示\n\n$$\nX\\_{train} = \\begin{bmatrix}\nX\\_1^0 & X\\_1^1 &  ... &  X\\_1^n \\\\\\\\\nX\\_2^0 & X\\_2^1 &  ... &  X\\_2^n \\\\\\\\\n... & ... & ... & ... \\\\\\\\\nX\\_M^0 & X\\_M^1 &  ... &  X\\_M^n \\\\\\\\\n\\end{bmatrix}\nY\\_{train} = \\begin{bmatrix}\nY\\_0 \\\\\\\\ Y\\_1 \\\\\\\\ ... \\\\\\\\ Y\\_M\n\\end{bmatrix}\n$$\n\n2. 对于一个需要计算的新样本$ X $，计算其类别：\n    1. 计算该样本$ X $与训练集$ X\\_{train} $中每个样本$ X\\_i $的距离$ D\\_i $(不同距离函数计算的距离不同，因此效果也会不同)\n    2. 在所有距离中取距离最小的前$ K $个样本的类别标签，根据$ K $个标签中出现次数最多的标签来确定样本$ X $的标签\n\n## 距离函数\n\n首先我们需要定义一些距离函数来衡量两个样本特征之间的相似度，常用的有L1距离、L2距离等。\n\n### L1 distance\n\n假设样本$ X_1 $有$ X_1^0, X_1^1, ..., X_1^n $特征，其与样本$ X_2 $之间的L1距离可以用以下公式计算:\n\n$$ L1(X_1, X_2) = \\left|X_1^0 - X_2^0\\right| + \\left|X_1^1 - X_2^1\\right| + ... + \\left|X_1^n - X_2^n\\right| $$\n\nL1函数代码示例:\n\n```Python\ndef L1(x1, x2):\n    # x1和x2都是向量，x1 - x2为每个特征相减\n    # np.abs为每个结果求绝对值\n    # np.sum将所有绝对值求和\n    return np.sum(np.abs(x1 - x2))\n```\n\n### L2 distance\n\nL2距离即为特征差的平方求和开方，即:\n\n$$ L2(X_1, X_2) = \\sqrt{(X_1^0 -  X_2^0)^2 + (X_1^1 -  X_2^1)^2 + ... + (X_1^n -  X_2^n)^2} $$\n\nL2函数代码示例:\n\n```Python\ndef L2(x1, x2):\n    # (x1 - x2) ** 2 为特征差的平方\n    # np.sum进行求和运算\n    # np.sqrt进行开方运算\n    return np.sqrt(np.sum((x1 - x2) ** 2))\n```\n\n## KNN代码\n\n由于前面已经介绍过KNN的算法流程了，在此处直接给出实现代码(此处的代码并不是最优的，有其他优化方式，有兴趣的可以自己研究)，代码给出了详细注释。\n\n```Python\ndef knn(train_x, train_y, test_x, sim_func=None, K=10):\n    # 防御性编程，忽略\n    assert sim_func is not None\n    # 声明结果存储的空间，所有元素初始化为0\n    test_y = np.zeros(M2).astype(int)\n    # 遍历每一个test_x中的样本，enumerate函数使得在遍历的同时返回其遍历序号，默认idx以0开始\n    for idx, X1 in enumerate(test_x):\n        # 我们需要一个列表来存储所有计算的距离值\n        neighbors = []\n        # 遍历每一个train_x中的样本，zip函数可以对多个序列进行遍历，\n        # 因此我们可以很方便的同时得到train_x中的X1的特征以及它对应的标签\n        for X2, Y2 in zip(train_x, train_y):\n            # 使用距离函数sim_func计算样本X1和X2的距离dis\n            dis = sim_func(X1, X2)\n            # 我们将距离和标签以Python元组的形式(dis, Y2)放入前面声明的列表中\n            neighbors.append((dis, Y2))\n        # 对neighbors列表中的所有元组进行排序，\n        # 比较关键字key使用了每个元组中的第0个元素即(dis, Y2)中的dis\n        # 这样我们得到了一个dis从小到大排列的列表\n        neighbors.sort(key=lambda x: x[0])\n        # 使用Python的切片功能我们保留neighbors的前K个元素(即dis最小的前K个)\n        neighbors = neighbors[:K]\n        # 声明一个字典votes\n        votes = {}\n        # 遍历neighbors中的K个元素\n        for dis, label in neighbors:\n            # 如果当前遍历到的标签label不在字典votes中\n            # setdefault函数将会将其加入字典中，并将其值置为0\n            # 如果标签在label中，setdefault函数不做任何处理\n            votes.setdefault(label, 0)\n            # 标签label计数加1\n            votes[label] += 1\n        # votes.items()方法返回一个列表(实际是一个迭代器，可以先忽略)，\n        # 其形式为(label, count)，即标签和它出现的次数\n        # max函数用来找到这个列表中最大的那个元素(即我们要的出现最多次的元素)\n        # 比较关键字在此处为x[1]，即(label, count)中的count\n        # 最后max函数返回了一个(label, count)，该对象是出现次数最多的，我们用下标[0]访问即可得到该标签，\n        # 最后将该标签赋值给test_y[idx]，完成！\n        test_y[idx] = max(votes.items(), key=lambda x: x[1])[0]\n    return test_y\n```\n\n最后保存并执行，即可得到预期结果\n\n```sh\n$ python3 knn.py\nEvaluating with your implementation of L1 distance\nAccuracy: 100.00%\nConguratulations, Your implementation is correct\n\nEvaluating with your implementation of L2 distance\nAccuracy: 100.00%\nConguratulations, Your implementation is correct\n```\n\n至此，一个简单的KNN算法工作完毕。","source":"_posts/kNN.md","raw":"---\ntitle: 机器学习算法之监督学习算法KNN(K近邻)\ndate: 2017-10-22 22:07:40\ntags: [机器学习,监督学习,KNN]\ncategories: 机器学习\n---\n今天在学院论坛里面写了关于KNN的一篇解释，顺手就转到自己博客了，毕竟这都又是3个月没更新了，感觉自己学了很多但是就是太懒，不想记下来，这个习惯还是得改改。\n\n<!-- more -->\n\n## Python\n\n首先是原始代码，已经写好非核心代码，只需要补充`L1`、`L2`、`knn`三个函数。\n\n```Python\n#!/usr/bin/env python3\n# coding: UTF-8\n# Author: David\n# Email: youchen.du@gmail.com\n# Created: 2017-10-21 13:06\n# Last modified: 2017-10-21 13:53\n# Filename: knn.py\n# Description:\nimport numpy as np\n\n# ===============================================\n# For reproducibility, DO NOT CHANGE THIS SECTION\nnp.random.seed(1111)\n\nM1 = 500\nM2 = 50\nN = 1024\nS = 10\n\ntrain_x = S * np.random.randn(M1, N)\ntrain_y = np.random.randint(0, 10, M1)\ntest_x = S * np.random.randn(M2, N)\ntarget_l1_y = [\n    4, 4, 9, 9, 6, 4, 9, 5, 3, 2, 9, 4,\n    4, 8, 8, 9, 6, 6, 5, 9, 7, 1, 6, 0,\n    9, 8, 9, 9, 2, 6, 2, 3, 0, 3, 0, 4,\n    1, 9, 8, 2, 2, 4, 2, 1, 2, 4, 7, 3,\n    1, 9]\ntarget_l2_y = [\n    5, 4, 0, 2, 6, 4, 1, 0, 3, 2, 9, 3,\n    9, 1, 8, 9, 1, 0, 0, 9, 7, 1, 6, 0,\n    9, 3, 9, 2, 9, 7, 2, 8, 0, 3, 4, 6,\n    1, 1, 9, 6, 6, 4, 2, 9, 2, 3, 9, 6,\n    1, 5]\n# ==============================================\n\n\ndef L1(x1, x2):\n    # ===================\n    # TODO: Calculate the L1 distance between x1 and x2.\n    # Your code goes here\n    # L1 distance\n    # ===================\n    pass\n\n\ndef L2(x1, x2):\n    # ===================\n    # TODO: Calculate the L2 distance between x1 and x2.\n    # Your code goes here\n    # L2 distance\n    # ===================\n    pass\n\n\ndef knn(train_x, train_y, test_x, sim_func=None, K=10):\n    assert sim_func is not None\n    test_y = np.zeros(M2).astype(int)\n    # TODO:\n    # Instructions:\n    # 1. For each sample(x1) in test_x\n    # 2. Calculate similarity between each sample in train_x and x1\n    # 3. Using the K nearest neighbors to vote for x1\n    # 4. assign y1 to test_y[idx]\n    # -----------\n    # Please Note test_y is a numpy vector, For i-th example in test_x, you\n    # can do like this:\n    # test_y[i] = yi\n    # ===================\n    # Your code goes here\n    # ===================\n    return test_y\n\n\ndef accuracy(output, target):\n    return np.count_nonzero(np.equal(output, target)) / len(output)\n\n\ndef evaluate(func, target):\n    print('Evaluating with your implementation of '\n          '{} distance'.format(func.__name__))\n    test_y = knn(train_x, train_y, test_x, func)\n    acc = accuracy(test_y, target)\n    print('Accuracy: {:.2%}'.format(acc))\n    if np.abs(acc - 1) < 1e-5:\n        print('Conguratulations, Your implementation is correct')\n    else:\n        print('There are some bugs in your implementation, Please check again')\n    print()\n\n\ndef main():\n    evaluate(L1, target_l1_y)\n    evaluate(L2, target_l2_y)\n\n\nif __name__ == '__main__':\n    main()\n\n```\n\n有几点需要注意(对首次接触Python的人):\n\n* Python中以`#`开头的行都是注释，不对程序产生任何影响\n* 与C不同，Python是一门解释型语言，所以大家如果执行一个`.py`文件，解释器会从上到下依次执行语句，如果`.py`文件中只包含了类似`def func(x)`的定义代码，那么执行该文件仅会定义这些函数然后退出，所以如果`.py`文件里面有需要执行的语句，比如使用`print`打印一些内容，则可以直接像这么写:\n\n```Python\n# 该段代码首先定义了一个`hello`函数，该函数接收一个参数`name`，\n# 然后函数的作用是打印'hello, <name>'，最后执行`hello`函数\ndef hello(name):\n    print('hello', name)\n\nhello('david')\n```\n\n* 另外，直接执行一个`.py`文件时，被执行文件的`if __name__ == '__main__':`判断将会为真，在该示例中即会调用`main`函数。\n\n以上是需要注意的几点，具体的Python的语法由于篇幅关系，不再赘述。\n\n## KNN\n\nKNN，即K近邻，是一个监督学习算法，算法本身并不复杂，其基本流程是:\n\n1. 假设给定包含$ M $个样本的训练集$ X\\_{train} $，每个样本包含$ N $个特征，以及对应的类别标签$ Y\\_{train} $，则$ X\\_{train} $可以用一个$ M \\times N $的二维矩阵表示, $ Y\\_{train} $可以用一个$ M \\times 1 $的二维矩阵表示\n\n$$\nX\\_{train} = \\begin{bmatrix}\nX\\_1^0 & X\\_1^1 &  ... &  X\\_1^n \\\\\\\\\nX\\_2^0 & X\\_2^1 &  ... &  X\\_2^n \\\\\\\\\n... & ... & ... & ... \\\\\\\\\nX\\_M^0 & X\\_M^1 &  ... &  X\\_M^n \\\\\\\\\n\\end{bmatrix}\nY\\_{train} = \\begin{bmatrix}\nY\\_0 \\\\\\\\ Y\\_1 \\\\\\\\ ... \\\\\\\\ Y\\_M\n\\end{bmatrix}\n$$\n\n2. 对于一个需要计算的新样本$ X $，计算其类别：\n    1. 计算该样本$ X $与训练集$ X\\_{train} $中每个样本$ X\\_i $的距离$ D\\_i $(不同距离函数计算的距离不同，因此效果也会不同)\n    2. 在所有距离中取距离最小的前$ K $个样本的类别标签，根据$ K $个标签中出现次数最多的标签来确定样本$ X $的标签\n\n## 距离函数\n\n首先我们需要定义一些距离函数来衡量两个样本特征之间的相似度，常用的有L1距离、L2距离等。\n\n### L1 distance\n\n假设样本$ X_1 $有$ X_1^0, X_1^1, ..., X_1^n $特征，其与样本$ X_2 $之间的L1距离可以用以下公式计算:\n\n$$ L1(X_1, X_2) = \\left|X_1^0 - X_2^0\\right| + \\left|X_1^1 - X_2^1\\right| + ... + \\left|X_1^n - X_2^n\\right| $$\n\nL1函数代码示例:\n\n```Python\ndef L1(x1, x2):\n    # x1和x2都是向量，x1 - x2为每个特征相减\n    # np.abs为每个结果求绝对值\n    # np.sum将所有绝对值求和\n    return np.sum(np.abs(x1 - x2))\n```\n\n### L2 distance\n\nL2距离即为特征差的平方求和开方，即:\n\n$$ L2(X_1, X_2) = \\sqrt{(X_1^0 -  X_2^0)^2 + (X_1^1 -  X_2^1)^2 + ... + (X_1^n -  X_2^n)^2} $$\n\nL2函数代码示例:\n\n```Python\ndef L2(x1, x2):\n    # (x1 - x2) ** 2 为特征差的平方\n    # np.sum进行求和运算\n    # np.sqrt进行开方运算\n    return np.sqrt(np.sum((x1 - x2) ** 2))\n```\n\n## KNN代码\n\n由于前面已经介绍过KNN的算法流程了，在此处直接给出实现代码(此处的代码并不是最优的，有其他优化方式，有兴趣的可以自己研究)，代码给出了详细注释。\n\n```Python\ndef knn(train_x, train_y, test_x, sim_func=None, K=10):\n    # 防御性编程，忽略\n    assert sim_func is not None\n    # 声明结果存储的空间，所有元素初始化为0\n    test_y = np.zeros(M2).astype(int)\n    # 遍历每一个test_x中的样本，enumerate函数使得在遍历的同时返回其遍历序号，默认idx以0开始\n    for idx, X1 in enumerate(test_x):\n        # 我们需要一个列表来存储所有计算的距离值\n        neighbors = []\n        # 遍历每一个train_x中的样本，zip函数可以对多个序列进行遍历，\n        # 因此我们可以很方便的同时得到train_x中的X1的特征以及它对应的标签\n        for X2, Y2 in zip(train_x, train_y):\n            # 使用距离函数sim_func计算样本X1和X2的距离dis\n            dis = sim_func(X1, X2)\n            # 我们将距离和标签以Python元组的形式(dis, Y2)放入前面声明的列表中\n            neighbors.append((dis, Y2))\n        # 对neighbors列表中的所有元组进行排序，\n        # 比较关键字key使用了每个元组中的第0个元素即(dis, Y2)中的dis\n        # 这样我们得到了一个dis从小到大排列的列表\n        neighbors.sort(key=lambda x: x[0])\n        # 使用Python的切片功能我们保留neighbors的前K个元素(即dis最小的前K个)\n        neighbors = neighbors[:K]\n        # 声明一个字典votes\n        votes = {}\n        # 遍历neighbors中的K个元素\n        for dis, label in neighbors:\n            # 如果当前遍历到的标签label不在字典votes中\n            # setdefault函数将会将其加入字典中，并将其值置为0\n            # 如果标签在label中，setdefault函数不做任何处理\n            votes.setdefault(label, 0)\n            # 标签label计数加1\n            votes[label] += 1\n        # votes.items()方法返回一个列表(实际是一个迭代器，可以先忽略)，\n        # 其形式为(label, count)，即标签和它出现的次数\n        # max函数用来找到这个列表中最大的那个元素(即我们要的出现最多次的元素)\n        # 比较关键字在此处为x[1]，即(label, count)中的count\n        # 最后max函数返回了一个(label, count)，该对象是出现次数最多的，我们用下标[0]访问即可得到该标签，\n        # 最后将该标签赋值给test_y[idx]，完成！\n        test_y[idx] = max(votes.items(), key=lambda x: x[1])[0]\n    return test_y\n```\n\n最后保存并执行，即可得到预期结果\n\n```sh\n$ python3 knn.py\nEvaluating with your implementation of L1 distance\nAccuracy: 100.00%\nConguratulations, Your implementation is correct\n\nEvaluating with your implementation of L2 distance\nAccuracy: 100.00%\nConguratulations, Your implementation is correct\n```\n\n至此，一个简单的KNN算法工作完毕。","slug":"kNN","published":1,"updated":"2018-01-15T01:16:38.647Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgvnqmlf001iw628gcrek6c8","content":"<p>今天在学院论坛里面写了关于KNN的一篇解释，顺手就转到自己博客了，毕竟这都又是3个月没更新了，感觉自己学了很多但是就是太懒，不想记下来，这个习惯还是得改改。</p>\n<a id=\"more\"></a>\n<h2 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h2><p>首先是原始代码，已经写好非核心代码，只需要补充<code>L1</code>、<code>L2</code>、<code>knn</code>三个函数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python3</span></span><br><span class=\"line\"><span class=\"comment\"># coding: UTF-8</span></span><br><span class=\"line\"><span class=\"comment\"># Author: David</span></span><br><span class=\"line\"><span class=\"comment\"># Email: youchen.du@gmail.com</span></span><br><span class=\"line\"><span class=\"comment\"># Created: 2017-10-21 13:06</span></span><br><span class=\"line\"><span class=\"comment\"># Last modified: 2017-10-21 13:53</span></span><br><span class=\"line\"><span class=\"comment\"># Filename: knn.py</span></span><br><span class=\"line\"><span class=\"comment\"># Description:</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ===============================================</span></span><br><span class=\"line\"><span class=\"comment\"># For reproducibility, DO NOT CHANGE THIS SECTION</span></span><br><span class=\"line\">np.random.seed(<span class=\"number\">1111</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">M1 = <span class=\"number\">500</span></span><br><span class=\"line\">M2 = <span class=\"number\">50</span></span><br><span class=\"line\">N = <span class=\"number\">1024</span></span><br><span class=\"line\">S = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\">train_x = S * np.random.randn(M1, N)</span><br><span class=\"line\">train_y = np.random.randint(<span class=\"number\">0</span>, <span class=\"number\">10</span>, M1)</span><br><span class=\"line\">test_x = S * np.random.randn(M2, N)</span><br><span class=\"line\">target_l1_y = [</span><br><span class=\"line\">    <span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">9</span>, <span class=\"number\">6</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">4</span>,</span><br><span class=\"line\">    <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">6</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">6</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>,</span><br><span class=\"line\">    <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">3</span>,</span><br><span class=\"line\">    <span class=\"number\">1</span>, <span class=\"number\">9</span>]</span><br><span class=\"line\">target_l2_y = [</span><br><span class=\"line\">    <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>,</span><br><span class=\"line\">    <span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">9</span>, <span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">6</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>,</span><br><span class=\"line\">    <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">6</span>, <span class=\"number\">6</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">9</span>, <span class=\"number\">6</span>,</span><br><span class=\"line\">    <span class=\"number\">1</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"comment\"># ==============================================</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">L1</span><span class=\"params\">(x1, x2)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># ===================</span></span><br><span class=\"line\">    <span class=\"comment\"># <span class=\"doctag\">TODO:</span> Calculate the L1 distance between x1 and x2.</span></span><br><span class=\"line\">    <span class=\"comment\"># Your code goes here</span></span><br><span class=\"line\">    <span class=\"comment\"># L1 distance</span></span><br><span class=\"line\">    <span class=\"comment\"># ===================</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">L2</span><span class=\"params\">(x1, x2)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># ===================</span></span><br><span class=\"line\">    <span class=\"comment\"># <span class=\"doctag\">TODO:</span> Calculate the L2 distance between x1 and x2.</span></span><br><span class=\"line\">    <span class=\"comment\"># Your code goes here</span></span><br><span class=\"line\">    <span class=\"comment\"># L2 distance</span></span><br><span class=\"line\">    <span class=\"comment\"># ===================</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">knn</span><span class=\"params\">(train_x, train_y, test_x, sim_func=None, K=<span class=\"number\">10</span>)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> sim_func <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">    test_y = np.zeros(M2).astype(int)</span><br><span class=\"line\">    <span class=\"comment\"># <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\">    <span class=\"comment\"># Instructions:</span></span><br><span class=\"line\">    <span class=\"comment\"># 1. For each sample(x1) in test_x</span></span><br><span class=\"line\">    <span class=\"comment\"># 2. Calculate similarity between each sample in train_x and x1</span></span><br><span class=\"line\">    <span class=\"comment\"># 3. Using the K nearest neighbors to vote for x1</span></span><br><span class=\"line\">    <span class=\"comment\"># 4. assign y1 to test_y[idx]</span></span><br><span class=\"line\">    <span class=\"comment\"># -----------</span></span><br><span class=\"line\">    <span class=\"comment\"># Please Note test_y is a numpy vector, For i-th example in test_x, you</span></span><br><span class=\"line\">    <span class=\"comment\"># can do like this:</span></span><br><span class=\"line\">    <span class=\"comment\"># test_y[i] = yi</span></span><br><span class=\"line\">    <span class=\"comment\"># ===================</span></span><br><span class=\"line\">    <span class=\"comment\"># Your code goes here</span></span><br><span class=\"line\">    <span class=\"comment\"># ===================</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> test_y</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">accuracy</span><span class=\"params\">(output, target)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.count_nonzero(np.equal(output, target)) / len(output)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">evaluate</span><span class=\"params\">(func, target)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Evaluating with your implementation of '</span></span><br><span class=\"line\">          <span class=\"string\">'&#123;&#125; distance'</span>.format(func.__name__))</span><br><span class=\"line\">    test_y = knn(train_x, train_y, test_x, func)</span><br><span class=\"line\">    acc = accuracy(test_y, target)</span><br><span class=\"line\">    print(<span class=\"string\">'Accuracy: &#123;:.2%&#125;'</span>.format(acc))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> np.abs(acc - <span class=\"number\">1</span>) &lt; <span class=\"number\">1e-5</span>:</span><br><span class=\"line\">        print(<span class=\"string\">'Conguratulations, Your implementation is correct'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        print(<span class=\"string\">'There are some bugs in your implementation, Please check again'</span>)</span><br><span class=\"line\">    print()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    evaluate(L1, target_l1_y)</span><br><span class=\"line\">    evaluate(L2, target_l2_y)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<p>有几点需要注意(对首次接触Python的人):</p>\n<ul>\n<li>Python中以<code>#</code>开头的行都是注释，不对程序产生任何影响</li>\n<li>与C不同，Python是一门解释型语言，所以大家如果执行一个<code>.py</code>文件，解释器会从上到下依次执行语句，如果<code>.py</code>文件中只包含了类似<code>def func(x)</code>的定义代码，那么执行该文件仅会定义这些函数然后退出，所以如果<code>.py</code>文件里面有需要执行的语句，比如使用<code>print</code>打印一些内容，则可以直接像这么写:</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 该段代码首先定义了一个`hello`函数，该函数接收一个参数`name`，</span></span><br><span class=\"line\"><span class=\"comment\"># 然后函数的作用是打印'hello, &lt;name&gt;'，最后执行`hello`函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span><span class=\"params\">(name)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'hello'</span>, name)</span><br><span class=\"line\"></span><br><span class=\"line\">hello(<span class=\"string\">'david'</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>另外，直接执行一个<code>.py</code>文件时，被执行文件的<code>if __name__ == &#39;__main__&#39;:</code>判断将会为真，在该示例中即会调用<code>main</code>函数。</li>\n</ul>\n<p>以上是需要注意的几点，具体的Python的语法由于篇幅关系，不再赘述。</p>\n<h2 id=\"KNN\"><a href=\"#KNN\" class=\"headerlink\" title=\"KNN\"></a>KNN</h2><p>KNN，即K近邻，是一个监督学习算法，算法本身并不复杂，其基本流程是:</p>\n<ol>\n<li>假设给定包含$ M $个样本的训练集$ X_{train} $，每个样本包含$ N $个特征，以及对应的类别标签$ Y_{train} $，则$ X_{train} $可以用一个$ M \\times N $的二维矩阵表示, $ Y_{train} $可以用一个$ M \\times 1 $的二维矩阵表示</li>\n</ol>\n<p>$$<br>X_{train} = \\begin{bmatrix}<br>X_1^0 &amp; X_1^1 &amp;  … &amp;  X_1^n \\\\<br>X_2^0 &amp; X_2^1 &amp;  … &amp;  X_2^n \\\\<br>… &amp; … &amp; … &amp; … \\\\<br>X_M^0 &amp; X_M^1 &amp;  … &amp;  X_M^n \\\\<br>\\end{bmatrix}<br>Y_{train} = \\begin{bmatrix}<br>Y_0 \\\\ Y_1 \\\\ … \\\\ Y_M<br>\\end{bmatrix}<br>$$</p>\n<ol>\n<li>对于一个需要计算的新样本$ X $，计算其类别：<ol>\n<li>计算该样本$ X $与训练集$ X_{train} $中每个样本$ X_i $的距离$ D_i $(不同距离函数计算的距离不同，因此效果也会不同)</li>\n<li>在所有距离中取距离最小的前$ K $个样本的类别标签，根据$ K $个标签中出现次数最多的标签来确定样本$ X $的标签</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"距离函数\"><a href=\"#距离函数\" class=\"headerlink\" title=\"距离函数\"></a>距离函数</h2><p>首先我们需要定义一些距离函数来衡量两个样本特征之间的相似度，常用的有L1距离、L2距离等。</p>\n<h3 id=\"L1-distance\"><a href=\"#L1-distance\" class=\"headerlink\" title=\"L1 distance\"></a>L1 distance</h3><p>假设样本$ X_1 $有$ X_1^0, X_1^1, …, X_1^n $特征，其与样本$ X_2 $之间的L1距离可以用以下公式计算:</p>\n<p>$$ L1(X_1, X_2) = \\left|X_1^0 - X_2^0\\right| + \\left|X_1^1 - X_2^1\\right| + … + \\left|X_1^n - X_2^n\\right| $$</p>\n<p>L1函数代码示例:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">L1</span><span class=\"params\">(x1, x2)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># x1和x2都是向量，x1 - x2为每个特征相减</span></span><br><span class=\"line\">    <span class=\"comment\"># np.abs为每个结果求绝对值</span></span><br><span class=\"line\">    <span class=\"comment\"># np.sum将所有绝对值求和</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.sum(np.abs(x1 - x2))</span><br></pre></td></tr></table></figure>\n<h3 id=\"L2-distance\"><a href=\"#L2-distance\" class=\"headerlink\" title=\"L2 distance\"></a>L2 distance</h3><p>L2距离即为特征差的平方求和开方，即:</p>\n<p>$$ L2(X_1, X_2) = \\sqrt{(X_1^0 -  X_2^0)^2 + (X_1^1 -  X_2^1)^2 + … + (X_1^n -  X_2^n)^2} $$</p>\n<p>L2函数代码示例:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">L2</span><span class=\"params\">(x1, x2)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># (x1 - x2) ** 2 为特征差的平方</span></span><br><span class=\"line\">    <span class=\"comment\"># np.sum进行求和运算</span></span><br><span class=\"line\">    <span class=\"comment\"># np.sqrt进行开方运算</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.sqrt(np.sum((x1 - x2) ** <span class=\"number\">2</span>))</span><br></pre></td></tr></table></figure>\n<h2 id=\"KNN代码\"><a href=\"#KNN代码\" class=\"headerlink\" title=\"KNN代码\"></a>KNN代码</h2><p>由于前面已经介绍过KNN的算法流程了，在此处直接给出实现代码(此处的代码并不是最优的，有其他优化方式，有兴趣的可以自己研究)，代码给出了详细注释。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">knn</span><span class=\"params\">(train_x, train_y, test_x, sim_func=None, K=<span class=\"number\">10</span>)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 防御性编程，忽略</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> sim_func <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">    <span class=\"comment\"># 声明结果存储的空间，所有元素初始化为0</span></span><br><span class=\"line\">    test_y = np.zeros(M2).astype(int)</span><br><span class=\"line\">    <span class=\"comment\"># 遍历每一个test_x中的样本，enumerate函数使得在遍历的同时返回其遍历序号，默认idx以0开始</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> idx, X1 <span class=\"keyword\">in</span> enumerate(test_x):</span><br><span class=\"line\">        <span class=\"comment\"># 我们需要一个列表来存储所有计算的距离值</span></span><br><span class=\"line\">        neighbors = []</span><br><span class=\"line\">        <span class=\"comment\"># 遍历每一个train_x中的样本，zip函数可以对多个序列进行遍历，</span></span><br><span class=\"line\">        <span class=\"comment\"># 因此我们可以很方便的同时得到train_x中的X1的特征以及它对应的标签</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> X2, Y2 <span class=\"keyword\">in</span> zip(train_x, train_y):</span><br><span class=\"line\">            <span class=\"comment\"># 使用距离函数sim_func计算样本X1和X2的距离dis</span></span><br><span class=\"line\">            dis = sim_func(X1, X2)</span><br><span class=\"line\">            <span class=\"comment\"># 我们将距离和标签以Python元组的形式(dis, Y2)放入前面声明的列表中</span></span><br><span class=\"line\">            neighbors.append((dis, Y2))</span><br><span class=\"line\">        <span class=\"comment\"># 对neighbors列表中的所有元组进行排序，</span></span><br><span class=\"line\">        <span class=\"comment\"># 比较关键字key使用了每个元组中的第0个元素即(dis, Y2)中的dis</span></span><br><span class=\"line\">        <span class=\"comment\"># 这样我们得到了一个dis从小到大排列的列表</span></span><br><span class=\"line\">        neighbors.sort(key=<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"comment\"># 使用Python的切片功能我们保留neighbors的前K个元素(即dis最小的前K个)</span></span><br><span class=\"line\">        neighbors = neighbors[:K]</span><br><span class=\"line\">        <span class=\"comment\"># 声明一个字典votes</span></span><br><span class=\"line\">        votes = &#123;&#125;</span><br><span class=\"line\">        <span class=\"comment\"># 遍历neighbors中的K个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> dis, label <span class=\"keyword\">in</span> neighbors:</span><br><span class=\"line\">            <span class=\"comment\"># 如果当前遍历到的标签label不在字典votes中</span></span><br><span class=\"line\">            <span class=\"comment\"># setdefault函数将会将其加入字典中，并将其值置为0</span></span><br><span class=\"line\">            <span class=\"comment\"># 如果标签在label中，setdefault函数不做任何处理</span></span><br><span class=\"line\">            votes.setdefault(label, <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\"># 标签label计数加1</span></span><br><span class=\"line\">            votes[label] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># votes.items()方法返回一个列表(实际是一个迭代器，可以先忽略)，</span></span><br><span class=\"line\">        <span class=\"comment\"># 其形式为(label, count)，即标签和它出现的次数</span></span><br><span class=\"line\">        <span class=\"comment\"># max函数用来找到这个列表中最大的那个元素(即我们要的出现最多次的元素)</span></span><br><span class=\"line\">        <span class=\"comment\"># 比较关键字在此处为x[1]，即(label, count)中的count</span></span><br><span class=\"line\">        <span class=\"comment\"># 最后max函数返回了一个(label, count)，该对象是出现次数最多的，我们用下标[0]访问即可得到该标签，</span></span><br><span class=\"line\">        <span class=\"comment\"># 最后将该标签赋值给test_y[idx]，完成！</span></span><br><span class=\"line\">        test_y[idx] = max(votes.items(), key=<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">1</span>])[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> test_y</span><br></pre></td></tr></table></figure>\n<p>最后保存并执行，即可得到预期结果</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ python3 knn.py</span><br><span class=\"line\">Evaluating with your implementation of L1 distance</span><br><span class=\"line\">Accuracy: 100.00%</span><br><span class=\"line\">Conguratulations, Your implementation is correct</span><br><span class=\"line\"></span><br><span class=\"line\">Evaluating with your implementation of L2 distance</span><br><span class=\"line\">Accuracy: 100.00%</span><br><span class=\"line\">Conguratulations, Your implementation is correct</span><br></pre></td></tr></table></figure>\n<p>至此，一个简单的KNN算法工作完毕。</p>\n","site":{"data":{}},"excerpt":"<p>今天在学院论坛里面写了关于KNN的一篇解释，顺手就转到自己博客了，毕竟这都又是3个月没更新了，感觉自己学了很多但是就是太懒，不想记下来，这个习惯还是得改改。</p>","more":"<h2 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h2><p>首先是原始代码，已经写好非核心代码，只需要补充<code>L1</code>、<code>L2</code>、<code>knn</code>三个函数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python3</span></span><br><span class=\"line\"><span class=\"comment\"># coding: UTF-8</span></span><br><span class=\"line\"><span class=\"comment\"># Author: David</span></span><br><span class=\"line\"><span class=\"comment\"># Email: youchen.du@gmail.com</span></span><br><span class=\"line\"><span class=\"comment\"># Created: 2017-10-21 13:06</span></span><br><span class=\"line\"><span class=\"comment\"># Last modified: 2017-10-21 13:53</span></span><br><span class=\"line\"><span class=\"comment\"># Filename: knn.py</span></span><br><span class=\"line\"><span class=\"comment\"># Description:</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ===============================================</span></span><br><span class=\"line\"><span class=\"comment\"># For reproducibility, DO NOT CHANGE THIS SECTION</span></span><br><span class=\"line\">np.random.seed(<span class=\"number\">1111</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">M1 = <span class=\"number\">500</span></span><br><span class=\"line\">M2 = <span class=\"number\">50</span></span><br><span class=\"line\">N = <span class=\"number\">1024</span></span><br><span class=\"line\">S = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\">train_x = S * np.random.randn(M1, N)</span><br><span class=\"line\">train_y = np.random.randint(<span class=\"number\">0</span>, <span class=\"number\">10</span>, M1)</span><br><span class=\"line\">test_x = S * np.random.randn(M2, N)</span><br><span class=\"line\">target_l1_y = [</span><br><span class=\"line\">    <span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">9</span>, <span class=\"number\">6</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">4</span>,</span><br><span class=\"line\">    <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">6</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">9</span>, <span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">6</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>,</span><br><span class=\"line\">    <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">3</span>,</span><br><span class=\"line\">    <span class=\"number\">1</span>, <span class=\"number\">9</span>]</span><br><span class=\"line\">target_l2_y = [</span><br><span class=\"line\">    <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>,</span><br><span class=\"line\">    <span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">9</span>, <span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">6</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>,</span><br><span class=\"line\">    <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">6</span>, <span class=\"number\">6</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">9</span>, <span class=\"number\">6</span>,</span><br><span class=\"line\">    <span class=\"number\">1</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"comment\"># ==============================================</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">L1</span><span class=\"params\">(x1, x2)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># ===================</span></span><br><span class=\"line\">    <span class=\"comment\"># <span class=\"doctag\">TODO:</span> Calculate the L1 distance between x1 and x2.</span></span><br><span class=\"line\">    <span class=\"comment\"># Your code goes here</span></span><br><span class=\"line\">    <span class=\"comment\"># L1 distance</span></span><br><span class=\"line\">    <span class=\"comment\"># ===================</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">L2</span><span class=\"params\">(x1, x2)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># ===================</span></span><br><span class=\"line\">    <span class=\"comment\"># <span class=\"doctag\">TODO:</span> Calculate the L2 distance between x1 and x2.</span></span><br><span class=\"line\">    <span class=\"comment\"># Your code goes here</span></span><br><span class=\"line\">    <span class=\"comment\"># L2 distance</span></span><br><span class=\"line\">    <span class=\"comment\"># ===================</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">knn</span><span class=\"params\">(train_x, train_y, test_x, sim_func=None, K=<span class=\"number\">10</span>)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> sim_func <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">    test_y = np.zeros(M2).astype(int)</span><br><span class=\"line\">    <span class=\"comment\"># <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\">    <span class=\"comment\"># Instructions:</span></span><br><span class=\"line\">    <span class=\"comment\"># 1. For each sample(x1) in test_x</span></span><br><span class=\"line\">    <span class=\"comment\"># 2. Calculate similarity between each sample in train_x and x1</span></span><br><span class=\"line\">    <span class=\"comment\"># 3. Using the K nearest neighbors to vote for x1</span></span><br><span class=\"line\">    <span class=\"comment\"># 4. assign y1 to test_y[idx]</span></span><br><span class=\"line\">    <span class=\"comment\"># -----------</span></span><br><span class=\"line\">    <span class=\"comment\"># Please Note test_y is a numpy vector, For i-th example in test_x, you</span></span><br><span class=\"line\">    <span class=\"comment\"># can do like this:</span></span><br><span class=\"line\">    <span class=\"comment\"># test_y[i] = yi</span></span><br><span class=\"line\">    <span class=\"comment\"># ===================</span></span><br><span class=\"line\">    <span class=\"comment\"># Your code goes here</span></span><br><span class=\"line\">    <span class=\"comment\"># ===================</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> test_y</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">accuracy</span><span class=\"params\">(output, target)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.count_nonzero(np.equal(output, target)) / len(output)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">evaluate</span><span class=\"params\">(func, target)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Evaluating with your implementation of '</span></span><br><span class=\"line\">          <span class=\"string\">'&#123;&#125; distance'</span>.format(func.__name__))</span><br><span class=\"line\">    test_y = knn(train_x, train_y, test_x, func)</span><br><span class=\"line\">    acc = accuracy(test_y, target)</span><br><span class=\"line\">    print(<span class=\"string\">'Accuracy: &#123;:.2%&#125;'</span>.format(acc))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> np.abs(acc - <span class=\"number\">1</span>) &lt; <span class=\"number\">1e-5</span>:</span><br><span class=\"line\">        print(<span class=\"string\">'Conguratulations, Your implementation is correct'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        print(<span class=\"string\">'There are some bugs in your implementation, Please check again'</span>)</span><br><span class=\"line\">    print()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    evaluate(L1, target_l1_y)</span><br><span class=\"line\">    evaluate(L2, target_l2_y)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure>\n<p>有几点需要注意(对首次接触Python的人):</p>\n<ul>\n<li>Python中以<code>#</code>开头的行都是注释，不对程序产生任何影响</li>\n<li>与C不同，Python是一门解释型语言，所以大家如果执行一个<code>.py</code>文件，解释器会从上到下依次执行语句，如果<code>.py</code>文件中只包含了类似<code>def func(x)</code>的定义代码，那么执行该文件仅会定义这些函数然后退出，所以如果<code>.py</code>文件里面有需要执行的语句，比如使用<code>print</code>打印一些内容，则可以直接像这么写:</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 该段代码首先定义了一个`hello`函数，该函数接收一个参数`name`，</span></span><br><span class=\"line\"><span class=\"comment\"># 然后函数的作用是打印'hello, &lt;name&gt;'，最后执行`hello`函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span><span class=\"params\">(name)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'hello'</span>, name)</span><br><span class=\"line\"></span><br><span class=\"line\">hello(<span class=\"string\">'david'</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>另外，直接执行一个<code>.py</code>文件时，被执行文件的<code>if __name__ == &#39;__main__&#39;:</code>判断将会为真，在该示例中即会调用<code>main</code>函数。</li>\n</ul>\n<p>以上是需要注意的几点，具体的Python的语法由于篇幅关系，不再赘述。</p>\n<h2 id=\"KNN\"><a href=\"#KNN\" class=\"headerlink\" title=\"KNN\"></a>KNN</h2><p>KNN，即K近邻，是一个监督学习算法，算法本身并不复杂，其基本流程是:</p>\n<ol>\n<li>假设给定包含$ M $个样本的训练集$ X_{train} $，每个样本包含$ N $个特征，以及对应的类别标签$ Y_{train} $，则$ X_{train} $可以用一个$ M \\times N $的二维矩阵表示, $ Y_{train} $可以用一个$ M \\times 1 $的二维矩阵表示</li>\n</ol>\n<p>$$<br>X_{train} = \\begin{bmatrix}<br>X_1^0 &amp; X_1^1 &amp;  … &amp;  X_1^n \\\\<br>X_2^0 &amp; X_2^1 &amp;  … &amp;  X_2^n \\\\<br>… &amp; … &amp; … &amp; … \\\\<br>X_M^0 &amp; X_M^1 &amp;  … &amp;  X_M^n \\\\<br>\\end{bmatrix}<br>Y_{train} = \\begin{bmatrix}<br>Y_0 \\\\ Y_1 \\\\ … \\\\ Y_M<br>\\end{bmatrix}<br>$$</p>\n<ol>\n<li>对于一个需要计算的新样本$ X $，计算其类别：<ol>\n<li>计算该样本$ X $与训练集$ X_{train} $中每个样本$ X_i $的距离$ D_i $(不同距离函数计算的距离不同，因此效果也会不同)</li>\n<li>在所有距离中取距离最小的前$ K $个样本的类别标签，根据$ K $个标签中出现次数最多的标签来确定样本$ X $的标签</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"距离函数\"><a href=\"#距离函数\" class=\"headerlink\" title=\"距离函数\"></a>距离函数</h2><p>首先我们需要定义一些距离函数来衡量两个样本特征之间的相似度，常用的有L1距离、L2距离等。</p>\n<h3 id=\"L1-distance\"><a href=\"#L1-distance\" class=\"headerlink\" title=\"L1 distance\"></a>L1 distance</h3><p>假设样本$ X_1 $有$ X_1^0, X_1^1, …, X_1^n $特征，其与样本$ X_2 $之间的L1距离可以用以下公式计算:</p>\n<p>$$ L1(X_1, X_2) = \\left|X_1^0 - X_2^0\\right| + \\left|X_1^1 - X_2^1\\right| + … + \\left|X_1^n - X_2^n\\right| $$</p>\n<p>L1函数代码示例:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">L1</span><span class=\"params\">(x1, x2)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># x1和x2都是向量，x1 - x2为每个特征相减</span></span><br><span class=\"line\">    <span class=\"comment\"># np.abs为每个结果求绝对值</span></span><br><span class=\"line\">    <span class=\"comment\"># np.sum将所有绝对值求和</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.sum(np.abs(x1 - x2))</span><br></pre></td></tr></table></figure>\n<h3 id=\"L2-distance\"><a href=\"#L2-distance\" class=\"headerlink\" title=\"L2 distance\"></a>L2 distance</h3><p>L2距离即为特征差的平方求和开方，即:</p>\n<p>$$ L2(X_1, X_2) = \\sqrt{(X_1^0 -  X_2^0)^2 + (X_1^1 -  X_2^1)^2 + … + (X_1^n -  X_2^n)^2} $$</p>\n<p>L2函数代码示例:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">L2</span><span class=\"params\">(x1, x2)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># (x1 - x2) ** 2 为特征差的平方</span></span><br><span class=\"line\">    <span class=\"comment\"># np.sum进行求和运算</span></span><br><span class=\"line\">    <span class=\"comment\"># np.sqrt进行开方运算</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.sqrt(np.sum((x1 - x2) ** <span class=\"number\">2</span>))</span><br></pre></td></tr></table></figure>\n<h2 id=\"KNN代码\"><a href=\"#KNN代码\" class=\"headerlink\" title=\"KNN代码\"></a>KNN代码</h2><p>由于前面已经介绍过KNN的算法流程了，在此处直接给出实现代码(此处的代码并不是最优的，有其他优化方式，有兴趣的可以自己研究)，代码给出了详细注释。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">knn</span><span class=\"params\">(train_x, train_y, test_x, sim_func=None, K=<span class=\"number\">10</span>)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 防御性编程，忽略</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> sim_func <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span></span><br><span class=\"line\">    <span class=\"comment\"># 声明结果存储的空间，所有元素初始化为0</span></span><br><span class=\"line\">    test_y = np.zeros(M2).astype(int)</span><br><span class=\"line\">    <span class=\"comment\"># 遍历每一个test_x中的样本，enumerate函数使得在遍历的同时返回其遍历序号，默认idx以0开始</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> idx, X1 <span class=\"keyword\">in</span> enumerate(test_x):</span><br><span class=\"line\">        <span class=\"comment\"># 我们需要一个列表来存储所有计算的距离值</span></span><br><span class=\"line\">        neighbors = []</span><br><span class=\"line\">        <span class=\"comment\"># 遍历每一个train_x中的样本，zip函数可以对多个序列进行遍历，</span></span><br><span class=\"line\">        <span class=\"comment\"># 因此我们可以很方便的同时得到train_x中的X1的特征以及它对应的标签</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> X2, Y2 <span class=\"keyword\">in</span> zip(train_x, train_y):</span><br><span class=\"line\">            <span class=\"comment\"># 使用距离函数sim_func计算样本X1和X2的距离dis</span></span><br><span class=\"line\">            dis = sim_func(X1, X2)</span><br><span class=\"line\">            <span class=\"comment\"># 我们将距离和标签以Python元组的形式(dis, Y2)放入前面声明的列表中</span></span><br><span class=\"line\">            neighbors.append((dis, Y2))</span><br><span class=\"line\">        <span class=\"comment\"># 对neighbors列表中的所有元组进行排序，</span></span><br><span class=\"line\">        <span class=\"comment\"># 比较关键字key使用了每个元组中的第0个元素即(dis, Y2)中的dis</span></span><br><span class=\"line\">        <span class=\"comment\"># 这样我们得到了一个dis从小到大排列的列表</span></span><br><span class=\"line\">        neighbors.sort(key=<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"comment\"># 使用Python的切片功能我们保留neighbors的前K个元素(即dis最小的前K个)</span></span><br><span class=\"line\">        neighbors = neighbors[:K]</span><br><span class=\"line\">        <span class=\"comment\"># 声明一个字典votes</span></span><br><span class=\"line\">        votes = &#123;&#125;</span><br><span class=\"line\">        <span class=\"comment\"># 遍历neighbors中的K个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> dis, label <span class=\"keyword\">in</span> neighbors:</span><br><span class=\"line\">            <span class=\"comment\"># 如果当前遍历到的标签label不在字典votes中</span></span><br><span class=\"line\">            <span class=\"comment\"># setdefault函数将会将其加入字典中，并将其值置为0</span></span><br><span class=\"line\">            <span class=\"comment\"># 如果标签在label中，setdefault函数不做任何处理</span></span><br><span class=\"line\">            votes.setdefault(label, <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\"># 标签label计数加1</span></span><br><span class=\"line\">            votes[label] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"comment\"># votes.items()方法返回一个列表(实际是一个迭代器，可以先忽略)，</span></span><br><span class=\"line\">        <span class=\"comment\"># 其形式为(label, count)，即标签和它出现的次数</span></span><br><span class=\"line\">        <span class=\"comment\"># max函数用来找到这个列表中最大的那个元素(即我们要的出现最多次的元素)</span></span><br><span class=\"line\">        <span class=\"comment\"># 比较关键字在此处为x[1]，即(label, count)中的count</span></span><br><span class=\"line\">        <span class=\"comment\"># 最后max函数返回了一个(label, count)，该对象是出现次数最多的，我们用下标[0]访问即可得到该标签，</span></span><br><span class=\"line\">        <span class=\"comment\"># 最后将该标签赋值给test_y[idx]，完成！</span></span><br><span class=\"line\">        test_y[idx] = max(votes.items(), key=<span class=\"keyword\">lambda</span> x: x[<span class=\"number\">1</span>])[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> test_y</span><br></pre></td></tr></table></figure>\n<p>最后保存并执行，即可得到预期结果</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ python3 knn.py</span><br><span class=\"line\">Evaluating with your implementation of L1 distance</span><br><span class=\"line\">Accuracy: 100.00%</span><br><span class=\"line\">Conguratulations, Your implementation is correct</span><br><span class=\"line\"></span><br><span class=\"line\">Evaluating with your implementation of L2 distance</span><br><span class=\"line\">Accuracy: 100.00%</span><br><span class=\"line\">Conguratulations, Your implementation is correct</span><br></pre></td></tr></table></figure>\n<p>至此，一个简单的KNN算法工作完毕。</p>"},{"layout":"post","title":"欢迎","date":"2017-01-05T03:58:00.000Z","_content":"\n欢迎来到我的博客，这个博客使用了[Hexo](https://hexo.io)构建，托管在[Github Pages](https://pages.github.com),主题使用了[Apollo](https://github.com/pinggod/hexo-theme-apollo)。\n\n\n因为整个博客是托管在Github上的静态页面，没有数据库的支持，因此使用了[多说](http://duoshuo.com)来为整个博客提供评论功能，同时我也通过JS给博客增加了搜索功能，通过点击右下角的搜索图标或者双击`Ctrl`键可以启动搜索，这样可以方便快速查找相关内容。\n\n<!-- more -->\n\n现在博客的功能还有限，在以后我会慢慢增加新的功能，同时也会不定期更新一些我学习过程中的心得，欢迎大家阅读！\n\n谢谢！\n","source":"_posts/welcome.md","raw":"---\nlayout: post\ntitle: 欢迎\ntags: [欢迎,第一篇,博客,新功能]\ncategory: 其他\ndate: 2017-01-05 11:58\n---\n\n欢迎来到我的博客，这个博客使用了[Hexo](https://hexo.io)构建，托管在[Github Pages](https://pages.github.com),主题使用了[Apollo](https://github.com/pinggod/hexo-theme-apollo)。\n\n\n因为整个博客是托管在Github上的静态页面，没有数据库的支持，因此使用了[多说](http://duoshuo.com)来为整个博客提供评论功能，同时我也通过JS给博客增加了搜索功能，通过点击右下角的搜索图标或者双击`Ctrl`键可以启动搜索，这样可以方便快速查找相关内容。\n\n<!-- more -->\n\n现在博客的功能还有限，在以后我会慢慢增加新的功能，同时也会不定期更新一些我学习过程中的心得，欢迎大家阅读！\n\n谢谢！\n","slug":"welcome","published":1,"updated":"2018-01-13T00:50:39.868Z","comments":1,"photos":[],"link":"","_id":"cjgvnqmlg001mw628prwjt71w","content":"<p>欢迎来到我的博客，这个博客使用了<a href=\"https://hexo.io\" target=\"_blank\" rel=\"noopener\">Hexo</a>构建，托管在<a href=\"https://pages.github.com\" target=\"_blank\" rel=\"noopener\">Github Pages</a>,主题使用了<a href=\"https://github.com/pinggod/hexo-theme-apollo\" target=\"_blank\" rel=\"noopener\">Apollo</a>。</p>\n<p>因为整个博客是托管在Github上的静态页面，没有数据库的支持，因此使用了<a href=\"http://duoshuo.com\" target=\"_blank\" rel=\"noopener\">多说</a>来为整个博客提供评论功能，同时我也通过JS给博客增加了搜索功能，通过点击右下角的搜索图标或者双击<code>Ctrl</code>键可以启动搜索，这样可以方便快速查找相关内容。</p>\n<a id=\"more\"></a>\n<p>现在博客的功能还有限，在以后我会慢慢增加新的功能，同时也会不定期更新一些我学习过程中的心得，欢迎大家阅读！</p>\n<p>谢谢！</p>\n","site":{"data":{}},"excerpt":"<p>欢迎来到我的博客，这个博客使用了<a href=\"https://hexo.io\" target=\"_blank\" rel=\"noopener\">Hexo</a>构建，托管在<a href=\"https://pages.github.com\" target=\"_blank\" rel=\"noopener\">Github Pages</a>,主题使用了<a href=\"https://github.com/pinggod/hexo-theme-apollo\" target=\"_blank\" rel=\"noopener\">Apollo</a>。</p>\n<p>因为整个博客是托管在Github上的静态页面，没有数据库的支持，因此使用了<a href=\"http://duoshuo.com\" target=\"_blank\" rel=\"noopener\">多说</a>来为整个博客提供评论功能，同时我也通过JS给博客增加了搜索功能，通过点击右下角的搜索图标或者双击<code>Ctrl</code>键可以启动搜索，这样可以方便快速查找相关内容。</p>","more":"<p>现在博客的功能还有限，在以后我会慢慢增加新的功能，同时也会不定期更新一些我学习过程中的心得，欢迎大家阅读！</p>\n<p>谢谢！</p>"},{"title":"论文笔记-全卷积神经网络(FCN)","date":"2017-07-25T02:50:05.000Z","_content":"\n看了下时间已经快3个月没有写过东西了，客观原因是考试复习和项目上的事情比较多，主观原因是懒。\n\n最早接触机器学习是在大三，大四的时候了解了一些DL的知识，前几个月在网上学习了斯坦福的[CS231n: Convolutional Neural Networks for Visual Recognition](http://cs231n.stanford.edu)，看了一些论文，对DL相关概念有了一些基本的了解，这篇文章是我阅读[Fully Convolutional Networks for Semantic Segmentation](https://arxiv.org/abs/1411.4038v2)时的一些理解。\n\n<!-- more -->\n\n# Sementic Segmentation(语义分割)\n\n语义分割是计算机视觉领域的一个经典问题，它所要完成的工作是对于图片的每一个像素，对其赋予一个标签，这和分类(Classification)、定位(Localization)等任务有很大的区别，分类是完成判断“是什么”的任务，定位不仅需要判断“是什么”，还需要完成“在哪里”的任务。举个例子说明,对于下面这张图片:\n\n![cat](cat.png)\n\n对其进行语义分割，得到的结果如下图所示:\n\n![ss-cat](ss-cat.png)\n\n图中不同颜色代表了不同的语义，比如黄色代表了猫，绿色代表了草坪，蓝色代表了天空，粉紫色代表了猫身后的树林。\n\n语义分割对于人工智能迈向更高台阶是十分重要的，因为这一工作能够让计算机拥有类似人的判断，对其观察到的世界进行认识了解，这一工作在机器人领域以及自动驾驶等领域有很大的应用前景。\n\n在[Fully Convolutional Networks for Semantic Segmentation](https://arxiv.org/abs/1411.4038v2)这篇论文将深度学习引入该领域之前，传统的语义分割主要依赖使用人工提取特征和概率图模型，而FCN这篇论文的发表，成为了语义分割的一个重要转折点。\n\n全卷积网络的概念其实很早就提出了，因此在本文获得CVPR' 15最佳论文提名的时候被Yann Le\u0005Cun等人吐槽，当然，这篇论文仍然具有十分重要的意义。\n\n# 全连接层 --> 卷积层\n\n传统的分类网络，比如LeNet、AlexNet等，只接受固定尺寸的输入并产生非空间输出，原因在于全连接层参数的限制，而且这些网络在通过全连接层把输入展开成向量的时候丢失了图片原有的空间信息。对VGG16中第一个全连接层为25088x4096，即该层输入未展开成向量前形状为7x7x512，展开后为1x25088，得到的输出为1x4096，其实换一个角度来看，如果采用512x7x7x4096的卷积层原始输入进行卷积操作，得到的结果为1x1x4096。这样操作后，对应于原来输出的向量，现在输出了heatmap，如下图所示。\n\n![heatmap-cat](heatmap-cat.png)\n\n使用卷积层替换全连接层这种操作具体有什么作用呢？\n\n以AlexNet为例，该网络输入为224x224x3，使用一系列卷积层和Pooling层使得数据尺寸变为7x7x512，紧接着是三个4096、4096、1000的全连接层，我们将三个全连接层分别转化为三个卷积层:\n\n* 对第一个全连接层25088x4096，我们可以使用kernel_size为7的4096个卷积核代替，这样得到的输出为1x1x4096\n* 对第二个全连接层4096x4096，使用kernel_size为1的4096个卷积核代替，得到输出为1x1x4096\n* 对第三个全连接层4096x1000，使用kernel_size为1的1000个卷积核代替，得到输出为1x1x1000\n\n假如我们想对384x384x3的图片进行语义分割，在不使用卷积层替换全连接层的情况下，我们使用步长为32大小为224x224x3的窗口在384x384x3的图片上进行滑动，得到6x6个位置的语义分割得分，然后进行fusion处理。但是因为我们使用了卷积层替换全连接层，现在的网络有能力对不同尺寸的输入进行处理。因此，384x384x3的输入经过卷积层和Pooling层后得到的尺寸为12x12x512，再通过上面经过转化的三个卷积层，得到的结果为6x6x1000，正好是对原图进行滑动得到的结果。\n\n论文给出了这两种方式的时间性能比较，在GPU上，AlexNet需要花费1.2毫秒来产生对一张227x227的图片预测，而FCN版本花费了22毫秒对一张500x500的图片产生大小为10x10的预测，比AlexNet快了5倍多。\n\n# Upsampling(上采样)\n\n以改造后的VGG16为例，让输入经过网络之后，我们得到的数据尺寸为[H/32, W/32]，而我们的目标是对每一个像素产生预测，因此我们需要进行upsampling操作，即恢复原始尺寸。在某种程度上，使用系数为$f$的upsampling可以看成是步长为$1/f$的卷积的转置，即只要$f$是整数，一种进行upsampling的方法就是使用**backwards convolution**(或称**deconvolution**，该术语存在争议，也有人称**transposed convolution**)，以输出步长为$f$进行计算。\n\n![padding_strides](padding_strides.gif)\n\n如图所示，绿色部分为输入，蓝色部分为输出，stride为2，padding为1。可以看出，**transposed convolution**其实就是**convolution**反过来，调换了**convolution**的前向传播和反向传播过程而已。\n\n# Architecture\n\n以VGG16和PASCAL数据集为例，我们去除了最后的分类层，并将所有的全连接层转化为上述的卷积层，然后添加了一层1x1x21的卷积层用于预测每个类别(包括背景)的得分，然后使用转置卷积进行双线性上采样，使得粗粒度输出(coarse outputs)变成像素密集的输出。\n\n虽然可以通过fine-tune来优化分割结果，得分也会变高，但是这些输出仍然比较粗糙无法令人满意。最后的prediction层采用stride为32的方式限制了上采样结果的细节程度。那么怎么处理这一问题呢？\n\n我们知道，随着卷积神经网络层数的增加，每一层的感知野(reception field)也更广，而网络结构中越低的层感知野越小，因此能得到更多细节。结合低层与高层输出可以使得模型在全局结构下进行局部预测。\n\n![fine-coarse](fine-coarse.png)\n\n图中所示为改造后的VGG16的简化图，图中只包含了输入层、由全连接层转化而来的卷积层以及Pooling层。对我们最初采用stride为32的上采样得到结果的模型我们称为FCN-32s，为了进一步优化输出预测。我们首先在pool4后面添加1x1的卷积层来产生额外的预测。然后对使用步长为32的conv7(卷积化后的fc7)进行2x上采样，因为pool5将尺寸缩减了一半，此时进行2x上采样将会把尺寸恢复到跟pool4一样，然后把该结果和pool4后1x1卷积层产生的结果进行求和(不采用Max fusion的原因是会因为梯度选择而使得训练较为困难)。对于pool4后的1x1卷积层采用双线性插值初始化，但是允许参数在训练过程中进行调整。最后，将得到结果采用stride为16的方式进行上采样得到结果，该模型我们成为FCN-16s。同理，我们可以通过在pool3后添加1x1的卷积层并进行上述类似操作得到FCN-8s，但是得到的提升已经十分有限，因此不再进行更低层的fusion操作。\n\n![finer-fcns](finer-fcns.png)\n\n图中可以看出，通过融合使用不同stride的层得到的结果提高了分割的细节。\n\n![fcns-validation](fcns-validation.png)\n\n# 训练细节\n\n* SGD with momentum 0.9\n* Minibatch size of 20 images\n* Fixed learning rates of $10^{-3}$, $10^{-4}$, $10^{-5}$ for FCN-AlexNet, FCN-VGG16, FCN-GoogLeNet\n* Weight decay of $5^{-4}$ or $2^{-4}$\n* Doubled the learning rates for biases(非必要)\n* Zero-initialize the class scoring convolution layer\n* Dropout\n\n# 模型效果\n\n![resluts](results.png)\n\n# 参考文献\n* [全卷积网络 FCN 详解](http://www.cnblogs.com/gujianhan/p/6030639.html)\n* [论文阅读笔记：Fully Convolutional Networks for Semantic Segmentation](http://blog.csdn.net/tangwei2014/article/details/46882257)\n* [Convolution arithmetic](https://github.com/vdumoulin/conv_arithmetic)\n* [CS231n: Convolutional Neural Networks for Visual Recognition](http://cs231n.stanford.edu)\n","source":"_posts/论文笔记-全卷积神经网络-FCN.md","raw":"---\ntitle: 论文笔记-全卷积神经网络(FCN)\ndate: 2017-07-25 10:50:05\ntags: [机器学习,深度学习,语义分割]\ncategories: 机器学习\n---\n\n看了下时间已经快3个月没有写过东西了，客观原因是考试复习和项目上的事情比较多，主观原因是懒。\n\n最早接触机器学习是在大三，大四的时候了解了一些DL的知识，前几个月在网上学习了斯坦福的[CS231n: Convolutional Neural Networks for Visual Recognition](http://cs231n.stanford.edu)，看了一些论文，对DL相关概念有了一些基本的了解，这篇文章是我阅读[Fully Convolutional Networks for Semantic Segmentation](https://arxiv.org/abs/1411.4038v2)时的一些理解。\n\n<!-- more -->\n\n# Sementic Segmentation(语义分割)\n\n语义分割是计算机视觉领域的一个经典问题，它所要完成的工作是对于图片的每一个像素，对其赋予一个标签，这和分类(Classification)、定位(Localization)等任务有很大的区别，分类是完成判断“是什么”的任务，定位不仅需要判断“是什么”，还需要完成“在哪里”的任务。举个例子说明,对于下面这张图片:\n\n![cat](cat.png)\n\n对其进行语义分割，得到的结果如下图所示:\n\n![ss-cat](ss-cat.png)\n\n图中不同颜色代表了不同的语义，比如黄色代表了猫，绿色代表了草坪，蓝色代表了天空，粉紫色代表了猫身后的树林。\n\n语义分割对于人工智能迈向更高台阶是十分重要的，因为这一工作能够让计算机拥有类似人的判断，对其观察到的世界进行认识了解，这一工作在机器人领域以及自动驾驶等领域有很大的应用前景。\n\n在[Fully Convolutional Networks for Semantic Segmentation](https://arxiv.org/abs/1411.4038v2)这篇论文将深度学习引入该领域之前，传统的语义分割主要依赖使用人工提取特征和概率图模型，而FCN这篇论文的发表，成为了语义分割的一个重要转折点。\n\n全卷积网络的概念其实很早就提出了，因此在本文获得CVPR' 15最佳论文提名的时候被Yann Le\u0005Cun等人吐槽，当然，这篇论文仍然具有十分重要的意义。\n\n# 全连接层 --> 卷积层\n\n传统的分类网络，比如LeNet、AlexNet等，只接受固定尺寸的输入并产生非空间输出，原因在于全连接层参数的限制，而且这些网络在通过全连接层把输入展开成向量的时候丢失了图片原有的空间信息。对VGG16中第一个全连接层为25088x4096，即该层输入未展开成向量前形状为7x7x512，展开后为1x25088，得到的输出为1x4096，其实换一个角度来看，如果采用512x7x7x4096的卷积层原始输入进行卷积操作，得到的结果为1x1x4096。这样操作后，对应于原来输出的向量，现在输出了heatmap，如下图所示。\n\n![heatmap-cat](heatmap-cat.png)\n\n使用卷积层替换全连接层这种操作具体有什么作用呢？\n\n以AlexNet为例，该网络输入为224x224x3，使用一系列卷积层和Pooling层使得数据尺寸变为7x7x512，紧接着是三个4096、4096、1000的全连接层，我们将三个全连接层分别转化为三个卷积层:\n\n* 对第一个全连接层25088x4096，我们可以使用kernel_size为7的4096个卷积核代替，这样得到的输出为1x1x4096\n* 对第二个全连接层4096x4096，使用kernel_size为1的4096个卷积核代替，得到输出为1x1x4096\n* 对第三个全连接层4096x1000，使用kernel_size为1的1000个卷积核代替，得到输出为1x1x1000\n\n假如我们想对384x384x3的图片进行语义分割，在不使用卷积层替换全连接层的情况下，我们使用步长为32大小为224x224x3的窗口在384x384x3的图片上进行滑动，得到6x6个位置的语义分割得分，然后进行fusion处理。但是因为我们使用了卷积层替换全连接层，现在的网络有能力对不同尺寸的输入进行处理。因此，384x384x3的输入经过卷积层和Pooling层后得到的尺寸为12x12x512，再通过上面经过转化的三个卷积层，得到的结果为6x6x1000，正好是对原图进行滑动得到的结果。\n\n论文给出了这两种方式的时间性能比较，在GPU上，AlexNet需要花费1.2毫秒来产生对一张227x227的图片预测，而FCN版本花费了22毫秒对一张500x500的图片产生大小为10x10的预测，比AlexNet快了5倍多。\n\n# Upsampling(上采样)\n\n以改造后的VGG16为例，让输入经过网络之后，我们得到的数据尺寸为[H/32, W/32]，而我们的目标是对每一个像素产生预测，因此我们需要进行upsampling操作，即恢复原始尺寸。在某种程度上，使用系数为$f$的upsampling可以看成是步长为$1/f$的卷积的转置，即只要$f$是整数，一种进行upsampling的方法就是使用**backwards convolution**(或称**deconvolution**，该术语存在争议，也有人称**transposed convolution**)，以输出步长为$f$进行计算。\n\n![padding_strides](padding_strides.gif)\n\n如图所示，绿色部分为输入，蓝色部分为输出，stride为2，padding为1。可以看出，**transposed convolution**其实就是**convolution**反过来，调换了**convolution**的前向传播和反向传播过程而已。\n\n# Architecture\n\n以VGG16和PASCAL数据集为例，我们去除了最后的分类层，并将所有的全连接层转化为上述的卷积层，然后添加了一层1x1x21的卷积层用于预测每个类别(包括背景)的得分，然后使用转置卷积进行双线性上采样，使得粗粒度输出(coarse outputs)变成像素密集的输出。\n\n虽然可以通过fine-tune来优化分割结果，得分也会变高，但是这些输出仍然比较粗糙无法令人满意。最后的prediction层采用stride为32的方式限制了上采样结果的细节程度。那么怎么处理这一问题呢？\n\n我们知道，随着卷积神经网络层数的增加，每一层的感知野(reception field)也更广，而网络结构中越低的层感知野越小，因此能得到更多细节。结合低层与高层输出可以使得模型在全局结构下进行局部预测。\n\n![fine-coarse](fine-coarse.png)\n\n图中所示为改造后的VGG16的简化图，图中只包含了输入层、由全连接层转化而来的卷积层以及Pooling层。对我们最初采用stride为32的上采样得到结果的模型我们称为FCN-32s，为了进一步优化输出预测。我们首先在pool4后面添加1x1的卷积层来产生额外的预测。然后对使用步长为32的conv7(卷积化后的fc7)进行2x上采样，因为pool5将尺寸缩减了一半，此时进行2x上采样将会把尺寸恢复到跟pool4一样，然后把该结果和pool4后1x1卷积层产生的结果进行求和(不采用Max fusion的原因是会因为梯度选择而使得训练较为困难)。对于pool4后的1x1卷积层采用双线性插值初始化，但是允许参数在训练过程中进行调整。最后，将得到结果采用stride为16的方式进行上采样得到结果，该模型我们成为FCN-16s。同理，我们可以通过在pool3后添加1x1的卷积层并进行上述类似操作得到FCN-8s，但是得到的提升已经十分有限，因此不再进行更低层的fusion操作。\n\n![finer-fcns](finer-fcns.png)\n\n图中可以看出，通过融合使用不同stride的层得到的结果提高了分割的细节。\n\n![fcns-validation](fcns-validation.png)\n\n# 训练细节\n\n* SGD with momentum 0.9\n* Minibatch size of 20 images\n* Fixed learning rates of $10^{-3}$, $10^{-4}$, $10^{-5}$ for FCN-AlexNet, FCN-VGG16, FCN-GoogLeNet\n* Weight decay of $5^{-4}$ or $2^{-4}$\n* Doubled the learning rates for biases(非必要)\n* Zero-initialize the class scoring convolution layer\n* Dropout\n\n# 模型效果\n\n![resluts](results.png)\n\n# 参考文献\n* [全卷积网络 FCN 详解](http://www.cnblogs.com/gujianhan/p/6030639.html)\n* [论文阅读笔记：Fully Convolutional Networks for Semantic Segmentation](http://blog.csdn.net/tangwei2014/article/details/46882257)\n* [Convolution arithmetic](https://github.com/vdumoulin/conv_arithmetic)\n* [CS231n: Convolutional Neural Networks for Visual Recognition](http://cs231n.stanford.edu)\n","slug":"论文笔记-全卷积神经网络-FCN","published":1,"updated":"2018-01-15T01:09:30.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgvnqmlh001qw628vzw9qpyi","content":"<p>看了下时间已经快3个月没有写过东西了，客观原因是考试复习和项目上的事情比较多，主观原因是懒。</p>\n<p>最早接触机器学习是在大三，大四的时候了解了一些DL的知识，前几个月在网上学习了斯坦福的<a href=\"http://cs231n.stanford.edu\" target=\"_blank\" rel=\"noopener\">CS231n: Convolutional Neural Networks for Visual Recognition</a>，看了一些论文，对DL相关概念有了一些基本的了解，这篇文章是我阅读<a href=\"https://arxiv.org/abs/1411.4038v2\" target=\"_blank\" rel=\"noopener\">Fully Convolutional Networks for Semantic Segmentation</a>时的一些理解。</p>\n<a id=\"more\"></a>\n<h1 id=\"Sementic-Segmentation-语义分割\"><a href=\"#Sementic-Segmentation-语义分割\" class=\"headerlink\" title=\"Sementic Segmentation(语义分割)\"></a>Sementic Segmentation(语义分割)</h1><p>语义分割是计算机视觉领域的一个经典问题，它所要完成的工作是对于图片的每一个像素，对其赋予一个标签，这和分类(Classification)、定位(Localization)等任务有很大的区别，分类是完成判断“是什么”的任务，定位不仅需要判断“是什么”，还需要完成“在哪里”的任务。举个例子说明,对于下面这张图片:</p>\n<p><img src=\"/2017/07/25/论文笔记-全卷积神经网络-FCN/cat.png\" alt=\"cat\"></p>\n<p>对其进行语义分割，得到的结果如下图所示:</p>\n<p><img src=\"/2017/07/25/论文笔记-全卷积神经网络-FCN/ss-cat.png\" alt=\"ss-cat\"></p>\n<p>图中不同颜色代表了不同的语义，比如黄色代表了猫，绿色代表了草坪，蓝色代表了天空，粉紫色代表了猫身后的树林。</p>\n<p>语义分割对于人工智能迈向更高台阶是十分重要的，因为这一工作能够让计算机拥有类似人的判断，对其观察到的世界进行认识了解，这一工作在机器人领域以及自动驾驶等领域有很大的应用前景。</p>\n<p>在<a href=\"https://arxiv.org/abs/1411.4038v2\" target=\"_blank\" rel=\"noopener\">Fully Convolutional Networks for Semantic Segmentation</a>这篇论文将深度学习引入该领域之前，传统的语义分割主要依赖使用人工提取特征和概率图模型，而FCN这篇论文的发表，成为了语义分割的一个重要转折点。</p>\n<p>全卷积网络的概念其实很早就提出了，因此在本文获得CVPR’ 15最佳论文提名的时候被Yann Le\u0005Cun等人吐槽，当然，这篇论文仍然具有十分重要的意义。</p>\n<h1 id=\"全连接层-–-gt-卷积层\"><a href=\"#全连接层-–-gt-卷积层\" class=\"headerlink\" title=\"全连接层 –&gt; 卷积层\"></a>全连接层 –&gt; 卷积层</h1><p>传统的分类网络，比如LeNet、AlexNet等，只接受固定尺寸的输入并产生非空间输出，原因在于全连接层参数的限制，而且这些网络在通过全连接层把输入展开成向量的时候丢失了图片原有的空间信息。对VGG16中第一个全连接层为25088x4096，即该层输入未展开成向量前形状为7x7x512，展开后为1x25088，得到的输出为1x4096，其实换一个角度来看，如果采用512x7x7x4096的卷积层原始输入进行卷积操作，得到的结果为1x1x4096。这样操作后，对应于原来输出的向量，现在输出了heatmap，如下图所示。</p>\n<p><img src=\"/2017/07/25/论文笔记-全卷积神经网络-FCN/heatmap-cat.png\" alt=\"heatmap-cat\"></p>\n<p>使用卷积层替换全连接层这种操作具体有什么作用呢？</p>\n<p>以AlexNet为例，该网络输入为224x224x3，使用一系列卷积层和Pooling层使得数据尺寸变为7x7x512，紧接着是三个4096、4096、1000的全连接层，我们将三个全连接层分别转化为三个卷积层:</p>\n<ul>\n<li>对第一个全连接层25088x4096，我们可以使用kernel_size为7的4096个卷积核代替，这样得到的输出为1x1x4096</li>\n<li>对第二个全连接层4096x4096，使用kernel_size为1的4096个卷积核代替，得到输出为1x1x4096</li>\n<li>对第三个全连接层4096x1000，使用kernel_size为1的1000个卷积核代替，得到输出为1x1x1000</li>\n</ul>\n<p>假如我们想对384x384x3的图片进行语义分割，在不使用卷积层替换全连接层的情况下，我们使用步长为32大小为224x224x3的窗口在384x384x3的图片上进行滑动，得到6x6个位置的语义分割得分，然后进行fusion处理。但是因为我们使用了卷积层替换全连接层，现在的网络有能力对不同尺寸的输入进行处理。因此，384x384x3的输入经过卷积层和Pooling层后得到的尺寸为12x12x512，再通过上面经过转化的三个卷积层，得到的结果为6x6x1000，正好是对原图进行滑动得到的结果。</p>\n<p>论文给出了这两种方式的时间性能比较，在GPU上，AlexNet需要花费1.2毫秒来产生对一张227x227的图片预测，而FCN版本花费了22毫秒对一张500x500的图片产生大小为10x10的预测，比AlexNet快了5倍多。</p>\n<h1 id=\"Upsampling-上采样\"><a href=\"#Upsampling-上采样\" class=\"headerlink\" title=\"Upsampling(上采样)\"></a>Upsampling(上采样)</h1><p>以改造后的VGG16为例，让输入经过网络之后，我们得到的数据尺寸为[H/32, W/32]，而我们的目标是对每一个像素产生预测，因此我们需要进行upsampling操作，即恢复原始尺寸。在某种程度上，使用系数为$f$的upsampling可以看成是步长为$1/f$的卷积的转置，即只要$f$是整数，一种进行upsampling的方法就是使用<strong>backwards convolution</strong>(或称<strong>deconvolution</strong>，该术语存在争议，也有人称<strong>transposed convolution</strong>)，以输出步长为$f$进行计算。</p>\n<p><img src=\"/2017/07/25/论文笔记-全卷积神经网络-FCN/padding_strides.gif\" alt=\"padding_strides\"></p>\n<p>如图所示，绿色部分为输入，蓝色部分为输出，stride为2，padding为1。可以看出，<strong>transposed convolution</strong>其实就是<strong>convolution</strong>反过来，调换了<strong>convolution</strong>的前向传播和反向传播过程而已。</p>\n<h1 id=\"Architecture\"><a href=\"#Architecture\" class=\"headerlink\" title=\"Architecture\"></a>Architecture</h1><p>以VGG16和PASCAL数据集为例，我们去除了最后的分类层，并将所有的全连接层转化为上述的卷积层，然后添加了一层1x1x21的卷积层用于预测每个类别(包括背景)的得分，然后使用转置卷积进行双线性上采样，使得粗粒度输出(coarse outputs)变成像素密集的输出。</p>\n<p>虽然可以通过fine-tune来优化分割结果，得分也会变高，但是这些输出仍然比较粗糙无法令人满意。最后的prediction层采用stride为32的方式限制了上采样结果的细节程度。那么怎么处理这一问题呢？</p>\n<p>我们知道，随着卷积神经网络层数的增加，每一层的感知野(reception field)也更广，而网络结构中越低的层感知野越小，因此能得到更多细节。结合低层与高层输出可以使得模型在全局结构下进行局部预测。</p>\n<p><img src=\"/2017/07/25/论文笔记-全卷积神经网络-FCN/fine-coarse.png\" alt=\"fine-coarse\"></p>\n<p>图中所示为改造后的VGG16的简化图，图中只包含了输入层、由全连接层转化而来的卷积层以及Pooling层。对我们最初采用stride为32的上采样得到结果的模型我们称为FCN-32s，为了进一步优化输出预测。我们首先在pool4后面添加1x1的卷积层来产生额外的预测。然后对使用步长为32的conv7(卷积化后的fc7)进行2x上采样，因为pool5将尺寸缩减了一半，此时进行2x上采样将会把尺寸恢复到跟pool4一样，然后把该结果和pool4后1x1卷积层产生的结果进行求和(不采用Max fusion的原因是会因为梯度选择而使得训练较为困难)。对于pool4后的1x1卷积层采用双线性插值初始化，但是允许参数在训练过程中进行调整。最后，将得到结果采用stride为16的方式进行上采样得到结果，该模型我们成为FCN-16s。同理，我们可以通过在pool3后添加1x1的卷积层并进行上述类似操作得到FCN-8s，但是得到的提升已经十分有限，因此不再进行更低层的fusion操作。</p>\n<p><img src=\"/2017/07/25/论文笔记-全卷积神经网络-FCN/finer-fcns.png\" alt=\"finer-fcns\"></p>\n<p>图中可以看出，通过融合使用不同stride的层得到的结果提高了分割的细节。</p>\n<p><img src=\"/2017/07/25/论文笔记-全卷积神经网络-FCN/fcns-validation.png\" alt=\"fcns-validation\"></p>\n<h1 id=\"训练细节\"><a href=\"#训练细节\" class=\"headerlink\" title=\"训练细节\"></a>训练细节</h1><ul>\n<li>SGD with momentum 0.9</li>\n<li>Minibatch size of 20 images</li>\n<li>Fixed learning rates of $10^{-3}$, $10^{-4}$, $10^{-5}$ for FCN-AlexNet, FCN-VGG16, FCN-GoogLeNet</li>\n<li>Weight decay of $5^{-4}$ or $2^{-4}$</li>\n<li>Doubled the learning rates for biases(非必要)</li>\n<li>Zero-initialize the class scoring convolution layer</li>\n<li>Dropout</li>\n</ul>\n<h1 id=\"模型效果\"><a href=\"#模型效果\" class=\"headerlink\" title=\"模型效果\"></a>模型效果</h1><p><img src=\"/2017/07/25/论文笔记-全卷积神经网络-FCN/results.png\" alt=\"resluts\"></p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"http://www.cnblogs.com/gujianhan/p/6030639.html\" target=\"_blank\" rel=\"noopener\">全卷积网络 FCN 详解</a></li>\n<li><a href=\"http://blog.csdn.net/tangwei2014/article/details/46882257\" target=\"_blank\" rel=\"noopener\">论文阅读笔记：Fully Convolutional Networks for Semantic Segmentation</a></li>\n<li><a href=\"https://github.com/vdumoulin/conv_arithmetic\" target=\"_blank\" rel=\"noopener\">Convolution arithmetic</a></li>\n<li><a href=\"http://cs231n.stanford.edu\" target=\"_blank\" rel=\"noopener\">CS231n: Convolutional Neural Networks for Visual Recognition</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>看了下时间已经快3个月没有写过东西了，客观原因是考试复习和项目上的事情比较多，主观原因是懒。</p>\n<p>最早接触机器学习是在大三，大四的时候了解了一些DL的知识，前几个月在网上学习了斯坦福的<a href=\"http://cs231n.stanford.edu\" target=\"_blank\" rel=\"noopener\">CS231n: Convolutional Neural Networks for Visual Recognition</a>，看了一些论文，对DL相关概念有了一些基本的了解，这篇文章是我阅读<a href=\"https://arxiv.org/abs/1411.4038v2\" target=\"_blank\" rel=\"noopener\">Fully Convolutional Networks for Semantic Segmentation</a>时的一些理解。</p>","more":"<h1 id=\"Sementic-Segmentation-语义分割\"><a href=\"#Sementic-Segmentation-语义分割\" class=\"headerlink\" title=\"Sementic Segmentation(语义分割)\"></a>Sementic Segmentation(语义分割)</h1><p>语义分割是计算机视觉领域的一个经典问题，它所要完成的工作是对于图片的每一个像素，对其赋予一个标签，这和分类(Classification)、定位(Localization)等任务有很大的区别，分类是完成判断“是什么”的任务，定位不仅需要判断“是什么”，还需要完成“在哪里”的任务。举个例子说明,对于下面这张图片:</p>\n<p><img src=\"/2017/07/25/论文笔记-全卷积神经网络-FCN/cat.png\" alt=\"cat\"></p>\n<p>对其进行语义分割，得到的结果如下图所示:</p>\n<p><img src=\"/2017/07/25/论文笔记-全卷积神经网络-FCN/ss-cat.png\" alt=\"ss-cat\"></p>\n<p>图中不同颜色代表了不同的语义，比如黄色代表了猫，绿色代表了草坪，蓝色代表了天空，粉紫色代表了猫身后的树林。</p>\n<p>语义分割对于人工智能迈向更高台阶是十分重要的，因为这一工作能够让计算机拥有类似人的判断，对其观察到的世界进行认识了解，这一工作在机器人领域以及自动驾驶等领域有很大的应用前景。</p>\n<p>在<a href=\"https://arxiv.org/abs/1411.4038v2\" target=\"_blank\" rel=\"noopener\">Fully Convolutional Networks for Semantic Segmentation</a>这篇论文将深度学习引入该领域之前，传统的语义分割主要依赖使用人工提取特征和概率图模型，而FCN这篇论文的发表，成为了语义分割的一个重要转折点。</p>\n<p>全卷积网络的概念其实很早就提出了，因此在本文获得CVPR’ 15最佳论文提名的时候被Yann Le\u0005Cun等人吐槽，当然，这篇论文仍然具有十分重要的意义。</p>\n<h1 id=\"全连接层-–-gt-卷积层\"><a href=\"#全连接层-–-gt-卷积层\" class=\"headerlink\" title=\"全连接层 –&gt; 卷积层\"></a>全连接层 –&gt; 卷积层</h1><p>传统的分类网络，比如LeNet、AlexNet等，只接受固定尺寸的输入并产生非空间输出，原因在于全连接层参数的限制，而且这些网络在通过全连接层把输入展开成向量的时候丢失了图片原有的空间信息。对VGG16中第一个全连接层为25088x4096，即该层输入未展开成向量前形状为7x7x512，展开后为1x25088，得到的输出为1x4096，其实换一个角度来看，如果采用512x7x7x4096的卷积层原始输入进行卷积操作，得到的结果为1x1x4096。这样操作后，对应于原来输出的向量，现在输出了heatmap，如下图所示。</p>\n<p><img src=\"/2017/07/25/论文笔记-全卷积神经网络-FCN/heatmap-cat.png\" alt=\"heatmap-cat\"></p>\n<p>使用卷积层替换全连接层这种操作具体有什么作用呢？</p>\n<p>以AlexNet为例，该网络输入为224x224x3，使用一系列卷积层和Pooling层使得数据尺寸变为7x7x512，紧接着是三个4096、4096、1000的全连接层，我们将三个全连接层分别转化为三个卷积层:</p>\n<ul>\n<li>对第一个全连接层25088x4096，我们可以使用kernel_size为7的4096个卷积核代替，这样得到的输出为1x1x4096</li>\n<li>对第二个全连接层4096x4096，使用kernel_size为1的4096个卷积核代替，得到输出为1x1x4096</li>\n<li>对第三个全连接层4096x1000，使用kernel_size为1的1000个卷积核代替，得到输出为1x1x1000</li>\n</ul>\n<p>假如我们想对384x384x3的图片进行语义分割，在不使用卷积层替换全连接层的情况下，我们使用步长为32大小为224x224x3的窗口在384x384x3的图片上进行滑动，得到6x6个位置的语义分割得分，然后进行fusion处理。但是因为我们使用了卷积层替换全连接层，现在的网络有能力对不同尺寸的输入进行处理。因此，384x384x3的输入经过卷积层和Pooling层后得到的尺寸为12x12x512，再通过上面经过转化的三个卷积层，得到的结果为6x6x1000，正好是对原图进行滑动得到的结果。</p>\n<p>论文给出了这两种方式的时间性能比较，在GPU上，AlexNet需要花费1.2毫秒来产生对一张227x227的图片预测，而FCN版本花费了22毫秒对一张500x500的图片产生大小为10x10的预测，比AlexNet快了5倍多。</p>\n<h1 id=\"Upsampling-上采样\"><a href=\"#Upsampling-上采样\" class=\"headerlink\" title=\"Upsampling(上采样)\"></a>Upsampling(上采样)</h1><p>以改造后的VGG16为例，让输入经过网络之后，我们得到的数据尺寸为[H/32, W/32]，而我们的目标是对每一个像素产生预测，因此我们需要进行upsampling操作，即恢复原始尺寸。在某种程度上，使用系数为$f$的upsampling可以看成是步长为$1/f$的卷积的转置，即只要$f$是整数，一种进行upsampling的方法就是使用<strong>backwards convolution</strong>(或称<strong>deconvolution</strong>，该术语存在争议，也有人称<strong>transposed convolution</strong>)，以输出步长为$f$进行计算。</p>\n<p><img src=\"/2017/07/25/论文笔记-全卷积神经网络-FCN/padding_strides.gif\" alt=\"padding_strides\"></p>\n<p>如图所示，绿色部分为输入，蓝色部分为输出，stride为2，padding为1。可以看出，<strong>transposed convolution</strong>其实就是<strong>convolution</strong>反过来，调换了<strong>convolution</strong>的前向传播和反向传播过程而已。</p>\n<h1 id=\"Architecture\"><a href=\"#Architecture\" class=\"headerlink\" title=\"Architecture\"></a>Architecture</h1><p>以VGG16和PASCAL数据集为例，我们去除了最后的分类层，并将所有的全连接层转化为上述的卷积层，然后添加了一层1x1x21的卷积层用于预测每个类别(包括背景)的得分，然后使用转置卷积进行双线性上采样，使得粗粒度输出(coarse outputs)变成像素密集的输出。</p>\n<p>虽然可以通过fine-tune来优化分割结果，得分也会变高，但是这些输出仍然比较粗糙无法令人满意。最后的prediction层采用stride为32的方式限制了上采样结果的细节程度。那么怎么处理这一问题呢？</p>\n<p>我们知道，随着卷积神经网络层数的增加，每一层的感知野(reception field)也更广，而网络结构中越低的层感知野越小，因此能得到更多细节。结合低层与高层输出可以使得模型在全局结构下进行局部预测。</p>\n<p><img src=\"/2017/07/25/论文笔记-全卷积神经网络-FCN/fine-coarse.png\" alt=\"fine-coarse\"></p>\n<p>图中所示为改造后的VGG16的简化图，图中只包含了输入层、由全连接层转化而来的卷积层以及Pooling层。对我们最初采用stride为32的上采样得到结果的模型我们称为FCN-32s，为了进一步优化输出预测。我们首先在pool4后面添加1x1的卷积层来产生额外的预测。然后对使用步长为32的conv7(卷积化后的fc7)进行2x上采样，因为pool5将尺寸缩减了一半，此时进行2x上采样将会把尺寸恢复到跟pool4一样，然后把该结果和pool4后1x1卷积层产生的结果进行求和(不采用Max fusion的原因是会因为梯度选择而使得训练较为困难)。对于pool4后的1x1卷积层采用双线性插值初始化，但是允许参数在训练过程中进行调整。最后，将得到结果采用stride为16的方式进行上采样得到结果，该模型我们成为FCN-16s。同理，我们可以通过在pool3后添加1x1的卷积层并进行上述类似操作得到FCN-8s，但是得到的提升已经十分有限，因此不再进行更低层的fusion操作。</p>\n<p><img src=\"/2017/07/25/论文笔记-全卷积神经网络-FCN/finer-fcns.png\" alt=\"finer-fcns\"></p>\n<p>图中可以看出，通过融合使用不同stride的层得到的结果提高了分割的细节。</p>\n<p><img src=\"/2017/07/25/论文笔记-全卷积神经网络-FCN/fcns-validation.png\" alt=\"fcns-validation\"></p>\n<h1 id=\"训练细节\"><a href=\"#训练细节\" class=\"headerlink\" title=\"训练细节\"></a>训练细节</h1><ul>\n<li>SGD with momentum 0.9</li>\n<li>Minibatch size of 20 images</li>\n<li>Fixed learning rates of $10^{-3}$, $10^{-4}$, $10^{-5}$ for FCN-AlexNet, FCN-VGG16, FCN-GoogLeNet</li>\n<li>Weight decay of $5^{-4}$ or $2^{-4}$</li>\n<li>Doubled the learning rates for biases(非必要)</li>\n<li>Zero-initialize the class scoring convolution layer</li>\n<li>Dropout</li>\n</ul>\n<h1 id=\"模型效果\"><a href=\"#模型效果\" class=\"headerlink\" title=\"模型效果\"></a>模型效果</h1><p><img src=\"/2017/07/25/论文笔记-全卷积神经网络-FCN/results.png\" alt=\"resluts\"></p>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><ul>\n<li><a href=\"http://www.cnblogs.com/gujianhan/p/6030639.html\" target=\"_blank\" rel=\"noopener\">全卷积网络 FCN 详解</a></li>\n<li><a href=\"http://blog.csdn.net/tangwei2014/article/details/46882257\" target=\"_blank\" rel=\"noopener\">论文阅读笔记：Fully Convolutional Networks for Semantic Segmentation</a></li>\n<li><a href=\"https://github.com/vdumoulin/conv_arithmetic\" target=\"_blank\" rel=\"noopener\">Convolution arithmetic</a></li>\n<li><a href=\"http://cs231n.stanford.edu\" target=\"_blank\" rel=\"noopener\">CS231n: Convolutional Neural Networks for Visual Recognition</a></li>\n</ul>"}],"PostAsset":[{"_id":"source/_posts/Bloom-Filter/error_rate_fig.png","slug":"error_rate_fig.png","post":"cjgvnqmkg0008w62883q260tt","modified":1,"renderable":0},{"_id":"source/_posts/Python-A-JD-spider-based-on-scrapy/console_network_after.png","slug":"console_network_after.png","post":"cjgvnqml4000qw628phqqr7if","modified":1,"renderable":0},{"_id":"source/_posts/Python-A-JD-spider-based-on-scrapy/console_network_before.png","slug":"console_network_before.png","post":"cjgvnqml4000qw628phqqr7if","modified":1,"renderable":0},{"_id":"source/_posts/Python-A-JD-spider-based-on-scrapy/item_shoe_comments_tab.png","slug":"item_shoe_comments_tab.png","post":"cjgvnqml4000qw628phqqr7if","modified":1,"renderable":0},{"_id":"source/_posts/DDIA读书笔记1/Data_system_architecture_combining_several_components.png","post":"cjgvnqmkr000fw628x9b1homu","slug":"Data_system_architecture_combining_several_components.png","modified":1,"renderable":1},{"_id":"source/_posts/Python-multiprocessing pool/python_multiprocessing_pool.png","post":"cjgvnqml90015w628ld33u3f4","slug":"python_multiprocessing_pool.png","modified":1,"renderable":1},{"_id":"source/_posts/CPP-Access-n-d-array-with-1-d-index-array/c_1d_array.png","post":"cjgvnqmkj000bw628o2xttoz2","slug":"c_1d_array.png","modified":1,"renderable":1},{"_id":"source/_posts/CPP-Access-n-d-array-with-1-d-index-array/c_2d_array.png","post":"cjgvnqmkj000bw628o2xttoz2","slug":"c_2d_array.png","modified":1,"renderable":1},{"_id":"source/_posts/DDIA读书笔记2/requests.png","post":"cjgvnqmkv000hw628tqu1bnpb","slug":"requests.png","modified":1,"renderable":1},{"_id":"source/_posts/DDIA读书笔记2/twitter_sql.png","post":"cjgvnqmkv000hw628tqu1bnpb","slug":"twitter_sql.png","modified":1,"renderable":1},{"_id":"source/_posts/Bloom-Filter/bloom_filter.png","post":"cjgvnqmkg0008w62883q260tt","slug":"bloom_filter.png","modified":1,"renderable":1},{"_id":"source/_posts/Bloom-Filter/bloom_filter_error.png","post":"cjgvnqmkg0008w62883q260tt","slug":"bloom_filter_error.png","modified":1,"renderable":1},{"_id":"source/_posts/Bloom-Filter/bloom_filter_lookup.png","post":"cjgvnqmkg0008w62883q260tt","slug":"bloom_filter_lookup.png","modified":1,"renderable":1},{"_id":"source/_posts/Python-Method Resolution Order/python_inheritance.png","post":"cjgvnqml5000tw628a1af1zp4","slug":"python_inheritance.png","modified":1,"renderable":1},{"_id":"source/_posts/Python-Method Resolution Order/python_inheritance2.png","post":"cjgvnqml5000tw628a1af1zp4","slug":"python_inheritance2.png","modified":1,"renderable":1},{"_id":"source/_posts/Python-Method Resolution Order/python_inheritance3.png","post":"cjgvnqml5000tw628a1af1zp4","slug":"python_inheritance3.png","modified":1,"renderable":1},{"_id":"source/_posts/Python-Method Resolution Order/python_inheritance4.png","post":"cjgvnqml5000tw628a1af1zp4","slug":"python_inheritance4.png","modified":1,"renderable":1},{"_id":"source/_posts/New-to-asyncio/async.png","post":"cjgvnqml2000nw628x8rdpejh","slug":"async.png","modified":1,"renderable":1},{"_id":"source/_posts/New-to-asyncio/block.png","post":"cjgvnqml2000nw628x8rdpejh","slug":"block.png","modified":1,"renderable":1},{"_id":"source/_posts/New-to-asyncio/reactor-1.png","post":"cjgvnqml2000nw628x8rdpejh","slug":"reactor-1.png","modified":1,"renderable":1},{"_id":"source/_posts/New-to-asyncio/sync.png","post":"cjgvnqml2000nw628x8rdpejh","slug":"sync.png","modified":1,"renderable":1},{"_id":"source/_posts/New-to-asyncio/threaded.png","post":"cjgvnqml2000nw628x8rdpejh","slug":"threaded.png","modified":1,"renderable":1},{"_id":"source/_posts/Consistent-Hashing/bias_on_hash_ring.png","post":"cjgvnqmko000cw6284vskvqpv","slug":"bias_on_hash_ring.png","modified":1,"renderable":1},{"_id":"source/_posts/Consistent-Hashing/hash_ring.png","post":"cjgvnqmko000cw6284vskvqpv","slug":"hash_ring.png","modified":1,"renderable":1},{"_id":"source/_posts/Consistent-Hashing/pic_belong.png","post":"cjgvnqmko000cw6284vskvqpv","slug":"pic_belong.png","modified":1,"renderable":1},{"_id":"source/_posts/Consistent-Hashing/pic_on_hash_ring.png","post":"cjgvnqmko000cw6284vskvqpv","slug":"pic_on_hash_ring.png","modified":1,"renderable":1},{"_id":"source/_posts/Consistent-Hashing/pics_on_hash_ring.png","post":"cjgvnqmko000cw6284vskvqpv","slug":"pics_on_hash_ring.png","modified":1,"renderable":1},{"_id":"source/_posts/Consistent-Hashing/servers_on_hash_ring.png","post":"cjgvnqmko000cw6284vskvqpv","slug":"servers_on_hash_ring.png","modified":1,"renderable":1},{"_id":"source/_posts/Consistent-Hashing/virtual_nodes_on_hash_ring.png","post":"cjgvnqmko000cw6284vskvqpv","slug":"virtual_nodes_on_hash_ring.png","modified":1,"renderable":1},{"_id":"source/_posts/Python-A-JD-spider-based-on-scrapy/comments_json_1.png","slug":"comments_json_1.png","post":"cjgvnqml4000qw628phqqr7if","modified":1,"renderable":0},{"_id":"source/_posts/Python-A-JD-spider-based-on-scrapy/comments_json_2.png","post":"cjgvnqml4000qw628phqqr7if","slug":"comments_json_2.png","modified":1,"renderable":1},{"_id":"source/_posts/Python-A-JD-spider-based-on-scrapy/console_item_list.png","slug":"console_item_list.png","post":"cjgvnqml4000qw628phqqr7if","modified":1,"renderable":0},{"_id":"source/_posts/Python-A-JD-spider-based-on-scrapy/console_item_list_2.png","post":"cjgvnqml4000qw628phqqr7if","slug":"console_item_list_2.png","modified":1,"renderable":1},{"_id":"source/_posts/Python-A-JD-spider-based-on-scrapy/item_detail_no_js.png","post":"cjgvnqml4000qw628phqqr7if","slug":"item_detail_no_js.png","modified":1,"renderable":1},{"_id":"source/_posts/论文笔记-全卷积神经网络-FCN/cat.png","post":"cjgvnqmlh001qw628vzw9qpyi","slug":"cat.png","modified":1,"renderable":1},{"_id":"source/_posts/论文笔记-全卷积神经网络-FCN/fcns-validation.png","post":"cjgvnqmlh001qw628vzw9qpyi","slug":"fcns-validation.png","modified":1,"renderable":1},{"_id":"source/_posts/论文笔记-全卷积神经网络-FCN/fine-coarse.png","post":"cjgvnqmlh001qw628vzw9qpyi","slug":"fine-coarse.png","modified":1,"renderable":1},{"_id":"source/_posts/论文笔记-全卷积神经网络-FCN/finer-fcns.png","post":"cjgvnqmlh001qw628vzw9qpyi","slug":"finer-fcns.png","modified":1,"renderable":1},{"_id":"source/_posts/论文笔记-全卷积神经网络-FCN/heatmap-cat.png","slug":"heatmap-cat.png","post":"cjgvnqmlh001qw628vzw9qpyi","modified":1,"renderable":0},{"_id":"source/_posts/论文笔记-全卷积神经网络-FCN/padding_strides.gif","post":"cjgvnqmlh001qw628vzw9qpyi","slug":"padding_strides.gif","modified":1,"renderable":1},{"_id":"source/_posts/论文笔记-全卷积神经网络-FCN/results.png","slug":"results.png","post":"cjgvnqmlh001qw628vzw9qpyi","modified":1,"renderable":0},{"_id":"source/_posts/论文笔记-全卷积神经网络-FCN/ss-cat.png","post":"cjgvnqmlh001qw628vzw9qpyi","slug":"ss-cat.png","modified":1,"renderable":1},{"_id":"source/_posts/Django中的select-related与prefetch-related/complex_raw_sel_pre_avg.png","post":"cjgvnqmky000kw628fafkq5cb","slug":"complex_raw_sel_pre_avg.png","modified":1,"renderable":1},{"_id":"source/_posts/Django中的select-related与prefetch-related/complex_raw_sel_pre_tot.png","post":"cjgvnqmky000kw628fafkq5cb","slug":"complex_raw_sel_pre_tot.png","modified":1,"renderable":1},{"_id":"source/_posts/Django中的select-related与prefetch-related/complex_sel_pre_avg.png","post":"cjgvnqmky000kw628fafkq5cb","slug":"complex_sel_pre_avg.png","modified":1,"renderable":1},{"_id":"source/_posts/Django中的select-related与prefetch-related/complex_sel_pre_tot.png","post":"cjgvnqmky000kw628fafkq5cb","slug":"complex_sel_pre_tot.png","modified":1,"renderable":1},{"_id":"source/_posts/Django中的select-related与prefetch-related/filter_id_lte_5.png","post":"cjgvnqmky000kw628fafkq5cb","slug":"filter_id_lte_5.png","modified":1,"renderable":1},{"_id":"source/_posts/Django中的select-related与prefetch-related/filter_id_lte_5_with_prefetch_related.png","post":"cjgvnqmky000kw628fafkq5cb","slug":"filter_id_lte_5_with_prefetch_related.png","modified":1,"renderable":1},{"_id":"source/_posts/Django中的select-related与prefetch-related/get_with_prefetch_related.png","post":"cjgvnqmky000kw628fafkq5cb","slug":"get_with_prefetch_related.png","modified":1,"renderable":1},{"_id":"source/_posts/Django中的select-related与prefetch-related/get_with_select_related.png","post":"cjgvnqmky000kw628fafkq5cb","slug":"get_with_select_related.png","modified":1,"renderable":1},{"_id":"source/_posts/Django中的select-related与prefetch-related/get_without_select_related.png","post":"cjgvnqmky000kw628fafkq5cb","slug":"get_without_select_related.png","modified":1,"renderable":1},{"_id":"source/_posts/Django中的select-related与prefetch-related/simple_raw_sel_pre_avg.png","post":"cjgvnqmky000kw628fafkq5cb","slug":"simple_raw_sel_pre_avg.png","modified":1,"renderable":1},{"_id":"source/_posts/Django中的select-related与prefetch-related/simple_raw_sel_pre_tot.png","post":"cjgvnqmky000kw628fafkq5cb","slug":"simple_raw_sel_pre_tot.png","modified":1,"renderable":1},{"_id":"source/_posts/Django中的select-related与prefetch-related/simple_sel_pre_avg.png","post":"cjgvnqmky000kw628fafkq5cb","slug":"simple_sel_pre_avg.png","modified":1,"renderable":1},{"_id":"source/_posts/Django中的select-related与prefetch-related/simple_sel_pre_tot.png","post":"cjgvnqmky000kw628fafkq5cb","slug":"simple_sel_pre_tot.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjgvnqmk30000w6280px2lyg5","category_id":"cjgvnqmkb0004w628wndorn43","_id":"cjgvnqmkp000ew628az558g5x"},{"post_id":"cjgvnqmk90002w628hequnrxl","category_id":"cjgvnqmkb0004w628wndorn43","_id":"cjgvnqmkw000jw628qdvkojqx"},{"post_id":"cjgvnqmko000cw6284vskvqpv","category_id":"cjgvnqmkb0004w628wndorn43","_id":"cjgvnqmkz000lw628ijkxwlmu"},{"post_id":"cjgvnqmkr000fw628x9b1homu","category_id":"cjgvnqmkb0004w628wndorn43","_id":"cjgvnqml2000ow6289m6kst5e"},{"post_id":"cjgvnqmkc0005w628y22s6xpj","category_id":"cjgvnqmkb0004w628wndorn43","_id":"cjgvnqml4000rw628th2bq8pb"},{"post_id":"cjgvnqmkv000hw628tqu1bnpb","category_id":"cjgvnqmkb0004w628wndorn43","_id":"cjgvnqml6000uw628u63q8pkx"},{"post_id":"cjgvnqmke0007w628j9gypif4","category_id":"cjgvnqmkw000iw628q5zkksbf","_id":"cjgvnqml7000yw6283y2oz9un"},{"post_id":"cjgvnqml2000nw628x8rdpejh","category_id":"cjgvnqmkw000iw628q5zkksbf","_id":"cjgvnqml90012w628quljgq3k"},{"post_id":"cjgvnqml4000qw628phqqr7if","category_id":"cjgvnqmkw000iw628q5zkksbf","_id":"cjgvnqmla0016w6289vtysu9d"},{"post_id":"cjgvnqmkg0008w62883q260tt","category_id":"cjgvnqml3000pw628hi2a7upl","_id":"cjgvnqmlb0019w62872jzyf6l"},{"post_id":"cjgvnqml5000tw628a1af1zp4","category_id":"cjgvnqmkw000iw628q5zkksbf","_id":"cjgvnqmlc001bw628ckn6ddim"},{"post_id":"cjgvnqml7000xw6281wkd7h77","category_id":"cjgvnqmkw000iw628q5zkksbf","_id":"cjgvnqmld001dw628o7qfm3ar"},{"post_id":"cjgvnqmkj000bw628o2xttoz2","category_id":"cjgvnqml6000ww628o43pkuw6","_id":"cjgvnqmlf001hw6285nfpfsh0"},{"post_id":"cjgvnqml80011w628lhozngx0","category_id":"cjgvnqmkw000iw628q5zkksbf","_id":"cjgvnqmlg001kw628j0k4a992"},{"post_id":"cjgvnqml90015w628ld33u3f4","category_id":"cjgvnqmkw000iw628q5zkksbf","_id":"cjgvnqmlh001ow628ggd4wr3k"},{"post_id":"cjgvnqmla0017w628j2omkd74","category_id":"cjgvnqmkw000iw628q5zkksbf","_id":"cjgvnqmli001rw6283s50aa6b"},{"post_id":"cjgvnqmky000kw628fafkq5cb","category_id":"cjgvnqml90014w628seyno2av","_id":"cjgvnqmlj001tw628jy6hig13"},{"post_id":"cjgvnqmlc001aw628r8tv2z1z","category_id":"cjgvnqmkw000iw628q5zkksbf","_id":"cjgvnqmlj001vw628kp650ea0"},{"post_id":"cjgvnqmld001cw628kwijvlce","category_id":"cjgvnqmkw000iw628q5zkksbf","_id":"cjgvnqmlj001xw6284r6970ma"},{"post_id":"cjgvnqmle001fw628yyop8l1l","category_id":"cjgvnqmkw000iw628q5zkksbf","_id":"cjgvnqmlk001zw628jgxuyaoa"},{"post_id":"cjgvnqmlf001iw628gcrek6c8","category_id":"cjgvnqmlh001pw628yfeu44wx","_id":"cjgvnqmll0023w62837keu7b6"},{"post_id":"cjgvnqmlg001mw628prwjt71w","category_id":"cjgvnqmlj001uw628ghr30xs2","_id":"cjgvnqmll0025w628tatuvggw"},{"post_id":"cjgvnqmlh001qw628vzw9qpyi","category_id":"cjgvnqmlh001pw628yfeu44wx","_id":"cjgvnqmll0027w628b8arxbmj"}],"PostTag":[{"post_id":"cjgvnqmke0007w628j9gypif4","tag_id":"cjgvnqmki000aw6286kmk2q32","_id":"cjgvnqml6000vw628j4g2ux2s"},{"post_id":"cjgvnqmke0007w628j9gypif4","tag_id":"cjgvnqmks000gw6281ss44i2b","_id":"cjgvnqml8000zw628umt1a6e5"},{"post_id":"cjgvnqmke0007w628j9gypif4","tag_id":"cjgvnqml1000mw628tn59zn2k","_id":"cjgvnqml90013w628p0osx4op"},{"post_id":"cjgvnqmkg0008w62883q260tt","tag_id":"cjgvnqml5000sw628s4ufh26o","_id":"cjgvnqmlf001gw62827srks65"},{"post_id":"cjgvnqmkg0008w62883q260tt","tag_id":"cjgvnqml80010w628djycx3nr","_id":"cjgvnqmlg001jw628vqp66l0v"},{"post_id":"cjgvnqmkg0008w62883q260tt","tag_id":"cjgvnqmlb0018w628qipuoagh","_id":"cjgvnqmlh001nw628emiqpmnx"},{"post_id":"cjgvnqmkj000bw628o2xttoz2","tag_id":"cjgvnqmle001ew628h6zremdt","_id":"cjgvnqmlk001yw628ng3a20o7"},{"post_id":"cjgvnqmkj000bw628o2xttoz2","tag_id":"cjgvnqmlg001lw628a0r6ugc1","_id":"cjgvnqmlk0021w628fee29j14"},{"post_id":"cjgvnqmkj000bw628o2xttoz2","tag_id":"cjgvnqmli001sw628l2t2yl4p","_id":"cjgvnqmll0024w628smg5xyvf"},{"post_id":"cjgvnqmko000cw6284vskvqpv","tag_id":"cjgvnqmlb0018w628qipuoagh","_id":"cjgvnqmlm0029w628brvjiqwx"},{"post_id":"cjgvnqmko000cw6284vskvqpv","tag_id":"cjgvnqmlk0022w628d4fouzr2","_id":"cjgvnqmlm002aw628rsii7iu4"},{"post_id":"cjgvnqmko000cw6284vskvqpv","tag_id":"cjgvnqmll0026w628tkifhwvz","_id":"cjgvnqmlm002cw6282hc52u8h"},{"post_id":"cjgvnqmkr000fw628x9b1homu","tag_id":"cjgvnqmlm0028w628nq7gjxr6","_id":"cjgvnqmlm002ew628ztz9g81q"},{"post_id":"cjgvnqmkr000fw628x9b1homu","tag_id":"cjgvnqmlm002bw628o307i1l4","_id":"cjgvnqmln002fw62879w7e9n7"},{"post_id":"cjgvnqmkv000hw628tqu1bnpb","tag_id":"cjgvnqmlm002dw628hff4mp53","_id":"cjgvnqmln002jw628wwh8gy4s"},{"post_id":"cjgvnqmkv000hw628tqu1bnpb","tag_id":"cjgvnqmln002gw62865mmlwsv","_id":"cjgvnqmlo002kw6289ek7t035"},{"post_id":"cjgvnqmkv000hw628tqu1bnpb","tag_id":"cjgvnqmln002hw628rf5rufj7","_id":"cjgvnqmlo002mw628642i9tt3"},{"post_id":"cjgvnqmky000kw628fafkq5cb","tag_id":"cjgvnqmki000aw6286kmk2q32","_id":"cjgvnqmlo002ow628v3k1u9db"},{"post_id":"cjgvnqmky000kw628fafkq5cb","tag_id":"cjgvnqmln002iw628gqjypdmq","_id":"cjgvnqmlo002pw628x6ile2g0"},{"post_id":"cjgvnqmky000kw628fafkq5cb","tag_id":"cjgvnqmlo002lw628oknqjqpc","_id":"cjgvnqmlp002rw62824ro8n1d"},{"post_id":"cjgvnqml2000nw628x8rdpejh","tag_id":"cjgvnqmki000aw6286kmk2q32","_id":"cjgvnqmlp002tw628q7vsz7ov"},{"post_id":"cjgvnqml2000nw628x8rdpejh","tag_id":"cjgvnqmlo002nw628gneb6foq","_id":"cjgvnqmlp002uw628yraw8rmd"},{"post_id":"cjgvnqml2000nw628x8rdpejh","tag_id":"cjgvnqmlo002qw628wzr23onn","_id":"cjgvnqmlq002ww628axj7z95i"},{"post_id":"cjgvnqml4000qw628phqqr7if","tag_id":"cjgvnqmki000aw6286kmk2q32","_id":"cjgvnqmlq002yw628q73okfjt"},{"post_id":"cjgvnqml4000qw628phqqr7if","tag_id":"cjgvnqml80010w628djycx3nr","_id":"cjgvnqmlq002zw628f6o1sp0q"},{"post_id":"cjgvnqml4000qw628phqqr7if","tag_id":"cjgvnqmlp002vw628x9qam46j","_id":"cjgvnqmlq0031w628n775e0qq"},{"post_id":"cjgvnqml5000tw628a1af1zp4","tag_id":"cjgvnqmki000aw6286kmk2q32","_id":"cjgvnqmlr0033w628msbopfuh"},{"post_id":"cjgvnqml5000tw628a1af1zp4","tag_id":"cjgvnqmlq002xw6285ll0w9e0","_id":"cjgvnqmlr0034w62880l8zjih"},{"post_id":"cjgvnqml5000tw628a1af1zp4","tag_id":"cjgvnqmlq0030w628617cuiab","_id":"cjgvnqmlr0036w62887mj3f2p"},{"post_id":"cjgvnqml7000xw6281wkd7h77","tag_id":"cjgvnqmki000aw6286kmk2q32","_id":"cjgvnqmls0038w628mz98jg6a"},{"post_id":"cjgvnqml7000xw6281wkd7h77","tag_id":"cjgvnqmlr0032w628lntcx0zx","_id":"cjgvnqmls0039w628ir4t68zy"},{"post_id":"cjgvnqml7000xw6281wkd7h77","tag_id":"cjgvnqmlr0035w628kub4jna0","_id":"cjgvnqmls003bw628qfptfuu3"},{"post_id":"cjgvnqml80011w628lhozngx0","tag_id":"cjgvnqmki000aw6286kmk2q32","_id":"cjgvnqmlt003dw628eobs1ur2"},{"post_id":"cjgvnqml80011w628lhozngx0","tag_id":"cjgvnqmlr0032w628lntcx0zx","_id":"cjgvnqmlt003ew628n15fpokn"},{"post_id":"cjgvnqml80011w628lhozngx0","tag_id":"cjgvnqmlr0035w628kub4jna0","_id":"cjgvnqmlt003gw628irdr0pb8"},{"post_id":"cjgvnqml90015w628ld33u3f4","tag_id":"cjgvnqmki000aw6286kmk2q32","_id":"cjgvnqmlu003iw628cvcsekb8"},{"post_id":"cjgvnqml90015w628ld33u3f4","tag_id":"cjgvnqmlt003cw628klwp3b0r","_id":"cjgvnqmlu003jw628ubpbi9f0"},{"post_id":"cjgvnqml90015w628ld33u3f4","tag_id":"cjgvnqmlt003fw6288t9dejjm","_id":"cjgvnqmlu003lw628g5rs2ck2"},{"post_id":"cjgvnqmla0017w628j2omkd74","tag_id":"cjgvnqmki000aw6286kmk2q32","_id":"cjgvnqmlv003nw628neg1a8kp"},{"post_id":"cjgvnqmla0017w628j2omkd74","tag_id":"cjgvnqmlq002xw6285ll0w9e0","_id":"cjgvnqmlv003ow6282p7nrozt"},{"post_id":"cjgvnqmla0017w628j2omkd74","tag_id":"cjgvnqmlu003kw6285mc5ulro","_id":"cjgvnqmlv003qw628rxttps4c"},{"post_id":"cjgvnqmlc001aw628r8tv2z1z","tag_id":"cjgvnqmki000aw6286kmk2q32","_id":"cjgvnqmlw003sw628e5f9uwg8"},{"post_id":"cjgvnqmlc001aw628r8tv2z1z","tag_id":"cjgvnqmlv003mw628i284tysl","_id":"cjgvnqmlw003tw628s7e3wzuk"},{"post_id":"cjgvnqmlc001aw628r8tv2z1z","tag_id":"cjgvnqmlv003pw62890elloke","_id":"cjgvnqmlx003vw6288zapr1zm"},{"post_id":"cjgvnqmld001cw628kwijvlce","tag_id":"cjgvnqmki000aw6286kmk2q32","_id":"cjgvnqmlx003xw628jreplyrx"},{"post_id":"cjgvnqmld001cw628kwijvlce","tag_id":"cjgvnqmlv003pw62890elloke","_id":"cjgvnqmly003yw628fx6mqhfz"},{"post_id":"cjgvnqmld001cw628kwijvlce","tag_id":"cjgvnqmlv003mw628i284tysl","_id":"cjgvnqmly0040w628oyx0k5ty"},{"post_id":"cjgvnqmle001fw628yyop8l1l","tag_id":"cjgvnqmki000aw6286kmk2q32","_id":"cjgvnqmlz0042w628c8u4xqrx"},{"post_id":"cjgvnqmle001fw628yyop8l1l","tag_id":"cjgvnqmlx003ww628cbvofbmr","_id":"cjgvnqmlz0043w628dlz3btsc"},{"post_id":"cjgvnqmle001fw628yyop8l1l","tag_id":"cjgvnqmly003zw6289fs0oahq","_id":"cjgvnqmlz0045w6285ynz33zy"},{"post_id":"cjgvnqmlf001iw628gcrek6c8","tag_id":"cjgvnqmly0041w628zx66ebu4","_id":"cjgvnqmm00048w628aha4flpy"},{"post_id":"cjgvnqmlf001iw628gcrek6c8","tag_id":"cjgvnqmlz0044w628hj3ovy6x","_id":"cjgvnqmm00049w628c0xd7o5o"},{"post_id":"cjgvnqmlf001iw628gcrek6c8","tag_id":"cjgvnqmlz0046w6288lyg1xj4","_id":"cjgvnqmm0004bw628kdlqbclf"},{"post_id":"cjgvnqmlg001mw628prwjt71w","tag_id":"cjgvnqmlz0047w6280mybbeoh","_id":"cjgvnqmm1004fw628fi8l1iv9"},{"post_id":"cjgvnqmlg001mw628prwjt71w","tag_id":"cjgvnqmm0004aw628a38ps00z","_id":"cjgvnqmm1004gw628uwi9o4xy"},{"post_id":"cjgvnqmlg001mw628prwjt71w","tag_id":"cjgvnqmm0004cw628zqqjtq21","_id":"cjgvnqmm2004iw628h35gtzat"},{"post_id":"cjgvnqmlg001mw628prwjt71w","tag_id":"cjgvnqmm1004dw6289h9qky88","_id":"cjgvnqmm2004jw62861fkf5wj"},{"post_id":"cjgvnqmlh001qw628vzw9qpyi","tag_id":"cjgvnqmly0041w628zx66ebu4","_id":"cjgvnqmm2004lw628w0ktovi1"},{"post_id":"cjgvnqmlh001qw628vzw9qpyi","tag_id":"cjgvnqmm1004hw6284rgqtho9","_id":"cjgvnqmm2004mw628ky8gbs7i"},{"post_id":"cjgvnqmlh001qw628vzw9qpyi","tag_id":"cjgvnqmm2004kw628zu413gq3","_id":"cjgvnqmm2004nw6283t7ds5p2"}],"Tag":[{"name":"Python","_id":"cjgvnqmki000aw6286kmk2q32"},{"name":"正则","_id":"cjgvnqmks000gw6281ss44i2b"},{"name":"re模块","_id":"cjgvnqml1000mw628tn59zn2k"},{"name":"系统设计","_id":"cjgvnqml5000sw628s4ufh26o"},{"name":"爬虫","_id":"cjgvnqml80010w628djycx3nr"},{"name":"哈希算法","_id":"cjgvnqmlb0018w628qipuoagh"},{"name":"CPP","_id":"cjgvnqmle001ew628h6zremdt"},{"name":"指针","_id":"cjgvnqmlg001lw628a0r6ugc1"},{"name":"数组","_id":"cjgvnqmli001sw628l2t2yl4p"},{"name":"分布式","_id":"cjgvnqmlk0022w628d4fouzr2"},{"name":"缓存","_id":"cjgvnqmll0026w628tkifhwvz"},{"name":"数据系统","_id":"cjgvnqmlm0028w628nq7gjxr6"},{"name":"可靠性","_id":"cjgvnqmlm002bw628o307i1l4"},{"name":"可扩展性","_id":"cjgvnqmlm002dw628hff4mp53"},{"name":"负载","_id":"cjgvnqmln002gw62865mmlwsv"},{"name":"可维护性","_id":"cjgvnqmln002hw628rf5rufj7"},{"name":"Django","_id":"cjgvnqmln002iw628gqjypdmq"},{"name":"数据库","_id":"cjgvnqmlo002lw628oknqjqpc"},{"name":"协程","_id":"cjgvnqmlo002nw628gneb6foq"},{"name":"asyncio","_id":"cjgvnqmlo002qw628wzr23onn"},{"name":"Scrapy","_id":"cjgvnqmlp002vw628x9qam46j"},{"name":"类","_id":"cjgvnqmlq002xw6285ll0w9e0"},{"name":"继承","_id":"cjgvnqmlq0030w628617cuiab"},{"name":"生成器","_id":"cjgvnqmlr0032w628lntcx0zx"},{"name":"迭代器","_id":"cjgvnqmlr0035w628kub4jna0"},{"name":"多进程","_id":"cjgvnqmlt003cw628klwp3b0r"},{"name":"进程池","_id":"cjgvnqmlt003fw6288t9dejjm"},{"name":"面向对象编程","_id":"cjgvnqmlu003kw6285mc5ulro"},{"name":"描述器","_id":"cjgvnqmlv003mw628i284tysl"},{"name":"属性","_id":"cjgvnqmlv003pw62890elloke"},{"name":"单元测试","_id":"cjgvnqmlx003ww628cbvofbmr"},{"name":"mock","_id":"cjgvnqmly003zw6289fs0oahq"},{"name":"机器学习","_id":"cjgvnqmly0041w628zx66ebu4"},{"name":"监督学习","_id":"cjgvnqmlz0044w628hj3ovy6x"},{"name":"KNN","_id":"cjgvnqmlz0046w6288lyg1xj4"},{"name":"欢迎","_id":"cjgvnqmlz0047w6280mybbeoh"},{"name":"第一篇","_id":"cjgvnqmm0004aw628a38ps00z"},{"name":"博客","_id":"cjgvnqmm0004cw628zqqjtq21"},{"name":"新功能","_id":"cjgvnqmm1004dw6289h9qky88"},{"name":"深度学习","_id":"cjgvnqmm1004hw6284rgqtho9"},{"name":"语义分割","_id":"cjgvnqmm2004kw628zu413gq3"}]}}