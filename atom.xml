<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>David&#39;s Blog</title>
  <subtitle>A graduate student in Computer Science</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://youchen.me/"/>
  <updated>2017-02-07T09:17:51.000Z</updated>
  <id>http://youchen.me/</id>
  
  <author>
    <name>David</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python中的metaclass(元类)</title>
    <link href="http://youchen.me/2017/02/06/Python-metaclass/"/>
    <id>http://youchen.me/2017/02/06/Python-metaclass/</id>
    <published>2017-02-06T08:11:02.000Z</published>
    <updated>2017-02-07T09:17:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文根据对<a href="http://stackoverflow.com" target="_blank" rel="external">StackOverflow</a>上问题<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python?answertab=votes#tab-top" target="_blank" rel="external">What is a metaclass in Python?</a>的高票回答翻译结合实际例子，试图解释<strong>元类</strong>的意义与用途。</p>
<h4 id="类也是对象"><a href="#类也是对象" class="headerlink" title="类也是对象"></a>类也是对象</h4><p>在想了解什么是<strong>元类</strong>之前，需要读者掌握Python中类的基本概念。而恰巧Python对类的定义有着不同于其他语言的解释。在大多数编程语言中，类仅仅只是指示如何生成实例对象的一段代码，这一点在Python中也如此:</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>      <span class="keyword">pass</span></div><div class="line"><span class="meta">... </span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_object = ObjectCreator()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(my_object)</div><div class="line">&lt;__main__.ObjectCreator object at <span class="number">0x8974f2c</span>&gt;</div></pre></td></tr></table></figure>
<p>但是，Python中的类还远不止如此:</p>
<div class="tip"><br>类也是实例对象<br></div>

<p>当程序员使用了关键字<code>class</code>时，Python将会执行它并且创建一个对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>      <span class="keyword">pass</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>上述代码将会在内存中创建一个名叫”ObjectCreator”的对象。</p>
<div class="tip"><br>这个对象(类)自身拥有创建对象(实例)的能力，因此被称作类<br></div>

<p>即便如此，它仍然是一个对象，因此:</p>
<ul>
<li>你可以将它赋值给一个变量</li>
<li>你可以复制它</li>
<li>你可以为它添加属性</li>
<li>你可以将它作为函数参数传递</li>
</ul>
<p>例如,<br>使用<code>print</code>打印:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreator) <span class="comment"># you can print a class because it's an object</span></div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></div></pre></td></tr></table></figure>
<p>作为函数参数传递:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(o)</span>:</span></div><div class="line"><span class="meta">... </span>      print(o)</div><div class="line"><span class="meta">... </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>echo(ObjectCreator) <span class="comment"># you can pass a class as a parameter</span></div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></div></pre></td></tr></table></figure>
<p>添加属性:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(hasattr(ObjectCreator, <span class="string">'new_attribute'</span>))</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ObjectCreator.new_attribute = <span class="string">'foo'</span> <span class="comment"># you can add attributes to a class</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(hasattr(ObjectCreator, <span class="string">'new_attribute'</span>))</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreator.new_attribute)</div><div class="line">foo</div></pre></td></tr></table></figure>
<p>赋值给另一个变量:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>ObjectCreatorMirror = ObjectCreator <span class="comment"># you can assign a class to a variable</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreatorMirror.new_attribute)</div><div class="line">foo</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreatorMirror())</div><div class="line">&lt;__main__.ObjectCreator object at <span class="number">0x8997b4c</span>&gt;</div></pre></td></tr></table></figure>
<h4 id="动态地创建类"><a href="#动态地创建类" class="headerlink" title="动态地创建类"></a>动态地创建类</h4><p>既然类也是对象，那么你可以向创建对象一样快速地创建它们。<br>首先，你可以通过使用关键字<code>class</code>在函数中创建一个类:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">choose_class</span><span class="params">(name)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">if</span> name == <span class="string">'foo'</span>:</div><div class="line"><span class="meta">... </span>        <span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>            <span class="keyword">pass</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">return</span> Foo <span class="comment"># return the class, not an instance</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</div><div class="line"><span class="meta">... </span>        <span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>            <span class="keyword">pass</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">return</span> Bar</div><div class="line"><span class="meta">... </span>    </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>MyClass = choose_class(<span class="string">'foo'</span>) </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(MyClass, MyClass()) <span class="comment"># the function returns a class, not an instance</span></div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">choose_class</span>.&lt;<span class="title">locals</span>&gt;.<span class="title">Foo</span>'&gt; &lt;<span class="title">__main__</span>.<span class="title">choose_class</span>.&lt;<span class="title">locals</span>&gt;.<span class="title">Foo</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x10a7d06a0</span>&gt;</span></div></pre></td></tr></table></figure>
<p>但它并不是很动态，因为你仍然需要亲自编写整个类。由于类是对象，那么它们必然是被某些东西生成的。当你使用关键字<code>class</code>时，Python自动地创建了其对象的对象。但就跟Python中大多数东西一样，Python给了你手动操作它的方法。<br>还记得函数<code>type</code>吗？这个函数能够让你知道一个对象的类型:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(<span class="number">1</span>))</div><div class="line">&lt;type <span class="string">'int'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(<span class="string">"1"</span>))</div><div class="line">&lt;type <span class="string">'str'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(ObjectCreator))</div><div class="line">&lt;type <span class="string">'type'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(ObjectCreator()))</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></div></pre></td></tr></table></figure>
<p>其实<code>type</code>还有一个完全不同的能力，它能够快速地创建类。<code>type</code>可以以参数的方式接收对一个类的描述，然后返回一个类。(可能有的人认为同一个函数根据传递不同的参数拥有两种完全不同的用途是一件很傻的事，但这是由于Python的向后兼容留下的问题)</p>
<p>通过<code>type</code>创建类的参数描述如下:</p>
<pre><code>type(name of the class, tuple of the parent class (for inheritance, can be empty), dictionary containing attributes names and values)
</code></pre><p>例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyShinyClass</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>      <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>可以以如下方式手动创建:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>MyShinyClass = type(<span class="string">'MyShinyClass'</span>, (), &#123;&#125;) <span class="comment"># returns a class object</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(MyShinyClass, MyShinyClass())</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">MyShinyClass</span>'&gt; &lt;<span class="title">__main__</span>.<span class="title">MyShinyClass</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x10a7a5518</span>&gt;</span></div></pre></td></tr></table></figure>
<p>你可能注意到了我们使用了”MyShinyClass”作为类的名字同时也作为变量名来保持对类的引用。它们可以不同，但是没有理由使其复杂化。<br><code>type</code>接收一个字典来定义类的属性，因此:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>      bar = <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>可以被翻译成:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>Foo = type(<span class="string">'Foo'</span>, (), &#123;<span class="string">'bar'</span>: <span class="keyword">True</span>&#125;)</div></pre></td></tr></table></figure>
<p>这样定义的类也可以当做普通类使用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">print(Foo)  <span class="comment"># &lt;class '__main__.Foo'&gt;</span></div><div class="line">print(Foo.bar)  <span class="comment"># True</span></div><div class="line">f = Foo()</div><div class="line">print(f)  <span class="comment"># &lt;__main__.Foo object at 0x8a9b84c&gt;</span></div><div class="line">print(f.bar)  <span class="comment"># True</span></div></pre></td></tr></table></figure>
<p>当然，你也可以继承自它:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>  <span class="class"><span class="keyword">class</span> <span class="title">FooChild</span><span class="params">(Foo)</span>:</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>将会是:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = type(<span class="string">'FooChild'</span>, (Foo,), &#123;&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(FooChild, FooChild.bar)  <span class="comment"># bar is inherited from Foo</span></div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">FooChild</span>'&gt; <span class="title">True</span></span></div></pre></td></tr></table></figure>
<p>最终你会想为你的类添加一些方法。只需要使用正确的语法定义一个函数然后作为一个属性赋值给类:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo_bar</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>      print(self.bar)</div><div class="line"><span class="meta">... </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = type(<span class="string">'FooChild'</span>, (Foo,), &#123;<span class="string">'echo_bar'</span>: echo_bar&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(Foo, <span class="string">'echo_bar'</span>)</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(FooChild, <span class="string">'echo_bar'</span>)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_foo = FooChild()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_foo.echo_bar()</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>你甚至可以在动态生成了类之后添加更多的方法，就和向普通生成的类对象添加方法一样:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo_bar_more</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>      print(<span class="string">'yet another method'</span>)</div><div class="line"><span class="meta">... </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild.echo_bar_more = echo_bar_more</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(FooChild, <span class="string">'echo_bar_more'</span>)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>如你所见:在Python中，类是对象，你可以快速动态地创建一个类。这便是当你使用关键字<code>class</code>时Python做的工作，它通过使用<strong>元类</strong>来完成这项工作。</p>
<h4 id="什么是元类-终于"><a href="#什么是元类-终于" class="headerlink" title="什么是元类(终于)"></a>什么是元类(终于)</h4><p><strong>元类</strong>是创建类的那些”东西”。你为了创建对象而定义了类，但是我们知道Python中的类也是对象，因此，元类是用来创建对象的。它们是<strong>类的类</strong>，你可以形象化地理解:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MyClass = MetaClass()</div><div class="line">MyObject = MyClass()</div></pre></td></tr></table></figure>
<p>你已经知道<code>type</code>可以这么用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MyClass = type(<span class="string">'MyClass'</span>, (), &#123;&#125;)</div></pre></td></tr></table></figure>
<p>这是因为函数<code>type</code>实际上是一个元类，而且是Python用来创建所有类的元类。</p>
<div class="tip"><br> 在Python中，所有东西都是对象<br></div>

<p>其中包括但不限于整型、字符串、函数和类。它们都是对象，而且它们都是被类创建的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>age = <span class="number">35</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__</div><div class="line">&lt;type <span class="string">'int'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'bob'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name.__class__</div><div class="line">&lt;type <span class="string">'str'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__class__</div><div class="line">&lt;type <span class="string">'function'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = Bar()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Bar</span>'&gt;</span></div></pre></td></tr></table></figure>
<p>现在让我们看看<code>__class__</code>的<code>__class__</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__.__class__</div><div class="line">&lt;type <span class="string">'type'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name.__class__.__class__</div><div class="line">&lt;type <span class="string">'type'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__class__.__class__</div><div class="line">&lt;type <span class="string">'type'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__.__class__</div><div class="line">&lt;type <span class="string">'type'</span>&gt;</div></pre></td></tr></table></figure>
<p>由此可见，一个元类正是用来创建所有类的。你也可以称它为”类工厂”。<code>type</code>是Python使用的内置的元类，当然，你也可以创建你自己的元类。</p>
<h4 id="metaclass-属性"><a href="#metaclass-属性" class="headerlink" title="__metaclass__属性"></a><code>__metaclass__</code>属性</h4><p>你可以在编写一个类时为其指定<code>__metaclass__</code>属性:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line">    __metaclass__ = something...</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>需要注意的是，上述语法仅适用于Python 2.x版本，在Python 3.x版本中，由新语法替代:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object, metaclass=something)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>当你为类指定了元类以后，Python将会使用该元类来创建类<code>Foo</code>。<br>特别注意:</p>
<div class="tip"><br>类对象在Python调用<strong>metaclass</strong>来创建类之后才会存在。<br></div>

<p><strong> Python 2.x中的<strong>metaclass</strong> </strong><br>对Python 2.x来说，即当首先写下了<code>class Foo(object)</code>，但是类对象<code>Foo</code>还并没有在内存中被创建。Python将会在类定义中查找<code>__metaclass__</code>，如果找到了，则用其来创建对象类<code>Foo</code>，如果没有找到，Python将会使用<code>type</code>来创建该类。</p>
<p>当你这么写:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(Bar)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>Python将会这么做:</p>
<ol>
<li>类<code>Foo</code>有定义<code>__metaclass__</code>吗？如果有，则使用指定的<code>__metaclass__</code>来创建类对象<code>Foo</code>。</li>
<li>如果没有找到这个属性，它将会在父类<code>Bar</code>中找</li>
<li>这样一直向父类找，直到达到<code>module</code>级别才停止。</li>
<li>如果在任何父类都找不到，那就用<code>type</code>创建类对象<code>Foo</code></li>
</ol>
<p>这里面有几点需要注意:</p>
<ol>
<li>为子类指定的<code>__metaclass__</code>需要是其所有父类<code>__metaclass__</code>的子类。</li>
<li>在多继承的情况下，如果没有为该类指定<code>__metaclass__</code>，则该类将会由MRO中第一个父类的<code>__metaclass__</code>和所有父类<code>__metaclass__</code>中处于继承最底层的<code>__metaclass__</code>生成。</li>
</ol>
<p>Python 2.x中<code>__metaclass__</code>使用如以下代码所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python 2.x</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta0</span><span class="params">(type)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></div><div class="line">        cls = type.__new__(meta, name, bases, cls_dict)</div><div class="line">        print(meta, name, bases, cls_dict)</div><div class="line">        <span class="keyword">return</span> cls</div><div class="line"></div><div class="line">__metaclass__ = Meta0</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(type)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></div><div class="line">        print(meta, name, bases, cls_dict)</div><div class="line">        cls_dict[<span class="string">'meta'</span>] = <span class="keyword">True</span></div><div class="line">        cls = type.__new__(meta, name, bases, cls_dict)</div><div class="line">        <span class="keyword">return</span> cls</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta2</span><span class="params">(Meta)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></div><div class="line">        print(meta, name, bases, cls_dict)</div><div class="line">        cls_dict[<span class="string">'meta2'</span>] = <span class="keyword">True</span></div><div class="line">        cls = type.__new__(meta, name, bases, cls_dict)</div><div class="line">        <span class="keyword">return</span> cls</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta3</span><span class="params">(Meta2)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></div><div class="line">        print(meta, name, bases, cls_dict)</div><div class="line">        cls_dict[<span class="string">'meta3'</span>] = <span class="keyword">True</span></div><div class="line">        cls = type.__new__(meta, name, bases, cls_dict)</div><div class="line">        <span class="keyword">return</span> cls</div><div class="line"></div><div class="line">print(<span class="string">'C1'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(<span class="string">'C2'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span>:</span></div><div class="line">    __metaclass__ = Meta</div><div class="line"></div><div class="line">print(<span class="string">'C3'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C3</span><span class="params">(C2)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(<span class="string">'C4'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C4</span><span class="params">(C2)</span>:</span></div><div class="line">    __metaclass__ = Meta2</div><div class="line"></div><div class="line">print(<span class="string">'C5'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C5</span><span class="params">(C2)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(<span class="string">'C6'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C6</span><span class="params">(C2)</span>:</span></div><div class="line">    __metaclass__ = Meta3</div><div class="line"></div><div class="line">print(<span class="string">'C7'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C7</span><span class="params">(C4, C6, C5)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>结果为:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">C1</div><div class="line">(&lt;class '__main__.Meta0'&gt;, 'C1', (), &#123;'__module__': '__main__'&#125;)</div><div class="line">C2</div><div class="line">(&lt;class '__main__.Meta'&gt;, 'C2', (), &#123;'__module__': '__main__', '__metaclass__': &lt;class '__main__.Meta'&gt;&#125;)</div><div class="line">C3</div><div class="line">(&lt;class '__main__.Meta'&gt;, 'C3', (&lt;class '__main__.C2'&gt;,), &#123;'__module__': '__main__'&#125;)</div><div class="line">C4</div><div class="line">(&lt;class '__main__.Meta2'&gt;, 'C4', (&lt;class '__main__.C2'&gt;,), &#123;'__module__': '__main__', '__metaclass__': &lt;class '__main__.Meta2'&gt;&#125;)</div><div class="line">C5</div><div class="line">(&lt;class '__main__.Meta'&gt;, 'C5', (&lt;class '__main__.C2'&gt;,), &#123;'__module__': '__main__'&#125;)</div><div class="line">C6</div><div class="line">(&lt;class '__main__.Meta3'&gt;, 'C6', (&lt;class '__main__.C2'&gt;,), &#123;'__module__': '__main__', '__metaclass__': &lt;class '__main__.Meta3'&gt;&#125;)</div><div class="line">C7</div><div class="line">(&lt;class '__main__.Meta2'&gt;, 'C7', (&lt;class '__main__.C4'&gt;, &lt;class '__main__.C6'&gt;, &lt;class '__main__.C5'&gt;), &#123;'__module__': '__main__'&#125;)</div><div class="line">(&lt;class '__main__.Meta3'&gt;, 'C7', (&lt;class '__main__.C4'&gt;, &lt;class '__main__.C6'&gt;, &lt;class '__main__.C5'&gt;), &#123;'__module__': '__main__', 'meta2': True&#125;)</div></pre></td></tr></table></figure>
<p>注意到在类<code>C7</code>的生成过程中，分别调用了<code>Meta2</code>和<code>Meta3</code>，调用<code>Meta2</code>是由于在<code>C7</code>的继承中，类<code>C4</code>位于第一位，而<code>C4</code>的<code>__metaclass__</code>为<code>Meta2</code>，所以首先使用<code>Meta2</code>，而在<code>C4</code>、<code>C5</code>和<code>C6</code>的<code>__metaclass__</code>中，<code>Meta3</code>处于继承最底层，所以还会调用<code>Meta3</code>来生成类<code>C7</code>。(如果类<code>C6</code>位于最前面则只会调用<code>Meta3</code>)<br>这样的多继承以及多元类调用比较复杂，个人认为还是少用较好。</p>
<p><strong> Python 3.x中的metaclass </strong><br>在Python3.x中，需要通过关键字参数<code>metaclass</code>给类指定元类。如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span><span class="params">(metaclass=Meta)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>关于元类的寻找与Python 2.x类似:</p>
<ol>
<li>类<code>Foo</code>有定义关键字参数<code>metaclass</code>吗？如果有，则使用指定的<code>metaclass</code>来创建类对象<code>Foo</code>。</li>
<li>如果没有找到这个属性，它将会在父类<code>Bar</code>中找</li>
<li>如果在任何父类都找不到，那就用<code>type</code>创建类对象<code>Foo</code></li>
</ol>
<p>Python 3.x的metaclass使用注意仍然与Python 2.x类似:</p>
<ol>
<li>为子类指定的<code>metaclass</code>需要是其所有父类<code>metaclass</code>的子类。</li>
<li>在多继承的情况下，如果没有为该类指定<code>metaclass</code>，则该类将会由所有父类<code>metaclass</code>中处于继承最底层的<code>metaclass</code>生成。如果有指定，则选择前述的<code>metaclass</code>和该<code>metaclass</code>中继承层次更低的那个来生成。</li>
</ol>
<p>Python 3.x中<code>metaclass</code>使用如以下代码所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python 3.x</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(type)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></div><div class="line">        print(meta, name, bases, cls_dict)</div><div class="line">        <span class="keyword">return</span> type.__new__(meta, name, bases, cls_dict)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta2</span><span class="params">(Meta)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></div><div class="line">        print(meta, name, bases, cls_dict)</div><div class="line">        cls_dict[<span class="string">'hello'</span>] = <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> type.__new__(meta, name, bases, cls_dict)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta3</span><span class="params">(Meta2)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></div><div class="line">        print(meta, name, bases, cls_dict)</div><div class="line">        <span class="keyword">return</span> type.__new__(meta, name, bases, cls_dict)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta4</span><span class="params">(Meta3)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></div><div class="line">        print(meta, name, bases, cls_dict)</div><div class="line">        <span class="keyword">return</span> type.__new__(meta, name, bases, cls_dict)</div><div class="line"></div><div class="line"></div><div class="line">print(<span class="string">'C1'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span><span class="params">(metaclass=Meta)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(<span class="string">'C2'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span><span class="params">(C1)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(<span class="string">'C3'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C3</span><span class="params">(C1, metaclass=Meta2)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(<span class="string">'C4'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C4</span><span class="params">(C1, metaclass=Meta3)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(<span class="string">'C5'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C5</span><span class="params">(C3, C4, C2)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(<span class="string">'C6'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C6</span><span class="params">(C3, C4, C2, metaclass=Meta4)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>结果为:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">C1</div><div class="line">&lt;class '__main__.Meta'&gt; C1 () &#123;'__module__': '__main__', '__qualname__': 'C1'&#125;</div><div class="line">C2</div><div class="line">&lt;class '__main__.Meta'&gt; C2 (&lt;class '__main__.C1'&gt;,) &#123;'__module__': '__main__', '__qualname__': 'C2'&#125;</div><div class="line">C3</div><div class="line">&lt;class '__main__.Meta2'&gt; C3 (&lt;class '__main__.C1'&gt;,) &#123;'__module__': '__main__', '__qualname__': 'C3'&#125;</div><div class="line">C4</div><div class="line">&lt;class '__main__.Meta3'&gt; C4 (&lt;class '__main__.C1'&gt;,) &#123;'__module__': '__main__', '__qualname__': 'C4'&#125;</div><div class="line">C5</div><div class="line">&lt;class '__main__.Meta3'&gt; C5 (&lt;class '__main__.C3'&gt;, &lt;class '__main__.C4'&gt;, &lt;class '__main__.C2'&gt;) &#123;'__module__': '__main__', '__qualname__': 'C5'&#125;</div><div class="line">C6</div><div class="line">&lt;class '__main__.Meta4'&gt; C6 (&lt;class '__main__.C3'&gt;, &lt;class '__main__.C4'&gt;, &lt;class '__main__.C2'&gt;) &#123;'__module__': '__main__', '__qualname__': 'C6'&#125;</div></pre></td></tr></table></figure>
<p>需要注意一点，为了输出内容的简洁，以上代码在方法<code>__new__</code>的最后都使用了<code>type.__new__</code>而不是<code>super().__new__</code>。改用<code>super().__new__</code>后执行仍相同，只是多了对父类的调用。</p>
<p>说了这么多，我们应该给<code>__metaclass__</code>赋值什么呢?答案当然是，一个可以创建类的东西。<br>那么，什么才能创建一个类呢？</p>
<h4 id="普通的元类"><a href="#普通的元类" class="headerlink" title="普通的元类"></a>普通的元类</h4><p>设计元类的一个很主要的原因就是为了在类被创建的时候进行自动修改，这经常用在API的设计上。<br>让我们举一个简单的例子，你决定让你的模块里所有类的属性都是大写形式。要完成这项工作有很多方法，其中一个便是在模块级别上定义<code>__metaclass__</code>。这样的话，该模块中所有的类都会通过该元类创建，我们只需要让这个元类完成将所有属性变成大写的工作。<br>幸运的是，<code>__metaclass__</code>可以是任何可调用(callable)对象，并不一定非要是一个正式的类。所以我们将从一个函数作为元类的例子说起:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python 2.x</span></div><div class="line"><span class="comment"># the metaclass will automatically get passed the same argument</span></div><div class="line"><span class="comment"># that you usually pass to `type`</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">upper_attr</span><span class="params">(future_class_name, future_class_parents, future_class_attr)</span>:</span></div><div class="line">  <span class="string">"""</span></div><div class="line">    Return a class object, with the list of its attribute turned </div><div class="line">    into uppercase.</div><div class="line">  """</div><div class="line"></div><div class="line">  <span class="comment"># pick up any attribute that doesn't start with '__' and uppercase it</span></div><div class="line">  uppercase_attr = &#123;&#125;</div><div class="line">  <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</div><div class="line">      <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</div><div class="line">          uppercase_attr[name.upper()] = val</div><div class="line">      <span class="keyword">else</span>:</div><div class="line">          uppercase_attr[name] = val</div><div class="line"></div><div class="line">  <span class="comment"># let `type` do the class creation</span></div><div class="line">  <span class="keyword">return</span> type(future_class_name, future_class_parents, uppercase_attr)</div><div class="line"></div><div class="line">__metaclass__ = upper_attr <span class="comment"># this will affect all classes in the module</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span> <span class="comment"># global __metaclass__ won't work with "object" though</span></div><div class="line">  <span class="comment"># but we can define __metaclass__ here instead to affect only this class</span></div><div class="line">  <span class="comment"># and this will work with "object" children</span></div><div class="line">  bar = <span class="string">'bip'</span></div><div class="line"></div><div class="line">print(hasattr(Foo, <span class="string">'bar'</span>))</div><div class="line"><span class="comment"># Out: False</span></div><div class="line">print(hasattr(Foo, <span class="string">'BAR'</span>))</div><div class="line"><span class="comment"># Out: True</span></div><div class="line"></div><div class="line">f = Foo()</div><div class="line">print(f.BAR)</div><div class="line"><span class="comment"># Out: 'bip'</span></div></pre></td></tr></table></figure>
<p>现在，让我们完成同样的工作，但这次我们将会使用一个真正的类作为元类:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python 2.x</span></div><div class="line"><span class="comment"># remember that `type` is actually a class like `str` and `int`</span></div><div class="line"><span class="comment"># so you can inherit from it</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span> </div><div class="line">    <span class="comment"># __new__ is the method called before __init__</span></div><div class="line">    <span class="comment"># it's the method that creates the object and returns it</span></div><div class="line">    <span class="comment"># while __init__ just initializes the object passed as parameter</span></div><div class="line">    <span class="comment"># you rarely use __new__, except when you want to control how the object</span></div><div class="line">    <span class="comment"># is created.</span></div><div class="line">    <span class="comment"># here the created object is the class, and we want to customize it</span></div><div class="line">    <span class="comment"># so we override __new__</span></div><div class="line">    <span class="comment"># you can do some stuff in __init__ too if you wish</span></div><div class="line">    <span class="comment"># some advanced use involves overriding __call__ as well, but we won't</span></div><div class="line">    <span class="comment"># see this</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(upperattr_metaclass, future_class_name, </span></span></div><div class="line">                future_class_parents, future_class_attr):</div><div class="line"></div><div class="line">        uppercase_attr = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</div><div class="line">                uppercase_attr[name.upper()] = val</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                uppercase_attr[name] = val</div><div class="line"></div><div class="line">        <span class="keyword">return</span> type(future_class_name, future_class_parents, uppercase_attr)</div></pre></td></tr></table></figure>
<p>但是上面这种方法并不是很符合OOP，因为我们直接调用了<code>type</code>而且我们没有重写或者调用父类的<code>__new__</code>，让我们改为下面这样:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python 2.x</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span> </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(upperattr_metaclass, future_class_name, </span></span></div><div class="line">                future_class_parents, future_class_attr):</div><div class="line"></div><div class="line">        uppercase_attr = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</div><div class="line">                uppercase_attr[name.upper()] = val</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                uppercase_attr[name] = val</div><div class="line"></div><div class="line">        <span class="comment"># reuse the type.__new__ method</span></div><div class="line">        <span class="comment"># this is basic OOP, nothing magic in there</span></div><div class="line">        <span class="keyword">return</span> type.__new__(upperattr_metaclass, future_class_name, </div><div class="line">                            future_class_parents, uppercase_attr)</div></pre></td></tr></table></figure>
<p>你可能注意到了一个额外的参数<code>upperattr_metaclass</code>，它其实并不特别:<code>__new__</code>总是将定义它的类作为第一个参数，就和实例方法中使用<code>self</code>或类方法中使用<code>cls</code>作为方法的第一个参数一样。当然，此处参数所使用的名字只是为了方便明确参数意义，但就跟<code>self</code>一样，所有参数都可以简写，因此实际使用中的一个元类可能看起来像这样:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span> </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, clsname, bases, dct)</span>:</span></div><div class="line"></div><div class="line">        uppercase_attr = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> dct.items():</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</div><div class="line">                uppercase_attr[name.upper()] = val</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                uppercase_attr[name] = val</div><div class="line"></div><div class="line">        <span class="keyword">return</span> type.__new__(cls, clsname, bases, uppercase_attr)</div></pre></td></tr></table></figure>
<p>是的，元类在完成一些”黑魔法”或者复杂事务的时候很有用，但是对于它们自身来说，其实很简单:</p>
<ol>
<li>拦截一个类的创建</li>
<li>修改这个类</li>
<li>返回修改后的类</li>
</ol>
<h4 id="你为什么要使用类而不是函数来作为元类？"><a href="#你为什么要使用类而不是函数来作为元类？" class="headerlink" title="你为什么要使用类而不是函数来作为元类？"></a>你为什么要使用类而不是函数来作为元类？</h4><p>由于<code>__metaclass__</code>可以接受任意可调用对象，那为什么你要使用一个明显更复杂的类呢？</p>
<p>有几个原因:</p>
<ul>
<li>意图明确。当你阅读到<code>UpperAttrMetaclass(type)</code>，你知道接下来会怎样</li>
<li>你可以使用OOP。元类可以继承，重写父类方法，甚至可以使用元类</li>
<li>你可以更好地组织里的代码。你不会在一些简单的工作中使用到元类，它通常是为了复杂工作准备的。编写多个方法并且将它们组织到一个类里将会对使代码清晰易读有巨大的帮助。</li>
<li>你可以拦截<code>__new__</code>、<code>__init__</code>和<code>__call__</code>等方法。这将允许你完成不同的工作。即使通常情况下你可以在<code>__new__</code>完成所有工作，但仍有许多人更偏爱在<code>__init__</code>中完成。</li>
<li>它们叫做metaclass，<code>class</code>!</li>
</ul>
<h4 id="为什么你要使用元类呢？"><a href="#为什么你要使用元类呢？" class="headerlink" title="为什么你要使用元类呢？"></a>为什么你要使用元类呢？</h4><p>现在到了最关键的问题，为什么你要使用一些既复杂又易错的功能呢？<br>实际上，通常情况下你不用:</p>
<blockquote>
<p>Metaclasses are deeper magic that 99% of users should never worry about. If you wonder whether you need them, you don’t (the people who actually need them know with certainty that they need them, and don’t need an explanation about why).      — Python Guru Tim Peters<br>译: 元类是较为高深的技术，99%的用户应该永远不用担心。如果你在犹豫你是否需要它们，那么你不需要(真正需要它们的人会清楚的知道需要它们，而且无须解释)</p>
</blockquote>
<p>元类主要的用途是创建一个API。一个典型的例子就是Django的ORM，它允许你这样定义:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></div><div class="line">  name = models.CharField(max_length=<span class="number">30</span>)</div><div class="line">  age = models.IntegerField()</div></pre></td></tr></table></figure>
<p>但是如果你这样做:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">guy = Person(name=<span class="string">'bob'</span>, age=<span class="string">'35'</span>)</div><div class="line">print(guy.age)</div></pre></td></tr></table></figure>
<p>它并不会返回一个<code>IntegerField</code>对象，而是返回一个<code>int</code>。这是因为<code>models.Model</code>定义了<code>__metaclass__</code>，而该元类将会完成一些工作使得你刚刚定义拥有一些简单语句的<code>Person</code>变成复杂的钩子(hook)与数据库字段相连。Django通过引入一个简单的API和使用元类来使一些复杂的事情看起来简单，根据该API重建代码完成实际工作都在幕后进行。</p>
<h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>首先，你知道了类也是对象，而且可以生成实例。当然，类也是元类的实例。<br>Python中的万物都是对象，它们要么是类的实例，要么是元类的实例。<code>type</code>除外:</p>
<div class="tip"><br><code>type</code>是它自己的元类<br></div>

<p>其次，元类十分复杂。对一个简单类的修改你可能并不会想使用它，而是使用另外两种不同的方式:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Monkey_patch" target="_blank" rel="external">Monkey patching</a></li>
<li>类装饰器</li>
</ul>
<p>在99%你需要修改类的情况下，你都最好使用以上两种方法。<br>但99%的时间里，你都不需要修改类。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文根据对&lt;a href=&quot;http://stackoverflow.com&quot;&gt;StackOverflow&lt;/a&gt;上问题&lt;a href=&quot;http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python?answertab=votes#tab-top&quot;&gt;What is a metaclass in Python?&lt;/a&gt;的高票回答翻译结合实际例子，试图解释&lt;strong&gt;元类&lt;/strong&gt;的意义与用途。&lt;/p&gt;
&lt;h4 id=&quot;类也是对象&quot;&gt;&lt;a href=&quot;#类也是对象&quot; class=&quot;headerlink&quot; title=&quot;类也是对象&quot;&gt;&lt;/a&gt;类也是对象&lt;/h4&gt;&lt;p&gt;在想了解什么是&lt;strong&gt;元类&lt;/strong&gt;之前，需要读者掌握Python中类的基本概念。而恰巧Python对类的定义有着不同于其他语言的解释。在大多数编程语言中，类仅仅只是指示如何生成实例对象的一段代码，这一点在Python中也如此:&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="类" scheme="http://youchen.me/tags/%E7%B1%BB/"/>
    
      <category term="OOP" scheme="http://youchen.me/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>Python属性访问</title>
    <link href="http://youchen.me/2017/02/04/Python-property%20access/"/>
    <id>http://youchen.me/2017/02/04/Python-property access/</id>
    <published>2017-02-04T08:26:07.000Z</published>
    <updated>2017-02-06T08:48:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇中讲到了描述器方法<code>__get__</code>、<code>__set__</code>和<code>__delete__</code>，同时也提到，一个对象具有任意一个方法的就会成为描述器，从而在被当作对象属性的时候会重写默认的查找行为。在本篇中，通过对<a href="https://docs.python.org/2/howto/descriptor.html" target="_blank" rel="external">Descriptor HowTo Guide</a>的节选翻译以及笔者的自身的一些实践，对描述器做一个更详细的说明。</p>
<p>如果一个对象同时定义了<code>__get__</code>和<code>__set__</code>方法，则称它为资料描述器(<em>data descriptor</em>)，而仅定义了<code>__get__</code>方法的描述器称为非资料描述器(<em>non-data descriptor</em>，常用于方法，其他用途也是可以的)。</p>
<p>资料描述器和非资料描述器的区别在于：<strong>相对于实例的字典的优先级</strong>。如果实例字典中有和描述器重名的属性，如果描述器是资料描述器，优先使用资料描述器，如果是非资料描述器，优先使用字典中的属性。这就是为何实例a的方法和属性重名时，比如都叫做<code>foo</code>，Python会在访问<code>a.foo</code>时优先访问实例字典中的属性，因为实例的方法是个非资料描述器。<br><a id="more"></a><br>要想制作一个只读的资料描述器需要同时定义<code>__set__</code>和<code>__get__</code>方法，由于是只读，所以只需要在<code>__set__</code>方法中抛出一个<code>AttributeError</code>异常即可。</p>
<p>在一般情况下，描述器在属性访问时被自动调用。举例来说，<code>obj.d</code>会在<code>obj</code>的字典里面查找<code>d</code>，如果<code>d</code>定义了<code>__get__</code>方法，那么<code>d.__get__(obj)</code>会依据下面的优先规则被调用。</p>
<p>调用的细节取决于<code>obj</code>是一个类还是一个实例，对于对象来讲，方法<code>object.__getattribute__</code>将属性访问<code>a.x</code>变成了<code>type(a).__dict__[&#39;x&#39;].__get__(a, type(a))</code>，具体实现依据这样的优先顺序:<strong>资料描述器</strong>优先于<strong>实例变量</strong>，<strong>实例变量</strong>优先于<strong>非资料描述器</strong>，<code>__getattr__()</code>方法具有最低优先级；对于类来讲，方法<code>type.__getattribute__</code>将<code>A.x</code>变成<code>A.__dict__[&#39;x&#39;].__get__(None, A)</code>。如以下代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">V</span>:</span></div><div class="line">    v = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>)</span>:</span></div><div class="line">        self.v = val</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, inst, owner)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.v</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, inst, value)</span>:</span></div><div class="line">        self.v = value</div><div class="line">        </div><div class="line">        </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line">    k1 = V(<span class="number">1</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">k</span><span class="params">(self)</span>:</span>  <span class="comment"># non-data descriptor</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">a = A()</div><div class="line">print(a.k)  <span class="comment"># &lt;bound method...&gt; *op1*</span></div><div class="line">a.k = <span class="number">6</span>  <span class="comment"># replace non-data descriptor with instance dict  *op2*</span></div><div class="line">print(a.k)  <span class="comment"># 6  *op3*</span></div><div class="line"></div><div class="line">print(a.k1)  <span class="comment"># 1</span></div><div class="line">a.__dict__[<span class="string">'k1'</span>] = V(<span class="number">2</span>)  <span class="comment"># *op4*</span></div><div class="line">print(a.k1)  <span class="comment"># 1</span></div></pre></td></tr></table></figure></p>
<p>这段代码展示了资料描述器、实例变量、非资料描述器在属性访问中的不同优先级，分析如下:类<code>A</code>中定义了方法<code>k</code>(非资料描述器)，第一次操作对<code>a.k</code>的访问将转变为<code>type(a).__dict__[&#39;k&#39;].__get__(a, type(a))</code>，<code>type(a)</code>即类<code>A</code>，<code>A.__dict__</code>中存储了方法<code>A.k</code>，由于方法<code>A.k</code>为非资料描述器，因此调用其定义的<code>__get__()</code>方法。第二次操作<code>a.k = 6</code>本质上是在字典<code>a.__dict__</code>中添加了<code>k</code>这一变量(注意<code>a.__dict__</code>和<code>A._dict__</code>的区别)，即新增了实例变量。第三次操作对<code>a.k</code>的访问由于<strong>实例变量</strong>优先级高于<strong>非资料描述器</strong>，因此将获得之前的赋值6而不是方法。在第四次操作前后分别访问了<code>a.k1</code>属性，由于<code>k1</code>是资料描述器，因此即使在<code>a.__dict__</code>中新增了实例变量<code>k1</code>，对<code>a.k1</code>仍然是访问了资料描述器而不是实例变量，与前述的优先级保持一致。</p>
<p><code>__getattr__</code>与<code>__getattribute__</code>区别:前者只会在待访问的属性缺失时触发，而后者则会在每次访问属性时触发。</p>
<p><strong>特别注意:</strong>如果要在<code>__getattribute__</code>和<code>__setattr__</code>方法中访问实例属性，那么应该直接通过<code>super()</code>来做，以避免无限递归。如以下代码就会抛出异常:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrokenAttribute</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></div><div class="line">        self._data = data</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, name)</span>:</span></div><div class="line">        print(<span class="string">'Called __getattribute__(&#123;0&#125;)'</span>.format(name))</div><div class="line">        <span class="keyword">return</span> self._data[name]</div><div class="line"></div><div class="line"></div><div class="line">data = BrokenAttribute(&#123;<span class="string">'foo'</span>: <span class="number">3</span>&#125;)</div><div class="line">print(data.foo)</div><div class="line">&gt;&gt;&gt;</div><div class="line">RecursionError: maximum recursion depth exceeded <span class="keyword">while</span> calling a Python object</div></pre></td></tr></table></figure></p>
<h4 id="属性Property"><a href="#属性Property" class="headerlink" title="属性Property"></a>属性Property</h4><p>调用<code>property()</code>是建立资料描述器的一种简洁方式，从而可以在访问属性时触发相应的方法调用。<code>property</code>函数原型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute</div></pre></td></tr></table></figure></p>
<p>下面展示了一个典型应用，定义一个托管属性(managed attribute)x:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getx</span><span class="params">(self)</span>:</span> <span class="keyword">return</span> self.__x</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setx</span><span class="params">(self, value)</span>:</span> self.__x = value</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delx</span><span class="params">(self)</span>:</span> <span class="keyword">del</span> self.__x</div><div class="line">    x = property(getx, setx, delx, <span class="string">"I'm the 'x' property."</span>)</div></pre></td></tr></table></figure>
<p>其等价Python实现为:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Property</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"Emulate PyProperty_Type() in Objects/descrobject.c"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fget=None, fset=None, fdel=None, doc=None)</span>:</span></div><div class="line">        self.fget = fget</div><div class="line">        self.fset = fset</div><div class="line">        self.fdel = fdel</div><div class="line">        self.__doc__ = doc</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype=None)</span>:</span></div><div class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> self</div><div class="line">        <span class="keyword">if</span> self.fget <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">raise</span> AttributeError, <span class="string">"unreadable attribute"</span></div><div class="line">        <span class="keyword">return</span> self.fget(obj)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, obj, value)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.fset <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">raise</span> AttributeError, <span class="string">"can't set attribute"</span></div><div class="line">        self.fset(obj, value)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, obj)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.fdel <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">raise</span> AttributeError, <span class="string">"can't delete attribute"</span></div><div class="line">        self.fdel(obj)</div></pre></td></tr></table></figure>
<h4 id="静态方法与类方法"><a href="#静态方法与类方法" class="headerlink" title="静态方法与类方法"></a>静态方法与类方法</h4><p>非资料描述器为将函数绑定成方法这种常见模式提供了一个简单的实现机制。<br>简而言之，函数有个方法<code>__get__()</code>，当函数被当作属性访问时，它会把函数变成一个实例方法。非资料描述器把实例调用<code>obj.f(*args)</code>转换成<code>f(obj, *args)</code>(绑定方法)，把类调用<code>klass.f(*args)</code>转换成<code>f(klass, *args)</code>(非绑定方法)。<br>静态方法原样返回函数，调用 c.f 或者 C.f 分别等价于<code>object.__getattribute__(c, &quot;f&quot;)</code>或者<code>object.__getattribute__(C, &quot;f&quot;)</code>。也就是说，无论是从一个对象还是一个类中，这个函数都会同样地访问到。<br>利用非资料描述器，<code>staticmethod()</code>的等价实现看起来像这样:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">staticmethod</span><span class="params">(object)</span>:</span></div><div class="line"> <span class="string">"Emulate PyStaticMethod_Type() in Objects/funcobject.c"</span></div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, f)</span>:</span></div><div class="line">      self.f = f</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype=None)</span>:</span></div><div class="line">      <span class="keyword">return</span> self.f</div></pre></td></tr></table></figure>
<p>同样的，<code>classmethod()</code>等价实现看起来像这样:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassMethod</span><span class="params">(object)</span>:</span></div><div class="line">     <span class="string">"Emulate PyClassMethod_Type() in Objects/funcobject.c"</span></div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, f)</span>:</span></div><div class="line">          self.f = f</div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, klass=None)</span>:</span></div><div class="line">          <span class="keyword">if</span> klass <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">               klass = type(obj)</div><div class="line">          <span class="function"><span class="keyword">def</span> <span class="title">newfunc</span><span class="params">(*args)</span>:</span></div><div class="line">               <span class="keyword">return</span> self.f(klass, *args)</div><div class="line">          <span class="keyword">return</span> newfunc</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇中讲到了描述器方法&lt;code&gt;__get__&lt;/code&gt;、&lt;code&gt;__set__&lt;/code&gt;和&lt;code&gt;__delete__&lt;/code&gt;，同时也提到，一个对象具有任意一个方法的就会成为描述器，从而在被当作对象属性的时候会重写默认的查找行为。在本篇中，通过对&lt;a href=&quot;https://docs.python.org/2/howto/descriptor.html&quot;&gt;Descriptor HowTo Guide&lt;/a&gt;的节选翻译以及笔者的自身的一些实践，对描述器做一个更详细的说明。&lt;/p&gt;
&lt;p&gt;如果一个对象同时定义了&lt;code&gt;__get__&lt;/code&gt;和&lt;code&gt;__set__&lt;/code&gt;方法，则称它为资料描述器(&lt;em&gt;data descriptor&lt;/em&gt;)，而仅定义了&lt;code&gt;__get__&lt;/code&gt;方法的描述器称为非资料描述器(&lt;em&gt;non-data descriptor&lt;/em&gt;，常用于方法，其他用途也是可以的)。&lt;/p&gt;
&lt;p&gt;资料描述器和非资料描述器的区别在于：&lt;strong&gt;相对于实例的字典的优先级&lt;/strong&gt;。如果实例字典中有和描述器重名的属性，如果描述器是资料描述器，优先使用资料描述器，如果是非资料描述器，优先使用字典中的属性。这就是为何实例a的方法和属性重名时，比如都叫做&lt;code&gt;foo&lt;/code&gt;，Python会在访问&lt;code&gt;a.foo&lt;/code&gt;时优先访问实例字典中的属性，因为实例的方法是个非资料描述器。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="描述器" scheme="http://youchen.me/tags/%E6%8F%8F%E8%BF%B0%E5%99%A8/"/>
    
      <category term="属性" scheme="http://youchen.me/tags/%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python属性与描述器</title>
    <link href="http://youchen.me/2017/01/24/Python-property%20and%20descriptor/"/>
    <id>http://youchen.me/2017/01/24/Python-property and descriptor/</id>
    <published>2017-01-24T09:03:27.000Z</published>
    <updated>2017-02-06T08:47:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="getter与setter"><a href="#getter与setter" class="headerlink" title="getter与setter"></a><code>getter</code>与<code>setter</code></h4><p>如果开发者之前有其他语言的开发经验，在转入Python之后，可能会在类中明确地实现类似<code>getter</code>和<code>setter</code>方法，如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OldResistor</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ohms)</span>:</span></div><div class="line">        self._ohms = ohms</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_ohms</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._homs</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_ohms</span><span class="params">(self, ohms)</span>:</span></div><div class="line">        self._ohms = ohms</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>然而这种方法却并不像Python的编程风格，特别是对于自增的代码来说更是如此:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">r = OldResistor(<span class="number">1e3</span>)</div><div class="line">r.set_ohms(r.get_ohms()+<span class="number">1e3</span>)</div></pre></td></tr></table></figure></p>
<p>对于Python语言来说，基本上不需要手工实现<code>getter</code>和<code>setter</code>方法，而是该先从简单的<code>public</code>属性写起:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewResistor</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ohms)</span>:</span></div><div class="line">        self.ohms = ohms</div><div class="line">        </div><div class="line">r = NewResistor(<span class="number">1e3</span>)</div><div class="line">r.ohms += <span class="number">1e3</span></div></pre></td></tr></table></figure></p>
<p>但是开发者可能需要在对某个属性操作的时候实现特殊行为，这时候可以改用<code>@property</code>修饰器和<code>setter</code>方法来做:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropResistor</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ohms)</span>:</span></div><div class="line">        self._ohms = ohms</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ohms</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># Do what you want when access ohms</span></div><div class="line">        <span class="keyword">return</span> self._ohms</div><div class="line">    </div><div class="line"><span class="meta">    @ohms.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ohms</span><span class="params">(self, ohms)</span>:</span></div><div class="line">        <span class="comment"># Do what you want when change ohms</span></div><div class="line">        self._ohms = ohms</div></pre></td></tr></table></figure></p>
<p>通过指定<code>setter</code>方法，我们可以在方法里面做类型验证以及数值验证。</p>
<p>但是,考虑下面一种情况:</p>
<blockquote>
<p>假设有一个考试成绩(<code>Exam</code>)类，由多个科目的小成绩组成，每一科需要单独计分，在进行分数录入的时候，要求对成绩进行验证，保证其在0~100之间</p>
</blockquote>
<p>如果使用属性<code>@property</code>实现，每添加一项科目，就要重复编写一次<code>@property</code>方法，而且还需要重复相关验证逻辑，如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">       self._chinese_grade = <span class="number">0</span></div><div class="line">       self._math_grade = <span class="number">0</span></div><div class="line">       </div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_grade</span><span class="params">(value)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>):</div><div class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'Grade must be between 0 and 100'</span>)</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">chinese_grade</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._chinese_grade</div><div class="line">    </div><div class="line"><span class="meta">    @chinese_grade.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">chinese_grade</span><span class="params">(self, grade)</span>:</span></div><div class="line">        self._check_grade(grade)</div><div class="line">        self._chinese_grade = grade</div><div class="line">        </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">math_grade</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._math_grade</div><div class="line">        </div><div class="line"><span class="meta">    @math_grade.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">math_grade</span><span class="params">(self, grade)</span>:</span></div><div class="line">        self._check_grade(grade)</div><div class="line">        self._math_grade = grade</div></pre></td></tr></table></figure></p>
<p>实际上，有另外一种更好的方式实现上述功能，那就是采用Python的描述器(<em>descriptor</em>)来做。</p>
<h4 id="描述器"><a href="#描述器" class="headerlink" title="描述器"></a>描述器</h4><blockquote>
<p>一般来说，一个描述器是一个有“绑定行为”的对象属性(object attribute)，它的访问控制被描述器协议方法重写。这些方法是 <code>__get__()</code>, <code>__set__()</code>, 和 <code>__delete__()</code> 。有这些方法的对象叫做描述器。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">descr.__get__(self, obj, type=None) --&gt; value</div><div class="line">descr.__set__(self, obj, value) --&gt; None</div><div class="line">descr.__delete__(self, obj) --&gt; None</div></pre></td></tr></table></figure>
<p>以上是所有描述器方法。一个对象具有其中任一个方法就会成为描述器，从而在被当作对象属性时重写默认的查找行为。来看一个例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._value = <span class="number">0</span></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, inst, owner)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._value</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, inst, value)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>):</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Grade must be between 0 and 100'</span>)</div><div class="line">        self._value = value</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam</span>:</span></div><div class="line">    math_grade = Grade()</div></pre></td></tr></table></figure></p>
<p>为属性赋值时:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">exam = Exam()</div><div class="line">exam.math_grade = <span class="number">50</span></div></pre></td></tr></table></figure></p>
<p>Python会对赋值操作进行转译，<code>exam.math_grade = 50</code>将会被转译成:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Exam.__dict__[<span class="string">'math_grade'</span>].__set__(exam, <span class="number">40</span>)</div></pre></td></tr></table></figure></p>
<p>同样，访问操作也会被转译，<code>print(exam.math_grade)</code>将会被转译成:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(Exam.__dict__[<span class="string">'math_grade'</span>].__get__(exam, Exam))</div></pre></td></tr></table></figure></p>
<p>但是，上面的代码存在一个问题，由于所有类<code>Exam</code>的实例都会共享同一份<code>math_grade</code>实例，即程序定义类<code>Exam</code>的时候，就会把类<code>Grade</code>的<code>math_grade</code>实例构建好，以后再创建类<code>Exam</code>的实例时，就不再构建Grade了，因此我们需要把每个<code>Exam</code>实例所对应的值记录到<code>Grade</code>中，因此可以采取字典保存:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._values = &#123;&#125;</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, inst, owner)</span>:</span></div><div class="line">        <span class="keyword">if</span> inst <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> self</div><div class="line">        <span class="keyword">return</span> self._values.get(inst, <span class="number">0</span>)</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, inst, value)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>):</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Grade must be between 0 and 100'</span>)</div><div class="line">        self._values[inst] = value</div></pre></td></tr></table></figure></p>
<p>这种方式实现简单，而且能够正常运作，但它仍然有一个问题，就是内存泄漏，在程序生命周期类，对于传给<code>__set__</code>方法的每个<code>Exam</code>实例来说，<code>_values</code>字典都会保存一份指向该实例的引用，这就导致该实例的引用计数无法降为0，从而使垃圾收集器无法将其回收，通过使用Python内置的<code>weakref</code>模块即可解决此问题。该模块提供了名为<code>WeakKeyDictionary</code>的特殊字典，该字典的引用为弱引用，系统能够正确的完成回收:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._values = WeakKeyDictionary()</div><div class="line">    <span class="comment"># ...</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;getter与setter&quot;&gt;&lt;a href=&quot;#getter与setter&quot; class=&quot;headerlink&quot; title=&quot;getter与setter&quot;&gt;&lt;/a&gt;&lt;code&gt;getter&lt;/code&gt;与&lt;code&gt;setter&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;如果开发者之前有其他语言的开发经验，在转入Python之后，可能会在类中明确地实现类似&lt;code&gt;getter&lt;/code&gt;和&lt;code&gt;setter&lt;/code&gt;方法，如:&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;OldResistor&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, ohms)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self._ohms = ohms&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get_ohms&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self._homs&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;set_ohms&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, ohms)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self._ohms = ohms&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="描述器" scheme="http://youchen.me/tags/%E6%8F%8F%E8%BF%B0%E5%99%A8/"/>
    
      <category term="属性" scheme="http://youchen.me/tags/%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python中的MRO</title>
    <link href="http://youchen.me/2017/01/22/Python-Method%20Resolution%20Order/"/>
    <id>http://youchen.me/2017/01/22/Python-Method Resolution Order/</id>
    <published>2017-01-22T07:23:00.000Z</published>
    <updated>2017-02-06T08:49:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天我想对Python中的方法解析顺序使用的C3算法进行一个梳理，文章内容主要基于对<a href="https://www.python.org/download/releases/2.3/mro/" target="_blank" rel="external">The Python 2.3 Method Resolution Order</a>一文的节选翻译。</p>
<p>首先，需要明白的是C3算法工作于Python 2.2引入的新式类(<em>new style classes</em>)，经典类(<em>classic classes</em>)中方法的解析仍然保持他们原有的顺序，即<code>深度优先，从左至右</code>，在此不进行深一步的讨论。</p>
<a id="more"></a>
<p>先来看一个例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>O = object</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">X</span><span class="params">(O)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Y</span><span class="params">(O)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(X, Y)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Y, X)</span>:</span> <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>继承顺序如图:<br><img src="/2017/01/22/Python-Method Resolution Order/python_inheritance.png" alt="Inheritance"></p>
<p>在这种情况下，通过A和B派生出一个新类C是有问题的，因为在A的继承中X先于Y,而在B中Y先于X，因此C中方法解析顺序会存在歧义。Python 2.3在这种情况下通过抛出异常<code>TypeError: MRO conflict among bases Y, X</code>来避免程序员创建有歧义的类。</p>
<h4 id="C3算法"><a href="#C3算法" class="headerlink" title="C3算法"></a>C3算法</h4><p>首先介绍一些简易记号来方便接下来的描述。</p>
<blockquote>
<p>$$C_1C_2…C_n$$</p>
</blockquote>
<p>表示一个类的列表<code>[C1, C2, ..., Cn]</code>。</p>
<p>列表的<code>head</code>为其第一个元素, <code>tail</code>为其余下元素:</p>
<blockquote>
<p>$$\begin{align}head &amp;= C_1\\tail &amp;= C_2…C_n\end{align}$$</p>
</blockquote>
<p>使用</p>
<blockquote>
<p>$$C+(C_1C_2…C_n) = CC_1C_2…C_n$$</p>
</blockquote>
<p>来表示<code>[C]+[C1, C2, ..., Cn]</code>。</p>
<p>线性化(<em>linearization</em>)定义:</p>
<blockquote>
<p>类C的线性化是指类C加上其父类的线性化以及其父类列表本身得到的和(列表)。</p>
</blockquote>
<p>用符号记号来描述:</p>
<blockquote>
<p>$$L[C(B_1…B_n)] = C + merge(L[B_1]…L[B_n], B_1…B_n)$$</p>
</blockquote>
<p>特别的，如果C是<code>object</code>类，即不存在父类，其线性化结果为:</p>
<blockquote>
<p>$$L[object] = object$$</p>
</blockquote>
<p>然而，要计算合并顺序需要遵循以下规则:</p>
<blockquote>
<p>取第一个列表的<code>head</code>，如$L[B_1][0]$；如果该<code>head</code>不在其余任一列表的尾部，将其加入类C的线性化结果列表中并将其从所有待合并列表中删除，否则从下一个列表中取出<code>head</code>并按上述规则处理。重复上述操作指导所有类都已经被删除或者无法再找到符合要求的<code>head</code>。在后者情况下，不可能完成merge操作，Python 2.3将会拒绝创建类C并抛出异常。</p>
</blockquote>
<p>下面举例说明，考虑如下继承:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>O = object</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">F</span><span class="params">(O)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(O)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(O)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(D, F)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(D, E)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(B, C)</span>:</span> <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<p>继承顺序如图:<br><img src="/2017/01/22/Python-Method Resolution Order/python_inheritance2.png" alt="Inheritance2"></p>
<p>B的线性化计算公式可以表示如下:</p>
<blockquote>
<p>$$L[B] = B + merge(DO, EO, DE)$$</p>
</blockquote>
<p>根据前述规则，我们首先取D作为<code>head</code>，待合并列表变成了$merge(O, EO, E)$，由于O不符合条件，我们跳过第一个列表在第二个列表中选择符合条件的E作为<code>head</code>，待合并列表变成了$merge(O, O)$，最后我们选择了O,因此:</p>
<blockquote>
<p>$$L[B] = B D E O$$</p>
</blockquote>
<p>同理可以得到C的线性化结果:</p>
<blockquote>
<p>$$\begin{align}L[C] &amp;= C + merge(DO, FO, DF)\\&amp;=C+D+merge(O, FO, F)\\&amp;=C+D+F+merge(O, O)\\&amp;=C\;D\;F\;O\end{align}$$</p>
</blockquote>
<p>最后来计算A的线性化结果:</p>
<blockquote>
<p>$$\begin{align}L[A] &amp;= A + merge(BDEO, CDFO, BC)\\&amp;=A+B+merge(DEO, CDFO, C)\\&amp;=A+B+C+merge(DEO, DFO)\\&amp;=A+B+C+D+merge(EO, FO)\\&amp;=A+B+C+D+E+merge(O, FO)\\&amp;=A+B+C+D+E+F+merge(O, O)\\&amp;=A\;B\;C\;D\;E\;F\;O\end{align}$$</p>
</blockquote>
<p>在Python 2.2以后，可以直接通过调用<code>.mro()</code>方法获得MRO:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; A.mro()</div><div class="line">[&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;,</div><div class="line">&lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.F'&gt;,</div><div class="line">&lt;type 'object'&gt;]</div></pre></td></tr></table></figure></p>
<p>最后，让我们回到最初的那个例子，其所有类的线性化结果计算如下:</p>
<blockquote>
<p>$$\begin{align}&amp;L[O] = O\\&amp;L[X] = X\;O\\&amp;L[Y] = Y\;O\\&amp;L[A] = A\;X\;Y\;O\\&amp;L[B] = B\;Y\;X\;O\end{align}$$</p>
</blockquote>
<p>然而，对于继承自类A和类B的类C来说是无法线性化的:</p>
<blockquote>
<p>$$\begin{align}L[C] &amp;= C + merge(AXYO, BYXO, AB)\\&amp;=C+A+merge(XYO, BYXO, B)\\&amp;=C+A+B+merge(XYO, YXO)\end{align}$$</p>
</blockquote>
<p>在此刻，我们无法完成对XYO和YXO的合并，因为X是YXO的尾，同时Y是XYO的尾，因此C3算法停止，Python 2.3将会抛出异常并拒绝创建类C。</p>
<h4 id="不好的MRO"><a href="#不好的MRO" class="headerlink" title="不好的MRO"></a>不好的MRO</h4><p>当一个MRO破坏了局部优先顺序和单调性等基础性质时称其为不好的MRO。<br>考虑如下例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>F=type(<span class="string">'Food'</span>,(),&#123;<span class="string">'remember2buy'</span>:<span class="string">'spam'</span>&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>E=type(<span class="string">'Eggs'</span>,(F,),&#123;<span class="string">'remember2buy'</span>:<span class="string">'eggs'</span>&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G=type(<span class="string">'GoodFood'</span>,(F,E),&#123;&#125;) <span class="comment"># under Python 2.3 this is an error!</span></div></pre></td></tr></table></figure></p>
<p>创建了F、E、G三个类，其中类E可表示为<code>class E(F)</code>，类G可表示为<code>class G(F, E)</code>，我们期望类G的<code>remember2buy</code>属性是继承自F而不是E的，然而在Python 2.2中我们会得到<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.remember2buy</div><div class="line"><span class="string">'eggs'</span></div></pre></td></tr></table></figure></p>
<p>这破坏了局部优先顺序,因为对于类G的继承顺序<code>(F, E)</code>,其局部优先顺序并没有在Python 2.2线性化结果中得到保留:</p>
<blockquote>
<p>$$L[G, P22] = G\;E\;F\;object$$</p>
</blockquote>
<p>有人可能会争辩说Python 2.2线性化结果中类F在类E之后的原因是因为类F没有类E更具体，因为类F是类E的父类；尽管如此打破了局部优先顺序会使得代码不直观且容易出错，一个有力的佐证就是其与经典类的不同:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">F</span>:</span> remember2buy=<span class="string">'spam'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(F)</span>:</span> remember2buy=<span class="string">'eggs'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">G</span><span class="params">(F,E)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.remember2buy</div><div class="line"><span class="string">'spam'</span></div></pre></td></tr></table></figure></p>
<p>回想之前谈到的，经典类的继承顺序为<code>深度优先，从左至右</code>，因此类G的MRO为GFEF，在这种情况下局部优先顺序得到了保留。<br>简而言之，像之前那种继承方式应该避免，Python 2.3开始通过抛出异常来避免了这种歧义，有力地阻止了程序员来创建有歧义的类继承(通过C3算法失败来完成)。</p>
<p>还有一点相关的，Python 2.3的算法足够智能来发现一些显而易见的错误，比如重复继承同一个父类:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class A(object): pass</div><div class="line">&gt;&gt;&gt; class C(A,A): pass # error</div><div class="line">Traceback (most recent call last):</div><div class="line">  File "&lt;stdin&gt;", line 1, in ?</div><div class="line">TypeError: duplicate base class A</div></pre></td></tr></table></figure></p>
<p>而这种情况在Python 2.2中(无论是经典类还是新式类)，都不会抛出异常。</p>
<p>最后，有一点十分重要的需要记住:</p>
<ul>
<li>MRO在决定方法解析顺序同时也决定了属性的解析顺序</li>
</ul>
<p>讨论完了局部优先顺序，下面再来看单调性问题。要证明经典类的MRO是非单调的很容易:<br><img src="/2017/01/22/Python-Method Resolution Order/python_inheritance3.png" alt="Inheritance3"></p>
<blockquote>
<p>$$\begin{align}&amp;L[B, P22] = B\;C\quad\#\;B在C之前：类B的方法优先\\&amp;L[D, P22] = D\;A\;C\;B\;C\quad\#\;B在C之后：类C的方法优先\end{align}$$</p>
</blockquote>
<p>另一方面，Python 2.2和Python 2.3的MRO中都不存在问题，都给出了:</p>
<blockquote>
<p>$$L[D] = D\;A\;B\;C$$</p>
</blockquote>
<p>Guido在他的<a href="https://www.python.org/download/releases/2.2.3/descrintro/#mro" target="_blank" rel="external">一篇文章</a>指出了经典类的MRO在实际使用中其实并不差，因为它可以使经典类避免钻石型结构。但由于所有新式类都继承自<code>object</code>，因此钻石型结果无法避免而且在所有的多继承图中前后矛盾都会出现。<br>Python 2.2的MRO使得破坏单调性十分困难，但并非不可能。接下来这个由<em>Samuele Pedroni</em>提供的例子，表明了Python 2.2新式类的MRO是非单调的:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">K1</span><span class="params">(A,B,C)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">K2</span><span class="params">(D,B,E)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">K3</span><span class="params">(D,A)</span>:</span>   <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Z</span><span class="params">(K1,K2,K3)</span>:</span> <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<p><img src="/2017/01/22/Python-Method Resolution Order/python_inheritance4.png" alt="Inheritance4"></p>
<p>使用C3算法的线性化结果如下:</p>
<blockquote>
<p>$$\begin{align}&amp;L[A] = A\;O\\&amp;L[B] = B\;O\\&amp;L[C] = C\;O\\&amp;L[D] = D\;O\\&amp;L[E] = E\;O\\&amp;L[K1] = K1\;A\;B\;C\;O\\&amp;L[K2] = K2\;D\;B\;E\;O\\&amp;L[K3] = K3\;D\;A\;O\\&amp;L[Z] = Z\;K1\;K2\;K3\;D\;A\;B\;C\;E\;O\end{align}$$</p>
</blockquote>
<p>Python 2.2对于A、B、C、D、E、K1、K2、K3的线性化给出了相同结果，但是对于Z则不同:</p>
<blockquote>
<p>$$L[Z, P22] = Z\;K1\;K3\;A\;K2\;D\;B\;C\;E\;O$$ </p>
</blockquote>
<p>显然这个线性化结果是错的，因为类先于D出现了，而K3的线性化结果中D先于A出现。换句话说，在K3中，从类A继承的方法被从类D继承的方法覆盖了，但是在Z中，作为一个K3的子类，却使用了从类A继承的方法去覆盖从类D继承的方法！这违反了单调性。此外，Python 2.2中类Z的线性化结果与局部优先顺序也不一致，类Z的局部优先列表为<code>[K1, K2, K3]</code>(K2在K3之前)，而在线性化结果中K3在K2之前，这些问题解释了为什么2.2中的规则被弃用转投C3规则。</p>
<h4 id="super函数"><a href="#super函数" class="headerlink" title="super函数"></a>super函数</h4><p>最后再来看Python 2.2引入的<code>super</code>函数，它主要用于初始化父类，避免了直接调用父类的<code>__init__</code>函数，减少耦合性，来看以下代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        self.value = value</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimesFive</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super(TimesFive, self).__init__(value)</div><div class="line">        self.value *= <span class="number">5</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlusTwo</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super(PlusTwo, self).__init__(value)</div><div class="line">        self.value += <span class="number">2</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodWay</span><span class="params">(TimesFive, PlusTwo)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super(GoodWay, self).__init__(value)</div><div class="line"></div><div class="line">foo = GoodWay(<span class="number">5</span>)</div></pre></td></tr></table></figure></p>
<p>它的计算顺序为<code>5 * (5 + 2)</code>而不是<code>(5 * 5) + 2</code>，原因在于程序的运行顺序与类GoodWay的MRO保持了一致，通过查看<code>GoodWay.mro()</code>可以得到:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; GoodWay.mro()</div><div class="line">[&lt;class '__main__.GoodWay'&gt;, &lt;class '__main__.TimesFive'&gt;, &lt;class '__main__.PlusTwo'&gt;, &lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;]</div></pre></td></tr></table></figure></p>
<p>调用<code>GoodWay(5)</code>的时候，它会调用<code>TimesFive.__init__</code>，而<code>TimesFive.__init__</code>又会调用<code>PlusTwo.__init__</code>，而<code>PlusTwo.__init__</code>会调用<code>Base.__init__</code>，当到达了钻石体系的顶部之后，所有的初始化方法会按照与刚才那些<code>__init__</code>相反的顺序执行，因此<code>Base.__init__</code>将value设为5，<code>PlusTwo.__init__</code>在此基础上加2，value变为7，最后<code>TimesFive.__init__</code>将value乘以5，得到35。</p>
<h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h4><p>一看到<code>super</code>这个函数很多人第一想法就是父类，但其实<code>super</code>工作原理是这样的:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">super</span><span class="params">(cls, inst)</span>:</span></div><div class="line">    mro = inst.__class__.mro()</div><div class="line">    <span class="keyword">return</span> mro[mro.index(cls) + <span class="number">1</span>]</div></pre></td></tr></table></figure></p>
<p>根据实例inst获得其类的MRO列表，返回cls所在位置的下一个位置的类，其中<code>inst</code>永远是最开始那个实例。</p>
<p>Python 3提供了一种不带参数的<code>super</code>调用方式，例如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Explicit</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super().__init__(value)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implicit</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super(__class__, self).__init__(value)</div><div class="line"></div><div class="line"><span class="keyword">assert</span> Explicit(<span class="number">10</span>).value == Implicit(<span class="number">10</span>).value</div></pre></td></tr></table></figure></p>
<p>由于Python 3程序可以在方法中通过<strong>class</strong>变量准确地引用当前类，所以上面的这种写法能够正常运作，而Python 2中则没有定义<strong>class</strong>，故而不能采用这种写法。可能有人试着用self.<strong>class</strong>做参数来调用<code>super</code>,但实际上这么做不行，因为Python 2是用<a href="http://stackoverflow.com/questions/18208683/when-calling-super-in-a-derived-class-can-i-pass-in-self-class" target="_blank" rel="external">特殊方式实现super</a>的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我想对Python中的方法解析顺序使用的C3算法进行一个梳理，文章内容主要基于对&lt;a href=&quot;https://www.python.org/download/releases/2.3/mro/&quot;&gt;The Python 2.3 Method Resolution Order&lt;/a&gt;一文的节选翻译。&lt;/p&gt;
&lt;p&gt;首先，需要明白的是C3算法工作于Python 2.2引入的新式类(&lt;em&gt;new style classes&lt;/em&gt;)，经典类(&lt;em&gt;classic classes&lt;/em&gt;)中方法的解析仍然保持他们原有的顺序，即&lt;code&gt;深度优先，从左至右&lt;/code&gt;，在此不进行深一步的讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="MRO" scheme="http://youchen.me/tags/MRO/"/>
    
      <category term="C3" scheme="http://youchen.me/tags/C3/"/>
    
  </entry>
  
  <entry>
    <title>multiprocessing中pool实现</title>
    <link href="http://youchen.me/2017/01/17/Python-multiprocessing%20pool/"/>
    <id>http://youchen.me/2017/01/17/Python-multiprocessing pool/</id>
    <published>2017-01-17T00:52:00.000Z</published>
    <updated>2017-01-17T02:10:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>终于有时间来整理整理之前自己的一些心得，今天想分享的是之前梳理的<code>Python</code>中<code>multiprocessing</code>模块的线程池与进程池实现。</p>
<a id="more"></a>
<p>multiprocessing.pool类包含taskqueue、inqueue、outqueue三个队列，其中：</p>
<ul>
<li>taskqueue采用<code>Queue.Queue</code>实现，通过apply、apply_async、map、map_async等函数向pool类提交任务。</li>
<li>inqueue、outqueue采用<code>SimpleQueue</code>实现，本质上是带锁的pipe</li>
<li>inqueue负责存放待完成任务，outqueue负责存放已完成任务</li>
</ul>
<p>multiprocessing.pool类包含worker_handler、task_handler、result_handler三个handler，均在threading.Thread上工作，均为<code>Daemon Thread</code>，其中：</p>
<ul>
<li><p>worker_handler负责回收已经完成任务的worker，同时根据回收数量使用process函数重新生成足够的worker，在生命周期中维护整个pool中worker的数量:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_maintain_pool</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""Clean up any exited workers and start replacements for them.</span></div><div class="line">    """</div><div class="line">    <span class="keyword">if</span> self._join_exited_workers():</div><div class="line">        self._repopulate_pool()</div><div class="line"></div><div class="line"><span class="meta">@staticmethod</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_handle_workers</span><span class="params">(pool)</span>:</span></div><div class="line">    thread = threading.current_thread()</div><div class="line"></div><div class="line">    <span class="comment"># Keep maintaining workers until the cache gets drained, unless the pool</span></div><div class="line">    <span class="comment"># is terminated.</span></div><div class="line">    <span class="keyword">while</span> thread._state == RUN <span class="keyword">or</span> (pool._cache <span class="keyword">and</span> thread._state != TERMINATE):</div><div class="line">        pool._maintain_pool()</div><div class="line">        time.sleep(<span class="number">0.1</span>)</div><div class="line">    <span class="comment"># send sentinel to stop workers</span></div><div class="line">    pool._taskqueue.put(<span class="keyword">None</span>)</div><div class="line">    util.debug(<span class="string">'worker handler exiting'</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>task_handler负责从taskqueue中按先后顺序阻塞获取待完成任务，更新pool的任务cache，并提交至inqueue中等待worker处理</p>
</li>
<li>result_handler负责从outqueue中按先后顺序阻塞获取已完成任务，更新pool的任务cache，如果存在回调函数则进行回调操作</li>
</ul>
<p>multiprocessing.pool类包含1个(未实现情况下)或多个(未提供数量，cpu_count()个)或指定数量的worker，其中：</p>
<ul>
<li>worker的维护由worker_handerler负责，在一个worker任务完成后由worker_handler负责回收并重新生成新的worker</li>
<li>worker包含对inqueue.get和outqueue.put的引用</li>
<li>worker从inqueue从获取待完成任务，并负责执行该任务，并将执行结果提交至outqueue中等待处理:<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(inqueue, outqueue, initializer=None, initargs=<span class="params">()</span>, maxtasks=None,</span></span></div><div class="line">           wrap_exception=False):</div><div class="line">    <span class="keyword">assert</span> maxtasks <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> (type(maxtasks) == int <span class="keyword">and</span> maxtasks &gt; <span class="number">0</span>)</div><div class="line">    put = outqueue.put</div><div class="line">    get = inqueue.get</div><div class="line">    <span class="keyword">if</span> hasattr(inqueue, <span class="string">'_writer'</span>):</div><div class="line">        inqueue._writer.close()</div><div class="line">        outqueue._reader.close()</div><div class="line"></div><div class="line">    <span class="keyword">if</span> initializer <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        initializer(*initargs)</div><div class="line"></div><div class="line">    completed = <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> maxtasks <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> (maxtasks <span class="keyword">and</span> completed &lt; maxtasks):</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            task = get()</div><div class="line">        <span class="keyword">except</span> (EOFError, OSError):</div><div class="line">            util.debug(<span class="string">'worker got EOFError or OSError -- exiting'</span>)</div><div class="line">            <span class="keyword">break</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> task <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            util.debug(<span class="string">'worker got sentinel -- exiting'</span>)</div><div class="line">            <span class="keyword">break</span></div><div class="line"></div><div class="line">        job, i, func, args, kwds = task</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            result = (<span class="keyword">True</span>, func(*args, **kwds))</div><div class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">            <span class="keyword">if</span> wrap_exception:</div><div class="line">                e = ExceptionWithTraceback(e, e.__traceback__)</div><div class="line">            result = (<span class="keyword">False</span>, e)</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            put((job, i, result))</div><div class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">            wrapped = MaybeEncodingError(e, result[<span class="number">1</span>])</div><div class="line">            util.debug(<span class="string">"Possible encoding error while sending result: %s"</span> % (</div><div class="line">                wrapped))</div><div class="line">            put((job, i, (<span class="keyword">False</span>, wrapped)))</div><div class="line">        completed += <span class="number">1</span></div><div class="line">    util.debug(<span class="string">'worker exiting after %d tasks'</span> % completed)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>PS：</p>
<blockquote>
<p>multiprocessing.ThreadPool是pool的thread-level级实现，以multiprocessing.dummy中的DummyProcess替换了pool的默认process，DummyProcess继承至threading.Thread，因此ThreadPool的实现是thread-level级的。</p>
</blockquote>
<p>实现用图来表示如下:</p>
<p><img src="/2017/01/17/Python-multiprocessing pool/python_multiprocessing_pool.png" alt="multiprocessing_pool"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于有时间来整理整理之前自己的一些心得，今天想分享的是之前梳理的&lt;code&gt;Python&lt;/code&gt;中&lt;code&gt;multiprocessing&lt;/code&gt;模块的线程池与进程池实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="多进程" scheme="http://youchen.me/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="进程池" scheme="http://youchen.me/tags/%E8%BF%9B%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>欢迎</title>
    <link href="http://youchen.me/2017/01/05/welcome/"/>
    <id>http://youchen.me/2017/01/05/welcome/</id>
    <published>2017-01-05T03:58:00.000Z</published>
    <updated>2017-02-04T08:31:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到我的博客，这个博客使用了<a href="https://hexo.io" target="_blank" rel="external">Hexo</a>构建，托管在<a href="https://pages.github.com" target="_blank" rel="external">Github Pages</a>,主题使用了<a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank" rel="external">Apollo</a>。</p>
<p>因为整个博客是托管在Github上的静态页面，没有数据库的支持，因此使用了<a href="http://duoshuo.com" target="_blank" rel="external">多说</a>来为整个博客提供评论功能，同时我也通过JS给博客增加了搜索功能，通过点击右下角的搜索图标或者双击<code>Ctrl</code>键可以启动搜索，这样可以方便快速查找相关内容。</p>
<a id="more"></a>
<p>现在博客的功能还有限，在以后我会慢慢增加新的功能，同时也会不定期更新一些我学习过程中的心得，欢迎大家阅读！</p>
<p>谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎来到我的博客，这个博客使用了&lt;a href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;构建，托管在&lt;a href=&quot;https://pages.github.com&quot;&gt;Github Pages&lt;/a&gt;,主题使用了&lt;a href=&quot;https://github.com/pinggod/hexo-theme-apollo&quot;&gt;Apollo&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;因为整个博客是托管在Github上的静态页面，没有数据库的支持，因此使用了&lt;a href=&quot;http://duoshuo.com&quot;&gt;多说&lt;/a&gt;来为整个博客提供评论功能，同时我也通过JS给博客增加了搜索功能，通过点击右下角的搜索图标或者双击&lt;code&gt;Ctrl&lt;/code&gt;键可以启动搜索，这样可以方便快速查找相关内容。&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="http://youchen.me/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="欢迎" scheme="http://youchen.me/tags/%E6%AC%A2%E8%BF%8E/"/>
    
      <category term="第一篇" scheme="http://youchen.me/tags/%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    
      <category term="博客" scheme="http://youchen.me/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="新功能" scheme="http://youchen.me/tags/%E6%96%B0%E5%8A%9F%E8%83%BD/"/>
    
  </entry>
  
</feed>
