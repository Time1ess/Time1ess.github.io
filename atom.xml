<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>David&#39;s Blog</title>
  <subtitle>A graduate student in Computer Science</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://youchen.me/"/>
  <updated>2017-02-04T09:19:05.000Z</updated>
  <id>http://youchen.me/</id>
  
  <author>
    <name>David</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python属性访问</title>
    <link href="http://youchen.me/2017/02/04/Python%20property%20access/"/>
    <id>http://youchen.me/2017/02/04/Python property access/</id>
    <published>2017-02-04T08:26:07.000Z</published>
    <updated>2017-02-04T09:19:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇中讲到了描述器方法<code>__get__</code>、<code>__set__</code>和<code>__delete__</code>，同时也提到，一个对象具有任意一个方法的就会成为描述器，从而在被当作对象属性的时候会重写默认的查找行为。在本片中，通过对<a href="https://docs.python.org/2/howto/descriptor.html" target="_blank" rel="external">Descriptor HowTo Guide</a>的节选翻译以及笔者的自身的一些实践，对描述器做一个更详细的说明。</p>
<p>如果一个对象同时定义了<code>__get__</code>和<code>__set__</code>方法，则称它为资料描述器(<em>data descriptor</em>)，而仅定义了<code>__get__</code>方法的描述器称为非资料描述器(<em>non-data descriptor</em>，常用于方法，其他用途也是可以的)。</p>
<p>资料描述器和非资料描述器的区别在于：<strong>相对于实例的字典的优先级</strong>。如果实例字典中有和描述器重名的属性，如果描述器是资料描述器，优先使用资料描述器，如果是非资料描述器，优先使用字典中的属性。这就是为何实例a的方法和属性重名时，比如都叫做<code>foo</code>，Python会在访问<code>a.foo</code>时优先访问实例字典中的属性，因为实例的方法是个非资料描述器。<br><a id="more"></a><br>要想制作一个只读的资料描述器需要同时定义<code>__set__</code>和<code>__get__</code>方法，由于是只读，所以只需要在<code>__set__</code>方法中抛出一个<code>AttributeError</code>异常即可。</p>
<p>在一般情况下，描述器在属性访问时被自动调用。举例来说，<code>obj.d</code>会在<code>obj</code>的字典里面查找<code>d</code>，如果<code>d</code>定义了<code>__get__</code>方法，那么<code>d.__get__(obj)</code>会依据下面的优先规则被调用。</p>
<p>调用的细节取决于<code>obj</code>是一个类还是一个实例，对于对象来讲，方法<code>object.__getattribute__</code>将属性访问<code>a.x</code>变成了<code>type(a).__dict__[&#39;x&#39;].__get__(a, type(a))</code>，具体实现依据这样的优先顺序:<strong>资料描述器</strong>优先于<strong>实例变量</strong>，<strong>实例变量</strong>优先于<strong>非资料描述器</strong>，<code>__getattr__()</code>方法具有最低优先级；对于类来讲，方法<code>type.__getattribute__</code>将<code>A.x</code>变成<code>A.__dict__[&#39;x&#39;].__get__(None, A)</code>。如以下代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">V</span>:</span></div><div class="line">    v = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>)</span>:</span></div><div class="line">        self.v = val</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, inst, owner)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.v</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, inst, value)</span>:</span></div><div class="line">        self.v = value</div><div class="line">        </div><div class="line">        </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line">    k1 = V(<span class="number">1</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">k</span><span class="params">(self)</span>:</span>  <span class="comment"># non-data descriptor</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">a = A()</div><div class="line">print(a.k)  <span class="comment"># &lt;bound method...&gt; *op1*</span></div><div class="line">a.k = <span class="number">6</span>  <span class="comment"># replace non-data descriptor with instance dict  *op2*</span></div><div class="line">print(a.k)  <span class="comment"># 6  *op3*</span></div><div class="line"></div><div class="line">print(a.k1)  <span class="comment"># 1</span></div><div class="line">a.__dict__[<span class="string">'k1'</span>] = V(<span class="number">2</span>)  <span class="comment"># *op4*</span></div><div class="line">print(a.k1)  <span class="comment"># 1</span></div></pre></td></tr></table></figure></p>
<p>这段代码展示了资料描述器、实例变量、非资料描述器在属性访问中的不同优先级，分析如下:类<code>A</code>中定义了方法<code>k</code>(非资料描述器)，第一次操作对<code>a.k</code>的访问将转变为<code>type(a).__dict__[&#39;k&#39;].__get__(a, type(a))</code>，<code>type(a)</code>即类<code>A</code>，<code>A.__dict__</code>中存储了方法<code>A.k</code>，由于方法<code>A.k</code>为非资料描述器，因此调用其定义的<code>__get__()</code>方法。第二次操作<code>a.k = 6</code>本质上是在字典<code>a.__dict__</code>中添加了<code>k</code>这一变量(注意<code>a.__dict__</code>和<code>A._dict__</code>的区别)，即新增了实例变量。第三次操作对<code>a.k</code>的访问由于<strong>实例变量</strong>优先级高于<strong>非资料描述器</strong>，因此将获得之前的赋值6而不是方法。在第四次操作前后分别访问了<code>a.k1</code>属性，由于<code>k1</code>是资料描述器，因此即使在<code>a.__dict__</code>中新增了实例变量<code>k1</code>，对<code>a.k1</code>仍然是访问了资料描述器而不是实例变量，与前述的优先级保持一致。</p>
<p><code>__getattr__</code>与<code>__getattribute__</code>区别:前者只会在待访问的属性缺失时触发，而后者则会在每次访问属性时触发。</p>
<p><strong>特别注意:</strong>如果要在<code>__getattribute__</code>和<code>__setattr__</code>方法中访问实例属性，那么应该直接通过<code>super()</code>来做，以避免无限递归。如以下代码就会抛出异常:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrokenAttribute</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></div><div class="line">        self._data = data</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, name)</span>:</span></div><div class="line">        print(<span class="string">'Called __getattribute__(&#123;0&#125;)'</span>.format(name))</div><div class="line">        <span class="keyword">return</span> self._data[name]</div><div class="line"></div><div class="line"></div><div class="line">data = BrokenAttribute(&#123;<span class="string">'foo'</span>: <span class="number">3</span>&#125;)</div><div class="line">print(data.foo)</div><div class="line">&gt;&gt;&gt;</div><div class="line">RecursionError: maximum recursion depth exceeded <span class="keyword">while</span> calling a Python object</div></pre></td></tr></table></figure></p>
<p><strong>属性Property</strong></p>
<p>调用<code>property()</code>是建立资料描述器的一种简洁方式，从而可以在访问属性时触发相应的方法调用。<code>property</code>函数原型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute</div></pre></td></tr></table></figure></p>
<p>下面展示了一个典型应用，定义一个托管属性(managed attribute)x:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getx</span><span class="params">(self)</span>:</span> <span class="keyword">return</span> self.__x</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setx</span><span class="params">(self, value)</span>:</span> self.__x = value</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delx</span><span class="params">(self)</span>:</span> <span class="keyword">del</span> self.__x</div><div class="line">    x = property(getx, setx, delx, <span class="string">"I'm the 'x' property."</span>)</div></pre></td></tr></table></figure>
<p>其等价Python实现为:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Property</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"Emulate PyProperty_Type() in Objects/descrobject.c"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fget=None, fset=None, fdel=None, doc=None)</span>:</span></div><div class="line">        self.fget = fget</div><div class="line">        self.fset = fset</div><div class="line">        self.fdel = fdel</div><div class="line">        self.__doc__ = doc</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype=None)</span>:</span></div><div class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> self</div><div class="line">        <span class="keyword">if</span> self.fget <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">raise</span> AttributeError, <span class="string">"unreadable attribute"</span></div><div class="line">        <span class="keyword">return</span> self.fget(obj)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, obj, value)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.fset <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">raise</span> AttributeError, <span class="string">"can't set attribute"</span></div><div class="line">        self.fset(obj, value)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, obj)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.fdel <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">raise</span> AttributeError, <span class="string">"can't delete attribute"</span></div><div class="line">        self.fdel(obj)</div></pre></td></tr></table></figure>
<p><strong>静态方法与类方法</strong></p>
<p>非资料描述器为将函数绑定成方法这种常见模式提供了一个简单的实现机制。<br>简而言之，函数有个方法<code>__get__()</code>，当函数被当作属性访问时，它会把函数变成一个实例方法。非资料描述器把实例调用<code>obj.f(*args)</code>转换成<code>f(obj, *args)</code>(绑定方法)，把类调用<code>klass.f(*args)</code>转换成<code>f(klass, *args)</code>(非绑定方法)。<br>静态方法原样返回函数，调用 c.f 或者 C.f 分别等价于<code>object.__getattribute__(c, &quot;f&quot;)</code>或者<code>object.__getattribute__(C, &quot;f&quot;)</code>。也就是说，无论是从一个对象还是一个类中，这个函数都会同样地访问到。<br>利用非资料描述器，<code>staticmethod()</code>的等价实现看起来像这样:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">staticmethod</span><span class="params">(object)</span>:</span></div><div class="line"> <span class="string">"Emulate PyStaticMethod_Type() in Objects/funcobject.c"</span></div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, f)</span>:</span></div><div class="line">      self.f = f</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype=None)</span>:</span></div><div class="line">      <span class="keyword">return</span> self.f</div></pre></td></tr></table></figure>
<p>同样的，<code>classmethod()</code>等价实现看起来像这样:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassMethod</span><span class="params">(object)</span>:</span></div><div class="line">     <span class="string">"Emulate PyClassMethod_Type() in Objects/funcobject.c"</span></div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, f)</span>:</span></div><div class="line">          self.f = f</div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, klass=None)</span>:</span></div><div class="line">          <span class="keyword">if</span> klass <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">               klass = type(obj)</div><div class="line">          <span class="function"><span class="keyword">def</span> <span class="title">newfunc</span><span class="params">(*args)</span>:</span></div><div class="line">               <span class="keyword">return</span> self.f(klass, *args)</div><div class="line">          <span class="keyword">return</span> newfunc</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇中讲到了描述器方法&lt;code&gt;__get__&lt;/code&gt;、&lt;code&gt;__set__&lt;/code&gt;和&lt;code&gt;__delete__&lt;/code&gt;，同时也提到，一个对象具有任意一个方法的就会成为描述器，从而在被当作对象属性的时候会重写默认的查找行为。在本片中，通过对&lt;a href=&quot;https://docs.python.org/2/howto/descriptor.html&quot;&gt;Descriptor HowTo Guide&lt;/a&gt;的节选翻译以及笔者的自身的一些实践，对描述器做一个更详细的说明。&lt;/p&gt;
&lt;p&gt;如果一个对象同时定义了&lt;code&gt;__get__&lt;/code&gt;和&lt;code&gt;__set__&lt;/code&gt;方法，则称它为资料描述器(&lt;em&gt;data descriptor&lt;/em&gt;)，而仅定义了&lt;code&gt;__get__&lt;/code&gt;方法的描述器称为非资料描述器(&lt;em&gt;non-data descriptor&lt;/em&gt;，常用于方法，其他用途也是可以的)。&lt;/p&gt;
&lt;p&gt;资料描述器和非资料描述器的区别在于：&lt;strong&gt;相对于实例的字典的优先级&lt;/strong&gt;。如果实例字典中有和描述器重名的属性，如果描述器是资料描述器，优先使用资料描述器，如果是非资料描述器，优先使用字典中的属性。这就是为何实例a的方法和属性重名时，比如都叫做&lt;code&gt;foo&lt;/code&gt;，Python会在访问&lt;code&gt;a.foo&lt;/code&gt;时优先访问实例字典中的属性，因为实例的方法是个非资料描述器。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="描述器" scheme="http://youchen.me/tags/%E6%8F%8F%E8%BF%B0%E5%99%A8/"/>
    
      <category term="属性" scheme="http://youchen.me/tags/%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python属性与描述器</title>
    <link href="http://youchen.me/2017/01/24/Python%20property%20and%20descriptor/"/>
    <id>http://youchen.me/2017/01/24/Python property and descriptor/</id>
    <published>2017-01-24T09:03:27.000Z</published>
    <updated>2017-01-24T09:03:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><code>getter</code>与<code>setter</code></strong><br>如果开发者之前有其他语言的开发经验，在转入Python之后，可能会在类中明确地实现类似<code>getter</code>和<code>setter</code>方法，如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OldResistor</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ohms)</span>:</span></div><div class="line">        self._ohms = ohms</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_ohms</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._homs</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_ohms</span><span class="params">(self, ohms)</span>:</span></div><div class="line">        self._ohms = ohms</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>然而这种方法却并不像Python的编程风格，特别是对于自增的代码来说更是如此:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">r = OldResistor(<span class="number">1e3</span>)</div><div class="line">r.set_ohms(r.get_ohms()+<span class="number">1e3</span>)</div></pre></td></tr></table></figure></p>
<p>对于Python语言来说，基本上不需要手工实现<code>getter</code>和<code>setter</code>方法，而是该先从简单的<code>public</code>属性写起:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewResistor</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ohms)</span>:</span></div><div class="line">        self.ohms = ohms</div><div class="line">        </div><div class="line">r = NewResistor(<span class="number">1e3</span>)</div><div class="line">r.ohms += <span class="number">1e3</span></div></pre></td></tr></table></figure></p>
<p>但是开发者可能需要在对某个属性操作的时候实现特殊行为，这时候可以改用<code>@property</code>修饰器和<code>setter</code>方法来做:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropResistor</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ohms)</span>:</span></div><div class="line">        self._ohms = ohms</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ohms</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># Do what you want when access ohms</span></div><div class="line">        <span class="keyword">return</span> self._ohms</div><div class="line">    </div><div class="line"><span class="meta">    @ohms.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ohms</span><span class="params">(self, ohms)</span>:</span></div><div class="line">        <span class="comment"># Do what you want when change ohms</span></div><div class="line">        self._ohms = ohms</div></pre></td></tr></table></figure></p>
<p>通过指定<code>setter</code>方法，我们可以在方法里面做类型验证以及数值验证。</p>
<p>但是,考虑下面一种情况:</p>
<blockquote>
<p>假设有一个考试成绩(<code>Exam</code>)类，由多个科目的小成绩组成，每一科需要单独计分，在进行分数录入的时候，要求对成绩进行验证，保证其在0~100之间</p>
</blockquote>
<p>如果使用属性<code>@property</code>实现，每添加一项科目，就要重复编写一次<code>@property</code>方法，而且还需要重复相关验证逻辑，如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">       self._chinese_grade = <span class="number">0</span></div><div class="line">       self._math_grade = <span class="number">0</span></div><div class="line">       </div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_grade</span><span class="params">(value)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>):</div><div class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'Grade must be between 0 and 100'</span>)</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">chinese_grade</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._chinese_grade</div><div class="line">    </div><div class="line"><span class="meta">    @chinese_grade.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">chinese_grade</span><span class="params">(self, grade)</span>:</span></div><div class="line">        self._check_grade(grade)</div><div class="line">        self._chinese_grade = grade</div><div class="line">        </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">math_grade</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._math_grade</div><div class="line">        </div><div class="line"><span class="meta">    @math_grade.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">math_grade</span><span class="params">(self, grade)</span>:</span></div><div class="line">        self._check_grade(grade)</div><div class="line">        self._math_grade = grade</div></pre></td></tr></table></figure></p>
<p>实际上，有另外一种更好的方式实现上述功能，那就是采用Python的描述器(<em>descriptor</em>)来做。</p>
<p><strong>描述器</strong></p>
<blockquote>
<p>一般来说，一个描述器是一个有“绑定行为”的对象属性(object attribute)，它的访问控制被描述器协议方法重写。这些方法是 <code>__get__()</code>, <code>__set__()</code>, 和 <code>__delete__()</code> 。有这些方法的对象叫做描述器。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">descr.__get__(self, obj, type=None) --&gt; value</div><div class="line">descr.__set__(self, obj, value) --&gt; None</div><div class="line">descr.__delete__(self, obj) --&gt; None</div></pre></td></tr></table></figure>
<p>以上是所有描述器方法。一个对象具有其中任一个方法就会成为描述器，从而在被当作对象属性时重写默认的查找行为。来看一个例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._value = <span class="number">0</span></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, inst, owner)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._value</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, inst, value)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>):</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Grade must be between 0 and 100'</span>)</div><div class="line">        self._value = value</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam</span>:</span></div><div class="line">    math_grade = Grade()</div></pre></td></tr></table></figure></p>
<p>为属性赋值时:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">exam = Exam()</div><div class="line">exam.math_grade = <span class="number">50</span></div></pre></td></tr></table></figure></p>
<p>Python会对赋值操作进行转译，<code>exam.math_grade = 50</code>将会被转译成:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Exam.__dict__[<span class="string">'math_grade'</span>].__set__(exam, <span class="number">40</span>)</div></pre></td></tr></table></figure></p>
<p>同样，访问操作也会被转译，<code>print(exam.math_grade)</code>将会被转译成:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(Exam.__dict__[<span class="string">'math_grade'</span>].__get__(exam, Exam))</div></pre></td></tr></table></figure></p>
<p>但是，上面的代码存在一个问题，由于所有类<code>Exam</code>的实例都会共享同一份<code>math_grade</code>实例，即程序定义类<code>Exam</code>的时候，就会把类<code>Grade</code>的<code>math_grade</code>实例构建好，以后再创建类<code>Exam</code>的实例时，就不再构建Grade了，因此我们需要把每个<code>Exam</code>实例所对应的值记录到<code>Grade</code>中，因此可以采取字典保存:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._values = &#123;&#125;</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, inst, owner)</span>:</span></div><div class="line">        <span class="keyword">if</span> inst <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> self</div><div class="line">        <span class="keyword">return</span> self._values.get(inst, <span class="number">0</span>)</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, inst, value)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>):</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Grade must be between 0 and 100'</span>)</div><div class="line">        self._values[inst] = value</div></pre></td></tr></table></figure></p>
<p>这种方式实现简单，而且能够正常运作，但它仍然有一个问题，就是内存泄漏，在程序生命周期类，对于传给<code>__set__</code>方法的每个<code>Exam</code>实例来说，<code>_values</code>字典都会保存一份指向该实例的引用，这就导致该实例的引用计数无法降为0，从而使垃圾收集器无法将其回收，通过使用Python内置的<code>weakref</code>模块即可解决此问题。该模块提供了名为<code>WeakKeyDictionary</code>的特殊字典，该字典的引用为弱引用，系统能够正确的完成回收:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._values = WeakKeyDictionary()</div><div class="line">    <span class="comment"># ...</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;code&gt;getter&lt;/code&gt;与&lt;code&gt;setter&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;如果开发者之前有其他语言的开发经验，在转入Python之后，可能会在类中明确地实现类似&lt;code&gt;getter&lt;/code&gt;和&lt;code&gt;setter&lt;/code&gt;方法，如:&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;OldResistor&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, ohms)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self._ohms = ohms&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get_ohms&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self._homs&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;set_ohms&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, ohms)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self._ohms = ohms&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="描述器" scheme="http://youchen.me/tags/%E6%8F%8F%E8%BF%B0%E5%99%A8/"/>
    
      <category term="属性" scheme="http://youchen.me/tags/%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python中的MRO</title>
    <link href="http://youchen.me/2017/01/22/Method%20Resolution%20Order/"/>
    <id>http://youchen.me/2017/01/22/Method Resolution Order/</id>
    <published>2017-01-22T07:23:00.000Z</published>
    <updated>2017-01-23T04:31:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天我想对Python中的方法解析顺序使用的C3算法进行一个梳理，文章内容主要基于对<a href="https://www.python.org/download/releases/2.3/mro/" target="_blank" rel="external">The Python 2.3 Method Resolution Order</a>一文的节选翻译。</p>
<p>首先，需要明白的是C3算法工作于Python 2.2引入的新式类(<em>new style classes</em>)，经典类(<em>classic classes</em>)中方法的解析仍然保持他们原有的顺序，即<code>深度优先，从左至右</code>，在此不进行深一步的讨论。</p>
<a id="more"></a>
<p>先来看一个例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>O = object</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">X</span><span class="params">(O)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Y</span><span class="params">(O)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(X, Y)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Y, X)</span>:</span> <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>继承顺序如图:<br><img src="/2017/01/22/Method Resolution Order/python_inheritance.png" alt="Inheritance"></p>
<p>在这种情况下，通过A和B派生出一个新类C是有问题的，因为在A的继承中X先于Y,而在B中Y先于X，因此C中方法解析顺序会存在歧义。Python 2.3在这种情况下通过抛出异常<code>TypeError: MRO conflict among bases Y, X</code>来避免程序员创建有歧义的类。</p>
<p><strong>C3算法</strong><br>首先介绍一些简易记号来方便接下来的描述。</p>
<blockquote>
<p>$$C_1C_2…C_n$$</p>
</blockquote>
<p>表示一个类的列表<code>[C1, C2, ..., Cn]</code>。</p>
<p>列表的<code>head</code>为其第一个元素, <code>tail</code>为其余下元素:</p>
<blockquote>
<p>$$\begin{align}head &amp;= C_1\\tail &amp;= C_2…C_n\end{align}$$</p>
</blockquote>
<p>使用</p>
<blockquote>
<p>$$C+(C_1C_2…C_n) = CC_1C_2…C_n$$</p>
</blockquote>
<p>来表示<code>[C]+[C1, C2, ..., Cn]</code>。</p>
<p>线性化(<em>linearization</em>)定义:</p>
<blockquote>
<p>类C的线性化是指类C加上其父类的线性化以及其父类列表本身得到的和(列表)。</p>
</blockquote>
<p>用符号记号来描述:</p>
<blockquote>
<p>$$L[C(B_1…B_n)] = C + merge(L[B_1]…L[B_n], B_1…B_n)$$</p>
</blockquote>
<p>特别的，如果C是<code>object</code>类，即不存在父类，其线性化结果为:</p>
<blockquote>
<p>$$L[object] = object$$</p>
</blockquote>
<p>然而，要计算合并顺序需要遵循以下规则:</p>
<blockquote>
<p>取第一个列表的<code>head</code>，如$L[B_1][0]$；如果该<code>head</code>不在其余任一列表的尾部，将其加入类C的线性化结果列表中并将其从所有待合并列表中删除，否则从下一个列表中取出<code>head</code>并按上述规则处理。重复上述操作指导所有类都已经被删除或者无法再找到符合要求的<code>head</code>。在后者情况下，不可能完成merge操作，Python 2.3将会拒绝创建类C并抛出异常。</p>
</blockquote>
<p>下面举例说明，考虑如下继承:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>O = object</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">F</span><span class="params">(O)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(O)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(O)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(D, F)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(D, E)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(B, C)</span>:</span> <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<p>继承顺序如图:<br><img src="/2017/01/22/Method Resolution Order/python_inheritance2.png" alt="Inheritance2"></p>
<p>B的线性化计算公式可以表示如下:</p>
<blockquote>
<p>$$L[B] = B + merge(DO, EO, DE)$$</p>
</blockquote>
<p>根据前述规则，我们首先取D作为<code>head</code>，待合并列表变成了$merge(O, EO, E)$，由于O不符合条件，我们跳过第一个列表在第二个列表中选择符合条件的E作为<code>head</code>，待合并列表变成了$merge(O, O)$，最后我们选择了O,因此:</p>
<blockquote>
<p>$$L[B] = B D E O$$</p>
</blockquote>
<p>同理可以得到C的线性化结果:</p>
<blockquote>
<p>$$\begin{align}L[C] &amp;= C + merge(DO, FO, DF)\\&amp;=C+D+merge(O, FO, F)\\&amp;=C+D+F+merge(O, O)\\&amp;=C\;D\;F\;O\end{align}$$</p>
</blockquote>
<p>最后来计算A的线性化结果:</p>
<blockquote>
<p>$$\begin{align}L[A] &amp;= A + merge(BDEO, CDFO, BC)\\&amp;=A+B+merge(DEO, CDFO, C)\\&amp;=A+B+C+merge(DEO, DFO)\\&amp;=A+B+C+D+merge(EO, FO)\\&amp;=A+B+C+D+E+merge(O, FO)\\&amp;=A+B+C+D+E+F+merge(O, O)\\&amp;=A\;B\;C\;D\;E\;F\;O\end{align}$$</p>
</blockquote>
<p>在Python 2.2以后，可以直接通过调用<code>.mro()</code>方法获得MRO:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; A.mro()</div><div class="line">[&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;,</div><div class="line">&lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.F'&gt;,</div><div class="line">&lt;type 'object'&gt;]</div></pre></td></tr></table></figure></p>
<p>最后，让我们回到最初的那个例子，其所有类的线性化结果计算如下:</p>
<blockquote>
<p>$$\begin{align}&amp;L[O] = O\\&amp;L[X] = X\;O\\&amp;L[Y] = Y\;O\\&amp;L[A] = A\;X\;Y\;O\\&amp;L[B] = B\;Y\;X\;O\end{align}$$</p>
</blockquote>
<p>然而，对于继承自类A和类B的类C来说是无法线性化的:</p>
<blockquote>
<p>$$\begin{align}L[C] &amp;= C + merge(AXYO, BYXO, AB)\\&amp;=C+A+merge(XYO, BYXO, B)\\&amp;=C+A+B+merge(XYO, YXO)\end{align}$$</p>
</blockquote>
<p>在此刻，我们无法完成对XYO和YXO的合并，因为X是YXO的尾，同时Y是XYO的尾，因此C3算法停止，Python 2.3将会抛出异常并拒绝创建类C。</p>
<p><strong>不好的MRO</strong><br>当一个MRO破坏了局部优先顺序和单调性等基础性质时称其为不好的MRO。<br>考虑如下例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>F=type(<span class="string">'Food'</span>,(),&#123;<span class="string">'remember2buy'</span>:<span class="string">'spam'</span>&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>E=type(<span class="string">'Eggs'</span>,(F,),&#123;<span class="string">'remember2buy'</span>:<span class="string">'eggs'</span>&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G=type(<span class="string">'GoodFood'</span>,(F,E),&#123;&#125;) <span class="comment"># under Python 2.3 this is an error!</span></div></pre></td></tr></table></figure></p>
<p>创建了F、E、G三个类，其中类E可表示为<code>class E(F)</code>，类G可表示为<code>class G(F, E)</code>，我们期望类G的<code>remember2buy</code>属性是继承自F而不是E的，然而在Python 2.2中我们会得到<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.remember2buy</div><div class="line"><span class="string">'eggs'</span></div></pre></td></tr></table></figure></p>
<p>这破坏了局部优先顺序,因为对于类G的继承顺序<code>(F, E)</code>,其局部优先顺序并没有在Python 2.2线性化结果中得到保留:</p>
<blockquote>
<p>$$L[G, P22] = G\;E\;F\;object$$</p>
</blockquote>
<p>有人可能会争辩说Python 2.2线性化结果中类F在类E之后的原因是因为类F没有类E更具体，因为类F是类E的父类；尽管如此打破了局部优先顺序会使得代码不直观且容易出错，一个有力的佐证就是其与经典类的不同:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">F</span>:</span> remember2buy=<span class="string">'spam'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(F)</span>:</span> remember2buy=<span class="string">'eggs'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">G</span><span class="params">(F,E)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.remember2buy</div><div class="line"><span class="string">'spam'</span></div></pre></td></tr></table></figure></p>
<p>回想之前谈到的，经典类的继承顺序为<code>深度优先，从左至右</code>，因此类G的MRO为GFEF，在这种情况下局部优先顺序得到了保留。<br>简而言之，像之前那种继承方式应该避免，Python 2.3开始通过抛出异常来避免了这种歧义，有力地阻止了程序员来创建有歧义的类继承(通过C3算法失败来完成)。</p>
<p>还有一点相关的，Python 2.3的算法足够智能来发现一些显而易见的错误，比如重复继承同一个父类:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class A(object): pass</div><div class="line">&gt;&gt;&gt; class C(A,A): pass # error</div><div class="line">Traceback (most recent call last):</div><div class="line">  File "&lt;stdin&gt;", line 1, in ?</div><div class="line">TypeError: duplicate base class A</div></pre></td></tr></table></figure></p>
<p>而这种情况在Python 2.2中(无论是经典类还是新式类)，都不会抛出异常。</p>
<p>最后，有一点十分重要的需要记住:</p>
<ul>
<li>MRO在决定方法解析顺序同时也决定了属性的解析顺序</li>
</ul>
<p>讨论完了局部优先顺序，下面再来看单调性问题。要证明经典类的MRO是非单调的很容易:<br><img src="/2017/01/22/Method Resolution Order/python_inheritance3.png" alt="Inheritance3"></p>
<blockquote>
<p>$$\begin{align}&amp;L[B, P22] = B\;C\quad\#\;B在C之前：类B的方法优先\\&amp;L[D, P22] = D\;A\;C\;B\;C\quad\#\;B在C之后：类C的方法优先\end{align}$$</p>
</blockquote>
<p>另一方面，Python 2.2和Python 2.3的MRO中都不存在问题，都给出了:</p>
<blockquote>
<p>$$L[D] = D\;A\;B\;C$$</p>
</blockquote>
<p>Guido在他的<a href="https://www.python.org/download/releases/2.2.3/descrintro/#mro" target="_blank" rel="external">一篇文章</a>指出了经典类的MRO在实际使用中其实并不差，因为它可以使经典类避免钻石型结构。但由于所有新式类都继承自<code>object</code>，因此钻石型结果无法避免而且在所有的多继承图中前后矛盾都会出现。<br>Python 2.2的MRO使得破坏单调性十分困难，但并非不可能。接下来这个由<em>Samuele Pedroni</em>提供的例子，表明了Python 2.2新式类的MRO是非单调的:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">K1</span><span class="params">(A,B,C)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">K2</span><span class="params">(D,B,E)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">K3</span><span class="params">(D,A)</span>:</span>   <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Z</span><span class="params">(K1,K2,K3)</span>:</span> <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<p><img src="/2017/01/22/Method Resolution Order/python_inheritance4.png" alt="Inheritance4"></p>
<p>使用C3算法的线性化结果如下:</p>
<blockquote>
<p>$$\begin{align}&amp;L[A] = A\;O\\&amp;L[B] = B\;O\\&amp;L[C] = C\;O\\&amp;L[D] = D\;O\\&amp;L[E] = E\;O\\&amp;L[K1] = K1\;A\;B\;C\;O\\&amp;L[K2] = K2\;D\;B\;E\;O\\&amp;L[K3] = K3\;D\;A\;O\\&amp;L[Z] = Z\;K1\;K2\;K3\;D\;A\;B\;C\;E\;O\end{align}$$</p>
</blockquote>
<p>Python 2.2对于A、B、C、D、E、K1、K2、K3的线性化给出了相同结果，但是对于Z则不同:</p>
<blockquote>
<p>$$L[Z, P22] = Z\;K1\;K3\;A\;K2\;D\;B\;C\;E\;O$$ </p>
</blockquote>
<p>显然这个线性化结果是错的，因为类先于D出现了，而K3的线性化结果中D先于A出现。换句话说，在K3中，从类A继承的方法被从类D继承的方法覆盖了，但是在Z中，作为一个K3的子类，却使用了从类A继承的方法去覆盖从类D继承的方法！这违反了单调性。此外，Python 2.2中类Z的线性化结果与局部优先顺序也不一致，类Z的局部优先列表为<code>[K1, K2, K3]</code>(K2在K3之前)，而在线性化结果中K3在K2之前，这些问题解释了为什么2.2中的规则被弃用转投C3规则。</p>
<p><strong>super</strong><br>最后再来看Python 2.2引入的<code>super</code>函数，它主要用于初始化父类，避免了直接调用父类的<code>__init__</code>函数，减少耦合性，来看以下代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        self.value = value</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimesFive</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super(TimesFive, self).__init__(value)</div><div class="line">        self.value *= <span class="number">5</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlusTwo</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super(PlusTwo, self).__init__(value)</div><div class="line">        self.value += <span class="number">2</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodWay</span><span class="params">(TimesFive, PlusTwo)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super(GoodWay, self).__init__(value)</div><div class="line"></div><div class="line">foo = GoodWay(<span class="number">5</span>)</div></pre></td></tr></table></figure></p>
<p>它的计算顺序为<code>5 * (5 + 2)</code>而不是<code>(5 * 5) + 2</code>，原因在于程序的运行顺序与类GoodWay的MRO保持了一致，通过查看<code>GoodWay.mro()</code>可以得到:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; GoodWay.mro()</div><div class="line">[&lt;class '__main__.GoodWay'&gt;, &lt;class '__main__.TimesFive'&gt;, &lt;class '__main__.PlusTwo'&gt;, &lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;]</div></pre></td></tr></table></figure></p>
<p>调用<code>GoodWay(5)</code>的时候，它会调用<code>TimesFive.__init__</code>，而<code>TimesFive.__init__</code>又会调用<code>PlusTwo.__init__</code>，而<code>PlusTwo.__init__</code>会调用<code>Base.__init__</code>，当到达了钻石体系的顶部之后，所有的初始化方法会按照与刚才那些<code>__init__</code>相反的顺序执行，因此<code>Base.__init__</code>将value设为5，<code>PlusTwo.__init__</code>在此基础上加2，value变为7，最后<code>TimesFive.__init__</code>将value乘以5，得到35。</p>
<p><strong><em>特别注意</em></strong><br>一看到<code>super</code>这个函数很多人第一想法就是父类，但其实<code>super</code>工作原理是这样的:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">super</span><span class="params">(cls, inst)</span>:</span></div><div class="line">    mro = inst.__class__.mro()</div><div class="line">    <span class="keyword">return</span> mro[mro.index(cls) + <span class="number">1</span>]</div></pre></td></tr></table></figure></p>
<p>根据实例inst获得其类的MRO列表，返回cls所在位置的下一个位置的类，其中<code>inst</code>永远是最开始那个实例。</p>
<p>Python 3提供了一种不带参数的<code>super</code>调用方式，例如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Explicit</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super().__init__(value)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implicit</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super(__class__, self).__init__(value)</div><div class="line"></div><div class="line"><span class="keyword">assert</span> Explicit(<span class="number">10</span>).value == Implicit(<span class="number">10</span>).value</div></pre></td></tr></table></figure></p>
<p>由于Python 3程序可以在方法中通过<strong>class</strong>变量准确地引用当前类，所以上面的这种写法能够正常运作，而Python 2中则没有定义<strong>class</strong>，故而不能采用这种写法。可能有人试着用self.<strong>class</strong>做参数来调用<code>super</code>,但实际上这么做不行，因为Python 2是用<a href="http://stackoverflow.com/questions/18208683/when-calling-super-in-a-derived-class-can-i-pass-in-self-class" target="_blank" rel="external">特殊方式实现super</a>的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我想对Python中的方法解析顺序使用的C3算法进行一个梳理，文章内容主要基于对&lt;a href=&quot;https://www.python.org/download/releases/2.3/mro/&quot;&gt;The Python 2.3 Method Resolution Order&lt;/a&gt;一文的节选翻译。&lt;/p&gt;
&lt;p&gt;首先，需要明白的是C3算法工作于Python 2.2引入的新式类(&lt;em&gt;new style classes&lt;/em&gt;)，经典类(&lt;em&gt;classic classes&lt;/em&gt;)中方法的解析仍然保持他们原有的顺序，即&lt;code&gt;深度优先，从左至右&lt;/code&gt;，在此不进行深一步的讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="MRO" scheme="http://youchen.me/tags/MRO/"/>
    
      <category term="C3" scheme="http://youchen.me/tags/C3/"/>
    
  </entry>
  
  <entry>
    <title>multiprocessing中pool实现</title>
    <link href="http://youchen.me/2017/01/17/multiprocessing-pool/"/>
    <id>http://youchen.me/2017/01/17/multiprocessing-pool/</id>
    <published>2017-01-17T00:52:00.000Z</published>
    <updated>2017-01-17T02:10:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>终于有时间来整理整理之前自己的一些心得，今天想分享的是之前梳理的<code>Python</code>中<code>multiprocessing</code>模块的线程池与进程池实现。</p>
<a id="more"></a>
<p>multiprocessing.pool类包含taskqueue、inqueue、outqueue三个队列，其中：</p>
<ul>
<li>taskqueue采用<code>Queue.Queue</code>实现，通过apply、apply_async、map、map_async等函数向pool类提交任务。</li>
<li>inqueue、outqueue采用<code>SimpleQueue</code>实现，本质上是带锁的pipe</li>
<li>inqueue负责存放待完成任务，outqueue负责存放已完成任务</li>
</ul>
<p>multiprocessing.pool类包含worker_handler、task_handler、result_handler三个handler，均在threading.Thread上工作，均为<code>Daemon Thread</code>，其中：</p>
<ul>
<li><p>worker_handler负责回收已经完成任务的worker，同时根据回收数量使用process函数重新生成足够的worker，在生命周期中维护整个pool中worker的数量:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_maintain_pool</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""Clean up any exited workers and start replacements for them.</span></div><div class="line">    """</div><div class="line">    <span class="keyword">if</span> self._join_exited_workers():</div><div class="line">        self._repopulate_pool()</div><div class="line"></div><div class="line"><span class="meta">@staticmethod</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_handle_workers</span><span class="params">(pool)</span>:</span></div><div class="line">    thread = threading.current_thread()</div><div class="line"></div><div class="line">    <span class="comment"># Keep maintaining workers until the cache gets drained, unless the pool</span></div><div class="line">    <span class="comment"># is terminated.</span></div><div class="line">    <span class="keyword">while</span> thread._state == RUN <span class="keyword">or</span> (pool._cache <span class="keyword">and</span> thread._state != TERMINATE):</div><div class="line">        pool._maintain_pool()</div><div class="line">        time.sleep(<span class="number">0.1</span>)</div><div class="line">    <span class="comment"># send sentinel to stop workers</span></div><div class="line">    pool._taskqueue.put(<span class="keyword">None</span>)</div><div class="line">    util.debug(<span class="string">'worker handler exiting'</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>task_handler负责从taskqueue中按先后顺序阻塞获取待完成任务，更新pool的任务cache，并提交至inqueue中等待worker处理</p>
</li>
<li>result_handler负责从outqueue中按先后顺序阻塞获取已完成任务，更新pool的任务cache，如果存在回调函数则进行回调操作</li>
</ul>
<p>multiprocessing.pool类包含1个(未实现情况下)或多个(未提供数量，cpu_count()个)或指定数量的worker，其中：</p>
<ul>
<li>worker的维护由worker_handerler负责，在一个worker任务完成后由worker_handler负责回收并重新生成新的worker</li>
<li>worker包含对inqueue.get和outqueue.put的引用</li>
<li>worker从inqueue从获取待完成任务，并负责执行该任务，并将执行结果提交至outqueue中等待处理:<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(inqueue, outqueue, initializer=None, initargs=<span class="params">()</span>, maxtasks=None,</span></span></div><div class="line">           wrap_exception=False):</div><div class="line">    <span class="keyword">assert</span> maxtasks <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> (type(maxtasks) == int <span class="keyword">and</span> maxtasks &gt; <span class="number">0</span>)</div><div class="line">    put = outqueue.put</div><div class="line">    get = inqueue.get</div><div class="line">    <span class="keyword">if</span> hasattr(inqueue, <span class="string">'_writer'</span>):</div><div class="line">        inqueue._writer.close()</div><div class="line">        outqueue._reader.close()</div><div class="line"></div><div class="line">    <span class="keyword">if</span> initializer <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        initializer(*initargs)</div><div class="line"></div><div class="line">    completed = <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> maxtasks <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> (maxtasks <span class="keyword">and</span> completed &lt; maxtasks):</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            task = get()</div><div class="line">        <span class="keyword">except</span> (EOFError, OSError):</div><div class="line">            util.debug(<span class="string">'worker got EOFError or OSError -- exiting'</span>)</div><div class="line">            <span class="keyword">break</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> task <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            util.debug(<span class="string">'worker got sentinel -- exiting'</span>)</div><div class="line">            <span class="keyword">break</span></div><div class="line"></div><div class="line">        job, i, func, args, kwds = task</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            result = (<span class="keyword">True</span>, func(*args, **kwds))</div><div class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">            <span class="keyword">if</span> wrap_exception:</div><div class="line">                e = ExceptionWithTraceback(e, e.__traceback__)</div><div class="line">            result = (<span class="keyword">False</span>, e)</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            put((job, i, result))</div><div class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">            wrapped = MaybeEncodingError(e, result[<span class="number">1</span>])</div><div class="line">            util.debug(<span class="string">"Possible encoding error while sending result: %s"</span> % (</div><div class="line">                wrapped))</div><div class="line">            put((job, i, (<span class="keyword">False</span>, wrapped)))</div><div class="line">        completed += <span class="number">1</span></div><div class="line">    util.debug(<span class="string">'worker exiting after %d tasks'</span> % completed)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>PS：</p>
<blockquote>
<p>multiprocessing.ThreadPool是pool的thread-level级实现，以multiprocessing.dummy中的DummyProcess替换了pool的默认process，DummyProcess继承至threading.Thread，因此ThreadPool的实现是thread-level级的。</p>
</blockquote>
<p>实现用图来表示如下:</p>
<p><img src="/2017/01/17/multiprocessing-pool/python_multiprocessing_pool.png" alt="multiprocessing_pool"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于有时间来整理整理之前自己的一些心得，今天想分享的是之前梳理的&lt;code&gt;Python&lt;/code&gt;中&lt;code&gt;multiprocessing&lt;/code&gt;模块的线程池与进程池实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="多进程" scheme="http://youchen.me/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="进程池" scheme="http://youchen.me/tags/%E8%BF%9B%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>欢迎</title>
    <link href="http://youchen.me/2017/01/05/welcome/"/>
    <id>http://youchen.me/2017/01/05/welcome/</id>
    <published>2017-01-05T03:58:00.000Z</published>
    <updated>2017-02-04T08:31:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到我的博客，这个博客使用了<a href="https://hexo.io" target="_blank" rel="external">Hexo</a>构建，托管在<a href="https://pages.github.com" target="_blank" rel="external">Github Pages</a>,主题使用了<a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank" rel="external">Apollo</a>。</p>
<p>因为整个博客是托管在Github上的静态页面，没有数据库的支持，因此使用了<a href="http://duoshuo.com" target="_blank" rel="external">多说</a>来为整个博客提供评论功能，同时我也通过JS给博客增加了搜索功能，通过点击右下角的搜索图标或者双击<code>Ctrl</code>键可以启动搜索，这样可以方便快速查找相关内容。</p>
<a id="more"></a>
<p>现在博客的功能还有限，在以后我会慢慢增加新的功能，同时也会不定期更新一些我学习过程中的心得，欢迎大家阅读！</p>
<p>谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎来到我的博客，这个博客使用了&lt;a href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;构建，托管在&lt;a href=&quot;https://pages.github.com&quot;&gt;Github Pages&lt;/a&gt;,主题使用了&lt;a href=&quot;https://github.com/pinggod/hexo-theme-apollo&quot;&gt;Apollo&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;因为整个博客是托管在Github上的静态页面，没有数据库的支持，因此使用了&lt;a href=&quot;http://duoshuo.com&quot;&gt;多说&lt;/a&gt;来为整个博客提供评论功能，同时我也通过JS给博客增加了搜索功能，通过点击右下角的搜索图标或者双击&lt;code&gt;Ctrl&lt;/code&gt;键可以启动搜索，这样可以方便快速查找相关内容。&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="http://youchen.me/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="欢迎" scheme="http://youchen.me/tags/%E6%AC%A2%E8%BF%8E/"/>
    
      <category term="第一篇" scheme="http://youchen.me/tags/%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    
      <category term="博客" scheme="http://youchen.me/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="新功能" scheme="http://youchen.me/tags/%E6%96%B0%E5%8A%9F%E8%83%BD/"/>
    
  </entry>
  
</feed>
