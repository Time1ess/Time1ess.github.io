<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>David&#39;s Blog</title>
  
  <subtitle>A graduate student in Computer Science</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://youchen.me/"/>
  <updated>2018-01-15T08:35:15.681Z</updated>
  <id>http://youchen.me/</id>
  
  <author>
    <name>David</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在Python中使用mock进行单元测试</title>
    <link href="http://youchen.me/2018/01/15/Python-unit-testing-with-Mock/"/>
    <id>http://youchen.me/2018/01/15/Python-unit-testing-with-Mock/</id>
    <published>2018-01-15T01:07:28.000Z</published>
    <updated>2018-01-15T08:35:15.681Z</updated>
    
    <content type="html"><![CDATA[<p>在最近开发的项目中进行了单元测试，在测试过程中使用到了<code>Python 3.3</code>中加入到标准库的<code>mock</code>库(<code>unittest.mock</code>)，因此将使用心得整理成一篇博文。</p><a id="more"></a><p><code>mock</code>是一个Python中帮助用来提高单元测试效率的工具，在<code>Python 3.3</code>之前需要自行安装，<code>Python 3.3</code>将<code>mock</code>引入了标准库。单元测试的基本思想是测试逻辑集中的一小段函数，但是在实际编程中，随着开发的进行，可能函数之间有相互调用，对当前函数的单元测试不应该受到被调用函数的影响，因此如何屏蔽掉调用函数的影响而单独测试当前函数是必要的，原因有很多:</p><ul><li>被调用函数的调用可能产生不必要的问题，如调用生产接口</li><li>被调用函数的调用过程可能是复杂的，普通的调用无法覆盖所有可能发生的结果</li><li>被调用函数的调用条件比较复杂，如需额外搭建服务器等</li></ul><p>以上种种，都会使得单元测试的开发效率降低，因此，<code>Python 3.3</code>引入了<code>mock</code>来简化这些问题。让我们首先来看一个小例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">retrieve_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> resp.content</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_and_parse_json</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        content = retrieve_url(url)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'[ERROR] '</span> + str(e)</span><br><span class="line">    data = json.loads(content)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">json_url = <span class="string">'http://www.foo.com/bar'</span>  <span class="comment"># Return json response</span></span><br><span class="line"></span><br><span class="line">data = download_and_parse_json(json_url)</span><br><span class="line">print(<span class="string">'Parsed:'</span>, data)</span><br></pre></td></tr></table></figure><p>这段代码中我们编写了两个函数，一个是用来请求url获取响应的函数<code>retrieve_url</code>，一个用来下载url内容并尝试解析为<code>json</code>格式函数<code>download_and_parse_json</code>，假设我们有一个链接<code>json_url</code>，该链接正常情况下应该返回一个包含<code>json</code>数据的响应，但是在各种环境因素的作用下(网络通信中断，服务器宕机，接口失效)，也可能出现访问失败的情况，因此我们的第二个函数加入了简单的异常处理，在正常情况下返回解析的<code>json</code>字典，异常情况下返回错误信息。</p><h1 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h1><p>如果我们想在开发过程中对该函数(<code>download_and_parse_json</code>)进行单元测试，由于<code>json_url</code>对应的接口可能存在前文所说的各种可能原因，因此我们想模拟该部分操作，返回一个<code>json</code>格式的字符串或者抛出一个异常，这时候<code>mock</code>模块就派上用场了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> unittest.mock <span class="keyword">import</span> patch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">retrieve_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> resp.content</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_and_parse_json</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        content = retrieve_url(url)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'[ERROR] '</span> + str(e)</span><br><span class="line">    data = json.loads(content)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">json_url = <span class="string">'http://www.foo.com/bar'</span>  <span class="comment"># Return json response</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> patch(<span class="string">'__main__.retrieve_url'</span>) <span class="keyword">as</span> mocked_retrieve:</span><br><span class="line">    mocked_retrieve.return_value = <span class="string">'&#123;"a":1,"b":[1,3,4]&#125;'</span></span><br><span class="line">    data = download_and_parse_json(json_url)</span><br><span class="line">    print(<span class="string">'Parsed:'</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> patch(<span class="string">'__main__.retrieve_url'</span>) <span class="keyword">as</span> mocked_retrieve:</span><br><span class="line">    mocked_retrieve.side_effect = requests.exceptions.ConnectionError(</span><br><span class="line">        <span class="string">'Connection Error'</span>)</span><br><span class="line">    data = download_and_parse_json(json_url)</span><br><span class="line">    print(<span class="string">'Parsed:'</span>, data)</span><br></pre></td></tr></table></figure><p>注意该段代码和前一段代码的区别，我们首先从<code>unittest.mock</code>导入了<code>patch</code>，<code>patch</code>可作为函数装饰器、类装饰器、上下文管理器使用，而此处我们使用了第三种形式——上下文管理器。<code>patch</code>函数至少接收一个参数，即需要模拟的对象的导入路径，如<code>package.module.ClassName</code>，此处我们使用了<code>__main__.retrieve_url</code>指示了顶层执行代码中的<code>retrieve_url</code>函数，当作为上下文管理器使用的时候，<code>patch</code>会返回一个<code>MagicMock</code>对象，<code>MagicMock</code>是<code>Mock</code>的子类(关于<code>Mock</code>在下一节会介绍)。</p><p>经过<code>patch</code>后，在上下文作用域里面，<code>retireve_url</code>就已经被替换了，因此我们接下来只需要模拟该函数在正常情况下以及非正常情况下的运行结果就行了。</p><ol><li>第一个<code>with</code>语句中，我们设置了<code>mocked_retrieve.return_value = &#39;{&quot;a&quot;:1,&quot;b&quot;:[1,3,4]}&#39;</code>，即当该mock对象被调用的时候(执行<code>content = retrieve_url(url)</code>的时候)将返回我们设置的属性<code>return_value</code>的值，此处即一个<code>json</code>字符串。</li><li>第二个<code>with</code>语句中，我们设置了<code>mocked_retrieve.side_effect = requests.exceptions.ConnectionError(&#39;Connection Error&#39;)</code>，在<code>mock</code>被调用的时候将抛出<code>ConnectionError</code>以测试异常捕获相关代码，与<code>return_value</code>只能设置成一个值不同，<code>side_effect</code>支持赋值一个函数、一个迭代器或者一个异常(类或对象)。<ul><li>函数: 函数将接收与被mock对象相同的参数(如果函数返回<code>mock.DEFAULT</code>对象或者不设置函数，<code>mock</code>对象将会返回<code>return_value</code>)</li><li>迭代器: 在每次<code>mock</code>被调用的时候，将依次逐个返回迭代器中的值</li><li>异常: 调用<code>mock</code>的时候将抛出指定异常</li></ul></li></ol><div class="tip"><br>当<code>patch</code>作为函数装饰器使用的时候，被创建的<code>MagicMock</code>对象将会作为额外参数传给被装饰函数。(关键字参数new没有被指定的情况下)<br></div><h1 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h1><p>前文已经提到了<code>Mock</code>与<code>MagicMock</code>，那么它们到底有什么作用呢？</p><p>简单来说，<code>Mock</code>是一类特殊的对象，当访问该类对象上任意不存在的属性的时候，该属性将被自动创建，且该属性也是<code>Mock</code>对象，来看一个小例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> unittest.mock <span class="keyword">import</span> Mock</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = Mock()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.foo</span><br><span class="line">&lt;Mock name=<span class="string">'mock.foo'</span> id=<span class="string">'4404473248'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.bar.return_value = <span class="string">'hello mock'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(m.bar())</span><br><span class="line"><span class="string">'hello mock'</span></span><br></pre></td></tr></table></figure><p><code>m</code>是一个<code>Mock</code>对象，当访问<code>m</code>的<code>foo</code>属性时，一个新的<code>Mock</code>对象被创建了，我们可以使用链式调用来给<code>Mock</code>对象添加任意属性，以及设置调用返回值。</p><p>官方文档中给出的<code>Mock</code>的创建参数如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class unittest.mock.Mock(spec=None, side_effect=None, return_value=DEFAULT, wraps=None, name=None, spec_set=None, unsafe=False, **kwargs)</span><br></pre></td></tr></table></figure><p>在实际使用中，目前就使用到了前三者<code>spec</code>、<code>side_effect</code>、<code>return_value</code>，后两者在前文已经介绍到了，这里简单介绍下<code>spec</code>参数，该参数用来限制可以被<code>Mock</code>的属性的范围，<code>spec</code>可以是多个字符串的列表或者一个已存在的对象(类或实例)，当访问<code>spec</code>参数指定属性以外属性的时候将抛出<code>AttributeError</code>。</p><p><code>MagicMock</code>是<code>Mock</code>的子类，因此其拥有所有父类的表现，除此之外，使用该子类允许我们很方便的对<code>magic methods</code>进行设置，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> unittest.mock <span class="keyword">import</span> MagicMock</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = MagicMock()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.__str__.return_value = <span class="string">'hello mock'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(m)</span><br><span class="line">hello mock</span><br></pre></td></tr></table></figure><h2 id="方法与属性"><a href="#方法与属性" class="headerlink" title="方法与属性"></a>方法与属性</h2><p><code>Mock</code>对象实现了很多有用的方法以及属性方便开发者在进行单元测试时使用。</p><ul><li><p><code>assert_called</code>: 用来检验<code>Mock</code>对象至少有一次被调用</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mock = Mock()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mock.method()</span><br><span class="line">&lt;Mock name=<span class="string">'mock.method()'</span> id=<span class="string">'...'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mock.method.assert_called()</span><br></pre></td></tr></table></figure></li><li><p><code>assert_called_once</code>: 用来检验<code>Mock</code>对象恰好有一次被调用</p></li><li><p><code>call_count</code>: 用来表示<code>Mock</code>被调用次数</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mock = Mock(return_value=<span class="keyword">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mock.call_count</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mock()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mock()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mock.call_count</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>…</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在最近开发的项目中进行了单元测试，在测试过程中使用到了&lt;code&gt;Python 3.3&lt;/code&gt;中加入到标准库的&lt;code&gt;mock&lt;/code&gt;库(&lt;code&gt;unittest.mock&lt;/code&gt;)，因此将使用心得整理成一篇博文。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="单元测试" scheme="http://youchen.me/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
      <category term="mock" scheme="http://youchen.me/tags/mock/"/>
    
  </entry>
  
  <entry>
    <title>Django中的select_related与prefetch_related</title>
    <link href="http://youchen.me/2018/01/12/Django%E4%B8%AD%E7%9A%84select-related%E4%B8%8Eprefetch-related/"/>
    <id>http://youchen.me/2018/01/12/Django中的select-related与prefetch-related/</id>
    <published>2018-01-12T09:11:00.000Z</published>
    <updated>2018-01-13T01:56:07.312Z</updated>
    
    <content type="html"><![CDATA[<p>Django是一个基于Python的网站开发框架，一个很重要的特点就是Battery Included，简单来说就是包含了常规开发中所需要的一切东西，包括但不限于完整的ORM模型、中间件、会话处理、模板语言、路由映射、管理员站点等，大大提高了开发者的开发体验，今天要谈的东西便是属于Django ORM这块中查询集优化的内容。</p><a id="more"></a><p>在很早之前(1.4)就已经接触到了Django，也使用Django开发了一些项目练手，但是直到最近的一个项目才让我对Django的认识有了进一步的提高。这个问题来源于默认情况下ORM查询集的效率比较低，特别对于外键关系较多较深的模型，使用默认的查询将会导致难以忍受低效率，要谈到优化首先得从Django ORM的查询集工作方式说起。</p><h1 id="Queryset惰性求值"><a href="#Queryset惰性求值" class="headerlink" title="Queryset惰性求值"></a>Queryset惰性求值</h1><h2 id="Queryset是惰性的"><a href="#Queryset是惰性的" class="headerlink" title="Queryset是惰性的"></a>Queryset是惰性的</h2><p>在Django中，所有的Queryset都是惰性的，意思是当创建一个查询集的时候，并没有跟数据库发生任何交互。因此我们可以对查询集进行级联的filter等操作，只有在访问Queryset的内容的时候，Django才会真正进行数据库的访问，如以下例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = Entry.objects.filter(headline__startswith=<span class="string">"What"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = q.filter(pub_date__lte=datetime.date.today())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = q.exclude(body_text__icontains=<span class="string">"food"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(q)</span><br></pre></td></tr></table></figure><p>表面上来看该段代码进行了3次查询集操作，第一次获取所有以字段<code>headline</code>以<code>What</code>开头的Entry对象，第二次在前一次的基础上再次过滤，第三次在过滤。但实际上，Queryset的结果在真正使用之前都不会被获取，因此，只有到了最后一句<code>print(q)</code>的时候，Django才会真正的到数据库中获取相关数据，因此，整段代码其实只执行了一次数据库查询。</p><h2 id="外键关系仍然是惰性的"><a href="#外键关系仍然是惰性的" class="headerlink" title="外键关系仍然是惰性的"></a>外键关系仍然是惰性的</h2><p>在数据库中，外键(Foreignkey)这一字段是十分常见的，而在Django中也提供了对应的相关字段，如以下定义:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    foo = models.IntegerField()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    a = models.ForeignKey(A, on_delete=models.CASCADE, related_name=<span class="string">'bs'</span>)</span><br></pre></td></tr></table></figure><p>我们定义了一个带有一个<code>foo</code>字段的模型<code>A</code>，以及一个外键关联到<code>A</code>上的模型<code>B</code>，当我们获取一个<code>B</code>对象的时候，其<code>a</code>字段对应的模型<code>A</code>并没有被立刻获取，如以下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = B.objects.first()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(b.a)</span><br></pre></td></tr></table></figure><p>执行第一条语句获取到对象<code>b</code>的时候并没有把对应的a也获取到，因为实际上数据库<code>B</code>这个表中存储的<code>a</code>字段是<code>a_id</code>，即关联的对象的<code>id</code>，因此此处可以通过<code>b.a_id</code>获取到<code>id</code>而不真的获取<code>a</code>这个对象，这一方式也在Django的文档中提到，主要用于实际只需要<code>id</code>而不需要对象的情况。</p><blockquote><p>If you only need a foreign key value, use the foreign key value that is already on the object you’ve got, rather than getting the whole related object and taking its primary key.(译: 当你只需要一个外键值的时候，直接使用已经获得对象上的值，而不要去获取整个对象然后取它的主键值)</p></blockquote><p>这一方式也引入了今天的主题，假如我需要获取一个Queryset以及其对应的外键的对象，应该如何操作？</p><h1 id="访问外键对象"><a href="#访问外键对象" class="headerlink" title="访问外键对象"></a>访问外键对象</h1><h2 id="原始的访问方式"><a href="#原始的访问方式" class="headerlink" title="原始的访问方式"></a>原始的访问方式</h2><p>同样以上部分代码中定义的<code>A</code>与<code>B</code>为例，假设我们想打印所有<code>id</code>小于等于<code>k</code>的<code>B</code>对象的<code>A</code>对象的<code>foo</code>字段，最原始的写法是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>qs = B.objects.filter(id__lte=k)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> b <span class="keyword">in</span> qs:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    print(b.a.foo)</span><br></pre></td></tr></table></figure><p>这种写法符合逻辑，但是在性能上却是十分低下，原因在于，虽然我们使用<code>filter</code>获得了查询集<code>qs</code>，然后使用<code>for</code>遍历<code>qs</code>(求值)，只进行了一次数据库查询，但是在<code>for</code>循环体中<code>print(b.a.foo)</code>会再次触发查询，前面讲到了，Django的外键关系也是惰性的，因此获取<code>B</code>对象的时候并没有去获取相应的<code>A</code>对象，而是在真正使用的时候触发查询，也就是在打印<code>b.a.foo</code>的时候，这时候会触发一次数据库查询去查找<code>b</code>对应的<code>a</code>，而<code>for</code>在查询集<code>qs</code>上一共循环了<code>k</code>次，因此一共导致了<code>k+1</code>次数据库查询。</p><p>为了直观的演示这一过程，我们以<code>k=5</code>为例，并使用<a href="https://github.com/jazzband/django-debug-toolbar" target="_blank" rel="noopener">django-debug-toolbar</a>工具监视数据库查询。结果如下:</p><p><img src="/2018/01/12/Django中的select-related与prefetch-related/filter_id_lte_5.png" alt=""></p><p>可以看到，第三行SQL语句查询了所有<code>id &lt;= 5</code>的<code>B</code>对象，然后每次进行<code>print</code>的时候，都会触发一次SQL查询获得<code>a</code>的信息，因此共执行了<code>6</code>次查询。</p><h2 id="select-related-数据库上的join"><a href="#select-related-数据库上的join" class="headerlink" title="select_related - 数据库上的join"></a>select_related - 数据库上的join</h2><p>Django考虑到了这种低效的查询方式，因此在设计ORM的时候设计了提升性能的方式。<code>select_related</code>就是其中之一。</p><p><code>select_related</code>将会根据外键关系，在执行查询语句的时候一次性获得相关对象的信息，这种操作带来的结果是更加复杂的查询语句和避免对于即将使用的外键对象的额外数据库查询。Django的<a href="https://docs.djangoproject.com/en/2.0/ref/models/querysets/#django.db.models.query.QuerySet.select_related" target="_blank" rel="noopener">文档</a>详细的描述了相关内容，在此只进行简要介绍。标准的查询代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行数据库查询获取b</span></span><br><span class="line">b = B.objects.get(id=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次执行数据库查询获取关联的对象a</span></span><br><span class="line">a = b.a</span><br></pre></td></tr></table></figure><p><img src="/2018/01/12/Django中的select-related与prefetch-related/get_without_select_related.png" alt=""></p><p>换用<code>select_related</code>之后，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行数据库查询获取b</span></span><br><span class="line">b = B.objects.select_related(<span class="string">'a'</span>).get(id=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不再执行数据库查询，因为前一次操作中已经获取了a的相关信息</span></span><br><span class="line">a = b.a</span><br></pre></td></tr></table></figure><p><img src="/2018/01/12/Django中的select-related与prefetch-related/get_with_select_related.png" alt=""></p><p>我们可以看到，<code>select_related</code>实际上是在数据库层面进行了一次<code>inner join</code>操作，因此一次性获取了所有需要的信息。</p><p>需要注意的是，我们可以使用任意外键关系(ForeignKeyField)或一对一关系(OneToOneField)作为参数传给<code>select_related</code>，同时也可以使用反向的一对一关系，此时应使用<code>related_name</code>作为参数。某些情况下，你可能想获取所有的相关对象，或者你并不知道关联关系，此时可以使用不加参数的<code>.select_related()</code>，该方式下将会根据关联关系(级联的)获取所有关联的对象, 即假设有外键关系为<code>A&lt;-B&lt;-C</code>，使用<code>C.objects.select_related()</code>将同时获取相关<code>A</code>和<code>B</code>的信息。</p><div class="tip"><br>该方式在<strong>大多数情况下不推荐使用</strong><br></div><h2 id="prefetch-related-Python上的join"><a href="#prefetch-related-Python上的join" class="headerlink" title="prefetch_related - Python上的join"></a>prefetch_related - Python上的join</h2><p>与<code>select_related</code>类似，<code>prefetch_related</code>也可以大幅提高查询效率，但是<code>prefetch_related</code>的方式跟<code>select_related</code>大不一样。</p><p><code>select_reateld</code>是通过创建一条包含SQL join操作的<code>SELECT</code>语句来一次性获得所有相关对象的信息。因此，<code>select_related</code>需要从<strong>同一个</strong>数据库中获得相关对象。但是，为了避免由于join操作带来的较大的查询集结果，<code>select_related</code>被限制在了<strong>单值</strong>关系——外键关系或一对一关系。</p><p>另一方面，<code>prefetch_related</code>为每一个关系使用了单独的查询，并在Python层面进行’join’操作，因此该操作允许多对多关系以及反向关系，而这是<code>select_related</code>无法做到的。我们这次使用<code>prefetch_related</code>执行查询，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行数据库查询获取b</span></span><br><span class="line">b = B.objects.prefetch_related(<span class="string">'a'</span>).get(id=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不再执行数据库查询，因为前一次操作中已经获取了a的相关信息</span></span><br><span class="line">a = b.a</span><br></pre></td></tr></table></figure><p><img src="/2018/01/12/Django中的select-related与prefetch-related/get_with_prefetch_related.png" alt=""></p><p>可以看到，Django首先进行了<code>id=5</code>的第一次查询获取对象<code>b</code>，然后根据外键关系进行了第二次查询获取<code>b.a</code>。为了增强理解，我们引入第三个模型<code>C</code>，这次我们从<code>A</code>模型上查询<code>id__lte=5</code>的<code>A</code>对象及其相关对象，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    b = models.ForeignKey(B, on_delete=models.CASCADE, related_name=<span class="string">'cs'</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">qs = A.objects.prefetch_related(<span class="string">'bs'</span>, <span class="string">'bs__cs'</span>).filter(id__lte=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><img src="/2018/01/12/Django中的select-related与prefetch-related/filter_id_lte_5_with_prefetch_related.png" alt=""></p><p>Django首先查询了<code>id</code>小于等于5的所有<code>A</code>对象，然后根据反向关联关系，查询所有外键到这些<code>A</code>对象的<code>B</code>对象，然后查询所有外键到这些<code>B</code>对象的<code>C</code>对象。</p><p>篇幅关系，对于<code>prefetch_related</code>的介绍就到这里，下面对三种查询方式(原始，<code>select_related</code>，<code>prefetch_related</code>)的性能进行一些简单的实验。</p><h1 id="select-related与prefetch-related性能对比"><a href="#select-related与prefetch-related性能对比" class="headerlink" title="select_related与prefetch_related性能对比"></a>select_related与prefetch_related性能对比</h1><p>为了比较两种优化方式相比于标准查询带来的性能提升，我分别定义了两组模型并编写代码进行了相关实验，模型简要说明如下:</p><h3 id="第一组"><a href="#第一组" class="headerlink" title="第一组:"></a>第一组:</h3><table><thead><tr><th style="text-align:center">模型</th><th style="text-align:center">字段说明</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">ForeignKey(A), 4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">ForeignKey(B), 4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">ForeignKey(C), 4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField</td></tr><tr><td style="text-align:center">E</td><td style="text-align:center">ForeignKey(D), 4 x IntegerField, 4 x FloatField, 4 x DateTimeField, 4 x UUIDField, 4 x CharField</td></tr></tbody></table><h3 id="第二组"><a href="#第二组" class="headerlink" title="第二组:"></a>第二组:</h3><table><thead><tr><th style="text-align:center">模型</th><th style="text-align:center">字段说明x</th></tr></thead><tbody><tr><td style="text-align:center">A1</td><td style="text-align:center">1 x IntegerField, 1 x FloatField, 1 x DateTimeField</td></tr><tr><td style="text-align:center">B1</td><td style="text-align:center">ForeignKey(A1), 1 x IntegerField, 1 x FloatField, 1 x DateTimeField</td></tr><tr><td style="text-align:center">C1</td><td style="text-align:center">ForeignKey(B1), 1 x IntegerField, 1 x FloatField, 1 x DateTimeField</td></tr><tr><td style="text-align:center">D1</td><td style="text-align:center">ForeignKey(C1), 1 x IntegerField, 1 x FloatField, 1 x DateTimeField</td></tr><tr><td style="text-align:center">E1</td><td style="text-align:center">ForeignKey(D1), 1 x IntegerField, 1 x FloatField, 1 x DateTimeField</td></tr></tbody></table><p>前一组每个模型拥有约21个字段，后一组每个模型拥有约4个字段，CharField设置了max_length=100，DateTimeField设置了auto_now_add=True，UUIDField设置了default=uuid4, editable=False，所有的查询都是以E(E1)为出发点。</p><h2 id="复杂模型上的表现"><a href="#复杂模型上的表现" class="headerlink" title="复杂模型上的表现"></a>复杂模型上的表现</h2><p>首先来看第一组的实验结果, 首先我们来比较随着获取对象数量的提高，查询时间的变化:</p><p><img src="/2018/01/12/Django中的select-related与prefetch-related/complex_raw_sel_pre_tot.png" alt=""></p><p>可以看出，三者耗时随获取对象数量的争夺呈现近乎线性的关系，符合直观预期，同时，没有经过优化的标准查询相比于经过优化的查询，斜率明显高很多，标准查询更易受查询集大小变化的影响，因此在查询集较大时进行优化是必不可少的，且根据前文所述，我们可以很容易的计算执行的SQL语句数量，标准查询: <code>1 + 5 * N</code>条，<code>select_related</code>: <code>1</code>条，<code>prefetch_related</code>: <code>5</code>条。</p><blockquote><p>注: 横坐标的对象指的是一共获取的对象数量，因为<code>A&lt;-B&lt;-C&lt;-D&lt;-E</code>，查询每一个<code>E</code>对象，都会获得5个对象，因此横坐标的100000代表一共查询了20000个E对象。</p></blockquote><p>再来看每个对象的平均查询时间:</p><p><img src="/2018/01/12/Django中的select-related与prefetch-related/complex_raw_sel_pre_avg.png" alt=""></p><p>可以看出，每个对象的查询时间在实验条件下并没有随着查询集的大小发生太大的变化，且单个对象的查询效率优化后有至少7倍以上的提高。</p><p>为了详细对比<code>select_related</code>与<code>prefetch_related</code>，我们剔除标准查询后再进行比较:</p><p><img src="/2018/01/12/Django中的select-related与prefetch-related/complex_sel_pre_tot.png" alt=""><br><img src="/2018/01/12/Django中的select-related与prefetch-related/complex_sel_pre_avg.png" alt=""></p><p>可以看出，在总时间上，查询对象数量小于大约135000的时候二者的查询效率区别并不大，<code>select_related</code>略优于<code>prefetch_related</code>，但是超过了这一界限之后，二者的差距明显拉开，这可以理解为当查询集增大时SQL的<code>join</code>操作的开销大于多次<code>SELECT</code>的开销，从平均查询时间的图中也可以得出结论，由于查询集大小的增加，<code>prefetch_related</code>中多条<code>SELECT</code>语句的开销被均摊，因此导致单个对象的查询效率提高(查询时间降低)，而<code>select_related</code>的<code>join</code>操作的开销并不随着数量增多被均摊。因此在查询集较大的时候使用<code>prefetch_related</code>性能上可能更好。 </p><h2 id="简单模型上的表现"><a href="#简单模型上的表现" class="headerlink" title="简单模型上的表现"></a>简单模型上的表现</h2><p>我们再来看第二组实验结果，查询时间随获取对象数量的提高的变化结果与前一组类似，优化后仍远好于优化前:</p><p><img src="/2018/01/12/Django中的select-related与prefetch-related/simple_raw_sel_pre_tot.png" alt=""><br><img src="/2018/01/12/Django中的select-related与prefetch-related/simple_raw_sel_pre_avg.png" alt=""></p><p>我认为区别较大的地方在<code>select_related</code>与<code>prefetch_related</code>的变化:</p><p><img src="/2018/01/12/Django中的select-related与prefetch-related/simple_sel_pre_tot.png" alt=""><br><img src="/2018/01/12/Django中的select-related与prefetch-related/simple_sel_pre_avg.png" alt=""></p><p>在有限的实验条件内，在模型字段并不复杂且数量并不多的情况下，<code>select_related</code>的效率均优于<code>prefetch_related</code>，具体表现为前者查询总时间上均少于后者，但是从第二幅图中，我们可以观测到<code>prefetch_related</code>的平均查询时间下降的趋势，由于时间关系我只再进行了一次<code>X=600000</code>的实验，并没有观测到超过<code>select_related</code>的情况。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在查询集中的对象字段较多较复杂，且查询集较大的时候，或需要使用反向外键关系或多对多关系作为参数优化查询的时候，应该选用<code>prefetch_related</code>，在查询集中对象字段简单的，查询集不大的时候，应选用<code>select_related</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文通过对Django的查询集的惰性求值相关内容的介绍，引入了使用<code>select_related</code>和<code>prefetch_related</code>优化查询集效率的介绍，最后通过两组实验比较了<code>select_related</code>和<code>prefetch_related</code>的性能并给出了选用建议。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://docs.djangoproject.com/en/2.0/topics/db/queries/#querysets-are-lazy" target="_blank" rel="noopener">https://docs.djangoproject.com/en/2.0/topics/db/queries/#querysets-are-lazy</a></li><li><a href="https://docs.djangoproject.com/en/2.0/ref/models/querysets/#select-related" target="_blank" rel="noopener">https://docs.djangoproject.com/en/2.0/ref/models/querysets/#select-related</a></li><li><a href="https://docs.djangoproject.com/en/2.0/ref/models/querysets/#prefetch-related" target="_blank" rel="noopener">https://docs.djangoproject.com/en/2.0/ref/models/querysets/#prefetch-related</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Django是一个基于Python的网站开发框架，一个很重要的特点就是Battery Included，简单来说就是包含了常规开发中所需要的一切东西，包括但不限于完整的ORM模型、中间件、会话处理、模板语言、路由映射、管理员站点等，大大提高了开发者的开发体验，今天要谈的东西便是属于Django ORM这块中查询集优化的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Django" scheme="http://youchen.me/categories/Django/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="Django" scheme="http://youchen.me/tags/Django/"/>
    
      <category term="数据库" scheme="http://youchen.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法之监督学习算法KNN(K近邻)</title>
    <link href="http://youchen.me/2017/10/22/kNN/"/>
    <id>http://youchen.me/2017/10/22/kNN/</id>
    <published>2017-10-22T14:07:40.000Z</published>
    <updated>2018-01-15T01:16:38.647Z</updated>
    
    <content type="html"><![CDATA[<p>今天在学院论坛里面写了关于KNN的一篇解释，顺手就转到自己博客了，毕竟这都又是3个月没更新了，感觉自己学了很多但是就是太懒，不想记下来，这个习惯还是得改改。</p><a id="more"></a><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>首先是原始代码，已经写好非核心代码，只需要补充<code>L1</code>、<code>L2</code>、<code>knn</code>三个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding: UTF-8</span></span><br><span class="line"><span class="comment"># Author: David</span></span><br><span class="line"><span class="comment"># Email: youchen.du@gmail.com</span></span><br><span class="line"><span class="comment"># Created: 2017-10-21 13:06</span></span><br><span class="line"><span class="comment"># Last modified: 2017-10-21 13:53</span></span><br><span class="line"><span class="comment"># Filename: knn.py</span></span><br><span class="line"><span class="comment"># Description:</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># ===============================================</span></span><br><span class="line"><span class="comment"># For reproducibility, DO NOT CHANGE THIS SECTION</span></span><br><span class="line">np.random.seed(<span class="number">1111</span>)</span><br><span class="line"></span><br><span class="line">M1 = <span class="number">500</span></span><br><span class="line">M2 = <span class="number">50</span></span><br><span class="line">N = <span class="number">1024</span></span><br><span class="line">S = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">train_x = S * np.random.randn(M1, N)</span><br><span class="line">train_y = np.random.randint(<span class="number">0</span>, <span class="number">10</span>, M1)</span><br><span class="line">test_x = S * np.random.randn(M2, N)</span><br><span class="line">target_l1_y = [</span><br><span class="line">    <span class="number">4</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>,</span><br><span class="line">    <span class="number">4</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">9</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">9</span>]</span><br><span class="line">target_l2_y = [</span><br><span class="line">    <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">9</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># ==============================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L1</span><span class="params">(x1, x2)</span>:</span></span><br><span class="line">    <span class="comment"># ===================</span></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Calculate the L1 distance between x1 and x2.</span></span><br><span class="line">    <span class="comment"># Your code goes here</span></span><br><span class="line">    <span class="comment"># L1 distance</span></span><br><span class="line">    <span class="comment"># ===================</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L2</span><span class="params">(x1, x2)</span>:</span></span><br><span class="line">    <span class="comment"># ===================</span></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Calculate the L2 distance between x1 and x2.</span></span><br><span class="line">    <span class="comment"># Your code goes here</span></span><br><span class="line">    <span class="comment"># L2 distance</span></span><br><span class="line">    <span class="comment"># ===================</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knn</span><span class="params">(train_x, train_y, test_x, sim_func=None, K=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> sim_func <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span></span><br><span class="line">    test_y = np.zeros(M2).astype(int)</span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="comment"># Instructions:</span></span><br><span class="line">    <span class="comment"># 1. For each sample(x1) in test_x</span></span><br><span class="line">    <span class="comment"># 2. Calculate similarity between each sample in train_x and x1</span></span><br><span class="line">    <span class="comment"># 3. Using the K nearest neighbors to vote for x1</span></span><br><span class="line">    <span class="comment"># 4. assign y1 to test_y[idx]</span></span><br><span class="line">    <span class="comment"># -----------</span></span><br><span class="line">    <span class="comment"># Please Note test_y is a numpy vector, For i-th example in test_x, you</span></span><br><span class="line">    <span class="comment"># can do like this:</span></span><br><span class="line">    <span class="comment"># test_y[i] = yi</span></span><br><span class="line">    <span class="comment"># ===================</span></span><br><span class="line">    <span class="comment"># Your code goes here</span></span><br><span class="line">    <span class="comment"># ===================</span></span><br><span class="line">    <span class="keyword">return</span> test_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accuracy</span><span class="params">(output, target)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.count_nonzero(np.equal(output, target)) / len(output)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">(func, target)</span>:</span></span><br><span class="line">    print(<span class="string">'Evaluating with your implementation of '</span></span><br><span class="line">          <span class="string">'&#123;&#125; distance'</span>.format(func.__name__))</span><br><span class="line">    test_y = knn(train_x, train_y, test_x, func)</span><br><span class="line">    acc = accuracy(test_y, target)</span><br><span class="line">    print(<span class="string">'Accuracy: &#123;:.2%&#125;'</span>.format(acc))</span><br><span class="line">    <span class="keyword">if</span> np.abs(acc - <span class="number">1</span>) &lt; <span class="number">1e-5</span>:</span><br><span class="line">        print(<span class="string">'Conguratulations, Your implementation is correct'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'There are some bugs in your implementation, Please check again'</span>)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    evaluate(L1, target_l1_y)</span><br><span class="line">    evaluate(L2, target_l2_y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>有几点需要注意(对首次接触Python的人):</p><ul><li>Python中以<code>#</code>开头的行都是注释，不对程序产生任何影响</li><li>与C不同，Python是一门解释型语言，所以大家如果执行一个<code>.py</code>文件，解释器会从上到下依次执行语句，如果<code>.py</code>文件中只包含了类似<code>def func(x)</code>的定义代码，那么执行该文件仅会定义这些函数然后退出，所以如果<code>.py</code>文件里面有需要执行的语句，比如使用<code>print</code>打印一些内容，则可以直接像这么写:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该段代码首先定义了一个`hello`函数，该函数接收一个参数`name`，</span></span><br><span class="line"><span class="comment"># 然后函数的作用是打印'hello, &lt;name&gt;'，最后执行`hello`函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>, name)</span><br><span class="line"></span><br><span class="line">hello(<span class="string">'david'</span>)</span><br></pre></td></tr></table></figure><ul><li>另外，直接执行一个<code>.py</code>文件时，被执行文件的<code>if __name__ == &#39;__main__&#39;:</code>判断将会为真，在该示例中即会调用<code>main</code>函数。</li></ul><p>以上是需要注意的几点，具体的Python的语法由于篇幅关系，不再赘述。</p><h2 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h2><p>KNN，即K近邻，是一个监督学习算法，算法本身并不复杂，其基本流程是:</p><ol><li>假设给定包含$ M $个样本的训练集$ X_{train} $，每个样本包含$ N $个特征，以及对应的类别标签$ Y_{train} $，则$ X_{train} $可以用一个$ M \times N $的二维矩阵表示, $ Y_{train} $可以用一个$ M \times 1 $的二维矩阵表示</li></ol><p>$$<br>X_{train} = \begin{bmatrix}<br>X_1^0 &amp; X_1^1 &amp;  … &amp;  X_1^n \\<br>X_2^0 &amp; X_2^1 &amp;  … &amp;  X_2^n \\<br>… &amp; … &amp; … &amp; … \\<br>X_M^0 &amp; X_M^1 &amp;  … &amp;  X_M^n \\<br>\end{bmatrix}<br>Y_{train} = \begin{bmatrix}<br>Y_0 \\ Y_1 \\ … \\ Y_M<br>\end{bmatrix}<br>$$</p><ol><li>对于一个需要计算的新样本$ X $，计算其类别：<ol><li>计算该样本$ X $与训练集$ X_{train} $中每个样本$ X_i $的距离$ D_i $(不同距离函数计算的距离不同，因此效果也会不同)</li><li>在所有距离中取距离最小的前$ K $个样本的类别标签，根据$ K $个标签中出现次数最多的标签来确定样本$ X $的标签</li></ol></li></ol><h2 id="距离函数"><a href="#距离函数" class="headerlink" title="距离函数"></a>距离函数</h2><p>首先我们需要定义一些距离函数来衡量两个样本特征之间的相似度，常用的有L1距离、L2距离等。</p><h3 id="L1-distance"><a href="#L1-distance" class="headerlink" title="L1 distance"></a>L1 distance</h3><p>假设样本$ X_1 $有$ X_1^0, X_1^1, …, X_1^n $特征，其与样本$ X_2 $之间的L1距离可以用以下公式计算:</p><p>$$ L1(X_1, X_2) = \left|X_1^0 - X_2^0\right| + \left|X_1^1 - X_2^1\right| + … + \left|X_1^n - X_2^n\right| $$</p><p>L1函数代码示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L1</span><span class="params">(x1, x2)</span>:</span></span><br><span class="line">    <span class="comment"># x1和x2都是向量，x1 - x2为每个特征相减</span></span><br><span class="line">    <span class="comment"># np.abs为每个结果求绝对值</span></span><br><span class="line">    <span class="comment"># np.sum将所有绝对值求和</span></span><br><span class="line">    <span class="keyword">return</span> np.sum(np.abs(x1 - x2))</span><br></pre></td></tr></table></figure><h3 id="L2-distance"><a href="#L2-distance" class="headerlink" title="L2 distance"></a>L2 distance</h3><p>L2距离即为特征差的平方求和开方，即:</p><p>$$ L2(X_1, X_2) = \sqrt{(X_1^0 -  X_2^0)^2 + (X_1^1 -  X_2^1)^2 + … + (X_1^n -  X_2^n)^2} $$</p><p>L2函数代码示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L2</span><span class="params">(x1, x2)</span>:</span></span><br><span class="line">    <span class="comment"># (x1 - x2) ** 2 为特征差的平方</span></span><br><span class="line">    <span class="comment"># np.sum进行求和运算</span></span><br><span class="line">    <span class="comment"># np.sqrt进行开方运算</span></span><br><span class="line">    <span class="keyword">return</span> np.sqrt(np.sum((x1 - x2) ** <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h2 id="KNN代码"><a href="#KNN代码" class="headerlink" title="KNN代码"></a>KNN代码</h2><p>由于前面已经介绍过KNN的算法流程了，在此处直接给出实现代码(此处的代码并不是最优的，有其他优化方式，有兴趣的可以自己研究)，代码给出了详细注释。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knn</span><span class="params">(train_x, train_y, test_x, sim_func=None, K=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 防御性编程，忽略</span></span><br><span class="line">    <span class="keyword">assert</span> sim_func <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span></span><br><span class="line">    <span class="comment"># 声明结果存储的空间，所有元素初始化为0</span></span><br><span class="line">    test_y = np.zeros(M2).astype(int)</span><br><span class="line">    <span class="comment"># 遍历每一个test_x中的样本，enumerate函数使得在遍历的同时返回其遍历序号，默认idx以0开始</span></span><br><span class="line">    <span class="keyword">for</span> idx, X1 <span class="keyword">in</span> enumerate(test_x):</span><br><span class="line">        <span class="comment"># 我们需要一个列表来存储所有计算的距离值</span></span><br><span class="line">        neighbors = []</span><br><span class="line">        <span class="comment"># 遍历每一个train_x中的样本，zip函数可以对多个序列进行遍历，</span></span><br><span class="line">        <span class="comment"># 因此我们可以很方便的同时得到train_x中的X1的特征以及它对应的标签</span></span><br><span class="line">        <span class="keyword">for</span> X2, Y2 <span class="keyword">in</span> zip(train_x, train_y):</span><br><span class="line">            <span class="comment"># 使用距离函数sim_func计算样本X1和X2的距离dis</span></span><br><span class="line">            dis = sim_func(X1, X2)</span><br><span class="line">            <span class="comment"># 我们将距离和标签以Python元组的形式(dis, Y2)放入前面声明的列表中</span></span><br><span class="line">            neighbors.append((dis, Y2))</span><br><span class="line">        <span class="comment"># 对neighbors列表中的所有元组进行排序，</span></span><br><span class="line">        <span class="comment"># 比较关键字key使用了每个元组中的第0个元素即(dis, Y2)中的dis</span></span><br><span class="line">        <span class="comment"># 这样我们得到了一个dis从小到大排列的列表</span></span><br><span class="line">        neighbors.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 使用Python的切片功能我们保留neighbors的前K个元素(即dis最小的前K个)</span></span><br><span class="line">        neighbors = neighbors[:K]</span><br><span class="line">        <span class="comment"># 声明一个字典votes</span></span><br><span class="line">        votes = &#123;&#125;</span><br><span class="line">        <span class="comment"># 遍历neighbors中的K个元素</span></span><br><span class="line">        <span class="keyword">for</span> dis, label <span class="keyword">in</span> neighbors:</span><br><span class="line">            <span class="comment"># 如果当前遍历到的标签label不在字典votes中</span></span><br><span class="line">            <span class="comment"># setdefault函数将会将其加入字典中，并将其值置为0</span></span><br><span class="line">            <span class="comment"># 如果标签在label中，setdefault函数不做任何处理</span></span><br><span class="line">            votes.setdefault(label, <span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 标签label计数加1</span></span><br><span class="line">            votes[label] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># votes.items()方法返回一个列表(实际是一个迭代器，可以先忽略)，</span></span><br><span class="line">        <span class="comment"># 其形式为(label, count)，即标签和它出现的次数</span></span><br><span class="line">        <span class="comment"># max函数用来找到这个列表中最大的那个元素(即我们要的出现最多次的元素)</span></span><br><span class="line">        <span class="comment"># 比较关键字在此处为x[1]，即(label, count)中的count</span></span><br><span class="line">        <span class="comment"># 最后max函数返回了一个(label, count)，该对象是出现次数最多的，我们用下标[0]访问即可得到该标签，</span></span><br><span class="line">        <span class="comment"># 最后将该标签赋值给test_y[idx]，完成！</span></span><br><span class="line">        test_y[idx] = max(votes.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> test_y</span><br></pre></td></tr></table></figure><p>最后保存并执行，即可得到预期结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python3 knn.py</span><br><span class="line">Evaluating with your implementation of L1 distance</span><br><span class="line">Accuracy: 100.00%</span><br><span class="line">Conguratulations, Your implementation is correct</span><br><span class="line"></span><br><span class="line">Evaluating with your implementation of L2 distance</span><br><span class="line">Accuracy: 100.00%</span><br><span class="line">Conguratulations, Your implementation is correct</span><br></pre></td></tr></table></figure><p>至此，一个简单的KNN算法工作完毕。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在学院论坛里面写了关于KNN的一篇解释，顺手就转到自己博客了，毕竟这都又是3个月没更新了，感觉自己学了很多但是就是太懒，不想记下来，这个习惯还是得改改。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://youchen.me/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://youchen.me/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="监督学习" scheme="http://youchen.me/tags/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="KNN" scheme="http://youchen.me/tags/KNN/"/>
    
  </entry>
  
  <entry>
    <title>论文笔记-全卷积神经网络(FCN)</title>
    <link href="http://youchen.me/2017/07/25/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E5%85%A8%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-FCN/"/>
    <id>http://youchen.me/2017/07/25/论文笔记-全卷积神经网络-FCN/</id>
    <published>2017-07-25T02:50:05.000Z</published>
    <updated>2018-01-15T01:09:30.882Z</updated>
    
    <content type="html"><![CDATA[<p>看了下时间已经快3个月没有写过东西了，客观原因是考试复习和项目上的事情比较多，主观原因是懒。</p><p>最早接触机器学习是在大三，大四的时候了解了一些DL的知识，前几个月在网上学习了斯坦福的<a href="http://cs231n.stanford.edu" target="_blank" rel="noopener">CS231n: Convolutional Neural Networks for Visual Recognition</a>，看了一些论文，对DL相关概念有了一些基本的了解，这篇文章是我阅读<a href="https://arxiv.org/abs/1411.4038v2" target="_blank" rel="noopener">Fully Convolutional Networks for Semantic Segmentation</a>时的一些理解。</p><a id="more"></a><h1 id="Sementic-Segmentation-语义分割"><a href="#Sementic-Segmentation-语义分割" class="headerlink" title="Sementic Segmentation(语义分割)"></a>Sementic Segmentation(语义分割)</h1><p>语义分割是计算机视觉领域的一个经典问题，它所要完成的工作是对于图片的每一个像素，对其赋予一个标签，这和分类(Classification)、定位(Localization)等任务有很大的区别，分类是完成判断“是什么”的任务，定位不仅需要判断“是什么”，还需要完成“在哪里”的任务。举个例子说明,对于下面这张图片:</p><p><img src="/2017/07/25/论文笔记-全卷积神经网络-FCN/cat.png" alt="cat"></p><p>对其进行语义分割，得到的结果如下图所示:</p><p><img src="/2017/07/25/论文笔记-全卷积神经网络-FCN/ss-cat.png" alt="ss-cat"></p><p>图中不同颜色代表了不同的语义，比如黄色代表了猫，绿色代表了草坪，蓝色代表了天空，粉紫色代表了猫身后的树林。</p><p>语义分割对于人工智能迈向更高台阶是十分重要的，因为这一工作能够让计算机拥有类似人的判断，对其观察到的世界进行认识了解，这一工作在机器人领域以及自动驾驶等领域有很大的应用前景。</p><p>在<a href="https://arxiv.org/abs/1411.4038v2" target="_blank" rel="noopener">Fully Convolutional Networks for Semantic Segmentation</a>这篇论文将深度学习引入该领域之前，传统的语义分割主要依赖使用人工提取特征和概率图模型，而FCN这篇论文的发表，成为了语义分割的一个重要转折点。</p><p>全卷积网络的概念其实很早就提出了，因此在本文获得CVPR’ 15最佳论文提名的时候被Yann LeCun等人吐槽，当然，这篇论文仍然具有十分重要的意义。</p><h1 id="全连接层-–-gt-卷积层"><a href="#全连接层-–-gt-卷积层" class="headerlink" title="全连接层 –&gt; 卷积层"></a>全连接层 –&gt; 卷积层</h1><p>传统的分类网络，比如LeNet、AlexNet等，只接受固定尺寸的输入并产生非空间输出，原因在于全连接层参数的限制，而且这些网络在通过全连接层把输入展开成向量的时候丢失了图片原有的空间信息。对VGG16中第一个全连接层为25088x4096，即该层输入未展开成向量前形状为7x7x512，展开后为1x25088，得到的输出为1x4096，其实换一个角度来看，如果采用512x7x7x4096的卷积层原始输入进行卷积操作，得到的结果为1x1x4096。这样操作后，对应于原来输出的向量，现在输出了heatmap，如下图所示。</p><p><img src="/2017/07/25/论文笔记-全卷积神经网络-FCN/heatmap-cat.png" alt="heatmap-cat"></p><p>使用卷积层替换全连接层这种操作具体有什么作用呢？</p><p>以AlexNet为例，该网络输入为224x224x3，使用一系列卷积层和Pooling层使得数据尺寸变为7x7x512，紧接着是三个4096、4096、1000的全连接层，我们将三个全连接层分别转化为三个卷积层:</p><ul><li>对第一个全连接层25088x4096，我们可以使用kernel_size为7的4096个卷积核代替，这样得到的输出为1x1x4096</li><li>对第二个全连接层4096x4096，使用kernel_size为1的4096个卷积核代替，得到输出为1x1x4096</li><li>对第三个全连接层4096x1000，使用kernel_size为1的1000个卷积核代替，得到输出为1x1x1000</li></ul><p>假如我们想对384x384x3的图片进行语义分割，在不使用卷积层替换全连接层的情况下，我们使用步长为32大小为224x224x3的窗口在384x384x3的图片上进行滑动，得到6x6个位置的语义分割得分，然后进行fusion处理。但是因为我们使用了卷积层替换全连接层，现在的网络有能力对不同尺寸的输入进行处理。因此，384x384x3的输入经过卷积层和Pooling层后得到的尺寸为12x12x512，再通过上面经过转化的三个卷积层，得到的结果为6x6x1000，正好是对原图进行滑动得到的结果。</p><p>论文给出了这两种方式的时间性能比较，在GPU上，AlexNet需要花费1.2毫秒来产生对一张227x227的图片预测，而FCN版本花费了22毫秒对一张500x500的图片产生大小为10x10的预测，比AlexNet快了5倍多。</p><h1 id="Upsampling-上采样"><a href="#Upsampling-上采样" class="headerlink" title="Upsampling(上采样)"></a>Upsampling(上采样)</h1><p>以改造后的VGG16为例，让输入经过网络之后，我们得到的数据尺寸为[H/32, W/32]，而我们的目标是对每一个像素产生预测，因此我们需要进行upsampling操作，即恢复原始尺寸。在某种程度上，使用系数为$f$的upsampling可以看成是步长为$1/f$的卷积的转置，即只要$f$是整数，一种进行upsampling的方法就是使用<strong>backwards convolution</strong>(或称<strong>deconvolution</strong>，该术语存在争议，也有人称<strong>transposed convolution</strong>)，以输出步长为$f$进行计算。</p><p><img src="/2017/07/25/论文笔记-全卷积神经网络-FCN/padding_strides.gif" alt="padding_strides"></p><p>如图所示，绿色部分为输入，蓝色部分为输出，stride为2，padding为1。可以看出，<strong>transposed convolution</strong>其实就是<strong>convolution</strong>反过来，调换了<strong>convolution</strong>的前向传播和反向传播过程而已。</p><h1 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h1><p>以VGG16和PASCAL数据集为例，我们去除了最后的分类层，并将所有的全连接层转化为上述的卷积层，然后添加了一层1x1x21的卷积层用于预测每个类别(包括背景)的得分，然后使用转置卷积进行双线性上采样，使得粗粒度输出(coarse outputs)变成像素密集的输出。</p><p>虽然可以通过fine-tune来优化分割结果，得分也会变高，但是这些输出仍然比较粗糙无法令人满意。最后的prediction层采用stride为32的方式限制了上采样结果的细节程度。那么怎么处理这一问题呢？</p><p>我们知道，随着卷积神经网络层数的增加，每一层的感知野(reception field)也更广，而网络结构中越低的层感知野越小，因此能得到更多细节。结合低层与高层输出可以使得模型在全局结构下进行局部预测。</p><p><img src="/2017/07/25/论文笔记-全卷积神经网络-FCN/fine-coarse.png" alt="fine-coarse"></p><p>图中所示为改造后的VGG16的简化图，图中只包含了输入层、由全连接层转化而来的卷积层以及Pooling层。对我们最初采用stride为32的上采样得到结果的模型我们称为FCN-32s，为了进一步优化输出预测。我们首先在pool4后面添加1x1的卷积层来产生额外的预测。然后对使用步长为32的conv7(卷积化后的fc7)进行2x上采样，因为pool5将尺寸缩减了一半，此时进行2x上采样将会把尺寸恢复到跟pool4一样，然后把该结果和pool4后1x1卷积层产生的结果进行求和(不采用Max fusion的原因是会因为梯度选择而使得训练较为困难)。对于pool4后的1x1卷积层采用双线性插值初始化，但是允许参数在训练过程中进行调整。最后，将得到结果采用stride为16的方式进行上采样得到结果，该模型我们成为FCN-16s。同理，我们可以通过在pool3后添加1x1的卷积层并进行上述类似操作得到FCN-8s，但是得到的提升已经十分有限，因此不再进行更低层的fusion操作。</p><p><img src="/2017/07/25/论文笔记-全卷积神经网络-FCN/finer-fcns.png" alt="finer-fcns"></p><p>图中可以看出，通过融合使用不同stride的层得到的结果提高了分割的细节。</p><p><img src="/2017/07/25/论文笔记-全卷积神经网络-FCN/fcns-validation.png" alt="fcns-validation"></p><h1 id="训练细节"><a href="#训练细节" class="headerlink" title="训练细节"></a>训练细节</h1><ul><li>SGD with momentum 0.9</li><li>Minibatch size of 20 images</li><li>Fixed learning rates of $10^{-3}$, $10^{-4}$, $10^{-5}$ for FCN-AlexNet, FCN-VGG16, FCN-GoogLeNet</li><li>Weight decay of $5^{-4}$ or $2^{-4}$</li><li>Doubled the learning rates for biases(非必要)</li><li>Zero-initialize the class scoring convolution layer</li><li>Dropout</li></ul><h1 id="模型效果"><a href="#模型效果" class="headerlink" title="模型效果"></a>模型效果</h1><p><img src="/2017/07/25/论文笔记-全卷积神经网络-FCN/results.png" alt="resluts"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="http://www.cnblogs.com/gujianhan/p/6030639.html" target="_blank" rel="noopener">全卷积网络 FCN 详解</a></li><li><a href="http://blog.csdn.net/tangwei2014/article/details/46882257" target="_blank" rel="noopener">论文阅读笔记：Fully Convolutional Networks for Semantic Segmentation</a></li><li><a href="https://github.com/vdumoulin/conv_arithmetic" target="_blank" rel="noopener">Convolution arithmetic</a></li><li><a href="http://cs231n.stanford.edu" target="_blank" rel="noopener">CS231n: Convolutional Neural Networks for Visual Recognition</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看了下时间已经快3个月没有写过东西了，客观原因是考试复习和项目上的事情比较多，主观原因是懒。&lt;/p&gt;
&lt;p&gt;最早接触机器学习是在大三，大四的时候了解了一些DL的知识，前几个月在网上学习了斯坦福的&lt;a href=&quot;http://cs231n.stanford.edu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CS231n: Convolutional Neural Networks for Visual Recognition&lt;/a&gt;，看了一些论文，对DL相关概念有了一些基本的了解，这篇文章是我阅读&lt;a href=&quot;https://arxiv.org/abs/1411.4038v2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fully Convolutional Networks for Semantic Segmentation&lt;/a&gt;时的一些理解。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://youchen.me/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://youchen.me/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="http://youchen.me/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="语义分割" scheme="http://youchen.me/tags/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>初窥asyncio</title>
    <link href="http://youchen.me/2017/05/10/New-to-asyncio/"/>
    <id>http://youchen.me/2017/05/10/New-to-asyncio/</id>
    <published>2017-05-10T06:10:06.000Z</published>
    <updated>2018-01-15T01:18:15.816Z</updated>
    
    <content type="html"><![CDATA[<p>前两天花了些时间阅读了Python的<a href="https://docs.python.org/3/library/asyncio.html#module-asyncio" target="_blank" rel="noopener"><code>asyncio</code></a>模块的相关文档，综合之前对<a href="http://twistedmatrix.com/trac/" target="_blank" rel="noopener">Twisted</a>的一些了解，分享一些学习结果。</p><p>根据官方文档的介绍，<code>asyncio</code>这个模块是在Python 3.4进行引入的，这个模块提供了使用协程编写单线程并发程序、对sockets以及其他资源的多路I/O访问、执行网络客户端和服务器等工作的基础。模块内容主要包含:</p><ul><li>一个多种平台相关实现的可插拔事件循环；</li><li><code>transport</code>和<code>protocol</code>抽象(与<a href="http://twistedmatrix.com/trac/" target="_blank" rel="noopener">Twisted</a>的概念相似)；</li><li>对TCP、UDP、SSL、子进程管道、延迟调用、以及其他功能(以上操作可能平台相关)的有力支持；</li><li>一个模仿<a href="https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures" target="_blank" rel="noopener"><code>concurrent.futures</code></a>模块实现的<code>Future</code>类，但增加了对事件循环的适应；</li><li>使用<a href="https://www.python.org/dev/peps/pep-0380" target="_blank" rel="noopener"><code>yield from</code></a>的协程(coroutines)以及作业(tasks)，以帮助使用顺序方式编写并发代码；</li><li>对取消<code>Future</code>和协程的支持；</li><li>在单线程的不同协程中使用的<a href="https://docs.python.org/3/library/asyncio-sync.html#asyncio-sync" target="_blank" rel="noopener">同步原语</a>，模仿<a href="https://docs.python.org/3/library/threading.html#module-threading" target="_blank" rel="noopener">threading</a>实现；</li><li>一个向线程池传递任务的接口，以解决无可避免地需要使用某些会造成I/O阻塞库的调用。</li></ul><div class="tip">本文相关特性需Python 3.4以上版本支持，部分内容需要Python 3.5以上版本支持</div><a id="more"></a><p>在开始相关的介绍之前，我们需要对同步、异步等工作方式有一个简单的了解，以下部分内容引用自<a href="http://krondo.com" target="_blank" rel="noopener"><em>krondo</em></a>编写的<a href="http://krondo.com/an-introduction-to-asynchronous-programming-and-twisted/" target="_blank" rel="noopener">Twisted Introduction</a>。</p><h1 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h1><p>大部分程序员应该非常熟悉同步模型了：</p><p><img src="/2017/05/10/New-to-asyncio/sync.png" alt=""></p><p>这是最简单的一种编程方式，每个任务依次执行，只有上一个任务结束以后下一个才会执行，任务都是按照确定顺序执行的，后面的任务可以认为所有之前的任务都是没有错误的正常结束，且他们的输出可以正常使用。</p><p>当然，我们也可以对比多线程(同步)模型：</p><p><img src="/2017/05/10/New-to-asyncio/threaded.png" alt=""></p><p>在该模型中，每一个任务都在一个单独的线程中执行，线程由操作系统管理，且在某些拥有多处理器或多核的操作系统上，可能可以真正的并发执行，或者都被放入同一处理器中执行。关键在于，多线程模型的执行细节是由操作系统控制的，对于不相关的指令流程序员应该认为其是同时执行的。因此，虽然图看起来简单，但实际编写多线程模型可能比较复杂，因为不同线程之间需要保持一定的协调。线程通信以及协调是一个高级编程话题而且要正确实现很困难。</p><p>下面让我们来看异步模型：</p><p><img src="/2017/05/10/New-to-asyncio/async.png" alt=""></p><p>在该模型中，任务之间彼此交错，但是都在同一线程中执行。这比多线程的情况要简单因为程序要总是知道<strong>同一时间只有一个任务在执行</strong>。除此之外，异步模型与多线程模型之前还有一个区别，在多线程模型中，线程的挂起与执行是由操作系统而不是程序员决定的，程序员需要假设一个线程可能被随时挂起。与此相反，在异步模型中，一个任务将会持续运行直到在适当的时候明确主动地放弃CPU资源占用让其他任务执行，这比多线程模型简单许多。</p><h1 id="为什么要使用异步模型"><a href="#为什么要使用异步模型" class="headerlink" title="为什么要使用异步模型"></a>为什么要使用异步模型</h1><p>有很多原因促使我们使用异步模型，其中一个比较常见的就是解决阻塞问题：</p><p><img src="/2017/05/10/New-to-asyncio/block.png" alt=""></p><p>图中的灰色部分代表了一个任务正在阻塞等待而无法继续执行。为什么一个任务会阻塞？一个常见的原因就是该任务正在等待完成I/O，完成向外接设备传递数据或者从外界设备接收数据。通常情况下，由于CPU处理数据的速度是磁盘或者网络连接处理数据速度的几个数量级，因此一个完成大量I/O操作的程序将会在阻塞上大量时间以等待磁盘或者网络完成操作。回过头看异步模型，对于遇到一个任务可能在同步模型下阻塞的时候，将会让出CPU转而执行其他没有阻塞的任务。因此异步模型只在没有任务可以继续执行即所有任务都在等待I/O的时候“阻塞”。</p><p>相比较于同步模型，异步模型在以下情况下表现更好：</p><ol><li>有大量任务需要执行且无论什么时候至少有一个任务可以继续执行。</li><li>要完成的任务中需要完成大量I/O操作，导致同步程序在其他任务可以继续执行时候会浪费大量时间阻塞等待。</li><li>任务之间基本不相关因此不需要任务间交互。</li></ol><p>那么asyncio的异步模型实现是基于什么呢？</p><p><img src="/2017/05/10/New-to-asyncio/reactor-1.png" alt=""></p><p>如图所示，这是反应器模式的一个基本结构，它总是处在等待事件以及处理事件的状态之一，因此也被称作<strong>事件循环(event loop)</strong>，也即asyncio模块的核心之一。</p><h1 id="事件循环示例"><a href="#事件循环示例" class="headerlink" title="事件循环示例"></a>事件循环示例</h1><p>让我们从一些官方文档示例开始。</p><p>第一个例子是简单地打印字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">(loop)</span>:</span></span><br><span class="line">    print(<span class="string">'Hello World'</span>)</span><br><span class="line">    loop.stop()</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Schedule a call to hello_world()</span></span><br><span class="line">loop.call_soon(hello_world, loop)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Blocking call interrupted by loop.stop()</span></span><br><span class="line">loop.run_forever()</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure><p>代码首先导入了我们需要使用的asyncio模块，然后定义了一个接收一个参数的<code>hello_world</code>函数，该函数只完成了两件事，打印一段字符串并在一个对象上调用了<code>stop</code>方法，关键在这之后：</p><ol><li><code>get_event_loop</code>: 我们通过使用asyncio模块的<code>get_event_loop</code>方法取得了事件循环，之前说过了，事件循环是整个asyncio模块的核心，我们需要把我们的任务添加到事件循环中，那么第一步便是取得事件循环。除了取得事件循环，还可以更改或者新建事件循环，以及更底层的Policy，但是由于我们是初次接触，就不再深究。</li><li><code>call_soon</code>: 接着，我们在loop对象上调用了<code>call_soon</code>方法，该方法接收多个参数，第一个参数是一个可调用对象，后面的参数将会传给该对象，在此处我们传递了<code>hello_world</code>函数和loop对象。该函数的作用是在事件循环启动之后尽快调用传递的对象。</li><li><code>run_forever</code>: 通过调用loop对象的<code>run_forever</code>函数，将启动事件循环，外部代码将会阻塞，即<code>run_forever</code>之后的函数将不会继续执行。</li><li><code>stop</code>: 由于启动了事件循环，之前通过<code>call_soon</code>调度的<code>hello_world</code>函数将会执行，打印字符串并调用loop对象的<code>stop</code>方法，该方法将会停止事件循环，使得外部代码继续执行。</li><li><code>close</code>: 关闭事件循环，需要注意的是关闭之前必须保证事件循环没有执行。</li></ol><p>第二个例子每秒打印一次当前日期时间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display_date</span><span class="params">(end_time, loop)</span>:</span></span><br><span class="line">    print(datetime.datetime.now())</span><br><span class="line">    <span class="keyword">if</span> (loop.time() + <span class="number">1.0</span>) &lt; end_time:</span><br><span class="line">        loop.call_later(<span class="number">1</span>, display_date, end_time, loop)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        loop.stop()</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Schedule the first call to display_date()</span></span><br><span class="line">end_time = loop.time() + <span class="number">5.0</span></span><br><span class="line">loop.call_soon(display_date, end_time, loop)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Blocking call interrupted by loop.stop()</span></span><br><span class="line">loop.run_forever()</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure><p><code>call_soon</code>和<code>run_forever</code>等方法的调用和前一个例子相同，区别在于调用<code>display_date</code>函数将会打印当前日期时间然后判断当前时间是否超过结束时间，如果超过则停止事件循环，否则则使用<code>call_later</code>方法设置1秒后对<code>display_date</code>函数进行调用。需要注意的一点是loop的<code>time</code>方法和<code>time</code>模块的<code>time</code>方法相似，不过使用的loop的内部时钟。</p><p>第三个例子是监视文件描述符的读事件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> socket <span class="keyword">import</span> socketpair</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> asyncio.windows_utils <span class="keyword">import</span> socketpair</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a pair of connected file descriptors</span></span><br><span class="line">rsock, wsock = socketpair()</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">()</span>:</span></span><br><span class="line">    data = rsock.recv(<span class="number">100</span>)</span><br><span class="line">    print(<span class="string">"Received:"</span>, data.decode())</span><br><span class="line">    <span class="comment"># We are done: unregister the file descriptor</span></span><br><span class="line">    loop.remove_reader(rsock)</span><br><span class="line">    <span class="comment"># Stop the event loop</span></span><br><span class="line">    loop.stop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Register the file descriptor for read event</span></span><br><span class="line">loop.add_reader(rsock, reader)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Simulate the reception of data from the network</span></span><br><span class="line">loop.call_soon(wsock.send, <span class="string">'abc'</span>.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run the event loop</span></span><br><span class="line">loop.run_forever()</span><br><span class="line"></span><br><span class="line"><span class="comment"># We are done, close sockets and the event loop</span></span><br><span class="line">rsock.close()</span><br><span class="line">wsock.close()</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure><p>该示例通过使用socketpair函数创建了一组相连接的socket对象，<code>loop.call_soon(wsock.send, &#39;abc&#39;.encode())</code>将会在事件循环启动后尽快调用wsock的<code>send</code>方法，方法参数为<code>&#39;abc&#39;.encode()</code>。除此之外，通过调用loop的<code>add_reader</code>方法，监视rsock的读事件，当读可用时，将会调用注册的<code>reader</code>函数，接收内容并打印出来，然后取消对rsock的注册并停止事件循环。</p><p>最后一个例子是为<code>SIGINT</code>和<code>SIGTERM</code>等信号设置处理器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ask_exit</span><span class="params">(signame)</span>:</span></span><br><span class="line">    print(<span class="string">"got signal %s: exit"</span> % signame)</span><br><span class="line">    loop.stop()</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">for</span> signame <span class="keyword">in</span> (<span class="string">'SIGINT'</span>, <span class="string">'SIGTERM'</span>):</span><br><span class="line">    loop.add_signal_handler(getattr(signal, signame),</span><br><span class="line">                            functools.partial(ask_exit, signame))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Event loop running forever, press Ctrl+C to interrupt."</span>)</span><br><span class="line">print(<span class="string">"pid %s: send SIGINT or SIGTERM to exit."</span> % os.getpid())</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    loop.run_forever()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    loop.close()</span><br></pre></td></tr></table></figure><p>上面一段代码里面最重要的部分就是<code>add_signal_handler</code>方法，第一个参数为信号对象，第二个参数为该信号出现时该调用的函数。在本例中，即当<code>SIGINT</code>和<code>SIGTERM</code>信号出现时调用<code>ask_exit</code>函数。</p><p>在使用asyncio时，还有一点需要注意的是：</p><blockquote><p>许多asyncio模块的函数都不接受关键字参数。因此，如果需要向回调函数传递关键字参数，需要使用<code>functools</code>模块的<code>partial</code>方法，比如<code>loop.call_soon(functools.partial(print, &quot;Hello&quot;, flush=True))</code>将会调用<code>print(&quot;Hello&quot;, flush=True)</code>。</p></blockquote><p>限于篇幅原因，本文止步于此，对于asyncio模块的其他内容的学习在接下来的文章中会进行分享。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天花了些时间阅读了Python的&lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;asyncio&lt;/code&gt;&lt;/a&gt;模块的相关文档，综合之前对&lt;a href=&quot;http://twistedmatrix.com/trac/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Twisted&lt;/a&gt;的一些了解，分享一些学习结果。&lt;/p&gt;
&lt;p&gt;根据官方文档的介绍，&lt;code&gt;asyncio&lt;/code&gt;这个模块是在Python 3.4进行引入的，这个模块提供了使用协程编写单线程并发程序、对sockets以及其他资源的多路I/O访问、执行网络客户端和服务器等工作的基础。模块内容主要包含:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个多种平台相关实现的可插拔事件循环；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;transport&lt;/code&gt;和&lt;code&gt;protocol&lt;/code&gt;抽象(与&lt;a href=&quot;http://twistedmatrix.com/trac/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Twisted&lt;/a&gt;的概念相似)；&lt;/li&gt;
&lt;li&gt;对TCP、UDP、SSL、子进程管道、延迟调用、以及其他功能(以上操作可能平台相关)的有力支持；&lt;/li&gt;
&lt;li&gt;一个模仿&lt;a href=&quot;https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;concurrent.futures&lt;/code&gt;&lt;/a&gt;模块实现的&lt;code&gt;Future&lt;/code&gt;类，但增加了对事件循环的适应；&lt;/li&gt;
&lt;li&gt;使用&lt;a href=&quot;https://www.python.org/dev/peps/pep-0380&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;yield from&lt;/code&gt;&lt;/a&gt;的协程(coroutines)以及作业(tasks)，以帮助使用顺序方式编写并发代码；&lt;/li&gt;
&lt;li&gt;对取消&lt;code&gt;Future&lt;/code&gt;和协程的支持；&lt;/li&gt;
&lt;li&gt;在单线程的不同协程中使用的&lt;a href=&quot;https://docs.python.org/3/library/asyncio-sync.html#asyncio-sync&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;同步原语&lt;/a&gt;，模仿&lt;a href=&quot;https://docs.python.org/3/library/threading.html#module-threading&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;threading&lt;/a&gt;实现；&lt;/li&gt;
&lt;li&gt;一个向线程池传递任务的接口，以解决无可避免地需要使用某些会造成I/O阻塞库的调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;tip&quot;&gt;本文相关特性需Python 3.4以上版本支持，部分内容需要Python 3.5以上版本支持&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="协程" scheme="http://youchen.me/tags/%E5%8D%8F%E7%A8%8B/"/>
    
      <category term="asyncio" scheme="http://youchen.me/tags/asyncio/"/>
    
  </entry>
  
  <entry>
    <title>Python正则表达式中的反斜线</title>
    <link href="http://youchen.me/2017/04/24/Backslashes-in-Python-Regular-Expressions/"/>
    <id>http://youchen.me/2017/04/24/Backslashes-in-Python-Regular-Expressions/</id>
    <published>2017-04-24T02:13:12.000Z</published>
    <updated>2018-01-15T01:18:33.385Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式是一个十分强大的工具，可以完成对字符串的模式匹配以及提取工作，在很多工程中都被广泛使用，但是我之前对于Python正则表达式模块<code>re</code>的使用都没有进行一些深入学习，对<strong>原始字符串</strong>之类的了解也比较浅显，之前有个同学问到我关于反斜线<code>\</code>在正则中的一些表现的时候我也迷惑了，跟周围人讨论后上<a href="http://stackoverflow.com" target="_blank" rel="noopener">StackOverflow</a>问了一番，对这方面又多了一些了解，今天跟大家分享。</p><a id="more"></a><h1 id="字符串中的反斜线"><a href="#字符串中的反斜线" class="headerlink" title="字符串中的反斜线\"></a>字符串中的反斜线<code>\</code></h1><p>我们知道，反斜线<code>\</code>在字符串以及正则表达式中都是完成转义的工作，比如我有一个字符串s1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">'123'</span></span><br></pre></td></tr></table></figure><p>现在这个字符串s1内容为<code>123</code>，如果我想在字符串中保留一个单引号<code>&#39;</code>，那么我可能的一种做法是使用双引号来包含内容，字符串s2:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">"12'3"</span></span><br></pre></td></tr></table></figure><p>Python中的单引号<code>&#39;</code>和双引号<code>&#39;</code>其实都可以用来指示字符串，我们在此处使用双引号而不是单引号，原因是因为如果使用单引号Python解释器将会无法对这条语句进行正常解释，因为紧跟2之后的<code>&#39;</code>被用来指示字符串结束，然而后面还剩下<code>3</code>这个字符，所以会引发<code>Syntax Error</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'12'</span><span class="number">3</span><span class="string">'</span></span><br><span class="line"><span class="string">  File "&lt;stdin&gt;", line 1</span></span><br><span class="line"><span class="string">    s = '</span><span class="number">12</span><span class="string">'3'</span></span><br><span class="line">            ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>但是，只是使用语句中不包含的那种引号来指示字符串有时候是行不通的，因为有时候一个字符串可能同时包含单引号和双引号，比如字符串<code>1&quot;2&#39;3</code>，所以这时候我们需要使用反斜线<code>\</code>来对内容进行转义，因此对于字符串<code>1&quot;2&#39;3</code>，我们可以采用如下表示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'1"2\'3'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'1"2\'3'</span></span><br></pre></td></tr></table></figure><p>注意我们并没有对字符串内容中的双引号<code>&quot;</code>进行转义，原因同上，字符串使用单引号指示的，因此双引号只会被认为是一个普通的字符。对于字符串内部的单引号<code>&#39;</code>，为了让解释器得知它是一个普通字符，我们在其前面增加了一个反斜线<code>\</code>，<code>\&#39;</code>组合起来的意思是对反斜线后面的字符<code>&#39;</code>进行转义，可以这样理解，通过添加一个反斜线<code>\</code>，对于<code>\&#39;</code>，你告诉了解释器:<code>不要按照普通的方式去解释这个字符&#39;</code>，这样解释器就能正确地完成对该字符串的解释。</p><p>有编程基础的读者应该会知道<strong><em>转义</em></strong>这一概念广泛存在于很多编程语言中，对<code>\n</code>、<code>\r</code>等字符应该有一定了解，类比前面的解释，<code>\n</code>表示:<code>不要按照普通的方式去解释这个字符n</code>。</p><p>进一步理解，假设我们从键盘输入了字符串:<code>abc\nde</code>，一共输入了7个字符，这7个字符经过Python解释器解释，两个字符<code>\</code>和<code>n</code>将会被转义成一个字符<code>\n</code>，请特别注意这一点，虽然从表面上看是两个字符，但其实<code>\n</code>是一个特殊的字符，这一点我们可以从以下代码看出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'abc\nde'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(s)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>]</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>]</span><br><span class="line"><span class="string">'b'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">2</span>]</span><br><span class="line"><span class="string">'c'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">3</span>]</span><br><span class="line"><span class="string">'\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">4</span>]</span><br><span class="line"><span class="string">'d'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">5</span>]</span><br><span class="line"><span class="string">'e'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">6</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: string index out of range</span><br></pre></td></tr></table></figure><p>有了这些基础，下面我们进入到正则的部分。</p><h1 id="正则表达式中的反斜线"><a href="#正则表达式中的反斜线" class="headerlink" title="正则表达式中的反斜线\"></a>正则表达式中的反斜线<code>\</code></h1><p>因为有了Python解释器首先对字符串的转义，所以正则表达式模块<code>re</code>看到的和你输入的可能有所不同，比如，<code>\n</code>在字符串层被转义成一个换行字符，然后<code>re</code>看到的是字符<code>\n</code>而不是<code>\</code>和<code>n</code>两个字符，看以下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'abc\nde'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">'\n'</span>, s)</span><br><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">3</span>, <span class="number">4</span>), match=<span class="string">'\n'</span>&gt;</span><br></pre></td></tr></table></figure><p>以上代码首先定义了一个前文提到的字符串<code>s</code>，然后使用<code>re</code>模块的<code>search</code>方法搜索，然后要搜索的字符串是<code>\n</code>，注意我们输入的是字符<code>\</code>和字符<code>n</code>，然后经过Python解释器的解释实际在内存中的是一个<code>\n</code>字符，因此<code>re</code>模块看到的是只有一个字符的字符串<code>\n</code>，而不是两个字符，最后完成搜索。</p><p>如果我们想匹配字符串<code>\\\n</code>，应该怎么输入模式呢？，一种方法是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'\\\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pat = re.compile(<span class="string">'\\\\\n'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pat.pattern</span><br><span class="line"><span class="string">'\\\\\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pat.search(s)</span><br><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">2</span>), match=<span class="string">'\\\n'</span>&gt;</span><br></pre></td></tr></table></figure><p>对于字符串<code>\\\n</code>，它的内容其实是一个普通的<code>\</code>字符和一个换行字符<code>\n</code>，对于我们输入的匹配模式<code>\\\\\n</code>，首先经过Python解释器的字符串解释，变成了两个普通的<code>\</code>字符和一个换行字符<code>\n</code>，然后这些内容通过<code>re</code>模块的<code>compile</code>方法，<code>compile</code>方法发现有两个连续的<code>\</code>符号，因此将在接下来的匹配中匹配一个普通的<code>\</code>字符(请注意理解这一点)，而<code>\n</code>字符将会匹配一个<code>\n</code>字符，因此该模式的匹配内容是字符串中的一个普通<code>\</code>字符和一个<code>\n</code>字符。当然，写这么多反斜线显得十分麻烦，所以Python也提供了一种方便的方式，即<strong><em>原始字符串</em></strong>，其格式为在字符串前添加一个<code>r</code>字符:<code>r&#39;content&#39;</code>，通过这样的书写方式，Python解释器将使用不同的规则来解释转义(原始字符串不能以<code>\</code>符号结尾)。因此上述模式可以简化为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'\\\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pat = re.compile(<span class="string">r'\\\n'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pat.pattern</span><br><span class="line"><span class="string">'\\\\\\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pat.search(s)</span><br><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">2</span>), match=<span class="string">'\\\n'</span>&gt;</span><br></pre></td></tr></table></figure><p>让我们再回到普通字符串，考虑以下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'\\\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pat = re.compile(<span class="string">'\\\n'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pat.pattern</span><br><span class="line"><span class="string">'\\\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pat.search(s)</span><br><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">1</span>, <span class="number">2</span>), match=<span class="string">'\n'</span>&gt;</span><br></pre></td></tr></table></figure><p>对于模式<code>\\\n</code>，经过Python解释器的解释将变成一个普通’`字符和一个换行字符<code>\n</code>，<code>re</code>模块的<code>compile</code>方法将会看到以上解释结果，然后该模式组合起来就是:<strong>匹配一个换行字符<code>\n</code>的转义字符</strong>，也就是对换行字符<code>\n</code>进行转义！结果是:</p><div class="tip">对一个转义字符进行转义将会得到其本身</div><p>相关连接:</p><ul><li><a href="https://docs.python.org/3.6/library/re.html" target="_blank" rel="noopener">Regular expression operations</a></li><li><a href="http://stackoverflow.com/questions/33582162/backslashes-in-python-regular-expressions" target="_blank" rel="noopener">Backslashes in Python Regular Expressions</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正则表达式是一个十分强大的工具，可以完成对字符串的模式匹配以及提取工作，在很多工程中都被广泛使用，但是我之前对于Python正则表达式模块&lt;code&gt;re&lt;/code&gt;的使用都没有进行一些深入学习，对&lt;strong&gt;原始字符串&lt;/strong&gt;之类的了解也比较浅显，之前有个同学问到我关于反斜线&lt;code&gt;\&lt;/code&gt;在正则中的一些表现的时候我也迷惑了，跟周围人讨论后上&lt;a href=&quot;http://stackoverflow.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;StackOverflow&lt;/a&gt;问了一番，对这方面又多了一些了解，今天跟大家分享。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="正则" scheme="http://youchen.me/tags/%E6%AD%A3%E5%88%99/"/>
    
      <category term="re模块" scheme="http://youchen.me/tags/re%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>使用一维索引数组访问高维数组元素</title>
    <link href="http://youchen.me/2017/03/30/CPP-Access-n-d-array-with-1-d-index-array/"/>
    <id>http://youchen.me/2017/03/30/CPP-Access-n-d-array-with-1-d-index-array/</id>
    <published>2017-03-30T06:34:10.000Z</published>
    <updated>2018-01-13T00:50:39.840Z</updated>
    
    <content type="html"><![CDATA[<p>这是这两天看书偶然间突然间想到的一个问题，假设有一个高维数组，比如3维整型数组<code>int arr[10][10][10];</code>，用户每次输入对应维数个数(3)个参数，存入一个索引数组<code>int idx[3]</code>中，根据索引返回对应索引的元素值。在低维情况下，可以采取直接访问的方式，比如输入的索引值为<code>idx[0] = 1, idx[1] = 2, idx[2] = 3</code>，可以通过<code>arr[idx[0]][idx[1]][idx[2]]</code>访问，但是如果数组维度太高，这样的方式就不可行了，比如<code>arr[idx[0]][idx[1]]....[idx[n]]</code>。所以需要换种方式。</p><a id="more"></a><p><strong>指针</strong></p><p>我们知道，C/C++中数组的存放是采用连续内存单元的形式:</p><p><img src="/2017/03/30/CPP-Access-n-d-array-with-1-d-index-array/c_1d_array.png" alt="c_1d_array"></p><p>对一个长度为6的一维整型数组(<code>int a[6]</code>)，运行时将会分配一段连续的内存，我们可以通过<code>a[4]</code>来访问元素，其实这可以看做隐式的指针访问，即<code>*(a+4)</code>，该操作将会访问到第5个元素也就是<code>4</code>。</p><p>对<code>*(a+4)</code>的访问过程可以这么理解:</p><ol><li>得到数组a的基地址</li><li>在基地址的基础上加上偏移量<code>4</code></li><li>获取该地址对应的整型值</li></ol><p>下面来看二维的情况。</p><p><img src="/2017/03/30/CPP-Access-n-d-array-with-1-d-index-array/c_2d_array.png" alt="c_2d_array"></p><p>对一个维度为3*3的二维整型数组(<code>int b[3][3]</code>)，运行时仍然会分配一段连续的内存，直接访问的方式和上面讲的一样，比如<code>b[1][2]</code>，同样，这可以看做<code>*(*(b+1)+2)</code>，该操作会访问到第二行第三列的元素也就是<code>5</code>，其中，<code>b+1</code>的操作对应于取第几行元素，<code>+2</code>的操作就对应于一维的偏移了，具体细节不再展开讨论。</p><p>因此对于一个高维数组，比如四维数组<code>int c[5][5][5][5]</code>，<code>c[0][1][2][3]</code>代表的意思即是取<code>c</code>数组中第一维维度为<code>0</code>、第二维维度为<code>1</code>、第三维维度为<code>2</code>、第四维维度为<code>3</code>的对应元素，有了这样的理解，再看<code>*(*(*(*(c+0)+1)+2)+3)</code>就清晰多了。</p><p><strong>问题</strong></p><p>那么对于一个高维数组(100维、1000维等等)，就没有办法用代码直接写<code>*(*(*(....*(d+k1)+k2)+...+kn)</code>了，所以需要换个思路。</p><p>既然内存单元存储的是实际值或者是地址，那么经过多次寻址，我们可以找到需要的实际值，那么怎么完成这个操作呢？</p><p>我们仍然使用四维数组为例，假设有:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>][<span class="number">10</span>][<span class="number">10</span>][<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>同时，索引数组为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> idx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><p>我们想要的结果是得到<code>1</code>，可以直接通过<code>arr[idx[0]][idx[1]][idx[2]][idx[3]]</code>访问，但之前也说过了，这样的代码无法适用于高维情况。</p><p><strong><code>void *</code>(不那么好)</strong></p><p>最开始我想到的方式是使用<code>void *</code>指针，因为C中任意指针都可以赋值给<code>void *</code>指针，那么我们访问元素的思路可以这么理解:</p><ol><li>将数组<code>arr</code>的基地址赋值给<code>void *</code>指针</li><li>根据每一维索引的偏移量以及<code>int</code>类型的大小计算<code>void *</code>指针的值</li><li>将<code>void *</code>指针强制类型转换为<code>int *</code>指针并进行元素访问<code>*p</code></li></ol><p>需要注意的是第二步中，索引的偏移量代表的是<code>int</code>尺度的偏移，即对于<code>int a[2]</code>, <code>&amp;a[0]</code>和<code>&amp;a[1]</code>之间的偏移量，因此需要乘以<code>int</code>类型的大小。根据上面的描述，测试代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[N][N][N][N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> idx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    arr[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Expected: "</span>&lt;&lt;arr[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>]&lt;&lt;<span class="string">" at "</span>&lt;&lt;&amp;arr[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *p = arr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        p += idx[i] * <span class="keyword">int</span>(<span class="built_in">pow</span>(N, <span class="number">3</span>-i)) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Got with void *: "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*((<span class="keyword">int</span>*)p)&lt;&lt;<span class="string">" at "</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test.cpp: In function &apos;int main()&apos;:</span><br><span class="line">test.cpp:21:53: warning: pointer of type &apos;void *&apos; used in arithmetic [-Wpointer-arith]</span><br><span class="line">         p += idx[i] * int(pow(10, 3-i)) * sizeof(int);</span><br><span class="line">                                                     ^</span><br><span class="line">Expected: 1 at 0x7fff5cb20f18</span><br><span class="line">Got with void *: 1 at 0x7fff5cb20f18</span><br></pre></td></tr></table></figure><p>程序正确地得到了我们想要的结果，但是编译器给出了警告，因为<code>void *</code>指针是未知类型指针，因此编译器并不知道相关计算，另外还有在计算偏移尺度的时候，使用了<code>pow</code>函数而且使用了强制类型转换将其转为<code>int</code>，这可能导致舍入误差。</p><p><strong><code>int *</code>改进</strong></p><p>对于前述的方法，我们可以使用<code>int *</code>指针以及自己计算偏移尺度进行改进，通过将<code>arr</code>进行强制类型转换，赋值给整型指针<code>p</code>，在前面我们谈到数组的内存分配是连续的，因此我们只需要正确的计算出偏移量即可通过<code>p</code>指针得到所需要的值，此时因为使用的是整型指针<code>p</code>，因此不再需要乘以<code>sizeof(int)</code>，可以理解为<code>p+1</code>指向了下一个整型单元。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[N][N][N][N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> idx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    arr[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Expected: "</span>&lt;&lt;arr[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>]&lt;&lt;<span class="string">" at "</span>&lt;&lt;&amp;arr[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)arr;</span><br><span class="line">    <span class="keyword">int</span> offset = <span class="number">1e3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p += idx[i] * offset;</span><br><span class="line">        offset /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Got with int *: "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="string">" at "</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Expected: 1 at 0x7fff51d37f08</span><br><span class="line">Got with int *: 1 at 0x7fff51d37f08</span><br></pre></td></tr></table></figure><p><strong>后话</strong></p><p>以上方法需要对指针以及指针的运算有一定的了解，当然，更多情况下，我们完全可以将高维数组展开成低维甚至一维数组，这样的访问将会很方便。或许处理这种问题还有其他更好的方式，有兴趣的读者可以自行研究。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是这两天看书偶然间突然间想到的一个问题，假设有一个高维数组，比如3维整型数组&lt;code&gt;int arr[10][10][10];&lt;/code&gt;，用户每次输入对应维数个数(3)个参数，存入一个索引数组&lt;code&gt;int idx[3]&lt;/code&gt;中，根据索引返回对应索引的元素值。在低维情况下，可以采取直接访问的方式，比如输入的索引值为&lt;code&gt;idx[0] = 1, idx[1] = 2, idx[2] = 3&lt;/code&gt;，可以通过&lt;code&gt;arr[idx[0]][idx[1]][idx[2]]&lt;/code&gt;访问，但是如果数组维度太高，这样的方式就不可行了，比如&lt;code&gt;arr[idx[0]][idx[1]]....[idx[n]]&lt;/code&gt;。所以需要换种方式。&lt;/p&gt;
    
    </summary>
    
      <category term="CPP" scheme="http://youchen.me/categories/CPP/"/>
    
    
      <category term="CPP" scheme="http://youchen.me/tags/CPP/"/>
    
      <category term="指针" scheme="http://youchen.me/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="数组" scheme="http://youchen.me/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>基于Scrapy的京东商品评论爬虫</title>
    <link href="http://youchen.me/2017/03/12/Python-A-JD-spider-based-on-scrapy/"/>
    <id>http://youchen.me/2017/03/12/Python-A-JD-spider-based-on-scrapy/</id>
    <published>2017-03-12T14:07:57.000Z</published>
    <updated>2018-01-15T01:18:04.489Z</updated>
    
    <content type="html"><![CDATA[<p>今天想跟大家分享的是关于网络爬虫的相关知识，网络爬虫是一种根据一定的规则，自动地对互联网上相关内容进行抓取的程序或者脚本，本文的内容主要是通过分析京东评论的加载过程，获取相关API，然后通过使用基于Python语言的开源网络爬虫框架——Scrapy，大量获取相关评论内容。</p><div class="tip"><br>本文假定读者具有一定的Python编程经验，具有少量HTTP协议和HTML的相关知识，对爬虫的工作原理有一定了解。<br></div><a id="more"></a><h1 id="API获取"><a href="#API获取" class="headerlink" title="API获取"></a>API获取</h1><p>在开始编写爬虫之前，我们需要获得启动爬虫所需要的相关链接。在本文，我们将以对京东鞋类评论爬取为例，进行说明(其他种类爬取流程类似，区别只在于数据处理)。<br>首先打开京东，搜索“鞋”，打开任意一件商品，并切换到“商品评价”标签页，如图所示。</p><p><img src="/2017/03/12/Python-A-JD-spider-based-on-scrapy/item_shoe_comments_tab.png" alt="comments_tab"></p><p>启用浏览器的网页分析功能，以Safari浏览器为例，右键点击网页任意部分，选择”检查元素“，切换到“网络”标签下，如果有其他内容的话，可以点击右侧的垃圾桶图标清空历史，如图所示。</p><p><img src="/2017/03/12/Python-A-JD-spider-based-on-scrapy/console_network_before.png" alt="console_network_before"></p><p>然后我们点击评论区的换页按钮，切换到任意一页新的评论，此时可以发现浏览器对本次点击产生的数据交换过程进行了记录，我们发现其中有一条名为”productPageComments.action”的记录，对其进行分析可以看到对应的完整URL，如图所示。</p><p><img src="/2017/03/12/Python-A-JD-spider-based-on-scrapy/console_network_after.png" alt="console_network_after"></p><p>其完整URL为:<code>https://club.jd.com/comment/productPageComments.action?callback=fetchJSON_comment98vv6630&amp;productId=10353518575&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0</code></p><p>显而易见，评论的加载是通过GET请求实现，对我们来说，该URL中最关键的GET参数为<code>productID</code>和<code>page</code>，它们分别定义了对应的商品编号以及评论页码。通过访问该URL，我们可以得到内容如图所示。</p><p><img src="/2017/03/12/Python-A-JD-spider-based-on-scrapy/comments_json_1.png" alt="comments_json_1"></p><p>可以看到，该URL返回的内容为json数据包，同时以请求中<code>callback</code>定义的函数名对其进行包裹，这一点从整个数据包最前方可以看出。我们将GET请求中callback参数去掉以后即可得到原始的json数据包，如图所示。</p><p><img src="/2017/03/12/Python-A-JD-spider-based-on-scrapy/comments_json_2.png" alt="comments_json_2"></p><p>因此，在不考虑其他参数的情况下，我们需要的API格式为:<code>https://club.jd.com/comment/productPageComments.action?productId={}&amp;score=0&amp;sortType=5&amp;page={}&amp;pageSize=10&amp;isShadowSku=0</code></p><p>至此，我们获得了返回任意商品的任意评论页的API，下面我们将对API返回数据本身的内容进行分析。</p><h1 id="API返回字典分析"><a href="#API返回字典分析" class="headerlink" title="API返回字典分析"></a>API返回字典分析</h1><p>从前面图中可以看出，API返回数据应该是一个字典，我们通过使用requests获得API返回字典以及Python的json模块进行分析。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'https://club.jd.com/comment/productPageComments.action?productId=10353518575&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>html = requests.get(url)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = json.loads(html.text)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(data.keys())</span><br><span class="line">dict_keys([<span class="string">'productAttr'</span>, <span class="string">'productCommentSummary'</span>, <span class="string">'hotCommentTagStatistics'</span>,</span><br><span class="line"><span class="string">'jwotestProduct'</span>, <span class="string">'maxPage'</span>, <span class="string">'score'</span>, <span class="string">'soType'</span>, <span class="string">'imageListCount'</span>,</span><br><span class="line"><span class="string">'vTagStatistics'</span>, <span class="string">'comments'</span>])</span><br></pre></td></tr></table></figure><p>其中对我们来说最重要的是键<code>comments</code>所对应的值，值为一个列表，其中每个元素为一个字典，存放的是每一条评论的相关信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(data[<span class="string">'comments'</span>]))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">import</span> <span class="title">pprint</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">pprint</span><span class="params">(data[<span class="string">'comments'</span>][<span class="number">0</span>])</span></span></span><br><span class="line">&#123;'afterDays': 0,</span><br><span class="line"> <span class="string">'anonymousFlag'</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="string">'commentTags'</span>: [&#123;<span class="string">'commentId'</span>: <span class="number">1927838458</span>,</span><br><span class="line">                  <span class="string">'created'</span>: <span class="string">'2016-10-19 18:26:50'</span>,</span><br><span class="line">                  <span class="string">'id'</span>: <span class="number">12373951</span>,</span><br><span class="line">                  <span class="string">'modified'</span>: <span class="string">'2016-10-19 18:26:50'</span>,</span><br><span class="line">                  <span class="string">'name'</span>: <span class="string">'穿上很舒服'</span>,</span><br><span class="line">                  <span class="string">'pin'</span>: <span class="string">''</span>,</span><br><span class="line">                  <span class="string">'productId'</span>: <span class="number">10353518575</span>,</span><br><span class="line">                  <span class="string">'rid'</span>: <span class="number">11632</span>,</span><br><span class="line">                  <span class="string">'status'</span>: <span class="number">0</span>&#125;],</span><br><span class="line"> <span class="string">'content'</span>: <span class="string">'鞋子很不错，弹性很不错，材质很轻。穿上很舒服。透气性好，而且又长高了两厘米。'</span>,</span><br><span class="line"> <span class="string">'creationTime'</span>: <span class="string">'2016-10-19 18:26:20'</span>,</span><br><span class="line"> <span class="string">'days'</span>: <span class="number">8</span>,</span><br><span class="line"> <span class="string">'firstCategory'</span>: <span class="number">1318</span>,</span><br><span class="line"> <span class="string">'guid'</span>: <span class="string">'cc2fec79-304b-48c5-a263-151bf7d098d2'</span>,</span><br><span class="line"> <span class="string">'id'</span>: <span class="number">1927838458</span>,</span><br><span class="line"> <span class="string">'integral'</span>: <span class="number">-20</span>,</span><br><span class="line"> <span class="string">'isMobile'</span>: <span class="keyword">False</span>,</span><br><span class="line"> <span class="string">'isReplyGrade'</span>: <span class="keyword">False</span>,</span><br><span class="line"> <span class="string">'isTop'</span>: <span class="keyword">False</span>,</span><br><span class="line"> <span class="string">'nickname'</span>: <span class="string">'j***k'</span>,</span><br><span class="line"> <span class="string">'orderId'</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="string">'plusAvailable'</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="string">'productColor'</span>: <span class="string">'黑/安踏白'</span>,</span><br><span class="line"> <span class="string">'productSales'</span>: [],</span><br><span class="line"> <span class="string">'productSize'</span>: <span class="string">'8(男41)'</span>,</span><br><span class="line"> <span class="string">'recommend'</span>: <span class="keyword">True</span>,</span><br><span class="line"> <span class="string">'referenceId'</span>: <span class="string">'10353518575'</span>,</span><br><span class="line"> <span class="string">'referenceImage'</span>: <span class="string">'jfs/t3073/150/7342609081/176958/b211c3f7/58b4c73cN9621804d.jpg'</span>,</span><br><span class="line"> <span class="string">'referenceName'</span>: <span class="string">'安踏男鞋 易弯折科技跑步鞋 2017新款透气网面运动鞋 黑/安踏白-1 8(男41)'</span>,</span><br><span class="line"> <span class="string">'referenceTime'</span>: <span class="string">'2016-10-11 20:03:00'</span>,</span><br><span class="line"> <span class="string">'referenceType'</span>: <span class="string">'Product'</span>,</span><br><span class="line"> <span class="string">'referenceTypeId'</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="string">'replyCount'</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="string">'score'</span>: <span class="number">5</span>,</span><br><span class="line"> <span class="string">'secondCategory'</span>: <span class="number">12099</span>,</span><br><span class="line"> <span class="string">'status'</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="string">'thirdCategory'</span>: <span class="number">9756</span>,</span><br><span class="line"> <span class="string">'title'</span>: <span class="string">''</span>,</span><br><span class="line"> <span class="string">'usefulVoteCount'</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="string">'uselessVoteCount'</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="string">'userClient'</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="string">'userClientShow'</span>: <span class="string">''</span>,</span><br><span class="line"> <span class="string">'userImage'</span>: <span class="string">'misc.360buyimg.com/lib/img/u/b56.gif'</span>,</span><br><span class="line"> <span class="string">'userImageUrl'</span>: <span class="string">'misc.360buyimg.com/lib/img/u/b56.gif'</span>,</span><br><span class="line"> <span class="string">'userImgFlag'</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="string">'userLevelColor'</span>: <span class="string">'#666666'</span>,</span><br><span class="line"> <span class="string">'userLevelId'</span>: <span class="string">'56'</span>,</span><br><span class="line"> <span class="string">'userLevelName'</span>: <span class="string">'铜牌会员'</span>,</span><br><span class="line"> <span class="string">'userProvince'</span>: <span class="string">''</span>,</span><br><span class="line"> <span class="string">'viewCount'</span>: <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p>根据实际需要，在本次实现中选取了以下信息:</p><ul><li>guid                –&gt; 评论用户id</li><li>id                –&gt; 该评论id</li><li>referenceId        –&gt; 评论商品id</li><li>creationTime    –&gt; 评论时间</li><li>score            –&gt; 评论评分</li><li>userProvince    –&gt; 评论用户归属地</li><li>userLevelName    –&gt; 评论用户会员级别</li><li>productColor    –&gt; 评论用户购买颜色</li><li>productSize        –&gt; 评论用户购买尺寸</li></ul><p>至此，我们完成了对API返回字典的分析，在构建Scrapy爬虫之前，我们还需要对商品列表进行分析。</p><h1 id="商品列表分析"><a href="#商品列表分析" class="headerlink" title="商品列表分析"></a>商品列表分析</h1><p>我们已经拥有对任意给定的商品id,获取其所有评论的API，但在构建爬虫之前，我们还有最后一个问题，如何获得商品id?<br>我们可以很容易的获得并格式化京东的搜索链接:<code>https://search.jd.com/Search?keyword={}&amp;enc=utf-8&amp;page={}</code>，根据该格式化链接，我们只需要填写搜索关键字以及搜索页码就能得到对应页的搜索结果。通过对网页源代码进行分析，可以发现每个商品都处于<code>class=&quot;gl-item&quot;</code>的<code>li</code>元素下，如图所示。</p><p><img src="/2017/03/12/Python-A-JD-spider-based-on-scrapy/console_item_list.png" alt="console_item_list"><br><img src="/2017/03/12/Python-A-JD-spider-based-on-scrapy/console_item_list_2.png" alt="console_item_list_2"></p><p>我们只需要对<code>class=&quot;gl-item&quot;</code>的<code>li</code>元素下<code>class=&quot;p-img&quot;</code>的<code>div</code>元素下的<code>a</code>元素的<code>href</code>属性进行提取处理即可得到商品id，如图中的<code>10353518575</code>。</p><p>至此，我们完成了对商品列表的分析工作，接下来我们将构建基于Scrapy的爬虫来完成对评论的爬取工作。</p><h1 id="可选-商品详细信息"><a href="#可选-商品详细信息" class="headerlink" title="(可选)商品详细信息"></a>(可选)商品详细信息</h1><p>我们在上节中获得了商品的详细信息链接，如:<code>https://item.jd.com/10353518575.html</code>，我们可以对该页面内容进行爬取以获得更全面的商品信息。在这部分需要注意的是，很多内容是通过JavaScript进行动态加载的，在爬取时需要注意，否则得到的数据并不符合需要。通过启用浏览器的“停用JavaScript”功能，可以看到在不执行JavaScript时的页面是什么样的，如图所示。</p><p><img src="/2017/03/12/Python-A-JD-spider-based-on-scrapy/item_detail_no_js.png" alt="item_detail_no_js"></p><p>可以看到，商品的价格等信息是没有进行加载的，所以如果需要对价格进行爬取，需要使用到selenium等工具来完成浏览器的模拟或者进一步分析JavaScript的执行逻辑。</p><h1 id="Scrapy爬虫"><a href="#Scrapy爬虫" class="headerlink" title="Scrapy爬虫"></a>Scrapy爬虫</h1><p>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。其最初是为了网络抓取所设计的，也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。</p><p>要使用Scrapy，首先得建立项目:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ scrapy startproject jd</span><br><span class="line">New Scrapy project &apos;jd&apos;, using template directory &apos;/usr/local/lib/python3.6/site-packages/scrapy/templates/project&apos;, created in:</span><br><span class="line">    /private/tmp/jd</span><br><span class="line"></span><br><span class="line">You can start your first spider with:</span><br><span class="line">    cd jd</span><br><span class="line">    scrapy genspider example example.com</span><br></pre></td></tr></table></figure><p>在建好的<code>jd</code>文件夹下，有一个<code>jd</code>文件夹以及一个<code>scrapy.cfg</code>文件，进入前者，可以看到以下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">__init__.py    items.py       pipelines.py   spiders</span><br><span class="line">__pycache__    middlewares.py settings.py</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li>items.py         –&gt; 完成数据容器Item的定义<br>  爬取的主要目标就是从非结构性的数据源提取结构性数据，例如网页。Scrapy提供 Item 类来满足这样的需求。Item 对象是种简单的容器，保存了爬取到得数据。 其提供了 类似于词典(dictionary-like) 的API以及用于声明可用字段的简单语法。</li><li>pipelines.py    –&gt; 完成对Item处理流水线的定义<br>  当Item在Spider中被收集之后，它将会被传递到Item Pipeline，一些组件会按照一定的顺序执行对Item的处理。每个item pipeline组件(有时称之为“Item Pipeline”)是实现了简单方法的Python类。他们接收到Item并通过它执行一些行为，同时也决定此Item是否继续通过pipeline，或是被丢弃而不再进行处理。<br>  以下是item pipeline的一些典型应用：<ul><li>清理HTML数据</li><li>验证爬取的数据(检查item包含某些字段)</li><li>查重(并丢弃)</li><li>将爬取结果保存到数据库中</li></ul></li><li>middlewares.py    –&gt; 完成Spider中间件的定义<br>  Spider中间件是介入到Scrapy的spider处理机制的钩子框架，通过定义并使用中间件，可以对发送给Spiders的response以及Spiders产生的Request对象进行处理。</li><li>settings.py        –&gt; 完成对爬虫的控制<br>  Scrapy settings提供了定制Scrapy组件的方法。通过修改settings.py，可以控制包括核心(core)，插件(extension)，pipeline及spider组件。settings为代码提供了提取以key-value映射的配置值的的全局命名空间(namespace)。settings同时也是选择当前激活的Scrapy项目的方法。</li><li>spiders            –&gt; 完成对爬虫Spider的定义<br>  Spider类定义了如何爬取某个(或某些)网站。包括了爬取的动作(例如:是否跟进链接)以及如何从网页的内容中提取结构化数据(爬取item)。换句话说，Spider就是定义爬取的动作及分析某个网页(或者是有些网页)的地方。</li></ul><h4 id="定义数据容器items"><a href="#定义数据容器items" class="headerlink" title="定义数据容器items"></a>定义数据容器items</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeCommentItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    <span class="comment"># name = scrapy.Field()</span></span><br><span class="line">    _id = scrapy.Field()</span><br><span class="line">    iid = scrapy.Field()</span><br><span class="line">    uid = scrapy.Field()</span><br><span class="line">    creation_time = scrapy.Field()</span><br><span class="line">    score = scrapy.Field()</span><br><span class="line">    user_province = scrapy.Field()</span><br><span class="line">    user_level = scrapy.Field()</span><br><span class="line">    color = scrapy.Field()</span><br><span class="line">    size = scrapy.Field()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeDetailItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    iid = scrapy.Field()</span><br><span class="line">    name = scrapy.Field()</span><br><span class="line">    shop = scrapy.Field()</span><br><span class="line">    scores = scrapy.Field()</span><br></pre></td></tr></table></figure><h4 id="定义爬虫类"><a href="#定义爬虫类" class="headerlink" title="定义爬虫类"></a>定义爬虫类</h4><p>创建爬虫类的命令为:<code>scrapy genspider [爬虫名] [允许爬取域名]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ scrapy genspider shoes jd.com</span><br><span class="line">Created spider &apos;shoes&apos; using template &apos;basic&apos; in module:</span><br><span class="line">  jd.spiders.shoes</span><br></pre></td></tr></table></figure><p>接着打开<code>spiders</code>文件夹下的<code>shoes.py</code>文件进行编辑:</p><ul><li><p>首先我们需要定义一些变量，比如包含搜索关键字的列表、格式化搜索链接、格式化评论API链接等:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shoe_cates = [</span><br><span class="line">    <span class="string">'女深口单鞋'</span>, <span class="string">'工装鞋'</span>, <span class="string">'女鞋'</span>, <span class="string">'正装鞋'</span>, <span class="string">'平底鞋'</span>, <span class="string">'平底女鞋'</span>,</span><br><span class="line">    <span class="string">'功能鞋'</span>, <span class="string">'中跟单鞋'</span>, <span class="string">'女拖鞋'</span>, <span class="string">'凉鞋'</span>, <span class="string">'拖鞋'</span>, <span class="string">'帆布鞋'</span>, <span class="string">'人字拖'</span>,</span><br><span class="line">    <span class="string">'马丁靴'</span>, <span class="string">'商务休闲鞋'</span>, <span class="string">'传统布鞋'</span>, <span class="string">'休闲鞋'</span>, <span class="string">'鞋'</span>, <span class="string">'棉鞋'</span>, <span class="string">'定制鞋'</span>,</span><br><span class="line">    <span class="string">'男靴'</span>, <span class="string">'坡跟单鞋'</span>, <span class="string">'短靴'</span>, <span class="string">'雨鞋'</span>, <span class="string">'平板鞋'</span>, <span class="string">'尖头单鞋'</span>, <span class="string">'军靴'</span>, <span class="string">'女靴'</span>,</span><br><span class="line">    <span class="string">'皮鞋'</span>, <span class="string">'小白鞋'</span>, <span class="string">'雪地靴'</span>, <span class="string">'女豆豆鞋'</span>, <span class="string">'妈妈鞋'</span>, <span class="string">'增高鞋'</span>, <span class="string">'劳保鞋'</span>,</span><br><span class="line">    <span class="string">'豆豆鞋'</span>, <span class="string">'踝靴'</span>, <span class="string">'沙滩鞋'</span>, <span class="string">'鞋 女'</span>, <span class="string">'深口单鞋'</span>, <span class="string">'板鞋'</span>, <span class="string">'高帮鞋'</span>,</span><br><span class="line">    <span class="string">'人字拖鞋'</span>, <span class="string">'内增高'</span>, <span class="string">'发光鞋'</span>, <span class="string">'运动鞋'</span>, <span class="string">'高跟鞋'</span>, <span class="string">'雨靴'</span>, <span class="string">'鞋 男'</span>,</span><br><span class="line">    <span class="string">'乐福鞋'</span>, <span class="string">'内增高休闲鞋'</span>, <span class="string">'老人鞋'</span>, <span class="string">'男鞋'</span>, <span class="string">'平底单鞋'</span>, <span class="string">'浅口单鞋'</span>, <span class="string">'单鞋'</span>]</span><br><span class="line">shoe_list_url = <span class="string">'https://search.jd.com/Search?keyword=&#123;&#125;&amp;enc=utf-8&amp;page=&#123;&#125;'</span></span><br><span class="line">comment_url_api = (<span class="string">'https://club.jd.com/comment/productPageComments.action?'</span></span><br><span class="line">    <span class="string">'productId=&#123;&#125;&amp;score=0&amp;sortType=5&amp;page=&#123;&#125;&amp;pageSize=10&amp;isShadowSku=0'</span>)</span><br><span class="line">num_pat = re.compile(<span class="string">'(\d*?)'</span>)</span><br></pre></td></tr></table></figure></li><li><p>然后编辑<code>ShoesSpider</code>类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoesSpider</span><span class="params">(Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'shoes'</span></span><br><span class="line">    allowed_domains = [<span class="string">'jd.com'</span>]</span><br><span class="line">    start_urls = [shoe_list_url.format(cate, page) <span class="keyword">for</span> cate <span class="keyword">in</span> shoe_cates</span><br><span class="line">                  <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        item_urls = response.xpath(<span class="string">'//li[@class="gl-item"]/div'</span>)</span><br><span class="line">        <span class="keyword">for</span> item_xpath <span class="keyword">in</span> item_urls:</span><br><span class="line">            url = item_xpath.xpath(<span class="string">'div[@class="p-img"]/a'</span></span><br><span class="line">                                   <span class="string">'/@href'</span>).extract_first()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> url <span class="keyword">or</span> <span class="string">'ccc-x'</span> <span class="keyword">in</span> url:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            iid = url[url.rfind(<span class="string">'/'</span>)+<span class="number">1</span>:<span class="number">-5</span>]</span><br><span class="line">            detail_url = <span class="string">'http:'</span> + url</span><br><span class="line">            <span class="keyword">yield</span> Request(</span><br><span class="line">                detail_url,</span><br><span class="line">                callback=self.parse_detail,</span><br><span class="line">                meta=&#123;<span class="string">'iid'</span>: iid&#125;)</span><br><span class="line">            <span class="keyword">yield</span> Request(</span><br><span class="line">                comment_url_api.format(iid, <span class="number">1</span>),</span><br><span class="line">                callback=self.parse_comment,</span><br><span class="line">                meta=&#123;<span class="string">'page'</span>: <span class="number">1</span>, <span class="string">'iid'</span>: iid, <span class="string">'retry'</span>: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_detail</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        iid = int(response.meta[<span class="string">'iid'</span>])</span><br><span class="line">        name = response.xpath(<span class="string">'//div[@class="sku-name"]'</span></span><br><span class="line">                              <span class="string">'/text()'</span>).extract_first().strip(<span class="string">'\n '</span>)</span><br><span class="line">        xpath_aside = response.xpath(<span class="string">'//div[@class="aside"]'</span>)</span><br><span class="line">        shop = xpath_aside.xpath(<span class="string">'//div[@class="mt"]/'</span></span><br><span class="line">                                 <span class="string">'h3/a/@title'</span>).extract_first().strip(<span class="string">'\n '</span>)</span><br><span class="line">        scores = xpath_aside.xpath(<span class="string">'//div[@class="mc"]/div/'</span></span><br><span class="line">                                   <span class="string">'a//text()'</span>).extract()</span><br><span class="line">        scores = [s <span class="keyword">for</span> s <span class="keyword">in</span> scores <span class="keyword">if</span> s.strip(<span class="string">'\n '</span>)][::<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        sd = ShoeDetailItem(iid=iid, name=name, shop=shop,</span><br><span class="line">                            scores=<span class="string">'|'</span>.join(scores))</span><br><span class="line">        <span class="keyword">yield</span> sd</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_comment</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        iid = response.meta[<span class="string">'iid'</span>]</span><br><span class="line">        page = int(response.meta[<span class="string">'page'</span>])</span><br><span class="line">        retry = int(response.meta[<span class="string">'retry'</span>])</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            json_data = json.loads(response.text)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> retry &lt; <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">yield</span> Request(</span><br><span class="line">                    comment_url_api.format(iid, page),</span><br><span class="line">                    callback=self.parse_comment,</span><br><span class="line">                    meta=&#123;<span class="string">'page'</span>: page, <span class="string">'iid'</span>: iid, <span class="string">'retry'</span>: retry+<span class="number">1</span>&#125;)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> json_data[<span class="string">'comments'</span>]:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> cd <span class="keyword">in</span> json_data[<span class="string">'comments'</span>]:</span><br><span class="line">            d = &#123;&#125;</span><br><span class="line">            d[<span class="string">'_id'</span>] = cd[<span class="string">'id'</span>]</span><br><span class="line">            d[<span class="string">'iid'</span>] = cd[<span class="string">'referenceId'</span>]</span><br><span class="line">            d[<span class="string">'uid'</span>] = cd[<span class="string">'guid'</span>]</span><br><span class="line">            d[<span class="string">'creation_time'</span>] = cd[<span class="string">'creationTime'</span>]</span><br><span class="line">            d[<span class="string">'score'</span>] = cd[<span class="string">'score'</span>]</span><br><span class="line">            d[<span class="string">'user_province'</span>] = cd[<span class="string">'userProvince'</span>]</span><br><span class="line">            d[<span class="string">'user_level'</span>] = cd[<span class="string">'userLevelName'</span>]</span><br><span class="line">            d[<span class="string">'color'</span>] = cd[<span class="string">'productColor'</span>]</span><br><span class="line">            d[<span class="string">'size'</span>] = cd[<span class="string">'productSize'</span>]</span><br><span class="line">            sc = ShoeCommentItem(d)</span><br><span class="line">            <span class="keyword">yield</span> sc</span><br><span class="line">        <span class="keyword">yield</span> Request(</span><br><span class="line">            comment_url_api.format(iid, page+<span class="number">1</span>),</span><br><span class="line">            callback=self.parse_comment,</span><br><span class="line">            meta=&#123;<span class="string">'page'</span>: page+<span class="number">1</span>, <span class="string">'iid'</span>: iid, <span class="string">'retry'</span>: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>详细分析下这段代码:</p><ul><li>类<code>ShoesSpider</code>继承自<code>Spider</code>，其余可继承的类还有<code>CrawlSpider</code>、<code>XMLFeedSpider</code>、<code>SitemapSpider</code>，在这里我们使用了最基本的<code>Spider</code>。</li><li>属性<code>name</code>定义了该爬虫的名字，在启动爬虫的步骤中需要提供爬虫名字。</li><li>属性<code>allowed_domains</code>定义了一个列表，可以包含一个或多个域名，爬虫只会对该域名下的链接进行爬取。</li><li>属性<code>start_urls</code>定义了一个列表，spider启动时将从中获取链接进行爬取。</li><li>实例方法<code>parse</code>定义了对商品列表页面进行处理的相关逻辑:<ul><li>接收一个<code>response</code>参数，该<code>response</code>对象为爬虫根据<code>Request</code>对象请求获得的结果。</li><li>根据前面几节的描述，<code>parse</code>方法针对商品列表页面使用xpath进行分析。</li><li>在提取到商品<code>iid</code>后，对该页面下所有商品<code>iid</code>进行遍历，分别为商品详细页面(可选)以及商品评论页面构建<code>Request</code>请求，注意使用了<code>yield</code>，因为我们需要返回多个请求而不是一个请求。</li><li>对每个<code>Request</code>请求，我们指定了相关参数，比如链接、回调函数，以及通过<code>meta</code>关键字保存上下文信息字典，这可以在回调函数中访问<code>Response</code>的<code>meta</code>属性获得。</li></ul></li><li>实例方法<code>parse_detail</code>定义了对商品详细页面进行处理的相关逻辑:<ul><li>我们依然通过xpath进行分析，获得了商品名、商家名、商家评分等信息，使用其实例化<code>ShoeDetailItem</code>类并返回该实例。</li></ul></li><li>实例方法<code>parse_comment</code>定义了对商品评论进行处理的相关逻辑:<ul><li>根据在<code>Request</code>对象中设置<code>meta</code>属性，我们可以很方便地获得当前物品id、当前评论页码、以及访问重试次数。</li><li>我们需要对<code>response</code>对象的<code>text</code>属性使用<code>json.loads</code>进行格式化，但是由于各种原因可能会失败，所以我们设置了方式重试次数这一变量来控制重试，当本次<code>json.loads</code>格式化失败，我们会再次进行尝试访问该评论链接，直到达到最大重试次数10次，然后放弃。</li><li>如果解析成功，判断解析后的字典中键<code>comments</code>所对应的内容是否为空，为空代表已经没有更多评论，则返回。</li><li>否则，对每条评论进行遍历，使用其中的参数实例化<code>ShoeCommentItem</code>类并返回该实例。</li><li>在结束评论遍历后，尝试对评论下一页发出<code>Request</code>请求。</li></ul></li></ul><p>至此，我们完成了爬虫的工作逻辑，接下来需要对流水线进行定义，完成数据的查重以及保存等操作。</p><h4 id="定义pipeline流水线"><a href="#定义pipeline流水线" class="headerlink" title="定义pipeline流水线"></a>定义pipeline流水线</h4><p>对于各个<code>parse</code>方法返回的<code>Item</code>对象，它们将会被传递到在<code>pipelines.py</code>中定义以及<code>settings.py</code>中启用的流水线中进行处理。<br>在本文中我们需要对每个<code>Item</code>对象做两件事，去重以及保存。对于<code>ShoeCommentItem</code>的流水线定义如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeCommentPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    seen_ids = set()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></span><br><span class="line">        pipe = cls()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'shoe_comments.csv'</span>):</span><br><span class="line">            <span class="keyword">return</span> pipe</span><br><span class="line">        pat = re.compile(<span class="string">'^\d+?,'</span>)</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'shoe_comments.csv'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                _id = pat.findall(line)</span><br><span class="line">                <span class="keyword">if</span> _id:</span><br><span class="line">                    pipe.seen_ids.add(_id[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> pipe</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(item, ShoeCommentItem):</span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">        _id = item[<span class="string">'_id'</span>]</span><br><span class="line">        <span class="keyword">if</span> _id <span class="keyword">in</span> self.seen_ids:</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">'&#123;&#125; Have been processed.'</span>.format(_id))</span><br><span class="line">        self.seen_ids.add(_id)</span><br><span class="line"></span><br><span class="line">        key_values = list(item.items())</span><br><span class="line">        key_values.sort(key=<span class="keyword">lambda</span> x: val_indices[x[<span class="number">0</span>]])</span><br><span class="line">        values = [str(val) <span class="keyword">for</span> key, val <span class="keyword">in</span> key_values]</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'shoe_comments.csv'</span>, <span class="string">'a'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="string">','</span>.join(values)+<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><p>需要解释的是类方法<code>from_crawler</code>和实例方法<code>process_item</code>，前者在初始化时会被调用，后者在出现<code>Item</code>对象时被调用。<br>对于<code>from_crawler</code>方法:</p><ul><li>我们需要忽略之前已经处理过的评论，因此采用了一个<code>set</code>来存储已经处理过的<code>id</code></li><li>在初始化时，打开之前保存的评论文件<code>shoe_comments.csv</code>，从中获取<code>id</code>并对<code>seen_ids</code>进行填充</li><li>这是一个类方法，需要在最后返回类的实例</li></ul><p>对于<code>process_item</code>方法:</p><ul><li>方法接收两个参数，前一个是返回的<code>Item</code>对象，后一个是返回该对象的对应<code>Spider</code>对象</li><li>首先判断了该<code>Item</code>是否是类<code>ShoeCommentItem</code>实例，如果不是的话不进行处理直接返回该对象</li><li>提取该对象的<code>id</code>并判断该对象是否已经处理过，已经处理过的话抛出<code>DropItem</code>异常，停止后续流水线的处理</li><li>将该对象<code>id</code>加入<code>seen_ids</code>，并根据<code>val_indices</code>定义的顺序将其排序及格式化字符串并追加到<code>shoe_comments.csv</code>中</li><li>返回该对象</li></ul><blockquote><p>需要特别注意的是，<code>process_item</code>方法必须返回一个<code>Item</code>(或任何继承类)对象或者是抛出<code>DropItem</code>异常，被丢弃的item将不会被之后的pipeline组件所处理，而正常返回的会。</p></blockquote><p>同理我们可以定义<code>ShoeDetailItem</code>的流水线:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeDetailPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    seen_ids = set()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></span><br><span class="line">        pipe = cls()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'shoe_details.csv'</span>):</span><br><span class="line">            <span class="keyword">return</span> pipe</span><br><span class="line">        pat = re.compile(<span class="string">'^\d+?,'</span>)</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'shoe_details.csv'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                iid = pat.findall(line)</span><br><span class="line">                <span class="keyword">if</span> iid:</span><br><span class="line">                    pipe.seen_ids.add(iid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> pipe</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(item, ShoeDetailItem):</span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">        iid = item[<span class="string">'iid'</span>]</span><br><span class="line">        <span class="keyword">if</span> iid <span class="keyword">in</span> self.seen_ids:</span><br><span class="line">            <span class="keyword">raise</span> DropItem(<span class="string">'&#123;&#125; detail have been processed.'</span>.format(iid))</span><br><span class="line">        self.seen_ids.add(iid)</span><br><span class="line"></span><br><span class="line">        key_values = list(item.items())</span><br><span class="line">        key_values.sort(key=<span class="keyword">lambda</span> x: detail_indices[x[<span class="number">0</span>]])</span><br><span class="line">        values = [str(val) <span class="keyword">for</span> key, val <span class="keyword">in</span> key_values]</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'shoe_details.csv'</span>, <span class="string">'a'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="string">','</span>.join(values)+<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><p>该流水线逻辑与前一个类似，在此不再赘述。</p><h4 id="settings-py的配置"><a href="#settings-py的配置" class="headerlink" title="settings.py的配置"></a>settings.py的配置</h4><p>我们还需要对<code>settings.py</code>进行配置。<br>其中关键的几个设置是:</p><ul><li>CONCURRENT_REQUESTS(并发请求数): 100</li><li>COOKIES_ENABLED(启用cookies): False</li><li>ITEM_PIPELINES(item流水线): {‘jd.pipelines.ShoeCommentPipeline’: 300, ‘jd.pipelines.ShoeDetailPipeline’: 301}</li></ul><p>具体设置可以根据自己的需求进行设置，以上只是一个示例。</p><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>最后，让我们启动这个爬虫:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scrapy crawl shoes</span><br></pre></td></tr></table></figure><p>可以在控制台看到输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">2017-03-13 19:21:12 [scrapy.utils.log] INFO: Scrapy 1.3.0 started (bot: jd)</span><br><span class="line">2017-03-13 19:21:12 [scrapy.utils.log] INFO: Overridden settings: &#123;&apos;BOT_NAME&apos;: &apos;jd&apos;, &apos;CONCURRENT_REQUESTS&apos;: 100, &apos;COOKIES_ENABLED&apos;: False, &apos;DOWNLOAD_DELAY&apos;: 0.01, &apos;NEWSPIDER_MODULE&apos;: &apos;jd.spiders&apos;, &apos;SPIDER_MODULES&apos;: [&apos;jd.spiders&apos;]&#125;</span><br><span class="line">2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled extensions:</span><br><span class="line">[&apos;scrapy.extensions.corestats.CoreStats&apos;,</span><br><span class="line"> &apos;scrapy.extensions.telnet.TelnetConsole&apos;,</span><br><span class="line"> &apos;scrapy.extensions.logstats.LogStats&apos;]</span><br><span class="line">2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled downloader middlewares:</span><br><span class="line">[&apos;scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware&apos;,</span><br><span class="line"> &apos;scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware&apos;,</span><br><span class="line"> &apos;scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware&apos;,</span><br><span class="line"> &apos;scrapy.downloadermiddlewares.useragent.UserAgentMiddleware&apos;,</span><br><span class="line"> &apos;jd.middlewares.RandomUserAgentMiddleware&apos;,</span><br><span class="line"> &apos;jd.middlewares.ProxyMiddleware&apos;,</span><br><span class="line"> &apos;scrapy.downloadermiddlewares.retry.RetryMiddleware&apos;,</span><br><span class="line"> &apos;scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware&apos;,</span><br><span class="line"> &apos;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&apos;,</span><br><span class="line"> &apos;scrapy.downloadermiddlewares.redirect.RedirectMiddleware&apos;,</span><br><span class="line"> &apos;scrapy.downloadermiddlewares.stats.DownloaderStats&apos;]</span><br><span class="line">2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled spider middlewares:</span><br><span class="line">[&apos;scrapy.spidermiddlewares.httperror.HttpErrorMiddleware&apos;,</span><br><span class="line"> &apos;scrapy.spidermiddlewares.offsite.OffsiteMiddleware&apos;,</span><br><span class="line"> &apos;scrapy.spidermiddlewares.referer.RefererMiddleware&apos;,</span><br><span class="line"> &apos;scrapy.spidermiddlewares.urllength.UrlLengthMiddleware&apos;,</span><br><span class="line"> &apos;scrapy.spidermiddlewares.depth.DepthMiddleware&apos;]</span><br><span class="line">2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled item pipelines:</span><br><span class="line">[&apos;jd.pipelines.ShoeCommentPipeline&apos;, &apos;jd.pipelines.ShoeDetailPipeline&apos;]</span><br><span class="line">2017-03-13 19:21:12 [scrapy.core.engine] INFO: Spider opened</span><br><span class="line">2017-03-13 19:21:12 [scrapy.extensions.logstats] INFO: Crawled 0 pages (at 0 pages/min), scraped 0 items (at 0 items/min)</span><br><span class="line">2017-03-13 19:21:12 [scrapy.extensions.telnet] DEBUG: Telnet console listening on 127.0.0.1:6023</span><br><span class="line">2017-03-13 19:21:13 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=3&gt; (referer: None)</span><br><span class="line">2017-03-13 19:21:13 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=7&gt; (referer: None)</span><br><span class="line">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=6&gt; (referer: None)</span><br><span class="line">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=9&gt; (referer: None)</span><br><span class="line">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=5&gt; (referer: None)</span><br><span class="line">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=10&gt; (referer: None)</span><br><span class="line">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=2&gt; (referer: None)</span><br><span class="line">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=1&gt; (referer: None)</span><br><span class="line">2017-03-13 19:21:16 [scrapy.dupefilters] DEBUG: Filtered duplicate request: &lt;GET http://item.jd.com/10536835318.html&gt; - no more duplicates will be shown (see DUPEFILTER_DEBUG to show all duplicates)</span><br><span class="line">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=8&gt; (referer: None)</span><br><span class="line">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET http://item.jd.com/10536835318.html&gt; (referer: https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=6)</span><br><span class="line">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://club.jd.com/comment/productPageComments.action?productId=10589923020&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0&gt; (referer: https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=7)</span><br><span class="line">2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 http://item.jd.com/10536835318.html&gt;</span><br><span class="line">&#123;&apos;iid&apos;: 10536835318,</span><br><span class="line"> &apos;name&apos;: &apos;她芙 单鞋女2017春季新款中跟短靴女时尚女鞋性感尖头细跟单鞋深口裸靴防水台高跟鞋 黑色 37-标准码&apos;,</span><br><span class="line"> &apos;scores&apos;: &apos;9.72|9.75|9.65|9.63&apos;,</span><br><span class="line"> &apos;shop&apos;: &apos;卡曼鞋类专营店&apos;&#125;</span><br><span class="line">2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 https://club.jd.com/comment/productPageComments.action?productId=10589923020&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0&gt;</span><br><span class="line">&#123;&apos;_id&apos;: 10199823376,</span><br><span class="line"> &apos;color&apos;: &apos;金黑色.&apos;,</span><br><span class="line"> &apos;creation_time&apos;: &apos;2017-03-10 13:59:31&apos;,</span><br><span class="line"> &apos;iid&apos;: &apos;10589923020&apos;,</span><br><span class="line"> &apos;score&apos;: 5,</span><br><span class="line"> &apos;size&apos;: &apos;36&apos;,</span><br><span class="line"> &apos;uid&apos;: &apos;069d0baa-022b-421b-a43a-584f5aa3921e&apos;,</span><br><span class="line"> &apos;user_level&apos;: &apos;铜牌会员&apos;,</span><br><span class="line"> &apos;user_province&apos;: &apos;&apos;&#125;</span><br><span class="line">2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 https://club.jd.com/comment/productPageComments.action?productId=10589923020&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0&gt;</span><br><span class="line">&#123;&apos;_id&apos;: 10175008135,</span><br><span class="line"> &apos;color&apos;: &apos;金黑色.&apos;,</span><br><span class="line"> &apos;creation_time&apos;: &apos;2017-03-02 12:18:57&apos;,</span><br><span class="line"> &apos;iid&apos;: &apos;10589923020&apos;,</span><br><span class="line"> &apos;score&apos;: 5,</span><br><span class="line"> &apos;size&apos;: &apos;36&apos;,</span><br><span class="line"> &apos;uid&apos;: &apos;28dfd6c2-caf2-427d-9927-cf088d3099ea&apos;,</span><br><span class="line"> &apos;user_level&apos;: &apos;铜牌会员&apos;,</span><br><span class="line"> &apos;user_province&apos;: &apos;湖南&apos;&#125;</span><br><span class="line">2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 https://club.jd.com/comment/productPageComments.action?productId=10589923020&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0&gt;</span><br><span class="line">&#123;&apos;_id&apos;: 10163486837,</span><br><span class="line"> &apos;color&apos;: &apos;金黑色.&apos;,</span><br><span class="line"> &apos;creation_time&apos;: &apos;2017-02-26 15:28:14&apos;,</span><br><span class="line"> &apos;iid&apos;: &apos;10589923020&apos;,</span><br><span class="line"> &apos;score&apos;: 5,</span><br><span class="line"> &apos;size&apos;: &apos;36&apos;,</span><br><span class="line"> &apos;uid&apos;: &apos;736ad5a4-9470-4dcc-832d-b59094cf84f4&apos;,</span><br><span class="line"> &apos;user_level&apos;: &apos;铜牌会员&apos;,</span><br><span class="line"> &apos;user_province&apos;: &apos;云南&apos;&#125;</span><br></pre></td></tr></table></figure><p>在运行一段时间后，查看<code>shoe_comments.csv</code>和<code>shoe_details.csv</code>内容:</p><ul><li><p><code>shoe_comments.csv</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">10199823376,10589923020,069d0baa-022b-421b-a43a-584f5aa3921e,2017-03-10 13:59:31,5,,铜牌会员,金黑色.,36</span><br><span class="line">10175008135,10589923020,28dfd6c2-caf2-427d-9927-cf088d3099ea,2017-03-02 12:18:57,5,湖南,铜牌会员,金黑色.,36</span><br><span class="line">10163486837,10589923020,736ad5a4-9470-4dcc-832d-b59094cf84f4,2017-02-26 15:28:14,5,云南,铜牌会员,金黑色.,36</span><br><span class="line">10205838152,10589923020,93f35818-129f-4aaa-8ea9-549c28a4f791,2017-03-12 14:37:59,5,,注册会员,金黑色.,36</span><br><span class="line">10175298549,10589923020,fe1a26e0-8cae-43c3-b0d4-c99bf1d961cf,2017-03-02 13:49:07,5,,铜牌会员,金黑色.,36</span><br><span class="line">10205858068,10589923020,65a7243e-7116-4075-b64a-6e8d8d8382a4,2017-03-12 14:44:29,5,,铜牌会员,金黑色.,36</span><br><span class="line">10206280836,10589923020,1d9b5332-5ca6-40be-b408-250606f68c17,2017-03-12 17:00:48,5,,注册会员,金黑色.,36</span><br><span class="line">10200243913,10589923020,966cda26-ce10-432a-8309-95199ad1903e,2017-03-10 16:15:02,5,,铜牌会员,金黑色.,36</span><br><span class="line">10164313667,10589923020,d09eab89-ed53-47a3-abd1-c897a8bcf694,2017-02-26 20:15:01,5,北京,铜牌会员,金黑色.,36</span><br><span class="line">10162862191,10589923020,ddb58374-f48b-45f9-a2a6-e5e60d53d4ce,2017-02-26 11:42:58,5,,铜牌会员,金黑色.,36</span><br><span class="line">10149921178,11242420873,5f410ce9-fc38-4736-8465-88bbdd7da347,2017-02-21 19:45:56,5,上海,铜牌会员,70060黑色,36</span><br><span class="line">10143787582,11242420873,3f15f14f-1d37-4ccb-befa-9acccd22a3d1,2017-02-19 19:07:20,5,海南,铜牌会员,70060黑色,36</span><br><span class="line">10150729539,11242420873,a601a457-1cef-41c4-955b-3df3dd2646ec,2017-02-22 07:32:52,5,新疆,铜牌会员,70060黑色,36</span><br><span class="line">10147517331,11242420873,b50e1e32-e1fe-4084-b95a-71be8a720950,2017-02-20 23:29:52,5,北京,铜牌会员,70060黑色,36</span><br><span class="line">10147357719,11242420873,fe6ec9de-c39b-4d5e-9cee-bf5926abb465,2017-02-20 22:18:46,5,湖南,铜牌会员,70060黑色,36</span><br><span class="line">10187242860,11242420873,f12f02f7-b378-457f-a501-cdd81f69de6c,2017-03-06 13:53:31,5,云南,铜牌会员,70060黑色,36</span><br><span class="line">10203999129,11242420873,f61e40df-f919-43a2-b876-e81176d59cf9,2017-03-11 20:55:40,5,内蒙古,注册会员,70060黑色,36</span><br><span class="line">10203827884,11242420873,4a73b3d7-b489-4880-8f8a-bc70015c4e18,2017-03-11 19:55:57,5,浙江,注册会员,70060黑色,36</span><br><span class="line">10203810598,11242420873,4113c7e0-4556-4aa1-b441-2334bd5419d4,2017-03-11 19:49:51,5,安徽,注册会员,70060黑色,36</span><br><span class="line">10203802320,11242420873,38a65bba-5284-4190-83f2-1a6a54d57da3,2017-03-11 19:46:57,5,广西,注册会员,70060黑色,36</span><br></pre></td></tr></table></figure></li><li><p><code>shoe_details.csv</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">10536835318,她芙 单鞋女2017春季新款中跟短靴女时尚女鞋性感尖头细跟单鞋深口裸靴防水台高跟鞋 黑色 37-标准码,卡曼鞋类专营店,9.72|9.75|9.65|9.63</span><br><span class="line">1587186408,雅诗莱雅休闲鞋女 圆头深口低帮鞋 拼色厚底女鞋 系带防水台女鞋子 GH852Q0红色 37,宏嘉男鞋专营店,9.79|9.80|9.74|9.76</span><br><span class="line">10536835318,她芙 单鞋女2017春季新款中跟短靴女时尚女鞋性感尖头细跟单鞋深口裸靴防水台高跟鞋 黑色 37-标准码,卡曼鞋类专营店,9.72|9.75|9.65|9.63</span><br><span class="line">11242420873,百芙蓉单鞋女中跟2017春季新款粗跟英伦风小皮鞋女春季新款圆头深口妈妈工作韩版潮厚底 70060黑色 36,百芙蓉鞋类旗舰店,9.88|9.81|9.83|9.84</span><br><span class="line">11157498264,圆头深口低帮鞋2017年秋冬新款纯色系带坡跟女鞋防水台女鞋子 1343黑色 36,马登尔鞋靴专营店,9.78|9.81|9.75|9.76</span><br><span class="line">10638093860,爱思图牛津鞋英伦风皮鞋女中跟秋季女鞋粗跟单鞋大头皮鞋圆头学生鞋小皮鞋平底鞋潮妈妈鞋女生鞋子 黑色ML6X303 36,爱思图旗舰店,9.72|9.76|9.71|9.70</span><br><span class="line">10574081025,佩尼泰深口单鞋女头层牛皮尖头单鞋中跟粗跟 OL工作职业鞋大小码女鞋春季新款 灰色 38,佩尼泰旗舰店,9.68|9.73|9.67|9.66</span><br><span class="line">10459020322,瑞蓓妮真皮女鞋2017新款魔术贴深口单鞋女平底舒适休闲鞋大码防滑中老年妈妈鞋 黑色单鞋 38,瑞蓓妮旗舰店,9.70|9.75|9.65|9.65</span><br><span class="line">11273711543,细跟高跟鞋女2017春季新款尖头单鞋女深口高跟女士英伦厚底防水台工作女鞋 红色 37,家兴福鞋业专营店,9.87|9.82|9.80|9.81</span><br><span class="line">11226902308,粗跟单鞋女2017春季新款女鞋OL尖头高跟鞋深口工作鞋女士皮鞋水钻百搭鞋子女 DH3658黑色 37,彬度鸟鞋靴旗舰店,9.89|9.83|9.83|9.84</span><br><span class="line">11210447351,她芙 单鞋女2017春季新款单鞋粗跟女鞋子系带厚底高跟鞋深口学生休闲低帮鞋 绿色 37,她芙旗舰店,9.77|9.77|9.67|9.68</span><br><span class="line">11239261516,AUSDU休闲鞋女圆头平底深口单鞋粗跟厚底2017春款韩版百搭舒适女鞋妈妈绑带学生 70030黑色 36,AUSDU鞋类旗舰店,9.87|9.80|9.81|9.82</span><br><span class="line">11267204558,丹芭莎春季女鞋2017新品纯色深口鞋女韩版圆头高跟鞋粗跟防水台单鞋女潮鞋 M70050黑色 37,丹芭莎旗舰店,9.84|9.81|9.79|9.80</span><br><span class="line">10687936751,fullmir内增高休闲鞋女士小白鞋2016秋季新款厚底鞋韩版潮流低帮学生运动鞋子单鞋 红 色 37,fullmir鞋类旗舰店,9.61|9.66|9.58|9.58</span><br><span class="line">11167186789,新款单鞋女2017秋季时尚漆皮圆头低帮休闲鞋秋鞋 工作鞋套脚欧美低跟皮鞋 黑色6119 34,艾琳艺鞋类专营店,9.67|9.79|9.67|9.69</span><br><span class="line">11227438800,意米思时尚女鞋圆头高跟鞋粗跟妈妈鞋深口单鞋女2017春秋新款韩版百搭小皮鞋防水台鞋子女 莫70050黑色 36,意米思旗舰店,9.72|9.81|9.79|9.80</span><br><span class="line">11250120847,邻家天使细跟单鞋2017春季新款尖头欧美皮鞋深口高跟女鞋春秋款鞋子 LJ619黑色 39标码,邻家天使鞋类旗舰店,9.69|9.74|9.65|9.66</span><br><span class="line">11193717829,单鞋女2017春季新款韩版高跟防水台粗跟女鞋尖头深口水钻通勤OL工作小皮鞋女 邻1231黑色 37,NEB ANGEL梓赢专卖店,9.78|9.78|9.74|9.75</span><br><span class="line">11166169416,金丝兔尖头单鞋女2017春季新品深口金属超高跟鞋欧美时尚细跟女鞋百搭小皮鞋工作鞋 黑色 36,金丝兔广汇达专卖店,9.89|9.83|9.83|9.84</span><br><span class="line">10617152040,ZHR小皮鞋真皮小白鞋女深口单鞋平底护士工作鞋潮 白色 39,零邦鞋靴专营店,9.69|9.68|9.69|9.69</span><br><span class="line">1471841136,宝思特2017春季新款真皮平底平跟休闲女单鞋软牛皮软底妈妈鞋花朵跳舞鞋加大码女鞋子 黑色 39,宝思特旗舰店,9.75|9.74|9.65|9.65</span><br><span class="line">11204372265,霍尔世家 深口单鞋女粗跟高跟鞋2017春季新款英伦风真皮尖头女鞋防水台 黑色 37,霍尔世家旗舰店,9.64|9.70|9.63|9.64</span><br></pre></td></tr></table></figure></li></ul><p>至此，我们完成了整个数据的爬取工作。</p><h1 id="接下来的工作"><a href="#接下来的工作" class="headerlink" title="接下来的工作"></a>接下来的工作</h1><p>有经验的读者可以看出来，本文完成的爬虫是较为基础的爬虫，不涉及到Scrapy高级的特性，也不涉及到反爬虫的内容，对于感兴趣的读者，可以从以下几个方面继续深入。</p><ol><li>由于京东对爬虫爬取评论并没有反爬措施，所以本文没有涉及到反爬的内容，不过在编写该爬虫的时候有考虑到这部分内容，所以编写了中间件来完成<code>User-Agent</code>的随机设置以及使用代理池来分散请求等简单的反爬措施，有兴趣的读者可以查阅Github源代码。</li><li>对于较大的爬取工作，可以考虑使用<code>scrapy-redis</code>等工具来构建分布式爬虫，以增加爬取效率。</li><li>在获得大量的数据之后，可以使用<code>matplotlib</code>等工具对数据进行可视化分析。</li></ol><p>以上就是本文的全部内容，有兴趣的读者可以查阅Github并下载源码，该项目地址: <a href="https://github.com/Time1ess/MyCodes/tree/master/scrapy/jd" target="_blank" rel="noopener">https://github.com/Time1ess/MyCodes/tree/master/scrapy/jd</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天想跟大家分享的是关于网络爬虫的相关知识，网络爬虫是一种根据一定的规则，自动地对互联网上相关内容进行抓取的程序或者脚本，本文的内容主要是通过分析京东评论的加载过程，获取相关API，然后通过使用基于Python语言的开源网络爬虫框架——Scrapy，大量获取相关评论内容。&lt;/p&gt;
&lt;div class=&quot;tip&quot;&gt;&lt;br&gt;本文假定读者具有一定的Python编程经验，具有少量HTTP协议和HTML的相关知识，对爬虫的工作原理有一定了解。&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="爬虫" scheme="http://youchen.me/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Scrapy" scheme="http://youchen.me/tags/Scrapy/"/>
    
  </entry>
  
  <entry>
    <title>Python中yield from的用法</title>
    <link href="http://youchen.me/2017/02/10/Python-main-use-for-yield-from/"/>
    <id>http://youchen.me/2017/02/10/Python-main-use-for-yield-from/</id>
    <published>2017-02-10T05:22:58.000Z</published>
    <updated>2018-01-15T01:17:23.609Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇中谈到了迭代器、生成器以及<code>yield</code>的相关内容，而Python 3.3中，引入了在<a href="https://www.python.org/dev/peps/pep-0380/" target="_blank" rel="noopener">PEP 380 – Syntax for Delegating to a Subgenerator</a>中提出的<code>yield from</code>关键字，大幅简化了Python程序员在使用协程的时候的编程过程。</p><div class="tip"><br>本文内容除特殊说明外均基于Python 3.3以上版本。<br></div><p>首先需要声明的是，<code>yield from g</code>并不完全等于<code>for v in g: yield v</code>。而是应该将<code>yield from</code>看成为<strong>调用者(caller)</strong>和<strong>子生成器(sub-generator)</strong>之间提供了一种<strong>透明地双向通道</strong>。这包括了从子生成器中获取数据并向子生成器发送数据。</p><a id="more"></a><h4 id="使用yield-from从生成器中获得数据"><a href="#使用yield-from从生成器中获得数据" class="headerlink" title="使用yield from从生成器中获得数据"></a>使用<code>yield from</code>从生成器中获得数据</h4><p>考虑以下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""A generator that fakes a read from a file, socket, etc."""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'&lt;&lt; %s'</span> % i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader_wrapper</span><span class="params">(g)</span>:</span></span><br><span class="line">    <span class="comment"># Manually iterate over data produced by reader</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> g:</span><br><span class="line">        <span class="keyword">yield</span> v</span><br><span class="line"></span><br><span class="line">wrap = reader_wrapper(reader())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> wrap:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Result</span></span><br><span class="line">&lt;&lt; <span class="number">0</span></span><br><span class="line">&lt;&lt; <span class="number">1</span></span><br><span class="line">&lt;&lt; <span class="number">2</span></span><br><span class="line">&lt;&lt; <span class="number">3</span></span><br></pre></td></tr></table></figure><p>我们其实可以使用<code>yield from</code>来代替亲自迭代<code>reader()</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader_wrapper</span><span class="params">(g)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> g</span><br></pre></td></tr></table></figure><p>这可以很好的工作而且减少了一行代码，而且可能使得我们的意图更加明确。</p><h4 id="使用yield-from向生成器发送数据"><a href="#使用yield-from向生成器发送数据" class="headerlink" title="使用yield from向生成器发送数据"></a>使用<code>yield from</code>向生成器发送数据</h4><p>现在让我们做些更有趣的。首先创建一个名叫<code>writer</code>的协程，它可以接收发送给它的数据并写给套接字、文件描述符等等:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""A coroutine that writes data *sent* to it to fd, socket, etc."""</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        w = (<span class="keyword">yield</span>)</span><br><span class="line">        print(<span class="string">'&gt;&gt; '</span>, w)</span><br></pre></td></tr></table></figure><p>现在的问题是，包装函数<code>wrapper</code>如何处理将数据发送给<code>writer</code>，使得发送给包装函数的数据能够透明地发送给<code>writer()</code>？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer_wrapper</span><span class="params">(coro)</span>:</span></span><br><span class="line">    <span class="comment"># TBD</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">w = writer()</span><br><span class="line">wrap = writer_wrapper(w)</span><br><span class="line">wrap.send(<span class="keyword">None</span>)  <span class="comment"># "prime" the coroutine</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    wrap.send(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected result</span></span><br><span class="line">&gt;&gt;  <span class="number">0</span></span><br><span class="line">&gt;&gt;  <span class="number">1</span></span><br><span class="line">&gt;&gt;  <span class="number">2</span></span><br><span class="line">&gt;&gt;  <span class="number">3</span></span><br></pre></td></tr></table></figure><p>包装函数需要接受发送给它的数据(显而易见地)而且应该在循环结束的时候处理<code>StopIteration</code>异常。很明显只是完成<code>for x in coro: yield x</code>的话不能胜任这项工作。下面是一个能够工作的版本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer_wrapper</span><span class="params">(coro)</span>:</span></span><br><span class="line">    coro.send(<span class="keyword">None</span>)  <span class="comment"># prime the coro</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            x = (<span class="keyword">yield</span>)  <span class="comment"># Capture the value that's sent</span></span><br><span class="line">            coro.send(x)  <span class="comment"># and pass it to the writer</span></span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>或者，我们可以这样做:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer_wrapper</span><span class="params">(coro)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> coro</span><br></pre></td></tr></table></figure><p>这节省了6行代码，而且使得代码更加清晰易读，最关键的是，它可行！</p><h4 id="使用yield-from向生成器发送数据——异常处理"><a href="#使用yield-from向生成器发送数据——异常处理" class="headerlink" title="使用yield from向生成器发送数据——异常处理"></a>使用<code>yield from</code>向生成器发送数据——异常处理</h4><p>让我们使这个例子更复杂点，假设我们的<code>writer</code>需要处理异常呢？比如<code>writer</code>捕获<code>SpamException</code>异常并且在遇到这个的时候打印<code>***</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpamException</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            w = (<span class="keyword">yield</span>)</span><br><span class="line">        <span class="keyword">except</span> SpamException:</span><br><span class="line">            print(<span class="string">'***'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'&gt;&gt; '</span>, w)</span><br></pre></td></tr></table></figure><p>如果我们使用原始版本的<code>writer_wrapper</code>，会怎样？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># writer_wrapper same as above</span></span><br><span class="line"></span><br><span class="line">w = writer()</span><br><span class="line">wrap = writer_wrapper(w)</span><br><span class="line">wrap.send(<span class="keyword">None</span>)  <span class="comment"># "prime" the coroutine</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'spam'</span>, <span class="number">4</span>]:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="string">'spam'</span>:</span><br><span class="line">        wrap.throw(SpamException)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        wrap.send(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Expected Result</span></span><br><span class="line">&gt;&gt;  <span class="number">0</span></span><br><span class="line">&gt;&gt;  <span class="number">1</span></span><br><span class="line">&gt;&gt;  <span class="number">2</span></span><br><span class="line">***</span><br><span class="line">&gt;&gt;  <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Actual Result</span></span><br><span class="line">&gt;&gt;  <span class="number">0</span></span><br><span class="line">&gt;&gt;  <span class="number">1</span></span><br><span class="line">&gt;&gt;  <span class="number">2</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ... redacted ...</span><br><span class="line">  File ... <span class="keyword">in</span> writer_wrapper</span><br><span class="line">    x = (<span class="keyword">yield</span>)</span><br><span class="line">__main__.SpamException</span><br></pre></td></tr></table></figure><p>不能正常工作的原因是因为<code>x = (yield)</code>抛出了这个异常所以导致了程序崩溃。要使得其正常工作的话，我们需要亲自捕获异常并将它传递给子生成器(<code>writer</code>)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer_wrapper</span><span class="params">(coro)</span>:</span></span><br><span class="line">    <span class="string">"""Works. Manually catches exceptions and throws them"""</span></span><br><span class="line">    coro.send(<span class="keyword">None</span>)  <span class="comment"># prime the coro</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                x = (<span class="keyword">yield</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:   <span class="comment"># This catches the SpamException</span></span><br><span class="line">                coro.throw(e)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                coro.send(x)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment"># Result</span></span><br><span class="line">&gt;&gt;  <span class="number">0</span></span><br><span class="line">&gt;&gt;  <span class="number">1</span></span><br><span class="line">&gt;&gt;  <span class="number">2</span></span><br><span class="line">***</span><br><span class="line">&gt;&gt;  <span class="number">4</span></span><br></pre></td></tr></table></figure><p>这可以正常工作，但是假设我们这样呢:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer_wrapper</span><span class="params">(coro)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> coro</span><br></pre></td></tr></table></figure><p><code>yield from</code>语句透明地将数据或者异常发送给子生成器。</p><p>以上仍然没有覆盖所有的特殊情况。如果外部生成器关闭了会怎样？子生成器返回了一个值会怎样(Python 3里生成器可以返回值)？返回值会怎样被处理？而<code>yield from</code>很好的处理了以上所有情况。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="tip"><br><code>yield from</code>是<strong>调用者</strong>和<strong>子生成器</strong>之间的一个<strong>双向透明通道</strong>。<br></div><p>更多关于<code>yield from</code>的内容可以阅读<a href="https://www.python.org/dev/peps/pep-0380/" target="_blank" rel="noopener">PEP 380 – Syntax for Delegating to a Subgenerator</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇中谈到了迭代器、生成器以及&lt;code&gt;yield&lt;/code&gt;的相关内容，而Python 3.3中，引入了在&lt;a href=&quot;https://www.python.org/dev/peps/pep-0380/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PEP 380 – Syntax for Delegating to a Subgenerator&lt;/a&gt;中提出的&lt;code&gt;yield from&lt;/code&gt;关键字，大幅简化了Python程序员在使用协程的时候的编程过程。&lt;/p&gt;
&lt;div class=&quot;tip&quot;&gt;&lt;br&gt;本文内容除特殊说明外均基于Python 3.3以上版本。&lt;br&gt;&lt;/div&gt;

&lt;p&gt;首先需要声明的是，&lt;code&gt;yield from g&lt;/code&gt;并不完全等于&lt;code&gt;for v in g: yield v&lt;/code&gt;。而是应该将&lt;code&gt;yield from&lt;/code&gt;看成为&lt;strong&gt;调用者(caller)&lt;/strong&gt;和&lt;strong&gt;子生成器(sub-generator)&lt;/strong&gt;之间提供了一种&lt;strong&gt;透明地双向通道&lt;/strong&gt;。这包括了从子生成器中获取数据并向子生成器发送数据。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="生成器" scheme="http://youchen.me/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
      <category term="迭代器" scheme="http://youchen.me/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python中yield的作用</title>
    <link href="http://youchen.me/2017/02/10/Python-What-does-yield-do/"/>
    <id>http://youchen.me/2017/02/10/Python-What-does-yield-do/</id>
    <published>2017-02-10T02:42:13.000Z</published>
    <updated>2018-01-13T00:50:39.866Z</updated>
    
    <content type="html"><![CDATA[<p>最近在<a href="http://stackoverflow.com" target="_blank" rel="noopener">StackOverflow</a>上看的问题回答比较多，今天这篇是关于介绍Python生成器的相关思想以及其中关键字<code>yield</code>用法的翻译内容。</p><p>为了搞清楚<code>yield</code>是用来做什么的，你首先得知道Python中<strong><em>生成器</em></strong>的相关概念，而为了了解生成器的相关概念，你需要知道什么是<strong><em>迭代器</em></strong>。</p><a id="more"></a><div class="tip"><br>本篇中的Python除了特殊说明外都是Python 2.x<br></div><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>当你创建一个了列表，你可以逐个遍历列表中的元素，而这个过程便叫做<strong><em>迭代</em></strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line"><span class="meta">... </span>   print(i)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>而<code>mylist</code>是一个<strong><em>可迭代对象</em></strong>。当你使用列表推导式的时候，创建了一个列表，他也是可迭代对象:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line"><span class="meta">... </span>   print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>所有能够接受<code>for...in...</code>操作的对象都是可迭代对象，如列表、字符串、文件等。这些可迭代对象用起来都十分顺手因为你可以按照你的想法去访问它们，但是你把所有数据都保存在了内存中，而当你有大量数据的时候这可能并不是你想要的结果。</p><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>生成器也是迭代器，但是<strong>你只能对它们进行一次迭代</strong>，原因在于它们并没有将所有数据存储在内存中，而是即时生成这些数据:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mygenerator = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</span><br><span class="line"><span class="meta">... </span>   print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>这一段代码和上面那段很相似，唯一不同的地方是使用了<code>()</code>代替<code>[]</code>。但是，这样的后果是你无法对<code>mygenerator</code>进行第二次<code>for i in mygenerator</code>，因为生成器只能被使用一次:它首先计算出结果0，然后忘记它再计算出1，最后是4，一个接一个。</p><h4 id="Yield"><a href="#Yield" class="headerlink" title="Yield"></a>Yield</h4><p><code>yield</code>是一个用法跟<code>return</code>很相似的关键字，不同在于函数返回的是一个生成器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">createGenerator</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>   mylist = range(<span class="number">3</span>)</span><br><span class="line"><span class="meta">... </span>   <span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line"><span class="meta">... </span>       <span class="keyword">yield</span> i*i</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mygenerator = createGenerator() <span class="comment"># create a generator</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(mygenerator) <span class="comment"># mygenerator is an object!</span></span><br><span class="line">&lt;generator object createGenerator at <span class="number">0xb7555c34</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>这是一个没有什么用的例子，但是用来让你了解当你知道你的函数会返回一个只会被遍历1次的巨大数据集合该怎么做的时候十分方便。为了掌握<code>yield</code>，你必须了解<strong>当你调用这个函数的时候，你在函数体中写的代码并没有被执行</strong>，而是只返回了一个生成器对象，这个需要特别注意。然后，你的代码将会在每次<code>for</code>使用这个生成器的时候被执行。最后，最困难的部分:</p><blockquote><p><code>for</code>第一次调用通过你函数创建的生成器对象的时候，它将会从你函数的开头执行代码，一直到到达<code>yield</code>，然后它将会返回循环中的第一个值。然后，其他每次调用都会再一次执行你在函数中写的那段循环，并返回下一个值，直到没有值可以返回。</p></blockquote><p>生成器在函数执行了却没有到达<code>yield</code>的时候将被认为是空的，原因在于循环到达了终点，或者不再满足<code>if/else</code>条件。</p><h4 id="处理生成器耗尽"><a href="#处理生成器耗尽" class="headerlink" title="处理生成器耗尽"></a>处理生成器耗尽</h4><p>考虑以下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bank</span><span class="params">()</span>:</span> <span class="comment"># let's create a bank, building ATMs</span></span><br><span class="line"><span class="meta">... </span>   crisis = <span class="keyword">False</span></span><br><span class="line"><span class="meta">... </span>   <span class="function"><span class="keyword">def</span> <span class="title">create_atm</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>       <span class="keyword">while</span> <span class="keyword">not</span> self.crisis:</span><br><span class="line"><span class="meta">... </span>           <span class="keyword">yield</span> <span class="string">"$100"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsbc = Bank() <span class="comment"># when everything's ok the ATM gives you as much as you want</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>corner_street_atm = hsbc.create_atm()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class="line">$<span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class="line">$<span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print([corner_street_atm.next() <span class="keyword">for</span> cash <span class="keyword">in</span> range(<span class="number">5</span>)])</span><br><span class="line">[<span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsbc.crisis = <span class="keyword">True</span> <span class="comment"># crisis is coming, no more money!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wall_street_atm = hsbc.create_atm() <span class="comment"># it's even true for new ATMs</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(wall_street_atm.next())</span><br><span class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsbc.crisis = <span class="keyword">False</span> <span class="comment"># trouble is, even post-crisis the ATM remains empty</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(corner_street_atm.next())</span><br><span class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>brand_new_atm = hsbc.create_atm() <span class="comment"># build a new one to get back in business</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> cash <span class="keyword">in</span> brand_new_atm:</span><br><span class="line"><span class="meta">... </span>   <span class="keyword">print</span> cash</span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">$<span class="number">100</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>首先看生成器的<code>next</code>方法，它用来执行代码并从生成器中获取下一个元素(在Python 3.x中生成器已经没有next方法，而是使用next(iterator)代替)。在<code>crisis</code>未被置为<code>True</code>的时候，<code>create_atm</code>函数中的<code>while</code>循环可以看做是无尽的，当<code>crisis</code>为<code>True</code>的时候，跳出了<code>while</code>循环，所有迭代器将会到达函数尾部，此时再次访问<code>next</code>将会抛出<code>StopIteration</code>异常，而此时就算将<code>crisis</code>设置为<code>False</code>，这些生成器仍然处在函数尾部，访问会继续抛出<code>StopIteration</code>异常。</p><p>将以上例子用来控制访问资源等用途的时候十分有用。</p><h4 id="itertools，你的好朋友"><a href="#itertools，你的好朋友" class="headerlink" title="itertools，你的好朋友"></a><code>itertools</code>，你的好朋友</h4><p><code>itertools</code>模块包含了许多用来操作可迭代对象的函数。想复制一个生成器？向连接两个生成器？想把多个值组合到一个嵌套列表里面？使用<code>map/zip</code>而不用重新创建一个列表？那么就:<code>import itertools</code>吧。</p><p>让我们来看看四匹马赛跑可能的到达结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>horses = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>races = itertools.permutations(horses)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(races)</span><br><span class="line">&lt;itertools.permutations object at <span class="number">0xb754f1dc</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(itertools.permutations(horses)))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line"> (<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)]</span><br></pre></td></tr></table></figure><h4 id="迭代的内部机理"><a href="#迭代的内部机理" class="headerlink" title="迭代的内部机理"></a>迭代的内部机理</h4><p>迭代是一个依赖于可迭代对象(需要实现<code>__iter__()</code>方法)和迭代器(需要实现<code>__next__()</code>方法)的过程。</p><blockquote><p>可迭代对象是任意你可以从中得到一个迭代器的对象。</p><p>迭代器是让你可以对可迭代对象进行迭代的对象。</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>yield</code>语句将你的函数转化成一个能够生成一种能够包装你原函数体的名叫<strong><em>生成器</em></strong>的特殊对象的工厂。当生成器被迭代，它将会起始位置开始执行函数一直到到达下一个<code>yield</code>，然后挂起执行，计算返回传递给<code>yield</code>的值，它将会在每次迭代的时候重复这个过程直到函数执行到达函数的尾部，举例来说:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_generator</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'one'</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'two'</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'three'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> simple_generator():</span><br><span class="line">    <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure><p>这种效果的产生是由于在循环中使用了可以产生序列的生成器，生成器在每次循环时执行代码到下一个<code>yield</code>，并计算返回结果，这样生成器即时生成了一个列表，这对于特别是大型计算来说内存节省十分有效。</p><p>假设你想实现自己的可以产生一个可迭代一定范围数的<code>range</code>函数(特指Python 2.x中的<code>range</code>)，你可以这样做和使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myRangeNaive</span><span class="params">(i)</span>:</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    range = []</span><br><span class="line">    <span class="keyword">while</span> n &lt; i:</span><br><span class="line">        range.append(n)</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> range</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> myRangeNaive(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure><p>但是这样并不高效，原因1：你创建了一个你只会使用一次的列表；原因2：这段代码实际上循环了两次。<br>由于Guido和他的团队很慷慨地开发了生成器因此我们可以这样做:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myRangeSmart</span><span class="params">(i)</span>:</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; i:</span><br><span class="line">       <span class="keyword">yield</span> n</span><br><span class="line">       n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> myRangeSmart(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure><p>现在，每次对生成器迭代将会调用<code>next()</code>来执行函数体直到到达<code>yield</code>语句，然后停止执行，并计算返回结果，或者是到达函数体尾部。在这种情况下，第一次的调用<code>next()</code>将会执行到<code>yield n</code>并返回<code>n</code>，下一次的<code>next()</code>将会执行自增操作，然后回到<code>while</code>的判断，如果满足条件，则再一次停止并返回<code>n</code>，它将会以这种方式执行一直到不满足<code>while</code>条件，使得生成器到达函数体尾部。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在&lt;a href=&quot;http://stackoverflow.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;StackOverflow&lt;/a&gt;上看的问题回答比较多，今天这篇是关于介绍Python生成器的相关思想以及其中关键字&lt;code&gt;yield&lt;/code&gt;用法的翻译内容。&lt;/p&gt;
&lt;p&gt;为了搞清楚&lt;code&gt;yield&lt;/code&gt;是用来做什么的，你首先得知道Python中&lt;strong&gt;&lt;em&gt;生成器&lt;/em&gt;&lt;/strong&gt;的相关概念，而为了了解生成器的相关概念，你需要知道什么是&lt;strong&gt;&lt;em&gt;迭代器&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="生成器" scheme="http://youchen.me/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
      <category term="迭代器" scheme="http://youchen.me/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python中的metaclass(元类)</title>
    <link href="http://youchen.me/2017/02/06/Python-metaclass/"/>
    <id>http://youchen.me/2017/02/06/Python-metaclass/</id>
    <published>2017-02-06T08:11:02.000Z</published>
    <updated>2018-01-15T01:17:12.817Z</updated>
    
    <content type="html"><![CDATA[<p>本文根据对<a href="http://stackoverflow.com" target="_blank" rel="noopener">StackOverflow</a>上问题<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python?answertab=votes#tab-top" target="_blank" rel="noopener">What is a metaclass in Python?</a>的高票回答翻译结合实际例子，试图解释<strong>元类</strong>的意义与用途。</p><h4 id="类也是对象"><a href="#类也是对象" class="headerlink" title="类也是对象"></a>类也是对象</h4><p>在想了解什么是<strong>元类</strong>之前，需要读者掌握Python中类的基本概念。而恰巧Python对类的定义有着不同于其他语言的解释。在大多数编程语言中，类仅仅只是指示如何生成实例对象的一段代码，这一点在Python中也如此:</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>      <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_object = ObjectCreator()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(my_object)</span><br><span class="line">&lt;__main__.ObjectCreator object at <span class="number">0x8974f2c</span>&gt;</span><br></pre></td></tr></table></figure><p>但是，Python中的类还远不止如此:</p><div class="tip"><br>类也是实例对象<br></div><p>当程序员使用了关键字<code>class</code>时，Python将会执行它并且创建一个对象:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>      <span class="keyword">pass</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上述代码将会在内存中创建一个名叫”ObjectCreator”的对象。</p><div class="tip"><br>这个对象(类)自身拥有创建对象(实例)的能力，因此被称作类<br></div><p>即便如此，它仍然是一个对象，因此:</p><ul><li>你可以将它赋值给一个变量</li><li>你可以复制它</li><li>你可以为它添加属性</li><li>你可以将它作为函数参数传递</li></ul><p>例如,<br>使用<code>print</code>打印:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreator) <span class="comment"># you can print a class because it's an object</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>作为函数参数传递:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(o)</span>:</span></span><br><span class="line"><span class="meta">... </span>      print(o)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>echo(ObjectCreator) <span class="comment"># you can pass a class as a parameter</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>添加属性:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(hasattr(ObjectCreator, <span class="string">'new_attribute'</span>))</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ObjectCreator.new_attribute = <span class="string">'foo'</span> <span class="comment"># you can add attributes to a class</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(hasattr(ObjectCreator, <span class="string">'new_attribute'</span>))</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreator.new_attribute)</span><br><span class="line">foo</span><br></pre></td></tr></table></figure><p>赋值给另一个变量:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ObjectCreatorMirror = ObjectCreator <span class="comment"># you can assign a class to a variable</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreatorMirror.new_attribute)</span><br><span class="line">foo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreatorMirror())</span><br><span class="line">&lt;__main__.ObjectCreator object at <span class="number">0x8997b4c</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="动态地创建类"><a href="#动态地创建类" class="headerlink" title="动态地创建类"></a>动态地创建类</h4><p>既然类也是对象，那么你可以向创建对象一样快速地创建它们。<br>首先，你可以通过使用关键字<code>class</code>在函数中创建一个类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">choose_class</span><span class="params">(name)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> name == <span class="string">'foo'</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> Foo <span class="comment"># return the class, not an instance</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> Bar</span><br><span class="line"><span class="meta">... </span>    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyClass = choose_class(<span class="string">'foo'</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(MyClass, MyClass()) <span class="comment"># the function returns a class, not an instance</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">choose_class</span>.&lt;<span class="title">locals</span>&gt;.<span class="title">Foo</span>'&gt; &lt;<span class="title">__main__</span>.<span class="title">choose_class</span>.&lt;<span class="title">locals</span>&gt;.<span class="title">Foo</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x10a7d06a0</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但它并不是很动态，因为你仍然需要亲自编写整个类。由于类是对象，那么它们必然是被某些东西生成的。当你使用关键字<code>class</code>时，Python自动地创建了其对象的对象。但就跟Python中大多数东西一样，Python给了你手动操作它的方法。<br>还记得函数<code>type</code>吗？这个函数能够让你知道一个对象的类型:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(<span class="number">1</span>))</span><br><span class="line">&lt;type <span class="string">'int'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(<span class="string">"1"</span>))</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(ObjectCreator))</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(ObjectCreator()))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>其实<code>type</code>还有一个完全不同的能力，它能够快速地创建类。<code>type</code>可以以参数的方式接收对一个类的描述，然后返回一个类。(可能有的人认为同一个函数根据传递不同的参数拥有两种完全不同的用途是一件很傻的事，但这是由于Python的向后兼容留下的问题)</p><p>通过<code>type</code>创建类的参数描述如下:</p><pre><code>type(name of the class, tuple of the parent class (for inheritance, can be empty), dictionary containing attributes names and values)</code></pre><p>例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyShinyClass</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>      <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>可以以如下方式手动创建:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyShinyClass = type(<span class="string">'MyShinyClass'</span>, (), &#123;&#125;) <span class="comment"># returns a class object</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(MyShinyClass, MyShinyClass())</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">MyShinyClass</span>'&gt; &lt;<span class="title">__main__</span>.<span class="title">MyShinyClass</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x10a7a5518</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你可能注意到了我们使用了”MyShinyClass”作为类的名字同时也作为变量名来保持对类的引用。它们可以不同，但是没有理由使其复杂化。<br><code>type</code>接收一个字典来定义类的属性，因此:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>      bar = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>可以被翻译成:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo = type(<span class="string">'Foo'</span>, (), &#123;<span class="string">'bar'</span>: <span class="keyword">True</span>&#125;)</span><br></pre></td></tr></table></figure><p>这样定义的类也可以当做普通类使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(Foo)  <span class="comment"># &lt;class '__main__.Foo'&gt;</span></span><br><span class="line">print(Foo.bar)  <span class="comment"># True</span></span><br><span class="line">f = Foo()</span><br><span class="line">print(f)  <span class="comment"># &lt;__main__.Foo object at 0x8a9b84c&gt;</span></span><br><span class="line">print(f.bar)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>当然，你也可以继承自它:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>  <span class="class"><span class="keyword">class</span> <span class="title">FooChild</span><span class="params">(Foo)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>将会是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = type(<span class="string">'FooChild'</span>, (Foo,), &#123;&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(FooChild, FooChild.bar)  <span class="comment"># bar is inherited from Foo</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">FooChild</span>'&gt; <span class="title">True</span></span></span><br></pre></td></tr></table></figure><p>最终你会想为你的类添加一些方法。只需要使用正确的语法定义一个函数然后作为一个属性赋值给类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo_bar</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>      print(self.bar)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = type(<span class="string">'FooChild'</span>, (Foo,), &#123;<span class="string">'echo_bar'</span>: echo_bar&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(Foo, <span class="string">'echo_bar'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(FooChild, <span class="string">'echo_bar'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_foo = FooChild()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_foo.echo_bar()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>你甚至可以在动态生成了类之后添加更多的方法，就和向普通生成的类对象添加方法一样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo_bar_more</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>      print(<span class="string">'yet another method'</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild.echo_bar_more = echo_bar_more</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(FooChild, <span class="string">'echo_bar_more'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>如你所见:在Python中，类是对象，你可以快速动态地创建一个类。这便是当你使用关键字<code>class</code>时Python做的工作，它通过使用<strong>元类</strong>来完成这项工作。</p><h4 id="什么是元类-终于"><a href="#什么是元类-终于" class="headerlink" title="什么是元类(终于)"></a>什么是元类(终于)</h4><p><strong>元类</strong>是创建类的那些”东西”。你为了创建对象而定义了类，但是我们知道Python中的类也是对象，因此，元类是用来创建对象的。它们是<strong>类的类</strong>，你可以形象化地理解:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass = MetaClass()</span><br><span class="line">MyObject = MyClass()</span><br></pre></td></tr></table></figure><p>你已经知道<code>type</code>可以这么用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass = type(<span class="string">'MyClass'</span>, (), &#123;&#125;)</span><br></pre></td></tr></table></figure><p>这是因为函数<code>type</code>实际上是一个元类，而且是Python用来创建所有类的元类。</p><div class="tip"><br> 在Python中，所有东西都是对象<br></div><p>其中包括但不限于整型、字符串、函数和类。它们都是对象，而且它们都是被类创建的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>age = <span class="number">35</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__</span><br><span class="line">&lt;type <span class="string">'int'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'bob'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.__class__</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__class__</span><br><span class="line">&lt;type <span class="string">'function'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Bar()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Bar</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>现在让我们看看<code>__class__</code>的<code>__class__</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.__class__.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__class__.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__.__class__</span><br><span class="line">&lt;type <span class="string">'type'</span>&gt;</span><br></pre></td></tr></table></figure><p>由此可见，一个元类正是用来创建所有类的。你也可以称它为”类工厂”。<code>type</code>是Python使用的内置的元类，当然，你也可以创建你自己的元类。</p><h4 id="metaclass-属性"><a href="#metaclass-属性" class="headerlink" title="__metaclass__属性"></a><code>__metaclass__</code>属性</h4><p>你可以在编写一个类时为其指定<code>__metaclass__</code>属性:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__ = something...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>需要注意的是，上述语法仅适用于Python 2.x版本，在Python 3.x版本中，由新语法替代:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object, metaclass=something)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>当你为类指定了元类以后，Python将会使用该元类来创建类<code>Foo</code>。<br>特别注意:</p><div class="tip"><br>类对象在Python调用<strong>metaclass</strong>来创建类之后才会存在。<br></div><p><strong> Python 2.x中的<strong>metaclass</strong> </strong><br>对Python 2.x来说，即当首先写下了<code>class Foo(object)</code>，但是类对象<code>Foo</code>还并没有在内存中被创建。Python将会在类定义中查找<code>__metaclass__</code>，如果找到了，则用其来创建对象类<code>Foo</code>，如果没有找到，Python将会使用<code>type</code>来创建该类。</p><p>当你这么写:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(Bar)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>Python将会这么做:</p><ol><li>类<code>Foo</code>有定义<code>__metaclass__</code>吗？如果有，则使用指定的<code>__metaclass__</code>来创建类对象<code>Foo</code>。</li><li>如果没有找到这个属性，它将会在父类<code>Bar</code>中找</li><li>这样一直向父类找，直到达到<code>module</code>级别才停止。</li><li>如果在任何父类都找不到，那就用<code>type</code>创建类对象<code>Foo</code></li></ol><p>这里面有几点需要注意:</p><ol><li>为子类指定的<code>__metaclass__</code>需要是其所有父类<code>__metaclass__</code>的子类。</li><li>在多继承的情况下，如果没有为该类指定<code>__metaclass__</code>，则该类将会由MRO中第一个父类的<code>__metaclass__</code>和所有父类<code>__metaclass__</code>中处于继承最底层的<code>__metaclass__</code>生成。</li></ol><p>Python 2.x中<code>__metaclass__</code>使用如以下代码所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 2.x</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta0</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></span><br><span class="line">        cls = type.__new__(meta, name, bases, cls_dict)</span><br><span class="line">        print(meta, name, bases, cls_dict)</span><br><span class="line">        <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line">__metaclass__ = Meta0</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></span><br><span class="line">        print(meta, name, bases, cls_dict)</span><br><span class="line">        cls_dict[<span class="string">'meta'</span>] = <span class="keyword">True</span></span><br><span class="line">        cls = type.__new__(meta, name, bases, cls_dict)</span><br><span class="line">        <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta2</span><span class="params">(Meta)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></span><br><span class="line">        print(meta, name, bases, cls_dict)</span><br><span class="line">        cls_dict[<span class="string">'meta2'</span>] = <span class="keyword">True</span></span><br><span class="line">        cls = type.__new__(meta, name, bases, cls_dict)</span><br><span class="line">        <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta3</span><span class="params">(Meta2)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></span><br><span class="line">        print(meta, name, bases, cls_dict)</span><br><span class="line">        cls_dict[<span class="string">'meta3'</span>] = <span class="keyword">True</span></span><br><span class="line">        cls = type.__new__(meta, name, bases, cls_dict)</span><br><span class="line">        <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line">print(<span class="string">'C1'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'C2'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span>:</span></span><br><span class="line">    __metaclass__ = Meta</span><br><span class="line"></span><br><span class="line">print(<span class="string">'C3'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C3</span><span class="params">(C2)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'C4'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C4</span><span class="params">(C2)</span>:</span></span><br><span class="line">    __metaclass__ = Meta2</span><br><span class="line"></span><br><span class="line">print(<span class="string">'C5'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C5</span><span class="params">(C2)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'C6'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C6</span><span class="params">(C2)</span>:</span></span><br><span class="line">    __metaclass__ = Meta3</span><br><span class="line"></span><br><span class="line">print(<span class="string">'C7'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C7</span><span class="params">(C4, C6, C5)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>结果为:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C1</span><br><span class="line">(&lt;class '__main__.Meta0'&gt;, 'C1', (), &#123;'__module__': '__main__'&#125;)</span><br><span class="line">C2</span><br><span class="line">(&lt;class '__main__.Meta'&gt;, 'C2', (), &#123;'__module__': '__main__', '__metaclass__': &lt;class '__main__.Meta'&gt;&#125;)</span><br><span class="line">C3</span><br><span class="line">(&lt;class '__main__.Meta'&gt;, 'C3', (&lt;class '__main__.C2'&gt;,), &#123;'__module__': '__main__'&#125;)</span><br><span class="line">C4</span><br><span class="line">(&lt;class '__main__.Meta2'&gt;, 'C4', (&lt;class '__main__.C2'&gt;,), &#123;'__module__': '__main__', '__metaclass__': &lt;class '__main__.Meta2'&gt;&#125;)</span><br><span class="line">C5</span><br><span class="line">(&lt;class '__main__.Meta'&gt;, 'C5', (&lt;class '__main__.C2'&gt;,), &#123;'__module__': '__main__'&#125;)</span><br><span class="line">C6</span><br><span class="line">(&lt;class '__main__.Meta3'&gt;, 'C6', (&lt;class '__main__.C2'&gt;,), &#123;'__module__': '__main__', '__metaclass__': &lt;class '__main__.Meta3'&gt;&#125;)</span><br><span class="line">C7</span><br><span class="line">(&lt;class '__main__.Meta2'&gt;, 'C7', (&lt;class '__main__.C4'&gt;, &lt;class '__main__.C6'&gt;, &lt;class '__main__.C5'&gt;), &#123;'__module__': '__main__'&#125;)</span><br><span class="line">(&lt;class '__main__.Meta3'&gt;, 'C7', (&lt;class '__main__.C4'&gt;, &lt;class '__main__.C6'&gt;, &lt;class '__main__.C5'&gt;), &#123;'__module__': '__main__', 'meta2': True&#125;)</span><br></pre></td></tr></table></figure><p>注意到在类<code>C7</code>的生成过程中，分别调用了<code>Meta2</code>和<code>Meta3</code>，调用<code>Meta2</code>是由于在<code>C7</code>的继承中，类<code>C4</code>位于第一位，而<code>C4</code>的<code>__metaclass__</code>为<code>Meta2</code>，所以首先使用<code>Meta2</code>，而在<code>C4</code>、<code>C5</code>和<code>C6</code>的<code>__metaclass__</code>中，<code>Meta3</code>处于继承最底层，所以还会调用<code>Meta3</code>来生成类<code>C7</code>。(如果类<code>C6</code>位于最前面则只会调用<code>Meta3</code>)<br>这样的多继承以及多元类调用比较复杂，个人认为还是少用较好。</p><p><strong> Python 3.x中的metaclass </strong><br>在Python3.x中，需要通过关键字参数<code>metaclass</code>给类指定元类。如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span><span class="params">(metaclass=Meta)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>关于元类的寻找与Python 2.x类似:</p><ol><li>类<code>Foo</code>有定义关键字参数<code>metaclass</code>吗？如果有，则使用指定的<code>metaclass</code>来创建类对象<code>Foo</code>。</li><li>如果没有找到这个属性，它将会在父类<code>Bar</code>中找</li><li>如果在任何父类都找不到，那就用<code>type</code>创建类对象<code>Foo</code></li></ol><p>Python 3.x的metaclass使用注意仍然与Python 2.x类似:</p><ol><li>为子类指定的<code>metaclass</code>需要是其所有父类<code>metaclass</code>的子类。</li><li>在多继承的情况下，如果没有为该类指定<code>metaclass</code>，则该类将会由所有父类<code>metaclass</code>中处于继承最底层的<code>metaclass</code>生成。如果有指定，则选择前述的<code>metaclass</code>和该<code>metaclass</code>中继承层次更低的那个来生成。</li></ol><p>Python 3.x中<code>metaclass</code>使用如以下代码所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 3.x</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></span><br><span class="line">        print(meta, name, bases, cls_dict)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(meta, name, bases, cls_dict)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta2</span><span class="params">(Meta)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></span><br><span class="line">        print(meta, name, bases, cls_dict)</span><br><span class="line">        cls_dict[<span class="string">'hello'</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> type.__new__(meta, name, bases, cls_dict)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta3</span><span class="params">(Meta2)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></span><br><span class="line">        print(meta, name, bases, cls_dict)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(meta, name, bases, cls_dict)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta4</span><span class="params">(Meta3)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></span><br><span class="line">        print(meta, name, bases, cls_dict)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(meta, name, bases, cls_dict)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">'C1'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span><span class="params">(metaclass=Meta)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'C2'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span><span class="params">(C1)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'C3'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C3</span><span class="params">(C1, metaclass=Meta2)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'C4'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C4</span><span class="params">(C1, metaclass=Meta3)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'C5'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C5</span><span class="params">(C3, C4, C2)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'C6'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C6</span><span class="params">(C3, C4, C2, metaclass=Meta4)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>结果为:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C1</span><br><span class="line">&lt;class '__main__.Meta'&gt; C1 () &#123;'__module__': '__main__', '__qualname__': 'C1'&#125;</span><br><span class="line">C2</span><br><span class="line">&lt;class '__main__.Meta'&gt; C2 (&lt;class '__main__.C1'&gt;,) &#123;'__module__': '__main__', '__qualname__': 'C2'&#125;</span><br><span class="line">C3</span><br><span class="line">&lt;class '__main__.Meta2'&gt; C3 (&lt;class '__main__.C1'&gt;,) &#123;'__module__': '__main__', '__qualname__': 'C3'&#125;</span><br><span class="line">C4</span><br><span class="line">&lt;class '__main__.Meta3'&gt; C4 (&lt;class '__main__.C1'&gt;,) &#123;'__module__': '__main__', '__qualname__': 'C4'&#125;</span><br><span class="line">C5</span><br><span class="line">&lt;class '__main__.Meta3'&gt; C5 (&lt;class '__main__.C3'&gt;, &lt;class '__main__.C4'&gt;, &lt;class '__main__.C2'&gt;) &#123;'__module__': '__main__', '__qualname__': 'C5'&#125;</span><br><span class="line">C6</span><br><span class="line">&lt;class '__main__.Meta4'&gt; C6 (&lt;class '__main__.C3'&gt;, &lt;class '__main__.C4'&gt;, &lt;class '__main__.C2'&gt;) &#123;'__module__': '__main__', '__qualname__': 'C6'&#125;</span><br></pre></td></tr></table></figure><p>需要注意一点，为了输出内容的简洁，以上代码在方法<code>__new__</code>的最后都使用了<code>type.__new__</code>而不是<code>super().__new__</code>。改用<code>super().__new__</code>后执行仍相同，只是多了对父类的调用。</p><p>说了这么多，我们应该给<code>__metaclass__</code>赋值什么呢?答案当然是，一个可以创建类的东西。<br>那么，什么才能创建一个类呢？</p><h4 id="普通的元类"><a href="#普通的元类" class="headerlink" title="普通的元类"></a>普通的元类</h4><p>设计元类的一个很主要的原因就是为了在类被创建的时候进行自动修改，这经常用在API的设计上。<br>让我们举一个简单的例子，你决定让你的模块里所有类的属性都是大写形式。要完成这项工作有很多方法，其中一个便是在模块级别上定义<code>__metaclass__</code>。这样的话，该模块中所有的类都会通过该元类创建，我们只需要让这个元类完成将所有属性变成大写的工作。<br>幸运的是，<code>__metaclass__</code>可以是任何可调用(callable)对象，并不一定非要是一个正式的类。所以我们将从一个函数作为元类的例子说起:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 2.x</span></span><br><span class="line"><span class="comment"># the metaclass will automatically get passed the same argument</span></span><br><span class="line"><span class="comment"># that you usually pass to `type`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upper_attr</span><span class="params">(future_class_name, future_class_parents, future_class_attr)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">    Return a class object, with the list of its attribute turned </span></span><br><span class="line"><span class="string">    into uppercase.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># pick up any attribute that doesn't start with '__' and uppercase it</span></span><br><span class="line">  uppercase_attr = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</span><br><span class="line">          uppercase_attr[name.upper()] = val</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">  <span class="comment"># let `type` do the class creation</span></span><br><span class="line">  <span class="keyword">return</span> type(future_class_name, future_class_parents, uppercase_attr)</span><br><span class="line"></span><br><span class="line">__metaclass__ = upper_attr <span class="comment"># this will affect all classes in the module</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span> <span class="comment"># global __metaclass__ won't work with "object" though</span></span><br><span class="line">  <span class="comment"># but we can define __metaclass__ here instead to affect only this class</span></span><br><span class="line">  <span class="comment"># and this will work with "object" children</span></span><br><span class="line">  bar = <span class="string">'bip'</span></span><br><span class="line"></span><br><span class="line">print(hasattr(Foo, <span class="string">'bar'</span>))</span><br><span class="line"><span class="comment"># Out: False</span></span><br><span class="line">print(hasattr(Foo, <span class="string">'BAR'</span>))</span><br><span class="line"><span class="comment"># Out: True</span></span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line">print(f.BAR)</span><br><span class="line"><span class="comment"># Out: 'bip'</span></span><br></pre></td></tr></table></figure><p>现在，让我们完成同样的工作，但这次我们将会使用一个真正的类作为元类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 2.x</span></span><br><span class="line"><span class="comment"># remember that `type` is actually a class like `str` and `int`</span></span><br><span class="line"><span class="comment"># so you can inherit from it</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span> </span><br><span class="line">    <span class="comment"># __new__ is the method called before __init__</span></span><br><span class="line">    <span class="comment"># it's the method that creates the object and returns it</span></span><br><span class="line">    <span class="comment"># while __init__ just initializes the object passed as parameter</span></span><br><span class="line">    <span class="comment"># you rarely use __new__, except when you want to control how the object</span></span><br><span class="line">    <span class="comment"># is created.</span></span><br><span class="line">    <span class="comment"># here the created object is the class, and we want to customize it</span></span><br><span class="line">    <span class="comment"># so we override __new__</span></span><br><span class="line">    <span class="comment"># you can do some stuff in __init__ too if you wish</span></span><br><span class="line">    <span class="comment"># some advanced use involves overriding __call__ as well, but we won't</span></span><br><span class="line">    <span class="comment"># see this</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(upperattr_metaclass, future_class_name, </span></span></span><br><span class="line"><span class="function"><span class="params">                future_class_parents, future_class_attr)</span>:</span></span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> type(future_class_name, future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure><p>但是上面这种方法并不是很符合OOP，因为我们直接调用了<code>type</code>而且我们没有重写或者调用父类的<code>__new__</code>，让我们改为下面这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 2.x</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(upperattr_metaclass, future_class_name, </span></span></span><br><span class="line"><span class="function"><span class="params">                future_class_parents, future_class_attr)</span>:</span></span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        <span class="comment"># reuse the type.__new__ method</span></span><br><span class="line">        <span class="comment"># this is basic OOP, nothing magic in there</span></span><br><span class="line">        <span class="keyword">return</span> type.__new__(upperattr_metaclass, future_class_name, </span><br><span class="line">                            future_class_parents, uppercase_attr)</span><br></pre></td></tr></table></figure><p>你可能注意到了一个额外的参数<code>upperattr_metaclass</code>，它其实并不特别:<code>__new__</code>总是将定义它的类作为第一个参数，就和实例方法中使用<code>self</code>或类方法中使用<code>cls</code>作为方法的第一个参数一样。当然，此处参数所使用的名字只是为了方便明确参数意义，但就跟<code>self</code>一样，所有参数都可以简写，因此实际使用中的一个元类可能看起来像这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, clsname, bases, dct)</span>:</span></span><br><span class="line"></span><br><span class="line">        uppercase_attr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> dct.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</span><br><span class="line">                uppercase_attr[name.upper()] = val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uppercase_attr[name] = val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, clsname, bases, uppercase_attr)</span><br></pre></td></tr></table></figure><p>是的，元类在完成一些”黑魔法”或者复杂事务的时候很有用，但是对于它们自身来说，其实很简单:</p><ol><li>拦截一个类的创建</li><li>修改这个类</li><li>返回修改后的类</li></ol><h4 id="你为什么要使用类而不是函数来作为元类？"><a href="#你为什么要使用类而不是函数来作为元类？" class="headerlink" title="你为什么要使用类而不是函数来作为元类？"></a>你为什么要使用类而不是函数来作为元类？</h4><p>由于<code>__metaclass__</code>可以接受任意可调用对象，那为什么你要使用一个明显更复杂的类呢？</p><p>有几个原因:</p><ul><li>意图明确。当你阅读到<code>UpperAttrMetaclass(type)</code>，你知道接下来会怎样</li><li>你可以使用OOP。元类可以继承，重写父类方法，甚至可以使用元类</li><li>你可以更好地组织里的代码。你不会在一些简单的工作中使用到元类，它通常是为了复杂工作准备的。编写多个方法并且将它们组织到一个类里将会对使代码清晰易读有巨大的帮助。</li><li>你可以拦截<code>__new__</code>、<code>__init__</code>和<code>__call__</code>等方法。这将允许你完成不同的工作。即使通常情况下你可以在<code>__new__</code>完成所有工作，但仍有许多人更偏爱在<code>__init__</code>中完成。</li><li>它们叫做metaclass，<code>class</code>!</li></ul><h4 id="为什么你要使用元类呢？"><a href="#为什么你要使用元类呢？" class="headerlink" title="为什么你要使用元类呢？"></a>为什么你要使用元类呢？</h4><p>现在到了最关键的问题，为什么你要使用一些既复杂又易错的功能呢？<br>实际上，通常情况下你不用:</p><blockquote><p>Metaclasses are deeper magic that 99% of users should never worry about. If you wonder whether you need them, you don’t (the people who actually need them know with certainty that they need them, and don’t need an explanation about why).      — Python Guru Tim Peters<br>译: 元类是较为高深的技术，99%的用户应该永远不用担心。如果你在犹豫你是否需要它们，那么你不需要(真正需要它们的人会清楚的知道需要它们，而且无须解释)</p></blockquote><p>元类主要的用途是创建一个API。一个典型的例子就是Django的ORM，它允许你这样定义:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">  name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">  age = models.IntegerField()</span><br></pre></td></tr></table></figure><p>但是如果你这样做:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">guy = Person(name=<span class="string">'bob'</span>, age=<span class="string">'35'</span>)</span><br><span class="line">print(guy.age)</span><br></pre></td></tr></table></figure><p>它并不会返回一个<code>IntegerField</code>对象，而是返回一个<code>int</code>。这是因为<code>models.Model</code>定义了<code>__metaclass__</code>，而该元类将会完成一些工作使得你刚刚定义拥有一些简单语句的<code>Person</code>变成复杂的钩子(hook)与数据库字段相连。Django通过引入一个简单的API和使用元类来使一些复杂的事情看起来简单，根据该API重建代码完成实际工作都在幕后进行。</p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>首先，你知道了类也是对象，而且可以生成实例。当然，类也是元类的实例。<br>Python中的万物都是对象，它们要么是类的实例，要么是元类的实例。<code>type</code>除外:</p><div class="tip"><br><code>type</code>是它自己的元类<br></div><p>其次，元类十分复杂。对一个简单类的修改你可能并不会想使用它，而是使用另外两种不同的方式:</p><ul><li><a href="https://en.wikipedia.org/wiki/Monkey_patch" target="_blank" rel="noopener">Monkey patching</a></li><li>类装饰器</li></ul><p>在99%你需要修改类的情况下，你都最好使用以上两种方法。<br>但99%的时间里，你都不需要修改类。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文根据对&lt;a href=&quot;http://stackoverflow.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;StackOverflow&lt;/a&gt;上问题&lt;a href=&quot;http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python?answertab=votes#tab-top&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What is a metaclass in Python?&lt;/a&gt;的高票回答翻译结合实际例子，试图解释&lt;strong&gt;元类&lt;/strong&gt;的意义与用途。&lt;/p&gt;
&lt;h4 id=&quot;类也是对象&quot;&gt;&lt;a href=&quot;#类也是对象&quot; class=&quot;headerlink&quot; title=&quot;类也是对象&quot;&gt;&lt;/a&gt;类也是对象&lt;/h4&gt;&lt;p&gt;在想了解什么是&lt;strong&gt;元类&lt;/strong&gt;之前，需要读者掌握Python中类的基本概念。而恰巧Python对类的定义有着不同于其他语言的解释。在大多数编程语言中，类仅仅只是指示如何生成实例对象的一段代码，这一点在Python中也如此:&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="类" scheme="http://youchen.me/tags/%E7%B1%BB/"/>
    
      <category term="面向对象编程" scheme="http://youchen.me/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python属性访问</title>
    <link href="http://youchen.me/2017/02/04/Python-property%20access/"/>
    <id>http://youchen.me/2017/02/04/Python-property access/</id>
    <published>2017-02-04T08:26:07.000Z</published>
    <updated>2018-01-13T00:50:39.868Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇中讲到了描述器方法<code>__get__</code>、<code>__set__</code>和<code>__delete__</code>，同时也提到，一个对象具有任意一个方法的就会成为描述器，从而在被当作对象属性的时候会重写默认的查找行为。在本篇中，通过对<a href="https://docs.python.org/2/howto/descriptor.html" target="_blank" rel="noopener">Descriptor HowTo Guide</a>的节选翻译以及笔者的自身的一些实践，对描述器做一个更详细的说明。</p><p>如果一个对象同时定义了<code>__get__</code>和<code>__set__</code>方法，则称它为资料描述器(<em>data descriptor</em>)，而仅定义了<code>__get__</code>方法的描述器称为非资料描述器(<em>non-data descriptor</em>，常用于方法，其他用途也是可以的)。</p><p>资料描述器和非资料描述器的区别在于：<strong>相对于实例的字典的优先级</strong>。如果实例字典中有和描述器重名的属性，如果描述器是资料描述器，优先使用资料描述器，如果是非资料描述器，优先使用字典中的属性。这就是为何实例a的方法和属性重名时，比如都叫做<code>foo</code>，Python会在访问<code>a.foo</code>时优先访问实例字典中的属性，因为实例的方法是个非资料描述器。<br><a id="more"></a><br>要想制作一个只读的资料描述器需要同时定义<code>__set__</code>和<code>__get__</code>方法，由于是只读，所以只需要在<code>__set__</code>方法中抛出一个<code>AttributeError</code>异常即可。</p><p>在一般情况下，描述器在属性访问时被自动调用。举例来说，<code>obj.d</code>会在<code>obj</code>的字典里面查找<code>d</code>，如果<code>d</code>定义了<code>__get__</code>方法，那么<code>d.__get__(obj)</code>会依据下面的优先规则被调用。</p><p>调用的细节取决于<code>obj</code>是一个类还是一个实例，对于对象来讲，方法<code>object.__getattribute__</code>将属性访问<code>a.x</code>变成了<code>type(a).__dict__[&#39;x&#39;].__get__(a, type(a))</code>，具体实现依据这样的优先顺序:<strong>资料描述器</strong>优先于<strong>实例变量</strong>，<strong>实例变量</strong>优先于<strong>非资料描述器</strong>，<code>__getattr__()</code>方法具有最低优先级；对于类来讲，方法<code>type.__getattribute__</code>将<code>A.x</code>变成<code>A.__dict__[&#39;x&#39;].__get__(None, A)</code>。如以下代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V</span>:</span></span><br><span class="line">    v = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.v = val</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, inst, owner)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.v</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, inst, value)</span>:</span></span><br><span class="line">        self.v = value</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    k1 = V(<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">k</span><span class="params">(self)</span>:</span>  <span class="comment"># non-data descriptor</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(a.k)  <span class="comment"># &lt;bound method...&gt; *op1*</span></span><br><span class="line">a.k = <span class="number">6</span>  <span class="comment"># replace non-data descriptor with instance dict  *op2*</span></span><br><span class="line">print(a.k)  <span class="comment"># 6  *op3*</span></span><br><span class="line"></span><br><span class="line">print(a.k1)  <span class="comment"># 1</span></span><br><span class="line">a.__dict__[<span class="string">'k1'</span>] = V(<span class="number">2</span>)  <span class="comment"># *op4*</span></span><br><span class="line">print(a.k1)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure></p><p>这段代码展示了资料描述器、实例变量、非资料描述器在属性访问中的不同优先级，分析如下:类<code>A</code>中定义了方法<code>k</code>(非资料描述器)，第一次操作对<code>a.k</code>的访问将转变为<code>type(a).__dict__[&#39;k&#39;].__get__(a, type(a))</code>，<code>type(a)</code>即类<code>A</code>，<code>A.__dict__</code>中存储了方法<code>A.k</code>，由于方法<code>A.k</code>为非资料描述器，因此调用其定义的<code>__get__()</code>方法。第二次操作<code>a.k = 6</code>本质上是在字典<code>a.__dict__</code>中添加了<code>k</code>这一变量(注意<code>a.__dict__</code>和<code>A._dict__</code>的区别)，即新增了实例变量。第三次操作对<code>a.k</code>的访问由于<strong>实例变量</strong>优先级高于<strong>非资料描述器</strong>，因此将获得之前的赋值6而不是方法。在第四次操作前后分别访问了<code>a.k1</code>属性，由于<code>k1</code>是资料描述器，因此即使在<code>a.__dict__</code>中新增了实例变量<code>k1</code>，对<code>a.k1</code>仍然是访问了资料描述器而不是实例变量，与前述的优先级保持一致。</p><p><code>__getattr__</code>与<code>__getattribute__</code>区别:前者只会在待访问的属性缺失时触发，而后者则会在每次访问属性时触发。</p><p><strong>特别注意:</strong>如果要在<code>__getattribute__</code>和<code>__setattr__</code>方法中访问实例属性，那么应该直接通过<code>super()</code>来做，以避免无限递归。如以下代码就会抛出异常:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrokenAttribute</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self._data = data</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">'Called __getattribute__(&#123;0&#125;)'</span>.format(name))</span><br><span class="line">        <span class="keyword">return</span> self._data[name]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = BrokenAttribute(&#123;<span class="string">'foo'</span>: <span class="number">3</span>&#125;)</span><br><span class="line">print(data.foo)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">RecursionError: maximum recursion depth exceeded <span class="keyword">while</span> calling a Python object</span><br></pre></td></tr></table></figure></p><h4 id="属性Property"><a href="#属性Property" class="headerlink" title="属性Property"></a>属性Property</h4><p>调用<code>property()</code>是建立资料描述器的一种简洁方式，从而可以在访问属性时触发相应的方法调用。<code>property</code>函数原型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute</span><br></pre></td></tr></table></figure></p><p>下面展示了一个典型应用，定义一个托管属性(managed attribute)x:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getx</span><span class="params">(self)</span>:</span> <span class="keyword">return</span> self.__x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setx</span><span class="params">(self, value)</span>:</span> self.__x = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delx</span><span class="params">(self)</span>:</span> <span class="keyword">del</span> self.__x</span><br><span class="line">    x = property(getx, setx, delx, <span class="string">"I'm the 'x' property."</span>)</span><br></pre></td></tr></table></figure><p>其等价Python实现为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Property</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"Emulate PyProperty_Type() in Objects/descrobject.c"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fget=None, fset=None, fdel=None, doc=None)</span>:</span></span><br><span class="line">        self.fget = fget</span><br><span class="line">        self.fset = fset</span><br><span class="line">        self.fdel = fdel</span><br><span class="line">        self.__doc__ = doc</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">if</span> self.fget <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError, <span class="string">"unreadable attribute"</span></span><br><span class="line">        <span class="keyword">return</span> self.fget(obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, obj, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.fset <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError, <span class="string">"can't set attribute"</span></span><br><span class="line">        self.fset(obj, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.fdel <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError, <span class="string">"can't delete attribute"</span></span><br><span class="line">        self.fdel(obj)</span><br></pre></td></tr></table></figure><h4 id="静态方法与类方法"><a href="#静态方法与类方法" class="headerlink" title="静态方法与类方法"></a>静态方法与类方法</h4><p>非资料描述器为将函数绑定成方法这种常见模式提供了一个简单的实现机制。<br>简而言之，函数有个方法<code>__get__()</code>，当函数被当作属性访问时，它会把函数变成一个实例方法。非资料描述器把实例调用<code>obj.f(*args)</code>转换成<code>f(obj, *args)</code>(绑定方法)，把类调用<code>klass.f(*args)</code>转换成<code>f(klass, *args)</code>(非绑定方法)。<br>静态方法原样返回函数，调用 c.f 或者 C.f 分别等价于<code>object.__getattribute__(c, &quot;f&quot;)</code>或者<code>object.__getattribute__(C, &quot;f&quot;)</code>。也就是说，无论是从一个对象还是一个类中，这个函数都会同样地访问到。<br>利用非资料描述器，<code>staticmethod()</code>的等价实现看起来像这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">staticmethod</span><span class="params">(object)</span>:</span></span><br><span class="line"> <span class="string">"Emulate PyStaticMethod_Type() in Objects/funcobject.c"</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, f)</span>:</span></span><br><span class="line">      self.f = f</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype=None)</span>:</span></span><br><span class="line">      <span class="keyword">return</span> self.f</span><br></pre></td></tr></table></figure><p>同样的，<code>classmethod()</code>等价实现看起来像这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassMethod</span><span class="params">(object)</span>:</span></span><br><span class="line">     <span class="string">"Emulate PyClassMethod_Type() in Objects/funcobject.c"</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, f)</span>:</span></span><br><span class="line">          self.f = f</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, klass=None)</span>:</span></span><br><span class="line">          <span class="keyword">if</span> klass <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">               klass = type(obj)</span><br><span class="line">          <span class="function"><span class="keyword">def</span> <span class="title">newfunc</span><span class="params">(*args)</span>:</span></span><br><span class="line">               <span class="keyword">return</span> self.f(klass, *args)</span><br><span class="line">          <span class="keyword">return</span> newfunc</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇中讲到了描述器方法&lt;code&gt;__get__&lt;/code&gt;、&lt;code&gt;__set__&lt;/code&gt;和&lt;code&gt;__delete__&lt;/code&gt;，同时也提到，一个对象具有任意一个方法的就会成为描述器，从而在被当作对象属性的时候会重写默认的查找行为。在本篇中，通过对&lt;a href=&quot;https://docs.python.org/2/howto/descriptor.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Descriptor HowTo Guide&lt;/a&gt;的节选翻译以及笔者的自身的一些实践，对描述器做一个更详细的说明。&lt;/p&gt;
&lt;p&gt;如果一个对象同时定义了&lt;code&gt;__get__&lt;/code&gt;和&lt;code&gt;__set__&lt;/code&gt;方法，则称它为资料描述器(&lt;em&gt;data descriptor&lt;/em&gt;)，而仅定义了&lt;code&gt;__get__&lt;/code&gt;方法的描述器称为非资料描述器(&lt;em&gt;non-data descriptor&lt;/em&gt;，常用于方法，其他用途也是可以的)。&lt;/p&gt;
&lt;p&gt;资料描述器和非资料描述器的区别在于：&lt;strong&gt;相对于实例的字典的优先级&lt;/strong&gt;。如果实例字典中有和描述器重名的属性，如果描述器是资料描述器，优先使用资料描述器，如果是非资料描述器，优先使用字典中的属性。这就是为何实例a的方法和属性重名时，比如都叫做&lt;code&gt;foo&lt;/code&gt;，Python会在访问&lt;code&gt;a.foo&lt;/code&gt;时优先访问实例字典中的属性，因为实例的方法是个非资料描述器。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="描述器" scheme="http://youchen.me/tags/%E6%8F%8F%E8%BF%B0%E5%99%A8/"/>
    
      <category term="属性" scheme="http://youchen.me/tags/%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python属性与描述器</title>
    <link href="http://youchen.me/2017/01/24/Python-property%20and%20descriptor/"/>
    <id>http://youchen.me/2017/01/24/Python-property and descriptor/</id>
    <published>2017-01-24T09:03:27.000Z</published>
    <updated>2018-01-13T00:50:39.868Z</updated>
    
    <content type="html"><![CDATA[<h4 id="getter与setter"><a href="#getter与setter" class="headerlink" title="getter与setter"></a><code>getter</code>与<code>setter</code></h4><p>如果开发者之前有其他语言的开发经验，在转入Python之后，可能会在类中明确地实现类似<code>getter</code>和<code>setter</code>方法，如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OldResistor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ohms)</span>:</span></span><br><span class="line">        self._ohms = ohms</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_ohms</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._homs</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_ohms</span><span class="params">(self, ohms)</span>:</span></span><br><span class="line">        self._ohms = ohms</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>然而这种方法却并不像Python的编程风格，特别是对于自增的代码来说更是如此:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = OldResistor(<span class="number">1e3</span>)</span><br><span class="line">r.set_ohms(r.get_ohms()+<span class="number">1e3</span>)</span><br></pre></td></tr></table></figure></p><p>对于Python语言来说，基本上不需要手工实现<code>getter</code>和<code>setter</code>方法，而是该先从简单的<code>public</code>属性写起:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewResistor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ohms)</span>:</span></span><br><span class="line">        self.ohms = ohms</span><br><span class="line">        </span><br><span class="line">r = NewResistor(<span class="number">1e3</span>)</span><br><span class="line">r.ohms += <span class="number">1e3</span></span><br></pre></td></tr></table></figure></p><p>但是开发者可能需要在对某个属性操作的时候实现特殊行为，这时候可以改用<code>@property</code>修饰器和<code>setter</code>方法来做:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropResistor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ohms)</span>:</span></span><br><span class="line">        self._ohms = ohms</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ohms</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Do what you want when access ohms</span></span><br><span class="line">        <span class="keyword">return</span> self._ohms</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @ohms.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ohms</span><span class="params">(self, ohms)</span>:</span></span><br><span class="line">        <span class="comment"># Do what you want when change ohms</span></span><br><span class="line">        self._ohms = ohms</span><br></pre></td></tr></table></figure></p><p>通过指定<code>setter</code>方法，我们可以在方法里面做类型验证以及数值验证。</p><p>但是,考虑下面一种情况:</p><blockquote><p>假设有一个考试成绩(<code>Exam</code>)类，由多个科目的小成绩组成，每一科需要单独计分，在进行分数录入的时候，要求对成绩进行验证，保证其在0~100之间</p></blockquote><p>如果使用属性<code>@property</code>实现，每添加一项科目，就要重复编写一次<code>@property</code>方法，而且还需要重复相关验证逻辑，如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">       self._chinese_grade = <span class="number">0</span></span><br><span class="line">       self._math_grade = <span class="number">0</span></span><br><span class="line">       </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_grade</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'Grade must be between 0 and 100'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">chinese_grade</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._chinese_grade</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @chinese_grade.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">chinese_grade</span><span class="params">(self, grade)</span>:</span></span><br><span class="line">        self._check_grade(grade)</span><br><span class="line">        self._chinese_grade = grade</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">math_grade</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._math_grade</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @math_grade.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">math_grade</span><span class="params">(self, grade)</span>:</span></span><br><span class="line">        self._check_grade(grade)</span><br><span class="line">        self._math_grade = grade</span><br></pre></td></tr></table></figure></p><p>实际上，有另外一种更好的方式实现上述功能，那就是采用Python的描述器(<em>descriptor</em>)来做。</p><h4 id="描述器"><a href="#描述器" class="headerlink" title="描述器"></a>描述器</h4><blockquote><p>一般来说，一个描述器是一个有“绑定行为”的对象属性(object attribute)，它的访问控制被描述器协议方法重写。这些方法是 <code>__get__()</code>, <code>__set__()</code>, 和 <code>__delete__()</code> 。有这些方法的对象叫做描述器。</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">descr.__get__(self, obj, type=None) --&gt; value</span><br><span class="line">descr.__set__(self, obj, value) --&gt; None</span><br><span class="line">descr.__delete__(self, obj) --&gt; None</span><br></pre></td></tr></table></figure><p>以上是所有描述器方法。一个对象具有其中任一个方法就会成为描述器，从而在被当作对象属性时重写默认的查找行为。来看一个例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._value = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, inst, owner)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._value</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, inst, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Grade must be between 0 and 100'</span>)</span><br><span class="line">        self._value = value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam</span>:</span></span><br><span class="line">    math_grade = Grade()</span><br></pre></td></tr></table></figure></p><p>为属性赋值时:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exam = Exam()</span><br><span class="line">exam.math_grade = <span class="number">50</span></span><br></pre></td></tr></table></figure></p><p>Python会对赋值操作进行转译，<code>exam.math_grade = 50</code>将会被转译成:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exam.__dict__[<span class="string">'math_grade'</span>].__set__(exam, <span class="number">40</span>)</span><br></pre></td></tr></table></figure></p><p>同样，访问操作也会被转译，<code>print(exam.math_grade)</code>将会被转译成:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(Exam.__dict__[<span class="string">'math_grade'</span>].__get__(exam, Exam))</span><br></pre></td></tr></table></figure></p><p>但是，上面的代码存在一个问题，由于所有类<code>Exam</code>的实例都会共享同一份<code>math_grade</code>实例，即程序定义类<code>Exam</code>的时候，就会把类<code>Grade</code>的<code>math_grade</code>实例构建好，以后再创建类<code>Exam</code>的实例时，就不再构建Grade了，因此我们需要把每个<code>Exam</code>实例所对应的值记录到<code>Grade</code>中，因此可以采取字典保存:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._values = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, inst, owner)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> inst <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> self._values.get(inst, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, inst, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Grade must be between 0 and 100'</span>)</span><br><span class="line">        self._values[inst] = value</span><br></pre></td></tr></table></figure></p><p>这种方式实现简单，而且能够正常运作，但它仍然有一个问题，就是内存泄漏，在程序生命周期类，对于传给<code>__set__</code>方法的每个<code>Exam</code>实例来说，<code>_values</code>字典都会保存一份指向该实例的引用，这就导致该实例的引用计数无法降为0，从而使垃圾收集器无法将其回收，通过使用Python内置的<code>weakref</code>模块即可解决此问题。该模块提供了名为<code>WeakKeyDictionary</code>的特殊字典，该字典的引用为弱引用，系统能够正确的完成回收:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._values = WeakKeyDictionary()</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;getter与setter&quot;&gt;&lt;a href=&quot;#getter与setter&quot; class=&quot;headerlink&quot; title=&quot;getter与setter&quot;&gt;&lt;/a&gt;&lt;code&gt;getter&lt;/code&gt;与&lt;code&gt;setter&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;如果开发者之前有其他语言的开发经验，在转入Python之后，可能会在类中明确地实现类似&lt;code&gt;getter&lt;/code&gt;和&lt;code&gt;setter&lt;/code&gt;方法，如:&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;OldResistor&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, ohms)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self._ohms = ohms&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get_ohms&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self._homs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;set_ohms&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, ohms)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self._ohms = ohms&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="描述器" scheme="http://youchen.me/tags/%E6%8F%8F%E8%BF%B0%E5%99%A8/"/>
    
      <category term="属性" scheme="http://youchen.me/tags/%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python中的MRO</title>
    <link href="http://youchen.me/2017/01/22/Python-Method%20Resolution%20Order/"/>
    <id>http://youchen.me/2017/01/22/Python-Method Resolution Order/</id>
    <published>2017-01-22T07:23:00.000Z</published>
    <updated>2018-01-15T01:17:45.671Z</updated>
    
    <content type="html"><![CDATA[<p>今天我想对Python中的方法解析顺序使用的C3算法进行一个梳理，文章内容主要基于对<a href="https://www.python.org/download/releases/2.3/mro/" target="_blank" rel="noopener">The Python 2.3 Method Resolution Order</a>一文的节选翻译。</p><p>首先，需要明白的是C3算法工作于Python 2.2引入的新式类(<em>new style classes</em>)，经典类(<em>classic classes</em>)中方法的解析仍然保持他们原有的顺序，即<code>深度优先，从左至右</code>，在此不进行深一步的讨论。</p><a id="more"></a><p>先来看一个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>O = object</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">X</span><span class="params">(O)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Y</span><span class="params">(O)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(X, Y)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Y, X)</span>:</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>继承顺序如图:<br><img src="/2017/01/22/Python-Method Resolution Order/python_inheritance.png" alt="Inheritance"></p><p>在这种情况下，通过A和B派生出一个新类C是有问题的，因为在A的继承中X先于Y,而在B中Y先于X，因此C中方法解析顺序会存在歧义。Python 2.3在这种情况下通过抛出异常<code>TypeError: MRO conflict among bases Y, X</code>来避免程序员创建有歧义的类。</p><h4 id="C3算法"><a href="#C3算法" class="headerlink" title="C3算法"></a>C3算法</h4><p>首先介绍一些简易记号来方便接下来的描述。</p><blockquote><p>$$C_1C_2…C_n$$</p></blockquote><p>表示一个类的列表<code>[C1, C2, ..., Cn]</code>。</p><p>列表的<code>head</code>为其第一个元素, <code>tail</code>为其余下元素:</p><blockquote><p>$$\begin{align}head &amp;= C_1\\tail &amp;= C_2…C_n\end{align}$$</p></blockquote><p>使用</p><blockquote><p>$$C+(C_1C_2…C_n) = CC_1C_2…C_n$$</p></blockquote><p>来表示<code>[C]+[C1, C2, ..., Cn]</code>。</p><p>线性化(<em>linearization</em>)定义:</p><blockquote><p>类C的线性化是指类C加上其父类的线性化以及其父类列表本身得到的和(列表)。</p></blockquote><p>用符号记号来描述:</p><blockquote><p>$$L[C(B_1…B_n)] = C + merge(L[B_1]…L[B_n], B_1…B_n)$$</p></blockquote><p>特别的，如果C是<code>object</code>类，即不存在父类，其线性化结果为:</p><blockquote><p>$$L[object] = object$$</p></blockquote><p>然而，要计算合并顺序需要遵循以下规则:</p><blockquote><p>取第一个列表的<code>head</code>，如$L[B_1][0]$；如果该<code>head</code>不在其余任一列表的尾部，将其加入类C的线性化结果列表中并将其从所有待合并列表中删除，否则从下一个列表中取出<code>head</code>并按上述规则处理。重复上述操作指导所有类都已经被删除或者无法再找到符合要求的<code>head</code>。在后者情况下，不可能完成merge操作，Python 2.3将会拒绝创建类C并抛出异常。</p></blockquote><p>下面举例说明，考虑如下继承:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>O = object</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">F</span><span class="params">(O)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(O)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(O)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(D, F)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(D, E)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(B, C)</span>:</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>继承顺序如图:<br><img src="/2017/01/22/Python-Method Resolution Order/python_inheritance2.png" alt="Inheritance2"></p><p>B的线性化计算公式可以表示如下:</p><blockquote><p>$$L[B] = B + merge(DO, EO, DE)$$</p></blockquote><p>根据前述规则，我们首先取D作为<code>head</code>，待合并列表变成了$merge(O, EO, E)$，由于O不符合条件，我们跳过第一个列表在第二个列表中选择符合条件的E作为<code>head</code>，待合并列表变成了$merge(O, O)$，最后我们选择了O,因此:</p><blockquote><p>$$L[B] = B D E O$$</p></blockquote><p>同理可以得到C的线性化结果:</p><blockquote><p>$$\begin{align}L[C] &amp;= C + merge(DO, FO, DF)\\&amp;=C+D+merge(O, FO, F)\\&amp;=C+D+F+merge(O, O)\\&amp;=C\;D\;F\;O\end{align}$$</p></blockquote><p>最后来计算A的线性化结果:</p><blockquote><p>$$\begin{align}L[A] &amp;= A + merge(BDEO, CDFO, BC)\\&amp;=A+B+merge(DEO, CDFO, C)\\&amp;=A+B+C+merge(DEO, DFO)\\&amp;=A+B+C+D+merge(EO, FO)\\&amp;=A+B+C+D+E+merge(O, FO)\\&amp;=A+B+C+D+E+F+merge(O, O)\\&amp;=A\;B\;C\;D\;E\;F\;O\end{align}$$</p></blockquote><p>在Python 2.2以后，可以直接通过调用<code>.mro()</code>方法获得MRO:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.mro()</span><br><span class="line">[&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;,</span><br><span class="line">&lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.F'&gt;,</span><br><span class="line">&lt;type <span class="string">'object'</span>&gt;]</span><br></pre></td></tr></table></figure></p><p>最后，让我们回到最初的那个例子，其所有类的线性化结果计算如下:</p><blockquote><p>$$\begin{align}&amp;L[O] = O\\&amp;L[X] = X\;O\\&amp;L[Y] = Y\;O\\&amp;L[A] = A\;X\;Y\;O\\&amp;L[B] = B\;Y\;X\;O\end{align}$$</p></blockquote><p>然而，对于继承自类A和类B的类C来说是无法线性化的:</p><blockquote><p>$$\begin{align}L[C] &amp;= C + merge(AXYO, BYXO, AB)\\&amp;=C+A+merge(XYO, BYXO, B)\\&amp;=C+A+B+merge(XYO, YXO)\end{align}$$</p></blockquote><p>在此刻，我们无法完成对XYO和YXO的合并，因为X是YXO的尾，同时Y是XYO的尾，因此C3算法停止，Python 2.3将会抛出异常并拒绝创建类C。</p><h4 id="不好的MRO"><a href="#不好的MRO" class="headerlink" title="不好的MRO"></a>不好的MRO</h4><p>当一个MRO破坏了局部优先顺序和单调性等基础性质时称其为不好的MRO。<br>考虑如下例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>F=type(<span class="string">'Food'</span>,(),&#123;<span class="string">'remember2buy'</span>:<span class="string">'spam'</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>E=type(<span class="string">'Eggs'</span>,(F,),&#123;<span class="string">'remember2buy'</span>:<span class="string">'eggs'</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G=type(<span class="string">'GoodFood'</span>,(F,E),&#123;&#125;) <span class="comment"># under Python 2.3 this is an error!</span></span><br></pre></td></tr></table></figure></p><p>创建了F、E、G三个类，其中类E可表示为<code>class E(F)</code>，类G可表示为<code>class G(F, E)</code>，我们期望类G的<code>remember2buy</code>属性是继承自F而不是E的，然而在Python 2.2中我们会得到<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>G.remember2buy</span><br><span class="line"><span class="string">'eggs'</span></span><br></pre></td></tr></table></figure></p><p>这破坏了局部优先顺序,因为对于类G的继承顺序<code>(F, E)</code>,其局部优先顺序并没有在Python 2.2线性化结果中得到保留:</p><blockquote><p>$$L[G, P22] = G\;E\;F\;object$$</p></blockquote><p>有人可能会争辩说Python 2.2线性化结果中类F在类E之后的原因是因为类F没有类E更具体，因为类F是类E的父类；尽管如此打破了局部优先顺序会使得代码不直观且容易出错，一个有力的佐证就是其与经典类的不同:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">F</span>:</span> remember2buy=<span class="string">'spam'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(F)</span>:</span> remember2buy=<span class="string">'eggs'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">G</span><span class="params">(F,E)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>G.remember2buy</span><br><span class="line"><span class="string">'spam'</span></span><br></pre></td></tr></table></figure></p><p>回想之前谈到的，经典类的继承顺序为<code>深度优先，从左至右</code>，因此类G的MRO为GFEF，在这种情况下局部优先顺序得到了保留。<br>简而言之，像之前那种继承方式应该避免，Python 2.3开始通过抛出异常来避免了这种歧义，有力地阻止了程序员来创建有歧义的类继承(通过C3算法失败来完成)。</p><p>还有一点相关的，Python 2.3的算法足够智能来发现一些显而易见的错误，比如重复继承同一个父类:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,A)</span>:</span> <span class="keyword">pass</span> <span class="comment"># error</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "&lt;stdin&gt;", line 1, in ?</span><br><span class="line">TypeError: duplicate base <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br></pre></td></tr></table></figure></p><p>而这种情况在Python 2.2中(无论是经典类还是新式类)，都不会抛出异常。</p><p>最后，有一点十分重要的需要记住:</p><ul><li>MRO在决定方法解析顺序同时也决定了属性的解析顺序</li></ul><p>讨论完了局部优先顺序，下面再来看单调性问题。要证明经典类的MRO是非单调的很容易:<br><img src="/2017/01/22/Python-Method Resolution Order/python_inheritance3.png" alt="Inheritance3"></p><blockquote><p>$$\begin{align}&amp;L[B, P22] = B\;C\quad\#\;B在C之前：类B的方法优先\\&amp;L[D, P22] = D\;A\;C\;B\;C\quad\#\;B在C之后：类C的方法优先\end{align}$$</p></blockquote><p>另一方面，Python 2.2和Python 2.3的MRO中都不存在问题，都给出了:</p><blockquote><p>$$L[D] = D\;A\;B\;C$$</p></blockquote><p>Guido在他的<a href="https://www.python.org/download/releases/2.2.3/descrintro/#mro" target="_blank" rel="noopener">一篇文章</a>指出了经典类的MRO在实际使用中其实并不差，因为它可以使经典类避免钻石型结构。但由于所有新式类都继承自<code>object</code>，因此钻石型结果无法避免而且在所有的多继承图中前后矛盾都会出现。<br>Python 2.2的MRO使得破坏单调性十分困难，但并非不可能。接下来这个由<em>Samuele Pedroni</em>提供的例子，表明了Python 2.2新式类的MRO是非单调的:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">K1</span><span class="params">(A,B,C)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">K2</span><span class="params">(D,B,E)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">K3</span><span class="params">(D,A)</span>:</span>   <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Z</span><span class="params">(K1,K2,K3)</span>:</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p><img src="/2017/01/22/Python-Method Resolution Order/python_inheritance4.png" alt="Inheritance4"></p><p>使用C3算法的线性化结果如下:</p><blockquote><p>$$\begin{align}&amp;L[A] = A\;O\\&amp;L[B] = B\;O\\&amp;L[C] = C\;O\\&amp;L[D] = D\;O\\&amp;L[E] = E\;O\\&amp;L[K1] = K1\;A\;B\;C\;O\\&amp;L[K2] = K2\;D\;B\;E\;O\\&amp;L[K3] = K3\;D\;A\;O\\&amp;L[Z] = Z\;K1\;K2\;K3\;D\;A\;B\;C\;E\;O\end{align}$$</p></blockquote><p>Python 2.2对于A、B、C、D、E、K1、K2、K3的线性化给出了相同结果，但是对于Z则不同:</p><blockquote><p>$$L[Z, P22] = Z\;K1\;K3\;A\;K2\;D\;B\;C\;E\;O$$ </p></blockquote><p>显然这个线性化结果是错的，因为类先于D出现了，而K3的线性化结果中D先于A出现。换句话说，在K3中，从类A继承的方法被从类D继承的方法覆盖了，但是在Z中，作为一个K3的子类，却使用了从类A继承的方法去覆盖从类D继承的方法！这违反了单调性。此外，Python 2.2中类Z的线性化结果与局部优先顺序也不一致，类Z的局部优先列表为<code>[K1, K2, K3]</code>(K2在K3之前)，而在线性化结果中K3在K2之前，这些问题解释了为什么2.2中的规则被弃用转投C3规则。</p><h4 id="super函数"><a href="#super函数" class="headerlink" title="super函数"></a>super函数</h4><p>最后再来看Python 2.2引入的<code>super</code>函数，它主要用于初始化父类，避免了直接调用父类的<code>__init__</code>函数，减少耦合性，来看以下代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimesFive</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        super(TimesFive, self).__init__(value)</span><br><span class="line">        self.value *= <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlusTwo</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        super(PlusTwo, self).__init__(value)</span><br><span class="line">        self.value += <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodWay</span><span class="params">(TimesFive, PlusTwo)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        super(GoodWay, self).__init__(value)</span><br><span class="line"></span><br><span class="line">foo = GoodWay(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><p>它的计算顺序为<code>5 * (5 + 2)</code>而不是<code>(5 * 5) + 2</code>，原因在于程序的运行顺序与类GoodWay的MRO保持了一致，通过查看<code>GoodWay.mro()</code>可以得到:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>GoodWay.mro()</span><br><span class="line">[&lt;class '__main__.GoodWay'&gt;, &lt;class '__main__.TimesFive'&gt;, &lt;class '__main__.PlusTwo'&gt;, &lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;]</span><br></pre></td></tr></table></figure></p><p>调用<code>GoodWay(5)</code>的时候，它会调用<code>TimesFive.__init__</code>，而<code>TimesFive.__init__</code>又会调用<code>PlusTwo.__init__</code>，而<code>PlusTwo.__init__</code>会调用<code>Base.__init__</code>，当到达了钻石体系的顶部之后，所有的初始化方法会按照与刚才那些<code>__init__</code>相反的顺序执行，因此<code>Base.__init__</code>将value设为5，<code>PlusTwo.__init__</code>在此基础上加2，value变为7，最后<code>TimesFive.__init__</code>将value乘以5，得到35。</p><h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h4><p>一看到<code>super</code>这个函数很多人第一想法就是父类，但其实<code>super</code>工作原理是这样的:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">super</span><span class="params">(cls, inst)</span>:</span></span><br><span class="line">    mro = inst.__class__.mro()</span><br><span class="line">    <span class="keyword">return</span> mro[mro.index(cls) + <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>根据实例inst获得其类的MRO列表，返回cls所在位置的下一个位置的类，其中<code>inst</code>永远是最开始那个实例。</p><p>Python 3提供了一种不带参数的<code>super</code>调用方式，例如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Explicit</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        super().__init__(value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implicit</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        super(__class__, self).__init__(value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> Explicit(<span class="number">10</span>).value == Implicit(<span class="number">10</span>).value</span><br></pre></td></tr></table></figure></p><p>由于Python 3程序可以在方法中通过<strong>class</strong>变量准确地引用当前类，所以上面的这种写法能够正常运作，而Python 2中则没有定义<strong>class</strong>，故而不能采用这种写法。可能有人试着用self.<strong>class</strong>做参数来调用<code>super</code>,但实际上这么做不行，因为Python 2是用<a href="http://stackoverflow.com/questions/18208683/when-calling-super-in-a-derived-class-can-i-pass-in-self-class" target="_blank" rel="noopener">特殊方式实现super</a>的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我想对Python中的方法解析顺序使用的C3算法进行一个梳理，文章内容主要基于对&lt;a href=&quot;https://www.python.org/download/releases/2.3/mro/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Python 2.3 Method Resolution Order&lt;/a&gt;一文的节选翻译。&lt;/p&gt;
&lt;p&gt;首先，需要明白的是C3算法工作于Python 2.2引入的新式类(&lt;em&gt;new style classes&lt;/em&gt;)，经典类(&lt;em&gt;classic classes&lt;/em&gt;)中方法的解析仍然保持他们原有的顺序，即&lt;code&gt;深度优先，从左至右&lt;/code&gt;，在此不进行深一步的讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="类" scheme="http://youchen.me/tags/%E7%B1%BB/"/>
    
      <category term="继承" scheme="http://youchen.me/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>multiprocessing中pool实现</title>
    <link href="http://youchen.me/2017/01/17/Python-multiprocessing%20pool/"/>
    <id>http://youchen.me/2017/01/17/Python-multiprocessing pool/</id>
    <published>2017-01-17T00:52:00.000Z</published>
    <updated>2018-01-13T00:50:39.867Z</updated>
    
    <content type="html"><![CDATA[<p>终于有时间来整理整理之前自己的一些心得，今天想分享的是之前梳理的<code>Python</code>中<code>multiprocessing</code>模块的线程池与进程池实现。</p><a id="more"></a><p>multiprocessing.pool类包含taskqueue、inqueue、outqueue三个队列，其中：</p><ul><li>taskqueue采用<code>Queue.Queue</code>实现，通过apply、apply_async、map、map_async等函数向pool类提交任务。</li><li>inqueue、outqueue采用<code>SimpleQueue</code>实现，本质上是带锁的pipe</li><li>inqueue负责存放待完成任务，outqueue负责存放已完成任务</li></ul><p>multiprocessing.pool类包含worker_handler、task_handler、result_handler三个handler，均在threading.Thread上工作，均为<code>Daemon Thread</code>，其中：</p><ul><li><p>worker_handler负责回收已经完成任务的worker，同时根据回收数量使用process函数重新生成足够的worker，在生命周期中维护整个pool中worker的数量:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_maintain_pool</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Clean up any exited workers and start replacements for them.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> self._join_exited_workers():</span><br><span class="line">        self._repopulate_pool()</span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_handle_workers</span><span class="params">(pool)</span>:</span></span><br><span class="line">    thread = threading.current_thread()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Keep maintaining workers until the cache gets drained, unless the pool</span></span><br><span class="line">    <span class="comment"># is terminated.</span></span><br><span class="line">    <span class="keyword">while</span> thread._state == RUN <span class="keyword">or</span> (pool._cache <span class="keyword">and</span> thread._state != TERMINATE):</span><br><span class="line">        pool._maintain_pool()</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="comment"># send sentinel to stop workers</span></span><br><span class="line">    pool._taskqueue.put(<span class="keyword">None</span>)</span><br><span class="line">    util.debug(<span class="string">'worker handler exiting'</span>)</span><br></pre></td></tr></table></figure></li><li><p>task_handler负责从taskqueue中按先后顺序阻塞获取待完成任务，更新pool的任务cache，并提交至inqueue中等待worker处理</p></li><li>result_handler负责从outqueue中按先后顺序阻塞获取已完成任务，更新pool的任务cache，如果存在回调函数则进行回调操作</li></ul><p>multiprocessing.pool类包含1个(未实现情况下)或多个(未提供数量，cpu_count()个)或指定数量的worker，其中：</p><ul><li>worker的维护由worker_handerler负责，在一个worker任务完成后由worker_handler负责回收并重新生成新的worker</li><li>worker包含对inqueue.get和outqueue.put的引用</li><li>worker从inqueue从获取待完成任务，并负责执行该任务，并将执行结果提交至outqueue中等待处理:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(inqueue, outqueue, initializer=None, initargs=<span class="params">()</span>, maxtasks=None,</span></span></span><br><span class="line"><span class="function"><span class="params">           wrap_exception=False)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> maxtasks <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> (type(maxtasks) == int <span class="keyword">and</span> maxtasks &gt; <span class="number">0</span>)</span><br><span class="line">    put = outqueue.put</span><br><span class="line">    get = inqueue.get</span><br><span class="line">    <span class="keyword">if</span> hasattr(inqueue, <span class="string">'_writer'</span>):</span><br><span class="line">        inqueue._writer.close()</span><br><span class="line">        outqueue._reader.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> initializer <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        initializer(*initargs)</span><br><span class="line"></span><br><span class="line">    completed = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> maxtasks <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> (maxtasks <span class="keyword">and</span> completed &lt; maxtasks):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            task = get()</span><br><span class="line">        <span class="keyword">except</span> (EOFError, OSError):</span><br><span class="line">            util.debug(<span class="string">'worker got EOFError or OSError -- exiting'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> task <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            util.debug(<span class="string">'worker got sentinel -- exiting'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        job, i, func, args, kwds = task</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = (<span class="keyword">True</span>, func(*args, **kwds))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> wrap_exception:</span><br><span class="line">                e = ExceptionWithTraceback(e, e.__traceback__)</span><br><span class="line">            result = (<span class="keyword">False</span>, e)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            put((job, i, result))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            wrapped = MaybeEncodingError(e, result[<span class="number">1</span>])</span><br><span class="line">            util.debug(<span class="string">"Possible encoding error while sending result: %s"</span> % (</span><br><span class="line">                wrapped))</span><br><span class="line">            put((job, i, (<span class="keyword">False</span>, wrapped)))</span><br><span class="line">        completed += <span class="number">1</span></span><br><span class="line">    util.debug(<span class="string">'worker exiting after %d tasks'</span> % completed)</span><br></pre></td></tr></table></figure></li></ul><p>PS：</p><blockquote><p>multiprocessing.ThreadPool是pool的thread-level级实现，以multiprocessing.dummy中的DummyProcess替换了pool的默认process，DummyProcess继承至threading.Thread，因此ThreadPool的实现是thread-level级的。</p></blockquote><p>实现用图来表示如下:</p><p><img src="/2017/01/17/Python-multiprocessing pool/python_multiprocessing_pool.png" alt="multiprocessing_pool"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于有时间来整理整理之前自己的一些心得，今天想分享的是之前梳理的&lt;code&gt;Python&lt;/code&gt;中&lt;code&gt;multiprocessing&lt;/code&gt;模块的线程池与进程池实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="多进程" scheme="http://youchen.me/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="进程池" scheme="http://youchen.me/tags/%E8%BF%9B%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>欢迎</title>
    <link href="http://youchen.me/2017/01/05/welcome/"/>
    <id>http://youchen.me/2017/01/05/welcome/</id>
    <published>2017-01-05T03:58:00.000Z</published>
    <updated>2018-01-13T00:50:39.868Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到我的博客，这个博客使用了<a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>构建，托管在<a href="https://pages.github.com" target="_blank" rel="noopener">Github Pages</a>,主题使用了<a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank" rel="noopener">Apollo</a>。</p><p>因为整个博客是托管在Github上的静态页面，没有数据库的支持，因此使用了<a href="http://duoshuo.com" target="_blank" rel="noopener">多说</a>来为整个博客提供评论功能，同时我也通过JS给博客增加了搜索功能，通过点击右下角的搜索图标或者双击<code>Ctrl</code>键可以启动搜索，这样可以方便快速查找相关内容。</p><a id="more"></a><p>现在博客的功能还有限，在以后我会慢慢增加新的功能，同时也会不定期更新一些我学习过程中的心得，欢迎大家阅读！</p><p>谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎来到我的博客，这个博客使用了&lt;a href=&quot;https://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;构建，托管在&lt;a href=&quot;https://pages.github.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github Pages&lt;/a&gt;,主题使用了&lt;a href=&quot;https://github.com/pinggod/hexo-theme-apollo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apollo&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;因为整个博客是托管在Github上的静态页面，没有数据库的支持，因此使用了&lt;a href=&quot;http://duoshuo.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;多说&lt;/a&gt;来为整个博客提供评论功能，同时我也通过JS给博客增加了搜索功能，通过点击右下角的搜索图标或者双击&lt;code&gt;Ctrl&lt;/code&gt;键可以启动搜索，这样可以方便快速查找相关内容。&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="http://youchen.me/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="欢迎" scheme="http://youchen.me/tags/%E6%AC%A2%E8%BF%8E/"/>
    
      <category term="第一篇" scheme="http://youchen.me/tags/%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    
      <category term="博客" scheme="http://youchen.me/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="新功能" scheme="http://youchen.me/tags/%E6%96%B0%E5%8A%9F%E8%83%BD/"/>
    
  </entry>
  
</feed>
