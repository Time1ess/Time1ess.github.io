<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>David&#39;s Blog</title>
  <subtitle>A graduate student in Computer Science</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://youchen.me/"/>
  <updated>2017-07-25T08:06:45.000Z</updated>
  <id>http://youchen.me/</id>
  
  <author>
    <name>David</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>论文笔记-全卷积神经网络(FCN)</title>
    <link href="http://youchen.me/2017/07/25/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-%E5%85%A8%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-FCN/"/>
    <id>http://youchen.me/2017/07/25/论文笔记-全卷积神经网络-FCN/</id>
    <published>2017-07-25T02:50:05.000Z</published>
    <updated>2017-07-25T08:06:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>看了下时间已经快3个月没有写过东西了，客观原因是考试复习和项目上的事情比较多，主观原因是懒。</p>
<p>最早接触机器学习是在大三，大四的时候了解了一些DL的知识，前几个月在网上学习了斯坦福的<a href="http://cs231n.stanford.edu" target="_blank" rel="external">CS231n: Convolutional Neural Networks for Visual Recognition</a>，看了一些论文，对DL相关概念有了一些基本的了解，这篇文章是我阅读<a href="https://arxiv.org/abs/1411.4038v2" target="_blank" rel="external">Fully Convolutional Networks for Semantic Segmentation</a>时的一些理解。</p>
<a id="more"></a>
<h1 id="Sementic-Segmentation-语义分割"><a href="#Sementic-Segmentation-语义分割" class="headerlink" title="Sementic Segmentation(语义分割)"></a>Sementic Segmentation(语义分割)</h1><p>语义分割是计算机视觉领域的一个经典问题，它所要完成的工作是对于图片的每一个像素，对其赋予一个标签，这和分类(Classification)、定位(Localization)等任务有很大的区别，分类是完成判断“是什么”的任务，定位不仅需要判断“是什么”，还需要完成“在哪里”的任务。举个例子说明,对于下面这张图片:</p>
<p><img src="/2017/07/25/论文笔记-全卷积神经网络-FCN/cat.png" alt="cat"></p>
<p>对其进行语义分割，得到的结果如下图所示:</p>
<p><img src="/2017/07/25/论文笔记-全卷积神经网络-FCN/ss-cat.png" alt="ss-cat"></p>
<p>图中不同颜色代表了不同的语义，比如黄色代表了猫，绿色代表了草坪，蓝色代表了天空，粉紫色代表了猫身后的树林。</p>
<p>语义分割对于人工智能迈向更高台阶是十分重要的，因为这一工作能够让计算机拥有类似人的判断，对其观察到的世界进行认识了解，这一工作在机器人领域以及自动驾驶等领域有很大的应用前景。</p>
<p>在<a href="https://arxiv.org/abs/1411.4038v2" target="_blank" rel="external">Fully Convolutional Networks for Semantic Segmentation</a>这篇论文将深度学习引入该领域之前，传统的语义分割主要依赖使用人工提取特征和概率图模型，而FCN这篇论文的发表，成为了语义分割的一个重要转折点。</p>
<p>全卷积网络的概念其实很早就提出了，因此在本文获得CVPR’ 15最佳论文提名的时候被Yann LeCun等人吐槽，当然，这篇论文仍然具有十分重要的意义。</p>
<h1 id="全连接层-–-gt-卷积层"><a href="#全连接层-–-gt-卷积层" class="headerlink" title="全连接层 –&gt; 卷积层"></a>全连接层 –&gt; 卷积层</h1><p>传统的分类网络，比如LeNet、AlexNet等，只接受固定尺寸的输入并产生非空间输出，原因在于全连接层参数的限制，而且这些网络在通过全连接层把输入展开成向量的时候丢失了图片原有的空间信息。对VGG16中第一个全连接层为25088x4096，即该层输入未展开成向量前形状为7x7x512，展开后为1x25088，得到的输出为1x4096，其实换一个角度来看，如果采用512x7x7x4096的卷积层原始输入进行卷积操作，得到的结果为1x1x4096。这样操作后，对应于原来输出的向量，现在输出了heatmap，如下图所示。</p>
<p><img src="/2017/07/25/论文笔记-全卷积神经网络-FCN/heatmap-cat.png" alt="heatmap-cat"></p>
<p>使用卷积层替换全连接层这种操作具体有什么作用呢？</p>
<p>以AlexNet为例，该网络输入为224x224x3，使用一系列卷积层和Pooling层使得数据尺寸变为7x7x512，紧接着是三个4096、4096、1000的全连接层，我们将三个全连接层分别转化为三个卷积层:</p>
<ul>
<li>对第一个全连接层25088x4096，我们可以使用kernel_size为7的4096个卷积核代替，这样得到的输出为1x1x4096</li>
<li>对第二个全连接层4096x4096，使用kernel_size为1的4096个卷积核代替，得到输出为1x1x4096</li>
<li>对第三个全连接层4096x1000，使用kernel_size为1的1000个卷积核代替，得到输出为1x1x1000</li>
</ul>
<p>假如我们想对384x384x3的图片进行语义分割，在不使用卷积层替换全连接层的情况下，我们使用步长为32大小为224x224x3的窗口在384x384x3的图片上进行滑动，得到6x6个位置的语义分割得分，然后进行fusion处理。但是因为我们使用了卷积层替换全连接层，现在的网络有能力对不同尺寸的输入进行处理。因此，384x384x3的输入经过卷积层和Pooling层后得到的尺寸为12x12x512，再通过上面经过转化的三个卷积层，得到的结果为6x6x1000，正好是对原图进行滑动得到的结果。</p>
<p>论文给出了这两种方式的时间性能比较，在GPU上，AlexNet需要花费1.2毫秒来产生对一张227x227的图片预测，而FCN版本花费了22毫秒对一张500x500的图片产生大小为10x10的预测，比AlexNet快了5倍多。</p>
<h1 id="Upsampling-上采样"><a href="#Upsampling-上采样" class="headerlink" title="Upsampling(上采样)"></a>Upsampling(上采样)</h1><p>以改造后的VGG16为例，让输入经过网络之后，我们得到的数据尺寸为[H/32, W/32]，而我们的目标是对每一个像素产生预测，因此我们需要进行upsampling操作，即恢复原始尺寸。在某种程度上，使用系数为$f$的upsampling可以看成是步长为$1/f$的卷积的转置，即只要$f$是整数，一种进行upsampling的方法就是使用<strong>backwards convolution</strong>(或称<strong>deconvolution</strong>，该术语存在争议，也有人称<strong>transposed convolution</strong>)，以输出步长为$f$进行计算。</p>
<p><img src="/2017/07/25/论文笔记-全卷积神经网络-FCN/padding_strides.gif" alt="padding_strides"></p>
<p>如图所示，绿色部分为输入，蓝色部分为输出，stride为2，padding为1。可以看出，<strong>transposed convolution</strong>其实就是<strong>convolution</strong>反过来，调换了<strong>convolution</strong>的前向传播和反向传播过程而已。</p>
<h1 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h1><p>以VGG16和PASCAL数据集为例，我们去除了最后的分类层，并将所有的全连接层转化为上述的卷积层，然后添加了一层1x1x21的卷积层用于预测每个类别(包括背景)的得分，然后使用转置卷积进行双线性上采样，使得粗粒度输出(coarse outputs)变成像素密集的输出。</p>
<p>虽然可以通过fine-tune来优化分割结果，得分也会变高，但是这些输出仍然比较粗糙无法令人满意。最后的prediction层采用stride为32的方式限制了上采样结果的细节程度。那么怎么处理这一问题呢？</p>
<p>我们知道，随着卷积神经网络层数的增加，每一层的感知野(reception field)也更广，而网络结构中越低的层感知野越小，因此能得到更多细节。结合低层与高层输出可以使得模型在全局结构下进行局部预测。</p>
<p><img src="/2017/07/25/论文笔记-全卷积神经网络-FCN/fine-coarse.png" alt="fine-coarse"></p>
<p>图中所示为改造后的VGG16的简化图，图中只包含了输入层、由全连接层转化而来的卷积层以及Pooling层。对我们最初采用stride为32的上采样得到结果的模型我们称为FCN-32s，为了进一步优化输出预测。我们首先在pool4后面添加1x1的卷积层来产生额外的预测。然后对使用步长为32的conv7(卷积化后的fc7)进行2x上采样，因为pool5将尺寸缩减了一半，此时进行2x上采样将会把尺寸恢复到跟pool4一样，然后把该结果和pool4后1x1卷积层产生的结果进行求和(不采用Max fusion的原因是会因为梯度选择而使得训练较为困难)。对于pool4后的1x1卷积层采用双线性插值初始化，但是允许参数在训练过程中进行调整。最后，将得到结果采用stride为16的方式进行上采样得到结果，该模型我们成为FCN-16s。同理，我们可以通过在pool3后添加1x1的卷积层并进行上述类似操作得到FCN-8s，但是得到的提升已经十分有限，因此不再进行更低层的fusion操作。</p>
<p><img src="/2017/07/25/论文笔记-全卷积神经网络-FCN/finer-fcns.png" alt="finer-fcns"></p>
<p>图中可以看出，通过融合使用不同stride的层得到的结果提高了分割的细节。</p>
<p><img src="/2017/07/25/论文笔记-全卷积神经网络-FCN/fcns-validation.png" alt="fcns-validation"></p>
<h1 id="训练细节"><a href="#训练细节" class="headerlink" title="训练细节"></a>训练细节</h1><ul>
<li>SGD with momentum 0.9</li>
<li>Minibatch size of 20 images</li>
<li>Fixed learning rates of $10^{-3}$, $10^{-4}$, $10^{-5}$ for FCN-AlexNet, FCN-VGG16, FCN-GoogLeNet</li>
<li>Weight decay of $5^{-4}$ or $2^{-4}$</li>
<li>Doubled the learning rates for biases(非必要)</li>
<li>Zero-initialize the class scoring convolution layer</li>
<li>Dropout</li>
</ul>
<h1 id="模型效果"><a href="#模型效果" class="headerlink" title="模型效果"></a>模型效果</h1><p><img src="/2017/07/25/论文笔记-全卷积神经网络-FCN/results.png" alt="resluts"></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="http://www.cnblogs.com/gujianhan/p/6030639.html" target="_blank" rel="external">全卷积网络 FCN 详解</a></li>
<li><a href="http://blog.csdn.net/tangwei2014/article/details/46882257" target="_blank" rel="external">论文阅读笔记：Fully Convolutional Networks for Semantic Segmentation</a></li>
<li><a href="https://github.com/vdumoulin/conv_arithmetic" target="_blank" rel="external">Convolution arithmetic</a></li>
<li><a href="http://cs231n.stanford.edu" target="_blank" rel="external">CS231n: Convolutional Neural Networks for Visual Recognition</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看了下时间已经快3个月没有写过东西了，客观原因是考试复习和项目上的事情比较多，主观原因是懒。&lt;/p&gt;
&lt;p&gt;最早接触机器学习是在大三，大四的时候了解了一些DL的知识，前几个月在网上学习了斯坦福的&lt;a href=&quot;http://cs231n.stanford.edu&quot;&gt;CS231n: Convolutional Neural Networks for Visual Recognition&lt;/a&gt;，看了一些论文，对DL相关概念有了一些基本的了解，这篇文章是我阅读&lt;a href=&quot;https://arxiv.org/abs/1411.4038v2&quot;&gt;Fully Convolutional Networks for Semantic Segmentation&lt;/a&gt;时的一些理解。&lt;/p&gt;
    
    </summary>
    
      <category term="语义分割" scheme="http://youchen.me/categories/%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/"/>
    
    
      <category term="Semantic Segmentation" scheme="http://youchen.me/tags/Semantic-Segmentation/"/>
    
      <category term="Deep Learning" scheme="http://youchen.me/tags/Deep-Learning/"/>
    
      <category term="CNN" scheme="http://youchen.me/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>初窥asyncio</title>
    <link href="http://youchen.me/2017/05/10/New-to-asyncio/"/>
    <id>http://youchen.me/2017/05/10/New-to-asyncio/</id>
    <published>2017-05-10T06:10:06.000Z</published>
    <updated>2017-05-10T14:00:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两天花了些时间阅读了Python的<a href="https://docs.python.org/3/library/asyncio.html#module-asyncio" target="_blank" rel="external"><code>asyncio</code></a>模块的相关文档，综合之前对<a href="http://twistedmatrix.com/trac/" target="_blank" rel="external">Twisted</a>的一些了解，分享一些学习结果。</p>
<p>根据官方文档的介绍，<code>asyncio</code>这个模块是在Python 3.4进行引入的，这个模块提供了使用协程编写单线程并发程序、对sockets以及其他资源的多路I/O访问、执行网络客户端和服务器等工作的基础。模块内容主要包含:</p>
<ul>
<li>一个多种平台相关实现的可插拔事件循环；</li>
<li><code>transport</code>和<code>protocol</code>抽象(与<a href="http://twistedmatrix.com/trac/" target="_blank" rel="external">Twisted</a>的概念相似)；</li>
<li>对TCP、UDP、SSL、子进程管道、延迟调用、以及其他功能(以上操作可能平台相关)的有力支持；</li>
<li>一个模仿<a href="https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures" target="_blank" rel="external"><code>concurrent.futures</code></a>模块实现的<code>Future</code>类，但增加了对事件循环的适应；</li>
<li>使用<a href="https://www.python.org/dev/peps/pep-0380" target="_blank" rel="external"><code>yield from</code></a>的协程(coroutines)以及作业(tasks)，以帮助使用顺序方式编写并发代码；</li>
<li>对取消<code>Future</code>和协程的支持；</li>
<li>在单线程的不同协程中使用的<a href="https://docs.python.org/3/library/asyncio-sync.html#asyncio-sync" target="_blank" rel="external">同步原语</a>，模仿<a href="https://docs.python.org/3/library/threading.html#module-threading" target="_blank" rel="external">threading</a>实现；</li>
<li>一个向线程池传递任务的接口，以解决无可避免地需要使用某些会造成I/O阻塞库的调用。</li>
</ul>
<div class="tip">本文相关特性需Python 3.4以上版本支持，部分内容需要Python 3.5以上版本支持</div>

<a id="more"></a>
<p>在开始相关的介绍之前，我们需要对同步、异步等工作方式有一个简单的了解，以下部分内容引用自<a href="http://krondo.com" target="_blank" rel="external"><em>krondo</em></a>编写的<a href="http://krondo.com/an-introduction-to-asynchronous-programming-and-twisted/" target="_blank" rel="external">Twisted Introduction</a>。</p>
<h1 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h1><p>大部分程序员应该非常熟悉同步模型了：</p>
<p><img src="/2017/05/10/New-to-asyncio/sync.png" alt=""></p>
<p>这是最简单的一种编程方式，每个任务依次执行，只有上一个任务结束以后下一个才会执行，任务都是按照确定顺序执行的，后面的任务可以认为所有之前的任务都是没有错误的正常结束，且他们的输出可以正常使用。</p>
<p>当然，我们也可以对比多线程(同步)模型：</p>
<p><img src="/2017/05/10/New-to-asyncio/threaded.png" alt=""></p>
<p>在该模型中，每一个任务都在一个单独的线程中执行，线程由操作系统管理，且在某些拥有多处理器或多核的操作系统上，可能可以真正的并发执行，或者都被放入同一处理器中执行。关键在于，多线程模型的执行细节是由操作系统控制的，对于不相关的指令流程序员应该认为其是同时执行的。因此，虽然图看起来简单，但实际编写多线程模型可能比较复杂，因为不同线程之间需要保持一定的协调。线程通信以及协调是一个高级编程话题而且要正确实现很困难。</p>
<p>下面让我们来看异步模型：</p>
<p><img src="/2017/05/10/New-to-asyncio/async.png" alt=""></p>
<p>在该模型中，任务之间彼此交错，但是都在同一线程中执行。这比多线程的情况要简单因为程序要总是知道<strong>同一时间只有一个任务在执行</strong>。除此之外，异步模型与多线程模型之前还有一个区别，在多线程模型中，线程的挂起与执行是由操作系统而不是程序员决定的，程序员需要假设一个线程可能被随时挂起。与此相反，在异步模型中，一个任务将会持续运行直到在适当的时候明确主动地放弃CPU资源占用让其他任务执行，这比多线程模型简单许多。</p>
<h1 id="为什么要使用异步模型"><a href="#为什么要使用异步模型" class="headerlink" title="为什么要使用异步模型"></a>为什么要使用异步模型</h1><p>有很多原因促使我们使用异步模型，其中一个比较常见的就是解决阻塞问题：</p>
<p><img src="/2017/05/10/New-to-asyncio/block.png" alt=""></p>
<p>图中的灰色部分代表了一个任务正在阻塞等待而无法继续执行。为什么一个任务会阻塞？一个常见的原因就是该任务正在等待完成I/O，完成向外接设备传递数据或者从外界设备接收数据。通常情况下，由于CPU处理数据的速度是磁盘或者网络连接处理数据速度的几个数量级，因此一个完成大量I/O操作的程序将会在阻塞上大量时间以等待磁盘或者网络完成操作。回过头看异步模型，对于遇到一个任务可能在同步模型下阻塞的时候，将会让出CPU转而执行其他没有阻塞的任务。因此异步模型只在没有任务可以继续执行即所有任务都在等待I/O的时候“阻塞”。</p>
<p>相比较于同步模型，异步模型在以下情况下表现更好：</p>
<ol>
<li>有大量任务需要执行且无论什么时候至少有一个任务可以继续执行。</li>
<li>要完成的任务中需要完成大量I/O操作，导致同步程序在其他任务可以继续执行时候会浪费大量时间阻塞等待。</li>
<li>任务之间基本不相关因此不需要任务间交互。</li>
</ol>
<p>那么asyncio的异步模型实现是基于什么呢？</p>
<p><img src="/2017/05/10/New-to-asyncio/reactor-1.png" alt=""></p>
<p>如图所示，这是反应器模式的一个基本结构，它总是处在等待事件以及处理事件的状态之一，因此也被称作<strong>事件循环(event loop)</strong>，也即asyncio模块的核心之一。</p>
<h1 id="事件循环示例"><a href="#事件循环示例" class="headerlink" title="事件循环示例"></a>事件循环示例</h1><p>让我们从一些官方文档示例开始。</p>
<p>第一个例子是简单地打印字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">(loop)</span>:</span></div><div class="line">    print(<span class="string">'Hello World'</span>)</div><div class="line">    loop.stop()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"></div><div class="line"><span class="comment"># Schedule a call to hello_world()</span></div><div class="line">loop.call_soon(hello_world, loop)</div><div class="line"></div><div class="line"><span class="comment"># Blocking call interrupted by loop.stop()</span></div><div class="line">loop.run_forever()</div><div class="line">loop.close()</div></pre></td></tr></table></figure>
<p>代码首先导入了我们需要使用的asyncio模块，然后定义了一个接收一个参数的<code>hello_world</code>函数，该函数只完成了两件事，打印一段字符串并在一个对象上调用了<code>stop</code>方法，关键在这之后：</p>
<ol>
<li><code>get_event_loop</code>: 我们通过使用asyncio模块的<code>get_event_loop</code>方法取得了事件循环，之前说过了，事件循环是整个asyncio模块的核心，我们需要把我们的任务添加到事件循环中，那么第一步便是取得事件循环。除了取得事件循环，还可以更改或者新建事件循环，以及更底层的Policy，但是由于我们是初次接触，就不再深究。</li>
<li><code>call_soon</code>: 接着，我们在loop对象上调用了<code>call_soon</code>方法，该方法接收多个参数，第一个参数是一个可调用对象，后面的参数将会传给该对象，在此处我们传递了<code>hello_world</code>函数和loop对象。该函数的作用是在事件循环启动之后尽快调用传递的对象。</li>
<li><code>run_forever</code>: 通过调用loop对象的<code>run_forever</code>函数，将启动事件循环，外部代码将会阻塞，即<code>run_forever</code>之后的函数将不会继续执行。</li>
<li><code>stop</code>: 由于启动了事件循环，之前通过<code>call_soon</code>调度的<code>hello_world</code>函数将会执行，打印字符串并调用loop对象的<code>stop</code>方法，该方法将会停止事件循环，使得外部代码继续执行。</li>
<li><code>close</code>: 关闭事件循环，需要注意的是关闭之前必须保证事件循环没有执行。</li>
</ol>
<p>第二个例子每秒打印一次当前日期时间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> datetime</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">display_date</span><span class="params">(end_time, loop)</span>:</span></div><div class="line">    print(datetime.datetime.now())</div><div class="line">    <span class="keyword">if</span> (loop.time() + <span class="number">1.0</span>) &lt; end_time:</div><div class="line">        loop.call_later(<span class="number">1</span>, display_date, end_time, loop)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        loop.stop()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"></div><div class="line"><span class="comment"># Schedule the first call to display_date()</span></div><div class="line">end_time = loop.time() + <span class="number">5.0</span></div><div class="line">loop.call_soon(display_date, end_time, loop)</div><div class="line"></div><div class="line"><span class="comment"># Blocking call interrupted by loop.stop()</span></div><div class="line">loop.run_forever()</div><div class="line">loop.close()</div></pre></td></tr></table></figure>
<p><code>call_soon</code>和<code>run_forever</code>等方法的调用和前一个例子相同，区别在于调用<code>display_date</code>函数将会打印当前日期时间然后判断当前时间是否超过结束时间，如果超过则停止事件循环，否则则使用<code>call_later</code>方法设置1秒后对<code>display_date</code>函数进行调用。需要注意的一点是loop的<code>time</code>方法和<code>time</code>模块的<code>time</code>方法相似，不过使用的loop的内部时钟。</p>
<p>第三个例子是监视文件描述符的读事件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">from</span> socket <span class="keyword">import</span> socketpair</div><div class="line"><span class="keyword">except</span> ImportError:</div><div class="line">    <span class="keyword">from</span> asyncio.windows_utils <span class="keyword">import</span> socketpair</div><div class="line"></div><div class="line"><span class="comment"># Create a pair of connected file descriptors</span></div><div class="line">rsock, wsock = socketpair()</div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">()</span>:</span></div><div class="line">    data = rsock.recv(<span class="number">100</span>)</div><div class="line">    print(<span class="string">"Received:"</span>, data.decode())</div><div class="line">    <span class="comment"># We are done: unregister the file descriptor</span></div><div class="line">    loop.remove_reader(rsock)</div><div class="line">    <span class="comment"># Stop the event loop</span></div><div class="line">    loop.stop()</div><div class="line"></div><div class="line"><span class="comment"># Register the file descriptor for read event</span></div><div class="line">loop.add_reader(rsock, reader)</div><div class="line"></div><div class="line"><span class="comment"># Simulate the reception of data from the network</span></div><div class="line">loop.call_soon(wsock.send, <span class="string">'abc'</span>.encode())</div><div class="line"></div><div class="line"><span class="comment"># Run the event loop</span></div><div class="line">loop.run_forever()</div><div class="line"></div><div class="line"><span class="comment"># We are done, close sockets and the event loop</span></div><div class="line">rsock.close()</div><div class="line">wsock.close()</div><div class="line">loop.close()</div></pre></td></tr></table></figure>
<p>该示例通过使用socketpair函数创建了一组相连接的socket对象，<code>loop.call_soon(wsock.send, &#39;abc&#39;.encode())</code>将会在事件循环启动后尽快调用wsock的<code>send</code>方法，方法参数为<code>&#39;abc&#39;.encode()</code>。除此之外，通过调用loop的<code>add_reader</code>方法，监视rsock的读事件，当读可用时，将会调用注册的<code>reader</code>函数，接收内容并打印出来，然后取消对rsock的注册并停止事件循环。</p>
<p>最后一个例子是为<code>SIGINT</code>和<code>SIGTERM</code>等信号设置处理器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> functools</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> signal</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ask_exit</span><span class="params">(signame)</span>:</span></div><div class="line">    print(<span class="string">"got signal %s: exit"</span> % signame)</div><div class="line">    loop.stop()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"><span class="keyword">for</span> signame <span class="keyword">in</span> (<span class="string">'SIGINT'</span>, <span class="string">'SIGTERM'</span>):</div><div class="line">    loop.add_signal_handler(getattr(signal, signame),</div><div class="line">                            functools.partial(ask_exit, signame))</div><div class="line"></div><div class="line">print(<span class="string">"Event loop running forever, press Ctrl+C to interrupt."</span>)</div><div class="line">print(<span class="string">"pid %s: send SIGINT or SIGTERM to exit."</span> % os.getpid())</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    loop.run_forever()</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    loop.close()</div></pre></td></tr></table></figure>
<p>上面一段代码里面最重要的部分就是<code>add_signal_handler</code>方法，第一个参数为信号对象，第二个参数为该信号出现时该调用的函数。在本例中，即当<code>SIGINT</code>和<code>SIGTERM</code>信号出现时调用<code>ask_exit</code>函数。</p>
<p>在使用asyncio时，还有一点需要注意的是：</p>
<blockquote>
<p>许多asyncio模块的函数都不接受关键字参数。因此，如果需要向回调函数传递关键字参数，需要使用<code>functools</code>模块的<code>partial</code>方法，比如<code>loop.call_soon(functools.partial(print, &quot;Hello&quot;, flush=True))</code>将会调用<code>print(&quot;Hello&quot;, flush=True)</code>。</p>
</blockquote>
<p>限于篇幅原因，本文止步于此，对于asyncio模块的其他内容的学习在接下来的文章中会进行分享。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天花了些时间阅读了Python的&lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt;&lt;code&gt;asyncio&lt;/code&gt;&lt;/a&gt;模块的相关文档，综合之前对&lt;a href=&quot;http://twistedmatrix.com/trac/&quot;&gt;Twisted&lt;/a&gt;的一些了解，分享一些学习结果。&lt;/p&gt;
&lt;p&gt;根据官方文档的介绍，&lt;code&gt;asyncio&lt;/code&gt;这个模块是在Python 3.4进行引入的，这个模块提供了使用协程编写单线程并发程序、对sockets以及其他资源的多路I/O访问、执行网络客户端和服务器等工作的基础。模块内容主要包含:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个多种平台相关实现的可插拔事件循环；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;transport&lt;/code&gt;和&lt;code&gt;protocol&lt;/code&gt;抽象(与&lt;a href=&quot;http://twistedmatrix.com/trac/&quot;&gt;Twisted&lt;/a&gt;的概念相似)；&lt;/li&gt;
&lt;li&gt;对TCP、UDP、SSL、子进程管道、延迟调用、以及其他功能(以上操作可能平台相关)的有力支持；&lt;/li&gt;
&lt;li&gt;一个模仿&lt;a href=&quot;https://docs.python.org/3/library/concurrent.futures.html#module-concurrent.futures&quot;&gt;&lt;code&gt;concurrent.futures&lt;/code&gt;&lt;/a&gt;模块实现的&lt;code&gt;Future&lt;/code&gt;类，但增加了对事件循环的适应；&lt;/li&gt;
&lt;li&gt;使用&lt;a href=&quot;https://www.python.org/dev/peps/pep-0380&quot;&gt;&lt;code&gt;yield from&lt;/code&gt;&lt;/a&gt;的协程(coroutines)以及作业(tasks)，以帮助使用顺序方式编写并发代码；&lt;/li&gt;
&lt;li&gt;对取消&lt;code&gt;Future&lt;/code&gt;和协程的支持；&lt;/li&gt;
&lt;li&gt;在单线程的不同协程中使用的&lt;a href=&quot;https://docs.python.org/3/library/asyncio-sync.html#asyncio-sync&quot;&gt;同步原语&lt;/a&gt;，模仿&lt;a href=&quot;https://docs.python.org/3/library/threading.html#module-threading&quot;&gt;threading&lt;/a&gt;实现；&lt;/li&gt;
&lt;li&gt;一个向线程池传递任务的接口，以解决无可避免地需要使用某些会造成I/O阻塞库的调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;tip&quot;&gt;本文相关特性需Python 3.4以上版本支持，部分内容需要Python 3.5以上版本支持&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="asyncio" scheme="http://youchen.me/tags/asyncio/"/>
    
      <category term="协程" scheme="http://youchen.me/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python正则表达式中的反斜线</title>
    <link href="http://youchen.me/2017/04/24/Backslashes-in-Python-Regular-Expressions/"/>
    <id>http://youchen.me/2017/04/24/Backslashes-in-Python-Regular-Expressions/</id>
    <published>2017-04-24T02:13:12.000Z</published>
    <updated>2017-04-24T03:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式是一个十分强大的工具，可以完成对字符串的模式匹配以及提取工作，在很多工程中都被广泛使用，但是我之前对于Python正则表达式模块<code>re</code>的使用都没有进行一些深入学习，对<strong>原始字符串</strong>之类的了解也比较浅显，之前有个同学问到我关于反斜线<code>\</code>在正则中的一些表现的时候我也迷惑了，跟周围人讨论后上<a href="http://stackoverflow.com" target="_blank" rel="external">StackOverflow</a>问了一番，对这方面又多了一些了解，今天跟大家分享。</p>
<a id="more"></a>
<h1 id="字符串中的反斜线"><a href="#字符串中的反斜线" class="headerlink" title="字符串中的反斜线\"></a>字符串中的反斜线<code>\</code></h1><p>我们知道，反斜线<code>\</code>在字符串以及正则表达式中都是完成转义的工作，比如我有一个字符串s1:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">'123'</span></div></pre></td></tr></table></figure>
<p>现在这个字符串s1内容为<code>123</code>，如果我想在字符串中保留一个单引号<code>&#39;</code>，那么我可能的一种做法是使用双引号来包含内容，字符串s2:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">"12'3"</span></div></pre></td></tr></table></figure>
<p>Python中的单引号<code>&#39;</code>和双引号<code>&#39;</code>其实都可以用来指示字符串，我们在此处使用双引号而不是单引号，原因是因为如果使用单引号Python解释器将会无法对这条语句进行正常解释，因为紧跟2之后的<code>&#39;</code>被用来指示字符串结束，然而后面还剩下<code>3</code>这个字符，所以会引发<code>Syntax Error</code>:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; s = '12'3'</div><div class="line">  File "&lt;stdin&gt;", line 1</div><div class="line">    s = '12'3'</div><div class="line">            ^</div><div class="line">SyntaxError: invalid syntax</div></pre></td></tr></table></figure>
<p>但是，只是使用语句中不包含的那种引号来指示字符串有时候是行不通的，因为有时候一个字符串可能同时包含单引号和双引号，比如字符串<code>1&quot;2&#39;3</code>，所以这时候我们需要使用反斜线<code>\</code>来对内容进行转义，因此对于字符串<code>1&quot;2&#39;3</code>，我们可以采用如下表示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'1"2\'3'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s</div><div class="line"><span class="string">'1"2\'3'</span></div></pre></td></tr></table></figure>
<p>注意我们并没有对字符串内容中的双引号<code>&quot;</code>进行转义，原因同上，字符串使用单引号指示的，因此双引号只会被认为是一个普通的字符。对于字符串内部的单引号<code>&#39;</code>，为了让解释器得知它是一个普通字符，我们在其前面增加了一个反斜线<code>\</code>，<code>\&#39;</code>组合起来的意思是对反斜线后面的字符<code>&#39;</code>进行转义，可以这样理解，通过添加一个反斜线<code>\</code>，对于<code>\&#39;</code>，你告诉了解释器:<code>不要按照普通的方式去解释这个字符&#39;</code>，这样解释器就能正确地完成对该字符串的解释。</p>
<p>有编程基础的读者应该会知道<strong><em>转义</em></strong>这一概念广泛存在于很多编程语言中，对<code>\n</code>、<code>\r</code>等字符应该有一定了解，类比前面的解释，<code>\n</code>表示:<code>不要按照普通的方式去解释这个字符n</code>。</p>
<p>进一步理解，假设我们从键盘输入了字符串:<code>abc\nde</code>，一共输入了7个字符，这7个字符经过Python解释器解释，两个字符<code>\</code>和<code>n</code>将会被转义成一个字符<code>\n</code>，请特别注意这一点，虽然从表面上看是两个字符，但其实<code>\n</code>是一个特殊的字符，这一点我们可以从以下代码看出:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'abc\nde'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(s)</div><div class="line"><span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">0</span>]</div><div class="line"><span class="string">'a'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>]</div><div class="line"><span class="string">'b'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">2</span>]</div><div class="line"><span class="string">'c'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">3</span>]</div><div class="line"><span class="string">'\n'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">4</span>]</div><div class="line"><span class="string">'d'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">5</span>]</div><div class="line"><span class="string">'e'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">6</span>]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">IndexError: string index out of range</div></pre></td></tr></table></figure>
<p>有了这些基础，下面我们进入到正则的部分。</p>
<h1 id="正则表达式中的反斜线"><a href="#正则表达式中的反斜线" class="headerlink" title="正则表达式中的反斜线\"></a>正则表达式中的反斜线<code>\</code></h1><p>因为有了Python解释器首先对字符串的转义，所以正则表达式模块<code>re</code>看到的和你输入的可能有所不同，比如，<code>\n</code>在字符串层被转义成一个换行字符，然后<code>re</code>看到的是字符<code>\n</code>而不是<code>\</code>和<code>n</code>两个字符，看以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'abc\nde'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">'\n'</span>, s)</div><div class="line">&lt;_sre.SRE_Match object; span=(<span class="number">3</span>, <span class="number">4</span>), match=<span class="string">'\n'</span>&gt;</div></pre></td></tr></table></figure>
<p>以上代码首先定义了一个前文提到的字符串<code>s</code>，然后使用<code>re</code>模块的<code>search</code>方法搜索，然后要搜索的字符串是<code>\n</code>，注意我们输入的是字符<code>\</code>和字符<code>n</code>，然后经过Python解释器的解释实际在内存中的是一个<code>\n</code>字符，因此<code>re</code>模块看到的是只有一个字符的字符串<code>\n</code>，而不是两个字符，最后完成搜索。</p>
<p>如果我们想匹配字符串<code>\\\n</code>，应该怎么输入模式呢？，一种方法是:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'\\\n'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pat = re.compile(<span class="string">'\\\\\n'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pat.pattern</div><div class="line"><span class="string">'\\\\\n'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pat.search(s)</div><div class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">2</span>), match=<span class="string">'\\\n'</span>&gt;</div></pre></td></tr></table></figure>
<p>对于字符串<code>\\\n</code>，它的内容其实是一个普通的<code>\</code>字符和一个换行字符<code>\n</code>，对于我们输入的匹配模式<code>\\\\\n</code>，首先经过Python解释器的字符串解释，变成了两个普通的<code>\</code>字符和一个换行字符<code>\n</code>，然后这些内容通过<code>re</code>模块的<code>compile</code>方法，<code>compile</code>方法发现有两个连续的<code>\</code>符号，因此将在接下来的匹配中匹配一个普通的<code>\</code>字符(请注意理解这一点)，而<code>\n</code>字符将会匹配一个<code>\n</code>字符，因此该模式的匹配内容是字符串中的一个普通<code>\</code>字符和一个<code>\n</code>字符。当然，写这么多反斜线显得十分麻烦，所以Python也提供了一种方便的方式，即<strong><em>原始字符串</em></strong>，其格式为在字符串前添加一个<code>r</code>字符:<code>r&#39;content&#39;</code>，通过这样的书写方式，Python解释器将使用不同的规则来解释转义(原始字符串不能以<code>\</code>符号结尾)。因此上述模式可以简化为:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'\\\n'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pat = re.compile(<span class="string">r'\\\n'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pat.pattern</div><div class="line"><span class="string">'\\\\\\n'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pat.search(s)</div><div class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">2</span>), match=<span class="string">'\\\n'</span>&gt;</div></pre></td></tr></table></figure>
<p>让我们再回到普通字符串，考虑以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'\\\n'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pat = re.compile(<span class="string">'\\\n'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pat.pattern</div><div class="line"><span class="string">'\\\n'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pat.search(s)</div><div class="line">&lt;_sre.SRE_Match object; span=(<span class="number">1</span>, <span class="number">2</span>), match=<span class="string">'\n'</span>&gt;</div></pre></td></tr></table></figure>
<p>对于模式<code>\\\n</code>，经过Python解释器的解释将变成一个普通’`字符和一个换行字符<code>\n</code>，<code>re</code>模块的<code>compile</code>方法将会看到以上解释结果，然后该模式组合起来就是:<strong>匹配一个换行字符<code>\n</code>的转义字符</strong>，也就是对换行字符<code>\n</code>进行转义！结果是:</p>
<div class="tip">对一个转义字符进行转义将会得到其本身</div>

<p>相关连接:</p>
<ul>
<li><a href="https://docs.python.org/3.6/library/re.html" target="_blank" rel="external">Regular expression operations</a></li>
<li><a href="http://stackoverflow.com/questions/33582162/backslashes-in-python-regular-expressions" target="_blank" rel="external">Backslashes in Python Regular Expressions</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正则表达式是一个十分强大的工具，可以完成对字符串的模式匹配以及提取工作，在很多工程中都被广泛使用，但是我之前对于Python正则表达式模块&lt;code&gt;re&lt;/code&gt;的使用都没有进行一些深入学习，对&lt;strong&gt;原始字符串&lt;/strong&gt;之类的了解也比较浅显，之前有个同学问到我关于反斜线&lt;code&gt;\&lt;/code&gt;在正则中的一些表现的时候我也迷惑了，跟周围人讨论后上&lt;a href=&quot;http://stackoverflow.com&quot;&gt;StackOverflow&lt;/a&gt;问了一番，对这方面又多了一些了解，今天跟大家分享。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="re" scheme="http://youchen.me/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>使用一维索引数组访问高维数组元素</title>
    <link href="http://youchen.me/2017/03/30/CPP-Access-n-d-array-with-1-d-index-array/"/>
    <id>http://youchen.me/2017/03/30/CPP-Access-n-d-array-with-1-d-index-array/</id>
    <published>2017-03-30T06:34:10.000Z</published>
    <updated>2017-03-30T07:45:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是这两天看书偶然间突然间想到的一个问题，假设有一个高维数组，比如3维整型数组<code>int arr[10][10][10];</code>，用户每次输入对应维数个数(3)个参数，存入一个索引数组<code>int idx[3]</code>中，根据索引返回对应索引的元素值。在低维情况下，可以采取直接访问的方式，比如输入的索引值为<code>idx[0] = 1, idx[1] = 2, idx[2] = 3</code>，可以通过<code>arr[idx[0]][idx[1]][idx[2]]</code>访问，但是如果数组维度太高，这样的方式就不可行了，比如<code>arr[idx[0]][idx[1]]....[idx[n]]</code>。所以需要换种方式。</p>
<a id="more"></a>
<p><strong>指针</strong></p>
<p>我们知道，C/C++中数组的存放是采用连续内存单元的形式:</p>
<p><img src="/2017/03/30/CPP-Access-n-d-array-with-1-d-index-array/c_1d_array.png" alt="c_1d_array"></p>
<p>对一个长度为6的一维整型数组(<code>int a[6]</code>)，运行时将会分配一段连续的内存，我们可以通过<code>a[4]</code>来访问元素，其实这可以看做隐式的指针访问，即<code>*(a+4)</code>，该操作将会访问到第5个元素也就是<code>4</code>。</p>
<p>对<code>*(a+4)</code>的访问过程可以这么理解:</p>
<ol>
<li>得到数组a的基地址</li>
<li>在基地址的基础上加上偏移量<code>4</code></li>
<li>获取该地址对应的整型值</li>
</ol>
<p>下面来看二维的情况。</p>
<p><img src="/2017/03/30/CPP-Access-n-d-array-with-1-d-index-array/c_2d_array.png" alt="c_2d_array"></p>
<p>对一个维度为3*3的二维整型数组(<code>int b[3][3]</code>)，运行时仍然会分配一段连续的内存，直接访问的方式和上面讲的一样，比如<code>b[1][2]</code>，同样，这可以看做<code>*(*(b+1)+2)</code>，该操作会访问到第二行第三列的元素也就是<code>5</code>，其中，<code>b+1</code>的操作对应于取第几行元素，<code>+2</code>的操作就对应于一维的偏移了，具体细节不再展开讨论。</p>
<p>因此对于一个高维数组，比如四维数组<code>int c[5][5][5][5]</code>，<code>c[0][1][2][3]</code>代表的意思即是取<code>c</code>数组中第一维维度为<code>0</code>、第二维维度为<code>1</code>、第三维维度为<code>2</code>、第四维维度为<code>3</code>的对应元素，有了这样的理解，再看<code>*(*(*(*(c+0)+1)+2)+3)</code>就清晰多了。</p>
<p><strong>问题</strong></p>
<p>那么对于一个高维数组(100维、1000维等等)，就没有办法用代码直接写<code>*(*(*(....*(d+k1)+k2)+...+kn)</code>了，所以需要换个思路。</p>
<p>既然内存单元存储的是实际值或者是地址，那么经过多次寻址，我们可以找到需要的实际值，那么怎么完成这个操作呢？</p>
<p>我们仍然使用四维数组为例，假设有:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> arr[<span class="number">10</span>][<span class="number">10</span>][<span class="number">10</span>][<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">arr[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>] = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>同时，索引数组为:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> idx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</div></pre></td></tr></table></figure>
<p>我们想要的结果是得到<code>1</code>，可以直接通过<code>arr[idx[0]][idx[1]][idx[2]][idx[3]]</code>访问，但之前也说过了，这样的代码无法适用于高维情况。</p>
<p><strong><code>void *</code>(不那么好)</strong></p>
<p>最开始我想到的方式是使用<code>void *</code>指针，因为C中任意指针都可以赋值给<code>void *</code>指针，那么我们访问元素的思路可以这么理解:</p>
<ol>
<li>将数组<code>arr</code>的基地址赋值给<code>void *</code>指针</li>
<li>根据每一维索引的偏移量以及<code>int</code>类型的大小计算<code>void *</code>指针的值</li>
<li>将<code>void *</code>指针强制类型转换为<code>int *</code>指针并进行元素访问<code>*p</code></li>
</ol>
<p>需要注意的是第二步中，索引的偏移量代表的是<code>int</code>尺度的偏移，即对于<code>int a[2]</code>, <code>&amp;a[0]</code>和<code>&amp;a[1]</code>之间的偏移量，因此需要乘以<code>int</code>类型的大小。根据上面的描述，测试代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> arr[N][N][N][N] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="keyword">int</span> idx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</div><div class="line">    arr[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>] = <span class="number">1</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Expected: "</span>&lt;&lt;arr[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>]&lt;&lt;<span class="string">" at "</span>&lt;&lt;&amp;arr[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>]&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> *p = arr;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</div><div class="line">        p += idx[i] * <span class="keyword">int</span>(<span class="built_in">pow</span>(N, <span class="number">3</span>-i)) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Got with void *: "</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;*((<span class="keyword">int</span>*)p)&lt;&lt;<span class="string">" at "</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">test.cpp: In function &apos;int main()&apos;:</div><div class="line">test.cpp:21:53: warning: pointer of type &apos;void *&apos; used in arithmetic [-Wpointer-arith]</div><div class="line">         p += idx[i] * int(pow(10, 3-i)) * sizeof(int);</div><div class="line">                                                     ^</div><div class="line">Expected: 1 at 0x7fff5cb20f18</div><div class="line">Got with void *: 1 at 0x7fff5cb20f18</div></pre></td></tr></table></figure>
<p>程序正确地得到了我们想要的结果，但是编译器给出了警告，因为<code>void *</code>指针是未知类型指针，因此编译器并不知道相关计算，另外还有在计算偏移尺度的时候，使用了<code>pow</code>函数而且使用了强制类型转换将其转为<code>int</code>，这可能导致舍入误差。</p>
<p><strong><code>int *</code>改进</strong></p>
<p>对于前述的方法，我们可以使用<code>int *</code>指针以及自己计算偏移尺度进行改进，通过将<code>arr</code>进行强制类型转换，赋值给整型指针<code>p</code>，在前面我们谈到数组的内存分配是连续的，因此我们只需要正确的计算出偏移量即可通过<code>p</code>指针得到所需要的值，此时因为使用的是整型指针<code>p</code>，因此不再需要乘以<code>sizeof(int)</code>，可以理解为<code>p+1</code>指向了下一个整型单元。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> arr[N][N][N][N] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="keyword">int</span> idx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</div><div class="line">    arr[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>] = <span class="number">1</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Expected: "</span>&lt;&lt;arr[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>]&lt;&lt;<span class="string">" at "</span>&lt;&lt;&amp;arr[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>]&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span> *)arr;</div><div class="line">    <span class="keyword">int</span> offset = <span class="number">1e3</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</div><div class="line">    &#123;</div><div class="line">        p += idx[i] * offset;</div><div class="line">        offset /= <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Got with int *: "</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="string">" at "</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Expected: 1 at 0x7fff51d37f08</div><div class="line">Got with int *: 1 at 0x7fff51d37f08</div></pre></td></tr></table></figure>
<p><strong>后话</strong></p>
<p>以上方法需要对指针以及指针的运算有一定的了解，当然，更多情况下，我们完全可以将高维数组展开成低维甚至一维数组，这样的访问将会很方便。或许处理这种问题还有其他更好的方式，有兴趣的读者可以自行研究。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是这两天看书偶然间突然间想到的一个问题，假设有一个高维数组，比如3维整型数组&lt;code&gt;int arr[10][10][10];&lt;/code&gt;，用户每次输入对应维数个数(3)个参数，存入一个索引数组&lt;code&gt;int idx[3]&lt;/code&gt;中，根据索引返回对应索引的元素值。在低维情况下，可以采取直接访问的方式，比如输入的索引值为&lt;code&gt;idx[0] = 1, idx[1] = 2, idx[2] = 3&lt;/code&gt;，可以通过&lt;code&gt;arr[idx[0]][idx[1]][idx[2]]&lt;/code&gt;访问，但是如果数组维度太高，这样的方式就不可行了，比如&lt;code&gt;arr[idx[0]][idx[1]]....[idx[n]]&lt;/code&gt;。所以需要换种方式。&lt;/p&gt;
    
    </summary>
    
      <category term="CPP" scheme="http://youchen.me/categories/CPP/"/>
    
    
      <category term="CPP" scheme="http://youchen.me/tags/CPP/"/>
    
      <category term="指针" scheme="http://youchen.me/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="数组" scheme="http://youchen.me/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>基于Scrapy的京东商品评论爬虫</title>
    <link href="http://youchen.me/2017/03/12/Python-A-JD-spider-based-on-scrapy/"/>
    <id>http://youchen.me/2017/03/12/Python-A-JD-spider-based-on-scrapy/</id>
    <published>2017-03-12T14:07:57.000Z</published>
    <updated>2017-03-13T11:36:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天想跟大家分享的是关于网络爬虫的相关知识，网络爬虫是一种根据一定的规则，自动地对互联网上相关内容进行抓取的程序或者脚本，本文的内容主要是通过分析京东评论的加载过程，获取相关API，然后通过使用基于Python语言的开源网络爬虫框架——Scrapy，大量获取相关评论内容。</p>
<div class="tip"><br>本文假定读者具有一定的Python编程经验，具有少量HTTP协议和HTML的相关知识，对爬虫的工作原理有一定了解。<br></div>

<a id="more"></a>
<h1 id="API获取"><a href="#API获取" class="headerlink" title="API获取"></a>API获取</h1><p>在开始编写爬虫之前，我们需要获得启动爬虫所需要的相关链接。在本文，我们将以对京东鞋类评论爬取为例，进行说明(其他种类爬取流程类似，区别只在于数据处理)。<br>首先打开京东，搜索“鞋”，打开任意一件商品，并切换到“商品评价”标签页，如图所示。</p>
<p><img src="/2017/03/12/Python-A-JD-spider-based-on-scrapy/item_shoe_comments_tab.png" alt="comments_tab"></p>
<p>启用浏览器的网页分析功能，以Safari浏览器为例，右键点击网页任意部分，选择”检查元素“，切换到“网络”标签下，如果有其他内容的话，可以点击右侧的垃圾桶图标清空历史，如图所示。</p>
<p><img src="/2017/03/12/Python-A-JD-spider-based-on-scrapy/console_network_before.png" alt="console_network_before"></p>
<p>然后我们点击评论区的换页按钮，切换到任意一页新的评论，此时可以发现浏览器对本次点击产生的数据交换过程进行了记录，我们发现其中有一条名为”productPageComments.action”的记录，对其进行分析可以看到对应的完整URL，如图所示。</p>
<p><img src="/2017/03/12/Python-A-JD-spider-based-on-scrapy/console_network_after.png" alt="console_network_after"></p>
<p>其完整URL为:<code>https://club.jd.com/comment/productPageComments.action?callback=fetchJSON_comment98vv6630&amp;productId=10353518575&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0</code></p>
<p>显而易见，评论的加载是通过GET请求实现，对我们来说，该URL中最关键的GET参数为<code>productID</code>和<code>page</code>，它们分别定义了对应的商品编号以及评论页码。通过访问该URL，我们可以得到内容如图所示。</p>
<p><img src="/2017/03/12/Python-A-JD-spider-based-on-scrapy/comments_json_1.png" alt="comments_json_1"></p>
<p>可以看到，该URL返回的内容为json数据包，同时以请求中<code>callback</code>定义的函数名对其进行包裹，这一点从整个数据包最前方可以看出。我们将GET请求中callback参数去掉以后即可得到原始的json数据包，如图所示。</p>
<p><img src="/2017/03/12/Python-A-JD-spider-based-on-scrapy/comments_json_2.png" alt="comments_json_2"></p>
<p>因此，在不考虑其他参数的情况下，我们需要的API格式为:<code>https://club.jd.com/comment/productPageComments.action?productId={}&amp;score=0&amp;sortType=5&amp;page={}&amp;pageSize=10&amp;isShadowSku=0</code></p>
<p>至此，我们获得了返回任意商品的任意评论页的API，下面我们将对API返回数据本身的内容进行分析。</p>
<h1 id="API返回字典分析"><a href="#API返回字典分析" class="headerlink" title="API返回字典分析"></a>API返回字典分析</h1><p>从前面图中可以看出，API返回数据应该是一个字典，我们通过使用requests获得API返回字典以及Python的json模块进行分析。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'https://club.jd.com/comment/productPageComments.action?productId=10353518575&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>html = requests.get(url)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>data = json.loads(html.text)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(data.keys())</div><div class="line">dict_keys([<span class="string">'productAttr'</span>, <span class="string">'productCommentSummary'</span>, <span class="string">'hotCommentTagStatistics'</span>,</div><div class="line"><span class="string">'jwotestProduct'</span>, <span class="string">'maxPage'</span>, <span class="string">'score'</span>, <span class="string">'soType'</span>, <span class="string">'imageListCount'</span>,</div><div class="line"><span class="string">'vTagStatistics'</span>, <span class="string">'comments'</span>])</div></pre></td></tr></table></figure>
<p>其中对我们来说最重要的是键<code>comments</code>所对应的值，值为一个列表，其中每个元素为一个字典，存放的是每一条评论的相关信息。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; print(type(data['comments']))</div><div class="line">&lt;class 'list'&gt;</div><div class="line">&gt;&gt;&gt; import pprint</div><div class="line">&gt;&gt;&gt; pprint(data['comments'][0])</div><div class="line">&#123;'afterDays': 0,</div><div class="line"> 'anonymousFlag': 1,</div><div class="line"> 'commentTags': [&#123;'commentId': 1927838458,</div><div class="line">                  'created': '2016-10-19 18:26:50',</div><div class="line">                  'id': 12373951,</div><div class="line">                  'modified': '2016-10-19 18:26:50',</div><div class="line">                  'name': '穿上很舒服',</div><div class="line">                  'pin': '',</div><div class="line">                  'productId': 10353518575,</div><div class="line">                  'rid': 11632,</div><div class="line">                  'status': 0&#125;],</div><div class="line"> 'content': '鞋子很不错，弹性很不错，材质很轻。穿上很舒服。透气性好，而且又长高了两厘米。',</div><div class="line"> 'creationTime': '2016-10-19 18:26:20',</div><div class="line"> 'days': 8,</div><div class="line"> 'firstCategory': 1318,</div><div class="line"> 'guid': 'cc2fec79-304b-48c5-a263-151bf7d098d2',</div><div class="line"> 'id': 1927838458,</div><div class="line"> 'integral': -20,</div><div class="line"> 'isMobile': False,</div><div class="line"> 'isReplyGrade': False,</div><div class="line"> 'isTop': False,</div><div class="line"> 'nickname': 'j***k',</div><div class="line"> 'orderId': 0,</div><div class="line"> 'plusAvailable': 0,</div><div class="line"> 'productColor': '黑/安踏白',</div><div class="line"> 'productSales': [],</div><div class="line"> 'productSize': '8(男41)',</div><div class="line"> 'recommend': True,</div><div class="line"> 'referenceId': '10353518575',</div><div class="line"> 'referenceImage': 'jfs/t3073/150/7342609081/176958/b211c3f7/58b4c73cN9621804d.jpg',</div><div class="line"> 'referenceName': '安踏男鞋 易弯折科技跑步鞋 2017新款透气网面运动鞋 黑/安踏白-1 8(男41)',</div><div class="line"> 'referenceTime': '2016-10-11 20:03:00',</div><div class="line"> 'referenceType': 'Product',</div><div class="line"> 'referenceTypeId': 0,</div><div class="line"> 'replyCount': 0,</div><div class="line"> 'score': 5,</div><div class="line"> 'secondCategory': 12099,</div><div class="line"> 'status': 1,</div><div class="line"> 'thirdCategory': 9756,</div><div class="line"> 'title': '',</div><div class="line"> 'usefulVoteCount': 1,</div><div class="line"> 'uselessVoteCount': 0,</div><div class="line"> 'userClient': 0,</div><div class="line"> 'userClientShow': '',</div><div class="line"> 'userImage': 'misc.360buyimg.com/lib/img/u/b56.gif',</div><div class="line"> 'userImageUrl': 'misc.360buyimg.com/lib/img/u/b56.gif',</div><div class="line"> 'userImgFlag': 0,</div><div class="line"> 'userLevelColor': '#666666',</div><div class="line"> 'userLevelId': '56',</div><div class="line"> 'userLevelName': '铜牌会员',</div><div class="line"> 'userProvince': '',</div><div class="line"> 'viewCount': 0&#125;</div></pre></td></tr></table></figure>
<p>根据实际需要，在本次实现中选取了以下信息:</p>
<ul>
<li>guid                –&gt; 评论用户id</li>
<li>id                –&gt; 该评论id</li>
<li>referenceId        –&gt; 评论商品id</li>
<li>creationTime    –&gt; 评论时间</li>
<li>score            –&gt; 评论评分</li>
<li>userProvince    –&gt; 评论用户归属地</li>
<li>userLevelName    –&gt; 评论用户会员级别</li>
<li>productColor    –&gt; 评论用户购买颜色</li>
<li>productSize        –&gt; 评论用户购买尺寸</li>
</ul>
<p>至此，我们完成了对API返回字典的分析，在构建Scrapy爬虫之前，我们还需要对商品列表进行分析。</p>
<h1 id="商品列表分析"><a href="#商品列表分析" class="headerlink" title="商品列表分析"></a>商品列表分析</h1><p>我们已经拥有对任意给定的商品id,获取其所有评论的API，但在构建爬虫之前，我们还有最后一个问题，如何获得商品id?<br>我们可以很容易的获得并格式化京东的搜索链接:<code>https://search.jd.com/Search?keyword={}&amp;enc=utf-8&amp;page={}</code>，根据该格式化链接，我们只需要填写搜索关键字以及搜索页码就能得到对应页的搜索结果。通过对网页源代码进行分析，可以发现每个商品都处于<code>class=&quot;gl-item&quot;</code>的<code>li</code>元素下，如图所示。</p>
<p><img src="/2017/03/12/Python-A-JD-spider-based-on-scrapy/console_item_list.png" alt="console_item_list"><br><img src="/2017/03/12/Python-A-JD-spider-based-on-scrapy/console_item_list_2.png" alt="console_item_list_2"></p>
<p>我们只需要对<code>class=&quot;gl-item&quot;</code>的<code>li</code>元素下<code>class=&quot;p-img&quot;</code>的<code>div</code>元素下的<code>a</code>元素的<code>href</code>属性进行提取处理即可得到商品id，如图中的<code>10353518575</code>。</p>
<p>至此，我们完成了对商品列表的分析工作，接下来我们将构建基于Scrapy的爬虫来完成对评论的爬取工作。</p>
<h1 id="可选-商品详细信息"><a href="#可选-商品详细信息" class="headerlink" title="(可选)商品详细信息"></a>(可选)商品详细信息</h1><p>我们在上节中获得了商品的详细信息链接，如:<code>https://item.jd.com/10353518575.html</code>，我们可以对该页面内容进行爬取以获得更全面的商品信息。在这部分需要注意的是，很多内容是通过JavaScript进行动态加载的，在爬取时需要注意，否则得到的数据并不符合需要。通过启用浏览器的“停用JavaScript”功能，可以看到在不执行JavaScript时的页面是什么样的，如图所示。</p>
<p><img src="/2017/03/12/Python-A-JD-spider-based-on-scrapy/item_detail_no_js.png" alt="item_detail_no_js"></p>
<p>可以看到，商品的价格等信息是没有进行加载的，所以如果需要对价格进行爬取，需要使用到selenium等工具来完成浏览器的模拟或者进一步分析JavaScript的执行逻辑。</p>
<h1 id="Scrapy爬虫"><a href="#Scrapy爬虫" class="headerlink" title="Scrapy爬虫"></a>Scrapy爬虫</h1><p>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。其最初是为了网络抓取所设计的，也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。</p>
<p>要使用Scrapy，首先得建立项目:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ scrapy startproject jd</div><div class="line">New Scrapy project &apos;jd&apos;, using template directory &apos;/usr/local/lib/python3.6/site-packages/scrapy/templates/project&apos;, created in:</div><div class="line">    /private/tmp/jd</div><div class="line"></div><div class="line">You can start your first spider with:</div><div class="line">    cd jd</div><div class="line">    scrapy genspider example example.com</div></pre></td></tr></table></figure>
<p>在建好的<code>jd</code>文件夹下，有一个<code>jd</code>文件夹以及一个<code>scrapy.cfg</code>文件，进入前者，可以看到以下内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ls</div><div class="line">__init__.py    items.py       pipelines.py   spiders</div><div class="line">__pycache__    middlewares.py settings.py</div></pre></td></tr></table></figure>
<p>其中:</p>
<ul>
<li>items.py         –&gt; 完成数据容器Item的定义<br>  爬取的主要目标就是从非结构性的数据源提取结构性数据，例如网页。Scrapy提供 Item 类来满足这样的需求。Item 对象是种简单的容器，保存了爬取到得数据。 其提供了 类似于词典(dictionary-like) 的API以及用于声明可用字段的简单语法。</li>
<li>pipelines.py    –&gt; 完成对Item处理流水线的定义<br>  当Item在Spider中被收集之后，它将会被传递到Item Pipeline，一些组件会按照一定的顺序执行对Item的处理。每个item pipeline组件(有时称之为“Item Pipeline”)是实现了简单方法的Python类。他们接收到Item并通过它执行一些行为，同时也决定此Item是否继续通过pipeline，或是被丢弃而不再进行处理。<br>  以下是item pipeline的一些典型应用：<ul>
<li>清理HTML数据</li>
<li>验证爬取的数据(检查item包含某些字段)</li>
<li>查重(并丢弃)</li>
<li>将爬取结果保存到数据库中</li>
</ul>
</li>
<li>middlewares.py    –&gt; 完成Spider中间件的定义<br>  Spider中间件是介入到Scrapy的spider处理机制的钩子框架，通过定义并使用中间件，可以对发送给Spiders的response以及Spiders产生的Request对象进行处理。</li>
<li>settings.py        –&gt; 完成对爬虫的控制<br>  Scrapy settings提供了定制Scrapy组件的方法。通过修改settings.py，可以控制包括核心(core)，插件(extension)，pipeline及spider组件。settings为代码提供了提取以key-value映射的配置值的的全局命名空间(namespace)。settings同时也是选择当前激活的Scrapy项目的方法。</li>
<li>spiders            –&gt; 完成对爬虫Spider的定义<br>  Spider类定义了如何爬取某个(或某些)网站。包括了爬取的动作(例如:是否跟进链接)以及如何从网页的内容中提取结构化数据(爬取item)。换句话说，Spider就是定义爬取的动作及分析某个网页(或者是有些网页)的地方。</li>
</ul>
<h4 id="定义数据容器items"><a href="#定义数据容器items" class="headerlink" title="定义数据容器items"></a>定义数据容器items</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scrapy</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeCommentItem</span><span class="params">(scrapy.Item)</span>:</span></div><div class="line">    <span class="comment"># define the fields for your item here like:</span></div><div class="line">    <span class="comment"># name = scrapy.Field()</span></div><div class="line">    _id = scrapy.Field()</div><div class="line">    iid = scrapy.Field()</div><div class="line">    uid = scrapy.Field()</div><div class="line">    creation_time = scrapy.Field()</div><div class="line">    score = scrapy.Field()</div><div class="line">    user_province = scrapy.Field()</div><div class="line">    user_level = scrapy.Field()</div><div class="line">    color = scrapy.Field()</div><div class="line">    size = scrapy.Field()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeDetailItem</span><span class="params">(scrapy.Item)</span>:</span></div><div class="line">    iid = scrapy.Field()</div><div class="line">    name = scrapy.Field()</div><div class="line">    shop = scrapy.Field()</div><div class="line">    scores = scrapy.Field()</div></pre></td></tr></table></figure>
<h4 id="定义爬虫类"><a href="#定义爬虫类" class="headerlink" title="定义爬虫类"></a>定义爬虫类</h4><p>创建爬虫类的命令为:<code>scrapy genspider [爬虫名] [允许爬取域名]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ scrapy genspider shoes jd.com</div><div class="line">Created spider &apos;shoes&apos; using template &apos;basic&apos; in module:</div><div class="line">  jd.spiders.shoes</div></pre></td></tr></table></figure>
<p>接着打开<code>spiders</code>文件夹下的<code>shoes.py</code>文件进行编辑:</p>
<ul>
<li><p>首先我们需要定义一些变量，比如包含搜索关键字的列表、格式化搜索链接、格式化评论API链接等:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">shoe_cates = [</div><div class="line">    <span class="string">'女深口单鞋'</span>, <span class="string">'工装鞋'</span>, <span class="string">'女鞋'</span>, <span class="string">'正装鞋'</span>, <span class="string">'平底鞋'</span>, <span class="string">'平底女鞋'</span>,</div><div class="line">    <span class="string">'功能鞋'</span>, <span class="string">'中跟单鞋'</span>, <span class="string">'女拖鞋'</span>, <span class="string">'凉鞋'</span>, <span class="string">'拖鞋'</span>, <span class="string">'帆布鞋'</span>, <span class="string">'人字拖'</span>,</div><div class="line">    <span class="string">'马丁靴'</span>, <span class="string">'商务休闲鞋'</span>, <span class="string">'传统布鞋'</span>, <span class="string">'休闲鞋'</span>, <span class="string">'鞋'</span>, <span class="string">'棉鞋'</span>, <span class="string">'定制鞋'</span>,</div><div class="line">    <span class="string">'男靴'</span>, <span class="string">'坡跟单鞋'</span>, <span class="string">'短靴'</span>, <span class="string">'雨鞋'</span>, <span class="string">'平板鞋'</span>, <span class="string">'尖头单鞋'</span>, <span class="string">'军靴'</span>, <span class="string">'女靴'</span>,</div><div class="line">    <span class="string">'皮鞋'</span>, <span class="string">'小白鞋'</span>, <span class="string">'雪地靴'</span>, <span class="string">'女豆豆鞋'</span>, <span class="string">'妈妈鞋'</span>, <span class="string">'增高鞋'</span>, <span class="string">'劳保鞋'</span>,</div><div class="line">    <span class="string">'豆豆鞋'</span>, <span class="string">'踝靴'</span>, <span class="string">'沙滩鞋'</span>, <span class="string">'鞋 女'</span>, <span class="string">'深口单鞋'</span>, <span class="string">'板鞋'</span>, <span class="string">'高帮鞋'</span>,</div><div class="line">    <span class="string">'人字拖鞋'</span>, <span class="string">'内增高'</span>, <span class="string">'发光鞋'</span>, <span class="string">'运动鞋'</span>, <span class="string">'高跟鞋'</span>, <span class="string">'雨靴'</span>, <span class="string">'鞋 男'</span>,</div><div class="line">    <span class="string">'乐福鞋'</span>, <span class="string">'内增高休闲鞋'</span>, <span class="string">'老人鞋'</span>, <span class="string">'男鞋'</span>, <span class="string">'平底单鞋'</span>, <span class="string">'浅口单鞋'</span>, <span class="string">'单鞋'</span>]</div><div class="line">shoe_list_url = <span class="string">'https://search.jd.com/Search?keyword=&#123;&#125;&amp;enc=utf-8&amp;page=&#123;&#125;'</span></div><div class="line">comment_url_api = (<span class="string">'https://club.jd.com/comment/productPageComments.action?'</span></div><div class="line">    <span class="string">'productId=&#123;&#125;&amp;score=0&amp;sortType=5&amp;page=&#123;&#125;&amp;pageSize=10&amp;isShadowSku=0'</span>)</div><div class="line">num_pat = re.compile(<span class="string">'(\d*?)'</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>然后编辑<code>ShoesSpider</code>类:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoesSpider</span><span class="params">(Spider)</span>:</span></div><div class="line">    name = <span class="string">'shoes'</span></div><div class="line">    allowed_domains = [<span class="string">'jd.com'</span>]</div><div class="line">    start_urls = [shoe_list_url.format(cate, page) <span class="keyword">for</span> cate <span class="keyword">in</span> shoe_cates</div><div class="line">                  <span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>)]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></div><div class="line">        item_urls = response.xpath(<span class="string">'//li[@class="gl-item"]/div'</span>)</div><div class="line">        <span class="keyword">for</span> item_xpath <span class="keyword">in</span> item_urls:</div><div class="line">            url = item_xpath.xpath(<span class="string">'div[@class="p-img"]/a'</span></div><div class="line">                                   <span class="string">'/@href'</span>).extract_first()</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> url <span class="keyword">or</span> <span class="string">'ccc-x'</span> <span class="keyword">in</span> url:</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            iid = url[url.rfind(<span class="string">'/'</span>)+<span class="number">1</span>:<span class="number">-5</span>]</div><div class="line">            detail_url = <span class="string">'http:'</span> + url</div><div class="line">            <span class="keyword">yield</span> Request(</div><div class="line">                detail_url,</div><div class="line">                callback=self.parse_detail,</div><div class="line">                meta=&#123;<span class="string">'iid'</span>: iid&#125;)</div><div class="line">            <span class="keyword">yield</span> Request(</div><div class="line">                comment_url_api.format(iid, <span class="number">1</span>),</div><div class="line">                callback=self.parse_comment,</div><div class="line">                meta=&#123;<span class="string">'page'</span>: <span class="number">1</span>, <span class="string">'iid'</span>: iid, <span class="string">'retry'</span>: <span class="number">0</span>&#125;)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_detail</span><span class="params">(self, response)</span>:</span></div><div class="line">        iid = int(response.meta[<span class="string">'iid'</span>])</div><div class="line">        name = response.xpath(<span class="string">'//div[@class="sku-name"]'</span></div><div class="line">                              <span class="string">'/text()'</span>).extract_first().strip(<span class="string">'\n '</span>)</div><div class="line">        xpath_aside = response.xpath(<span class="string">'//div[@class="aside"]'</span>)</div><div class="line">        shop = xpath_aside.xpath(<span class="string">'//div[@class="mt"]/'</span></div><div class="line">                                 <span class="string">'h3/a/@title'</span>).extract_first().strip(<span class="string">'\n '</span>)</div><div class="line">        scores = xpath_aside.xpath(<span class="string">'//div[@class="mc"]/div/'</span></div><div class="line">                                   <span class="string">'a//text()'</span>).extract()</div><div class="line">        scores = [s <span class="keyword">for</span> s <span class="keyword">in</span> scores <span class="keyword">if</span> s.strip(<span class="string">'\n '</span>)][::<span class="number">2</span>]</div><div class="line"></div><div class="line">        sd = ShoeDetailItem(iid=iid, name=name, shop=shop,</div><div class="line">                            scores=<span class="string">'|'</span>.join(scores))</div><div class="line">        <span class="keyword">yield</span> sd</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_comment</span><span class="params">(self, response)</span>:</span></div><div class="line">        iid = response.meta[<span class="string">'iid'</span>]</div><div class="line">        page = int(response.meta[<span class="string">'page'</span>])</div><div class="line">        retry = int(response.meta[<span class="string">'retry'</span>])</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            json_data = json.loads(response.text)</div><div class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">            <span class="keyword">if</span> retry &lt; <span class="number">10</span>:</div><div class="line">                <span class="keyword">yield</span> Request(</div><div class="line">                    comment_url_api.format(iid, page),</div><div class="line">                    callback=self.parse_comment,</div><div class="line">                    meta=&#123;<span class="string">'page'</span>: page, <span class="string">'iid'</span>: iid, <span class="string">'retry'</span>: retry+<span class="number">1</span>&#125;)</div><div class="line">            <span class="keyword">return</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> json_data[<span class="string">'comments'</span>]:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="keyword">for</span> cd <span class="keyword">in</span> json_data[<span class="string">'comments'</span>]:</div><div class="line">            d = &#123;&#125;</div><div class="line">            d[<span class="string">'_id'</span>] = cd[<span class="string">'id'</span>]</div><div class="line">            d[<span class="string">'iid'</span>] = cd[<span class="string">'referenceId'</span>]</div><div class="line">            d[<span class="string">'uid'</span>] = cd[<span class="string">'guid'</span>]</div><div class="line">            d[<span class="string">'creation_time'</span>] = cd[<span class="string">'creationTime'</span>]</div><div class="line">            d[<span class="string">'score'</span>] = cd[<span class="string">'score'</span>]</div><div class="line">            d[<span class="string">'user_province'</span>] = cd[<span class="string">'userProvince'</span>]</div><div class="line">            d[<span class="string">'user_level'</span>] = cd[<span class="string">'userLevelName'</span>]</div><div class="line">            d[<span class="string">'color'</span>] = cd[<span class="string">'productColor'</span>]</div><div class="line">            d[<span class="string">'size'</span>] = cd[<span class="string">'productSize'</span>]</div><div class="line">            sc = ShoeCommentItem(d)</div><div class="line">            <span class="keyword">yield</span> sc</div><div class="line">        <span class="keyword">yield</span> Request(</div><div class="line">            comment_url_api.format(iid, page+<span class="number">1</span>),</div><div class="line">            callback=self.parse_comment,</div><div class="line">            meta=&#123;<span class="string">'page'</span>: page+<span class="number">1</span>, <span class="string">'iid'</span>: iid, <span class="string">'retry'</span>: <span class="number">0</span>&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>详细分析下这段代码:</p>
<ul>
<li>类<code>ShoesSpider</code>继承自<code>Spider</code>，其余可继承的类还有<code>CrawlSpider</code>、<code>XMLFeedSpider</code>、<code>SitemapSpider</code>，在这里我们使用了最基本的<code>Spider</code>。</li>
<li>属性<code>name</code>定义了该爬虫的名字，在启动爬虫的步骤中需要提供爬虫名字。</li>
<li>属性<code>allowed_domains</code>定义了一个列表，可以包含一个或多个域名，爬虫只会对该域名下的链接进行爬取。</li>
<li>属性<code>start_urls</code>定义了一个列表，spider启动时将从中获取链接进行爬取。</li>
<li>实例方法<code>parse</code>定义了对商品列表页面进行处理的相关逻辑:<ul>
<li>接收一个<code>response</code>参数，该<code>response</code>对象为爬虫根据<code>Request</code>对象请求获得的结果。</li>
<li>根据前面几节的描述，<code>parse</code>方法针对商品列表页面使用xpath进行分析。</li>
<li>在提取到商品<code>iid</code>后，对该页面下所有商品<code>iid</code>进行遍历，分别为商品详细页面(可选)以及商品评论页面构建<code>Request</code>请求，注意使用了<code>yield</code>，因为我们需要返回多个请求而不是一个请求。</li>
<li>对每个<code>Request</code>请求，我们指定了相关参数，比如链接、回调函数，以及通过<code>meta</code>关键字保存上下文信息字典，这可以在回调函数中访问<code>Response</code>的<code>meta</code>属性获得。</li>
</ul>
</li>
<li>实例方法<code>parse_detail</code>定义了对商品详细页面进行处理的相关逻辑:<ul>
<li>我们依然通过xpath进行分析，获得了商品名、商家名、商家评分等信息，使用其实例化<code>ShoeDetailItem</code>类并返回该实例。</li>
</ul>
</li>
<li>实例方法<code>parse_comment</code>定义了对商品评论进行处理的相关逻辑:<ul>
<li>根据在<code>Request</code>对象中设置<code>meta</code>属性，我们可以很方便地获得当前物品id、当前评论页码、以及访问重试次数。</li>
<li>我们需要对<code>response</code>对象的<code>text</code>属性使用<code>json.loads</code>进行格式化，但是由于各种原因可能会失败，所以我们设置了方式重试次数这一变量来控制重试，当本次<code>json.loads</code>格式化失败，我们会再次进行尝试访问该评论链接，直到达到最大重试次数10次，然后放弃。</li>
<li>如果解析成功，判断解析后的字典中键<code>comments</code>所对应的内容是否为空，为空代表已经没有更多评论，则返回。</li>
<li>否则，对每条评论进行遍历，使用其中的参数实例化<code>ShoeCommentItem</code>类并返回该实例。</li>
<li>在结束评论遍历后，尝试对评论下一页发出<code>Request</code>请求。</li>
</ul>
</li>
</ul>
<p>至此，我们完成了爬虫的工作逻辑，接下来需要对流水线进行定义，完成数据的查重以及保存等操作。</p>
<h4 id="定义pipeline流水线"><a href="#定义pipeline流水线" class="headerlink" title="定义pipeline流水线"></a>定义pipeline流水线</h4><p>对于各个<code>parse</code>方法返回的<code>Item</code>对象，它们将会被传递到在<code>pipelines.py</code>中定义以及<code>settings.py</code>中启用的流水线中进行处理。<br>在本文中我们需要对每个<code>Item</code>对象做两件事，去重以及保存。对于<code>ShoeCommentItem</code>的流水线定义如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeCommentPipeline</span><span class="params">(object)</span>:</span></div><div class="line">    seen_ids = set()</div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></div><div class="line">        pipe = cls()</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'shoe_comments.csv'</span>):</div><div class="line">            <span class="keyword">return</span> pipe</div><div class="line">        pat = re.compile(<span class="string">'^\d+?,'</span>)</div><div class="line">        <span class="keyword">with</span> open(<span class="string">'shoe_comments.csv'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">                _id = pat.findall(line)</div><div class="line">                <span class="keyword">if</span> _id:</div><div class="line">                    pipe.seen_ids.add(_id[<span class="number">0</span>])</div><div class="line">        <span class="keyword">return</span> pipe</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(item, ShoeCommentItem):</div><div class="line">            <span class="keyword">return</span> item</div><div class="line"></div><div class="line">        _id = item[<span class="string">'_id'</span>]</div><div class="line">        <span class="keyword">if</span> _id <span class="keyword">in</span> self.seen_ids:</div><div class="line">            <span class="keyword">raise</span> DropItem(<span class="string">'&#123;&#125; Have been processed.'</span>.format(_id))</div><div class="line">        self.seen_ids.add(_id)</div><div class="line"></div><div class="line">        key_values = list(item.items())</div><div class="line">        key_values.sort(key=<span class="keyword">lambda</span> x: val_indices[x[<span class="number">0</span>]])</div><div class="line">        values = [str(val) <span class="keyword">for</span> key, val <span class="keyword">in</span> key_values]</div><div class="line">        <span class="keyword">with</span> open(<span class="string">'shoe_comments.csv'</span>, <span class="string">'a'</span>) <span class="keyword">as</span> f:</div><div class="line">            f.write(<span class="string">','</span>.join(values)+<span class="string">'\n'</span>)</div><div class="line">        <span class="keyword">return</span> item</div></pre></td></tr></table></figure>
<p>需要解释的是类方法<code>from_crawler</code>和实例方法<code>process_item</code>，前者在初始化时会被调用，后者在出现<code>Item</code>对象时被调用。<br>对于<code>from_crawler</code>方法:</p>
<ul>
<li>我们需要忽略之前已经处理过的评论，因此采用了一个<code>set</code>来存储已经处理过的<code>id</code></li>
<li>在初始化时，打开之前保存的评论文件<code>shoe_comments.csv</code>，从中获取<code>id</code>并对<code>seen_ids</code>进行填充</li>
<li>这是一个类方法，需要在最后返回类的实例</li>
</ul>
<p>对于<code>process_item</code>方法:</p>
<ul>
<li>方法接收两个参数，前一个是返回的<code>Item</code>对象，后一个是返回该对象的对应<code>Spider</code>对象</li>
<li>首先判断了该<code>Item</code>是否是类<code>ShoeCommentItem</code>实例，如果不是的话不进行处理直接返回该对象</li>
<li>提取该对象的<code>id</code>并判断该对象是否已经处理过，已经处理过的话抛出<code>DropItem</code>异常，停止后续流水线的处理</li>
<li>将该对象<code>id</code>加入<code>seen_ids</code>，并根据<code>val_indices</code>定义的顺序将其排序及格式化字符串并追加到<code>shoe_comments.csv</code>中</li>
<li>返回该对象</li>
</ul>
<blockquote>
<p>需要特别注意的是，<code>process_item</code>方法必须返回一个<code>Item</code>(或任何继承类)对象或者是抛出<code>DropItem</code>异常，被丢弃的item将不会被之后的pipeline组件所处理，而正常返回的会。</p>
</blockquote>
<p>同理我们可以定义<code>ShoeDetailItem</code>的流水线:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeDetailPipeline</span><span class="params">(object)</span>:</span></div><div class="line">    seen_ids = set()</div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></div><div class="line">        pipe = cls()</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'shoe_details.csv'</span>):</div><div class="line">            <span class="keyword">return</span> pipe</div><div class="line">        pat = re.compile(<span class="string">'^\d+?,'</span>)</div><div class="line">        <span class="keyword">with</span> open(<span class="string">'shoe_details.csv'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">                iid = pat.findall(line)</div><div class="line">                <span class="keyword">if</span> iid:</div><div class="line">                    pipe.seen_ids.add(iid[<span class="number">0</span>])</div><div class="line">        <span class="keyword">return</span> pipe</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(item, ShoeDetailItem):</div><div class="line">            <span class="keyword">return</span> item</div><div class="line"></div><div class="line">        iid = item[<span class="string">'iid'</span>]</div><div class="line">        <span class="keyword">if</span> iid <span class="keyword">in</span> self.seen_ids:</div><div class="line">            <span class="keyword">raise</span> DropItem(<span class="string">'&#123;&#125; detail have been processed.'</span>.format(iid))</div><div class="line">        self.seen_ids.add(iid)</div><div class="line"></div><div class="line">        key_values = list(item.items())</div><div class="line">        key_values.sort(key=<span class="keyword">lambda</span> x: detail_indices[x[<span class="number">0</span>]])</div><div class="line">        values = [str(val) <span class="keyword">for</span> key, val <span class="keyword">in</span> key_values]</div><div class="line">        <span class="keyword">with</span> open(<span class="string">'shoe_details.csv'</span>, <span class="string">'a'</span>) <span class="keyword">as</span> f:</div><div class="line">            f.write(<span class="string">','</span>.join(values)+<span class="string">'\n'</span>)</div><div class="line">        <span class="keyword">return</span> item</div></pre></td></tr></table></figure>
<p>该流水线逻辑与前一个类似，在此不再赘述。</p>
<h4 id="settings-py的配置"><a href="#settings-py的配置" class="headerlink" title="settings.py的配置"></a>settings.py的配置</h4><p>我们还需要对<code>settings.py</code>进行配置。<br>其中关键的几个设置是:</p>
<ul>
<li>CONCURRENT_REQUESTS(并发请求数): 100</li>
<li>COOKIES_ENABLED(启用cookies): False</li>
<li>ITEM_PIPELINES(item流水线): {‘jd.pipelines.ShoeCommentPipeline’: 300, ‘jd.pipelines.ShoeDetailPipeline’: 301}</li>
</ul>
<p>具体设置可以根据自己的需求进行设置，以上只是一个示例。</p>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>最后，让我们启动这个爬虫:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ scrapy crawl shoes</div></pre></td></tr></table></figure>
<p>可以在控制台看到输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">2017-03-13 19:21:12 [scrapy.utils.log] INFO: Scrapy 1.3.0 started (bot: jd)</div><div class="line">2017-03-13 19:21:12 [scrapy.utils.log] INFO: Overridden settings: &#123;&apos;BOT_NAME&apos;: &apos;jd&apos;, &apos;CONCURRENT_REQUESTS&apos;: 100, &apos;COOKIES_ENABLED&apos;: False, &apos;DOWNLOAD_DELAY&apos;: 0.01, &apos;NEWSPIDER_MODULE&apos;: &apos;jd.spiders&apos;, &apos;SPIDER_MODULES&apos;: [&apos;jd.spiders&apos;]&#125;</div><div class="line">2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled extensions:</div><div class="line">[&apos;scrapy.extensions.corestats.CoreStats&apos;,</div><div class="line"> &apos;scrapy.extensions.telnet.TelnetConsole&apos;,</div><div class="line"> &apos;scrapy.extensions.logstats.LogStats&apos;]</div><div class="line">2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled downloader middlewares:</div><div class="line">[&apos;scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware&apos;,</div><div class="line"> &apos;scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware&apos;,</div><div class="line"> &apos;scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware&apos;,</div><div class="line"> &apos;scrapy.downloadermiddlewares.useragent.UserAgentMiddleware&apos;,</div><div class="line"> &apos;jd.middlewares.RandomUserAgentMiddleware&apos;,</div><div class="line"> &apos;jd.middlewares.ProxyMiddleware&apos;,</div><div class="line"> &apos;scrapy.downloadermiddlewares.retry.RetryMiddleware&apos;,</div><div class="line"> &apos;scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware&apos;,</div><div class="line"> &apos;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&apos;,</div><div class="line"> &apos;scrapy.downloadermiddlewares.redirect.RedirectMiddleware&apos;,</div><div class="line"> &apos;scrapy.downloadermiddlewares.stats.DownloaderStats&apos;]</div><div class="line">2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled spider middlewares:</div><div class="line">[&apos;scrapy.spidermiddlewares.httperror.HttpErrorMiddleware&apos;,</div><div class="line"> &apos;scrapy.spidermiddlewares.offsite.OffsiteMiddleware&apos;,</div><div class="line"> &apos;scrapy.spidermiddlewares.referer.RefererMiddleware&apos;,</div><div class="line"> &apos;scrapy.spidermiddlewares.urllength.UrlLengthMiddleware&apos;,</div><div class="line"> &apos;scrapy.spidermiddlewares.depth.DepthMiddleware&apos;]</div><div class="line">2017-03-13 19:21:12 [scrapy.middleware] INFO: Enabled item pipelines:</div><div class="line">[&apos;jd.pipelines.ShoeCommentPipeline&apos;, &apos;jd.pipelines.ShoeDetailPipeline&apos;]</div><div class="line">2017-03-13 19:21:12 [scrapy.core.engine] INFO: Spider opened</div><div class="line">2017-03-13 19:21:12 [scrapy.extensions.logstats] INFO: Crawled 0 pages (at 0 pages/min), scraped 0 items (at 0 items/min)</div><div class="line">2017-03-13 19:21:12 [scrapy.extensions.telnet] DEBUG: Telnet console listening on 127.0.0.1:6023</div><div class="line">2017-03-13 19:21:13 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=3&gt; (referer: None)</div><div class="line">2017-03-13 19:21:13 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=7&gt; (referer: None)</div><div class="line">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=6&gt; (referer: None)</div><div class="line">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=9&gt; (referer: None)</div><div class="line">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=5&gt; (referer: None)</div><div class="line">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=10&gt; (referer: None)</div><div class="line">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=2&gt; (referer: None)</div><div class="line">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=1&gt; (referer: None)</div><div class="line">2017-03-13 19:21:16 [scrapy.dupefilters] DEBUG: Filtered duplicate request: &lt;GET http://item.jd.com/10536835318.html&gt; - no more duplicates will be shown (see DUPEFILTER_DEBUG to show all duplicates)</div><div class="line">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=8&gt; (referer: None)</div><div class="line">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET http://item.jd.com/10536835318.html&gt; (referer: https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=6)</div><div class="line">2017-03-13 19:21:16 [scrapy.core.engine] DEBUG: Crawled (200) &lt;GET https://club.jd.com/comment/productPageComments.action?productId=10589923020&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0&gt; (referer: https://search.jd.com/Search?keyword=%E5%A5%B3%E6%B7%B1%E5%8F%A3%E5%8D%95%E9%9E%8B&amp;enc=utf-8&amp;page=7)</div><div class="line">2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 http://item.jd.com/10536835318.html&gt;</div><div class="line">&#123;&apos;iid&apos;: 10536835318,</div><div class="line"> &apos;name&apos;: &apos;她芙 单鞋女2017春季新款中跟短靴女时尚女鞋性感尖头细跟单鞋深口裸靴防水台高跟鞋 黑色 37-标准码&apos;,</div><div class="line"> &apos;scores&apos;: &apos;9.72|9.75|9.65|9.63&apos;,</div><div class="line"> &apos;shop&apos;: &apos;卡曼鞋类专营店&apos;&#125;</div><div class="line">2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 https://club.jd.com/comment/productPageComments.action?productId=10589923020&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0&gt;</div><div class="line">&#123;&apos;_id&apos;: 10199823376,</div><div class="line"> &apos;color&apos;: &apos;金黑色.&apos;,</div><div class="line"> &apos;creation_time&apos;: &apos;2017-03-10 13:59:31&apos;,</div><div class="line"> &apos;iid&apos;: &apos;10589923020&apos;,</div><div class="line"> &apos;score&apos;: 5,</div><div class="line"> &apos;size&apos;: &apos;36&apos;,</div><div class="line"> &apos;uid&apos;: &apos;069d0baa-022b-421b-a43a-584f5aa3921e&apos;,</div><div class="line"> &apos;user_level&apos;: &apos;铜牌会员&apos;,</div><div class="line"> &apos;user_province&apos;: &apos;&apos;&#125;</div><div class="line">2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 https://club.jd.com/comment/productPageComments.action?productId=10589923020&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0&gt;</div><div class="line">&#123;&apos;_id&apos;: 10175008135,</div><div class="line"> &apos;color&apos;: &apos;金黑色.&apos;,</div><div class="line"> &apos;creation_time&apos;: &apos;2017-03-02 12:18:57&apos;,</div><div class="line"> &apos;iid&apos;: &apos;10589923020&apos;,</div><div class="line"> &apos;score&apos;: 5,</div><div class="line"> &apos;size&apos;: &apos;36&apos;,</div><div class="line"> &apos;uid&apos;: &apos;28dfd6c2-caf2-427d-9927-cf088d3099ea&apos;,</div><div class="line"> &apos;user_level&apos;: &apos;铜牌会员&apos;,</div><div class="line"> &apos;user_province&apos;: &apos;湖南&apos;&#125;</div><div class="line">2017-03-13 19:21:16 [scrapy.core.scraper] DEBUG: Scraped from &lt;200 https://club.jd.com/comment/productPageComments.action?productId=10589923020&amp;score=0&amp;sortType=5&amp;page=1&amp;pageSize=10&amp;isShadowSku=0&gt;</div><div class="line">&#123;&apos;_id&apos;: 10163486837,</div><div class="line"> &apos;color&apos;: &apos;金黑色.&apos;,</div><div class="line"> &apos;creation_time&apos;: &apos;2017-02-26 15:28:14&apos;,</div><div class="line"> &apos;iid&apos;: &apos;10589923020&apos;,</div><div class="line"> &apos;score&apos;: 5,</div><div class="line"> &apos;size&apos;: &apos;36&apos;,</div><div class="line"> &apos;uid&apos;: &apos;736ad5a4-9470-4dcc-832d-b59094cf84f4&apos;,</div><div class="line"> &apos;user_level&apos;: &apos;铜牌会员&apos;,</div><div class="line"> &apos;user_province&apos;: &apos;云南&apos;&#125;</div></pre></td></tr></table></figure>
<p>在运行一段时间后，查看<code>shoe_comments.csv</code>和<code>shoe_details.csv</code>内容:</p>
<ul>
<li><p><code>shoe_comments.csv</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">10199823376,10589923020,069d0baa-022b-421b-a43a-584f5aa3921e,2017-03-10 13:59:31,5,,铜牌会员,金黑色.,36</div><div class="line">10175008135,10589923020,28dfd6c2-caf2-427d-9927-cf088d3099ea,2017-03-02 12:18:57,5,湖南,铜牌会员,金黑色.,36</div><div class="line">10163486837,10589923020,736ad5a4-9470-4dcc-832d-b59094cf84f4,2017-02-26 15:28:14,5,云南,铜牌会员,金黑色.,36</div><div class="line">10205838152,10589923020,93f35818-129f-4aaa-8ea9-549c28a4f791,2017-03-12 14:37:59,5,,注册会员,金黑色.,36</div><div class="line">10175298549,10589923020,fe1a26e0-8cae-43c3-b0d4-c99bf1d961cf,2017-03-02 13:49:07,5,,铜牌会员,金黑色.,36</div><div class="line">10205858068,10589923020,65a7243e-7116-4075-b64a-6e8d8d8382a4,2017-03-12 14:44:29,5,,铜牌会员,金黑色.,36</div><div class="line">10206280836,10589923020,1d9b5332-5ca6-40be-b408-250606f68c17,2017-03-12 17:00:48,5,,注册会员,金黑色.,36</div><div class="line">10200243913,10589923020,966cda26-ce10-432a-8309-95199ad1903e,2017-03-10 16:15:02,5,,铜牌会员,金黑色.,36</div><div class="line">10164313667,10589923020,d09eab89-ed53-47a3-abd1-c897a8bcf694,2017-02-26 20:15:01,5,北京,铜牌会员,金黑色.,36</div><div class="line">10162862191,10589923020,ddb58374-f48b-45f9-a2a6-e5e60d53d4ce,2017-02-26 11:42:58,5,,铜牌会员,金黑色.,36</div><div class="line">10149921178,11242420873,5f410ce9-fc38-4736-8465-88bbdd7da347,2017-02-21 19:45:56,5,上海,铜牌会员,70060黑色,36</div><div class="line">10143787582,11242420873,3f15f14f-1d37-4ccb-befa-9acccd22a3d1,2017-02-19 19:07:20,5,海南,铜牌会员,70060黑色,36</div><div class="line">10150729539,11242420873,a601a457-1cef-41c4-955b-3df3dd2646ec,2017-02-22 07:32:52,5,新疆,铜牌会员,70060黑色,36</div><div class="line">10147517331,11242420873,b50e1e32-e1fe-4084-b95a-71be8a720950,2017-02-20 23:29:52,5,北京,铜牌会员,70060黑色,36</div><div class="line">10147357719,11242420873,fe6ec9de-c39b-4d5e-9cee-bf5926abb465,2017-02-20 22:18:46,5,湖南,铜牌会员,70060黑色,36</div><div class="line">10187242860,11242420873,f12f02f7-b378-457f-a501-cdd81f69de6c,2017-03-06 13:53:31,5,云南,铜牌会员,70060黑色,36</div><div class="line">10203999129,11242420873,f61e40df-f919-43a2-b876-e81176d59cf9,2017-03-11 20:55:40,5,内蒙古,注册会员,70060黑色,36</div><div class="line">10203827884,11242420873,4a73b3d7-b489-4880-8f8a-bc70015c4e18,2017-03-11 19:55:57,5,浙江,注册会员,70060黑色,36</div><div class="line">10203810598,11242420873,4113c7e0-4556-4aa1-b441-2334bd5419d4,2017-03-11 19:49:51,5,安徽,注册会员,70060黑色,36</div><div class="line">10203802320,11242420873,38a65bba-5284-4190-83f2-1a6a54d57da3,2017-03-11 19:46:57,5,广西,注册会员,70060黑色,36</div></pre></td></tr></table></figure>
</li>
<li><p><code>shoe_details.csv</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">10536835318,她芙 单鞋女2017春季新款中跟短靴女时尚女鞋性感尖头细跟单鞋深口裸靴防水台高跟鞋 黑色 37-标准码,卡曼鞋类专营店,9.72|9.75|9.65|9.63</div><div class="line">1587186408,雅诗莱雅休闲鞋女 圆头深口低帮鞋 拼色厚底女鞋 系带防水台女鞋子 GH852Q0红色 37,宏嘉男鞋专营店,9.79|9.80|9.74|9.76</div><div class="line">10536835318,她芙 单鞋女2017春季新款中跟短靴女时尚女鞋性感尖头细跟单鞋深口裸靴防水台高跟鞋 黑色 37-标准码,卡曼鞋类专营店,9.72|9.75|9.65|9.63</div><div class="line">11242420873,百芙蓉单鞋女中跟2017春季新款粗跟英伦风小皮鞋女春季新款圆头深口妈妈工作韩版潮厚底 70060黑色 36,百芙蓉鞋类旗舰店,9.88|9.81|9.83|9.84</div><div class="line">11157498264,圆头深口低帮鞋2017年秋冬新款纯色系带坡跟女鞋防水台女鞋子 1343黑色 36,马登尔鞋靴专营店,9.78|9.81|9.75|9.76</div><div class="line">10638093860,爱思图牛津鞋英伦风皮鞋女中跟秋季女鞋粗跟单鞋大头皮鞋圆头学生鞋小皮鞋平底鞋潮妈妈鞋女生鞋子 黑色ML6X303 36,爱思图旗舰店,9.72|9.76|9.71|9.70</div><div class="line">10574081025,佩尼泰深口单鞋女头层牛皮尖头单鞋中跟粗跟 OL工作职业鞋大小码女鞋春季新款 灰色 38,佩尼泰旗舰店,9.68|9.73|9.67|9.66</div><div class="line">10459020322,瑞蓓妮真皮女鞋2017新款魔术贴深口单鞋女平底舒适休闲鞋大码防滑中老年妈妈鞋 黑色单鞋 38,瑞蓓妮旗舰店,9.70|9.75|9.65|9.65</div><div class="line">11273711543,细跟高跟鞋女2017春季新款尖头单鞋女深口高跟女士英伦厚底防水台工作女鞋 红色 37,家兴福鞋业专营店,9.87|9.82|9.80|9.81</div><div class="line">11226902308,粗跟单鞋女2017春季新款女鞋OL尖头高跟鞋深口工作鞋女士皮鞋水钻百搭鞋子女 DH3658黑色 37,彬度鸟鞋靴旗舰店,9.89|9.83|9.83|9.84</div><div class="line">11210447351,她芙 单鞋女2017春季新款单鞋粗跟女鞋子系带厚底高跟鞋深口学生休闲低帮鞋 绿色 37,她芙旗舰店,9.77|9.77|9.67|9.68</div><div class="line">11239261516,AUSDU休闲鞋女圆头平底深口单鞋粗跟厚底2017春款韩版百搭舒适女鞋妈妈绑带学生 70030黑色 36,AUSDU鞋类旗舰店,9.87|9.80|9.81|9.82</div><div class="line">11267204558,丹芭莎春季女鞋2017新品纯色深口鞋女韩版圆头高跟鞋粗跟防水台单鞋女潮鞋 M70050黑色 37,丹芭莎旗舰店,9.84|9.81|9.79|9.80</div><div class="line">10687936751,fullmir内增高休闲鞋女士小白鞋2016秋季新款厚底鞋韩版潮流低帮学生运动鞋子单鞋 红 色 37,fullmir鞋类旗舰店,9.61|9.66|9.58|9.58</div><div class="line">11167186789,新款单鞋女2017秋季时尚漆皮圆头低帮休闲鞋秋鞋 工作鞋套脚欧美低跟皮鞋 黑色6119 34,艾琳艺鞋类专营店,9.67|9.79|9.67|9.69</div><div class="line">11227438800,意米思时尚女鞋圆头高跟鞋粗跟妈妈鞋深口单鞋女2017春秋新款韩版百搭小皮鞋防水台鞋子女 莫70050黑色 36,意米思旗舰店,9.72|9.81|9.79|9.80</div><div class="line">11250120847,邻家天使细跟单鞋2017春季新款尖头欧美皮鞋深口高跟女鞋春秋款鞋子 LJ619黑色 39标码,邻家天使鞋类旗舰店,9.69|9.74|9.65|9.66</div><div class="line">11193717829,单鞋女2017春季新款韩版高跟防水台粗跟女鞋尖头深口水钻通勤OL工作小皮鞋女 邻1231黑色 37,NEB ANGEL梓赢专卖店,9.78|9.78|9.74|9.75</div><div class="line">11166169416,金丝兔尖头单鞋女2017春季新品深口金属超高跟鞋欧美时尚细跟女鞋百搭小皮鞋工作鞋 黑色 36,金丝兔广汇达专卖店,9.89|9.83|9.83|9.84</div><div class="line">10617152040,ZHR小皮鞋真皮小白鞋女深口单鞋平底护士工作鞋潮 白色 39,零邦鞋靴专营店,9.69|9.68|9.69|9.69</div><div class="line">1471841136,宝思特2017春季新款真皮平底平跟休闲女单鞋软牛皮软底妈妈鞋花朵跳舞鞋加大码女鞋子 黑色 39,宝思特旗舰店,9.75|9.74|9.65|9.65</div><div class="line">11204372265,霍尔世家 深口单鞋女粗跟高跟鞋2017春季新款英伦风真皮尖头女鞋防水台 黑色 37,霍尔世家旗舰店,9.64|9.70|9.63|9.64</div></pre></td></tr></table></figure>
</li>
</ul>
<p>至此，我们完成了整个数据的爬取工作。</p>
<h1 id="接下来的工作"><a href="#接下来的工作" class="headerlink" title="接下来的工作"></a>接下来的工作</h1><p>有经验的读者可以看出来，本文完成的爬虫是较为基础的爬虫，不涉及到Scrapy高级的特性，也不涉及到反爬虫的内容，对于感兴趣的读者，可以从以下几个方面继续深入。</p>
<ol>
<li>由于京东对爬虫爬取评论并没有反爬措施，所以本文没有涉及到反爬的内容，不过在编写该爬虫的时候有考虑到这部分内容，所以编写了中间件来完成<code>User-Agent</code>的随机设置以及使用代理池来分散请求等简单的反爬措施，有兴趣的读者可以查阅Github源代码。</li>
<li>对于较大的爬取工作，可以考虑使用<code>scrapy-redis</code>等工具来构建分布式爬虫，以增加爬取效率。</li>
<li>在获得大量的数据之后，可以使用<code>matplotlib</code>等工具对数据进行可视化分析。</li>
</ol>
<p>以上就是本文的全部内容，有兴趣的读者可以查阅Github并下载源码，该项目地址: <a href="https://github.com/Time1ess/MyCodes/tree/master/scrapy/jd" target="_blank" rel="external">https://github.com/Time1ess/MyCodes/tree/master/scrapy/jd</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天想跟大家分享的是关于网络爬虫的相关知识，网络爬虫是一种根据一定的规则，自动地对互联网上相关内容进行抓取的程序或者脚本，本文的内容主要是通过分析京东评论的加载过程，获取相关API，然后通过使用基于Python语言的开源网络爬虫框架——Scrapy，大量获取相关评论内容。&lt;/p&gt;
&lt;div class=&quot;tip&quot;&gt;&lt;br&gt;本文假定读者具有一定的Python编程经验，具有少量HTTP协议和HTML的相关知识，对爬虫的工作原理有一定了解。&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="Scrapy" scheme="http://youchen.me/tags/Scrapy/"/>
    
      <category term="Spider" scheme="http://youchen.me/tags/Spider/"/>
    
  </entry>
  
  <entry>
    <title>Python中yield from的用法</title>
    <link href="http://youchen.me/2017/02/10/Python-main-use-for-yield-from/"/>
    <id>http://youchen.me/2017/02/10/Python-main-use-for-yield-from/</id>
    <published>2017-02-10T05:22:58.000Z</published>
    <updated>2017-02-10T06:17:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇中谈到了迭代器、生成器以及<code>yield</code>的相关内容，而Python 3.3中，引入了在<a href="https://www.python.org/dev/peps/pep-0380/" target="_blank" rel="external">PEP 380 – Syntax for Delegating to a Subgenerator</a>中提出的<code>yield from</code>关键字，大幅简化了Python程序员在使用协程的时候的编程过程。</p>
<div class="tip"><br>本文内容除特殊说明外均基于Python 3.3以上版本。<br></div>

<p>首先需要声明的是，<code>yield from g</code>并不完全等于<code>for v in g: yield v</code>。而是应该将<code>yield from</code>看成为<strong>调用者(caller)</strong>和<strong>子生成器(sub-generator)</strong>之间提供了一种<strong>透明地双向通道</strong>。这包括了从子生成器中获取数据并向子生成器发送数据。</p>
<a id="more"></a>
<h4 id="使用yield-from从生成器中获得数据"><a href="#使用yield-from从生成器中获得数据" class="headerlink" title="使用yield from从生成器中获得数据"></a>使用<code>yield from</code>从生成器中获得数据</h4><p>考虑以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">"""A generator that fakes a read from a file, socket, etc."""</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</div><div class="line">        <span class="keyword">yield</span> <span class="string">'&lt;&lt; %s'</span> % i</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader_wrapper</span><span class="params">(g)</span>:</span></div><div class="line">    <span class="comment"># Manually iterate over data produced by reader</span></div><div class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> g:</div><div class="line">        <span class="keyword">yield</span> v</div><div class="line"></div><div class="line">wrap = reader_wrapper(reader())</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> wrap:</div><div class="line">    print(i)</div><div class="line"></div><div class="line"><span class="comment"># Result</span></div><div class="line">&lt;&lt; <span class="number">0</span></div><div class="line">&lt;&lt; <span class="number">1</span></div><div class="line">&lt;&lt; <span class="number">2</span></div><div class="line">&lt;&lt; <span class="number">3</span></div></pre></td></tr></table></figure>
<p>我们其实可以使用<code>yield from</code>来代替亲自迭代<code>reader()</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader_wrapper</span><span class="params">(g)</span>:</span></div><div class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> g</div></pre></td></tr></table></figure>
<p>这可以很好的工作而且减少了一行代码，而且可能使得我们的意图更加明确。</p>
<h4 id="使用yield-from向生成器发送数据"><a href="#使用yield-from向生成器发送数据" class="headerlink" title="使用yield from向生成器发送数据"></a>使用<code>yield from</code>向生成器发送数据</h4><p>现在让我们做些更有趣的。首先创建一个名叫<code>writer</code>的协程，它可以接收发送给它的数据并写给套接字、文件描述符等等:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">"""A coroutine that writes data *sent* to it to fd, socket, etc."""</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        w = (<span class="keyword">yield</span>)</div><div class="line">        print(<span class="string">'&gt;&gt; '</span>, w)</div></pre></td></tr></table></figure>
<p>现在的问题是，包装函数<code>wrapper</code>如何处理将数据发送给<code>writer</code>，使得发送给包装函数的数据能够透明地发送给<code>writer()</code>？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer_wrapper</span><span class="params">(coro)</span>:</span></div><div class="line">    <span class="comment"># TBD</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">w = writer()</div><div class="line">wrap = writer_wrapper(w)</div><div class="line">wrap.send(<span class="keyword">None</span>)  <span class="comment"># "prime" the coroutine</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</div><div class="line">    wrap.send(i)</div><div class="line"></div><div class="line"><span class="comment"># Expected result</span></div><div class="line">&gt;&gt;  <span class="number">0</span></div><div class="line">&gt;&gt;  <span class="number">1</span></div><div class="line">&gt;&gt;  <span class="number">2</span></div><div class="line">&gt;&gt;  <span class="number">3</span></div></pre></td></tr></table></figure>
<p>包装函数需要接受发送给它的数据(显而易见地)而且应该在循环结束的时候处理<code>StopIteration</code>异常。很明显只是完成<code>for x in coro: yield x</code>的话不能胜任这项工作。下面是一个能够工作的版本:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer_wrapper</span><span class="params">(coro)</span>:</span></div><div class="line">    coro.send(<span class="keyword">None</span>)  <span class="comment"># prime the coro</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            x = (<span class="keyword">yield</span>)  <span class="comment"># Capture the value that's sent</span></div><div class="line">            coro.send(x)  <span class="comment"># and pass it to the writer</span></div><div class="line">        <span class="keyword">except</span> StopIteration:</div><div class="line">            <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>或者，我们可以这样做:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer_wrapper</span><span class="params">(coro)</span>:</span></div><div class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> coro</div></pre></td></tr></table></figure>
<p>这节省了6行代码，而且使得代码更加清晰易读，最关键的是，它可行！</p>
<h4 id="使用yield-from向生成器发送数据——异常处理"><a href="#使用yield-from向生成器发送数据——异常处理" class="headerlink" title="使用yield from向生成器发送数据——异常处理"></a>使用<code>yield from</code>向生成器发送数据——异常处理</h4><p>让我们使这个例子更复杂点，假设我们的<code>writer</code>需要处理异常呢？比如<code>writer</code>捕获<code>SpamException</code>异常并且在遇到这个的时候打印<code>***</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpamException</span><span class="params">(Exception)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            w = (<span class="keyword">yield</span>)</div><div class="line">        <span class="keyword">except</span> SpamException:</div><div class="line">            print(<span class="string">'***'</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            print(<span class="string">'&gt;&gt; '</span>, w)</div></pre></td></tr></table></figure>
<p>如果我们使用原始版本的<code>writer_wrapper</code>，会怎样？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># writer_wrapper same as above</span></div><div class="line"></div><div class="line">w = writer()</div><div class="line">wrap = writer_wrapper(w)</div><div class="line">wrap.send(<span class="keyword">None</span>)  <span class="comment"># "prime" the coroutine</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'spam'</span>, <span class="number">4</span>]:</div><div class="line">    <span class="keyword">if</span> i == <span class="string">'spam'</span>:</div><div class="line">        wrap.throw(SpamException)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        wrap.send(i)</div><div class="line"></div><div class="line"><span class="comment"># Expected Result</span></div><div class="line">&gt;&gt;  <span class="number">0</span></div><div class="line">&gt;&gt;  <span class="number">1</span></div><div class="line">&gt;&gt;  <span class="number">2</span></div><div class="line">***</div><div class="line">&gt;&gt;  <span class="number">4</span></div><div class="line"></div><div class="line"><span class="comment"># Actual Result</span></div><div class="line">&gt;&gt;  <span class="number">0</span></div><div class="line">&gt;&gt;  <span class="number">1</span></div><div class="line">&gt;&gt;  <span class="number">2</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  ... redacted ...</div><div class="line">  File ... <span class="keyword">in</span> writer_wrapper</div><div class="line">    x = (<span class="keyword">yield</span>)</div><div class="line">__main__.SpamException</div></pre></td></tr></table></figure>
<p>不能正常工作的原因是因为<code>x = (yield)</code>抛出了这个异常所以导致了程序崩溃。要使得其正常工作的话，我们需要亲自捕获异常并将它传递给子生成器(<code>writer</code>)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer_wrapper</span><span class="params">(coro)</span>:</span></div><div class="line">    <span class="string">"""Works. Manually catches exceptions and throws them"""</span></div><div class="line">    coro.send(<span class="keyword">None</span>)  <span class="comment"># prime the coro</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                x = (<span class="keyword">yield</span>)</div><div class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:   <span class="comment"># This catches the SpamException</span></div><div class="line">                coro.throw(e)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                coro.send(x)</div><div class="line">        <span class="keyword">except</span> StopIteration:</div><div class="line">            <span class="keyword">pass</span></div><div class="line"></div><div class="line">...</div><div class="line"><span class="comment"># Result</span></div><div class="line">&gt;&gt;  <span class="number">0</span></div><div class="line">&gt;&gt;  <span class="number">1</span></div><div class="line">&gt;&gt;  <span class="number">2</span></div><div class="line">***</div><div class="line">&gt;&gt;  <span class="number">4</span></div></pre></td></tr></table></figure>
<p>这可以正常工作，但是假设我们这样呢:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer_wrapper</span><span class="params">(coro)</span>:</span></div><div class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> coro</div></pre></td></tr></table></figure>
<p><code>yield from</code>语句透明地将数据或者异常发送给子生成器。</p>
<p>以上仍然没有覆盖所有的特殊情况。如果外部生成器关闭了会怎样？子生成器返回了一个值会怎样(Python 3里生成器可以返回值)？返回值会怎样被处理？而<code>yield from</code>很好的处理了以上所有情况。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="tip"><br><code>yield from</code>是<strong>调用者</strong>和<strong>子生成器</strong>之间的一个<strong>双向透明通道</strong>。<br></div>

<p>更多关于<code>yield from</code>的内容可以阅读<a href="https://www.python.org/dev/peps/pep-0380/" target="_blank" rel="external">PEP 380 – Syntax for Delegating to a Subgenerator</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇中谈到了迭代器、生成器以及&lt;code&gt;yield&lt;/code&gt;的相关内容，而Python 3.3中，引入了在&lt;a href=&quot;https://www.python.org/dev/peps/pep-0380/&quot;&gt;PEP 380 – Syntax for Delegating to a Subgenerator&lt;/a&gt;中提出的&lt;code&gt;yield from&lt;/code&gt;关键字，大幅简化了Python程序员在使用协程的时候的编程过程。&lt;/p&gt;
&lt;div class=&quot;tip&quot;&gt;&lt;br&gt;本文内容除特殊说明外均基于Python 3.3以上版本。&lt;br&gt;&lt;/div&gt;

&lt;p&gt;首先需要声明的是，&lt;code&gt;yield from g&lt;/code&gt;并不完全等于&lt;code&gt;for v in g: yield v&lt;/code&gt;。而是应该将&lt;code&gt;yield from&lt;/code&gt;看成为&lt;strong&gt;调用者(caller)&lt;/strong&gt;和&lt;strong&gt;子生成器(sub-generator)&lt;/strong&gt;之间提供了一种&lt;strong&gt;透明地双向通道&lt;/strong&gt;。这包括了从子生成器中获取数据并向子生成器发送数据。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="生成器，迭代器" scheme="http://youchen.me/tags/%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python中yield的作用</title>
    <link href="http://youchen.me/2017/02/10/Python-What-does-yield-do/"/>
    <id>http://youchen.me/2017/02/10/Python-What-does-yield-do/</id>
    <published>2017-02-10T02:42:13.000Z</published>
    <updated>2017-02-10T04:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在<a href="http://stackoverflow.com" target="_blank" rel="external">StackOverflow</a>上看的问题回答比较多，今天这篇是关于介绍Python生成器的相关思想以及其中关键字<code>yield</code>用法的翻译内容。</p>
<p>为了搞清楚<code>yield</code>是用来做什么的，你首先得知道Python中<strong><em>生成器</em></strong>的相关概念，而为了了解生成器的相关概念，你需要知道什么是<strong><em>迭代器</em></strong>。</p>
<a id="more"></a>
<div class="tip"><br>本篇中的Python除了特殊说明外都是Python 2.x<br></div>

<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>当你创建一个了列表，你可以逐个遍历列表中的元素，而这个过程便叫做<strong><em>迭代</em></strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</div><div class="line"><span class="meta">... </span>   print(i)</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div></pre></td></tr></table></figure>
<p>而<code>mylist</code>是一个<strong><em>可迭代对象</em></strong>。当你使用列表推导式的时候，创建了一个列表，他也是可迭代对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</div><div class="line"><span class="meta">... </span>   print(i)</div><div class="line"><span class="number">0</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<p>所有能够接受<code>for...in...</code>操作的对象都是可迭代对象，如列表、字符串、文件等。这些可迭代对象用起来都十分顺手因为你可以按照你的想法去访问它们，但是你把所有数据都保存在了内存中，而当你有大量数据的时候这可能并不是你想要的结果。</p>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>生成器也是迭代器，但是<strong>你只能对它们进行一次迭代</strong>，原因在于它们并没有将所有数据存储在内存中，而是即时生成这些数据:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>mygenerator = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</div><div class="line"><span class="meta">... </span>   print(i)</div><div class="line"><span class="number">0</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<p>这一段代码和上面那段很相似，唯一不同的地方是使用了<code>()</code>代替<code>[]</code>。但是，这样的后果是你无法对<code>mygenerator</code>进行第二次<code>for i in mygenerator</code>，因为生成器只能被使用一次:它首先计算出结果0，然后忘记它再计算出1，最后是4，一个接一个。</p>
<h4 id="Yield"><a href="#Yield" class="headerlink" title="Yield"></a>Yield</h4><p><code>yield</code>是一个用法跟<code>return</code>很相似的关键字，不同在于函数返回的是一个生成器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">createGenerator</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">... </span>   mylist = range(<span class="number">3</span>)</div><div class="line"><span class="meta">... </span>   <span class="keyword">for</span> i <span class="keyword">in</span> mylist:</div><div class="line"><span class="meta">... </span>       <span class="keyword">yield</span> i*i</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>mygenerator = createGenerator() <span class="comment"># create a generator</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(mygenerator) <span class="comment"># mygenerator is an object!</span></div><div class="line">&lt;generator object createGenerator at <span class="number">0xb7555c34</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</div><div class="line"><span class="meta">... </span>    print(i)</div><div class="line"><span class="number">0</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<p>这是一个没有什么用的例子，但是用来让你了解当你知道你的函数会返回一个只会被遍历1次的巨大数据集合该怎么做的时候十分方便。为了掌握<code>yield</code>，你必须了解<strong>当你调用这个函数的时候，你在函数体中写的代码并没有被执行</strong>，而是只返回了一个生成器对象，这个需要特别注意。然后，你的代码将会在每次<code>for</code>使用这个生成器的时候被执行。最后，最困难的部分:</p>
<blockquote>
<p><code>for</code>第一次调用通过你函数创建的生成器对象的时候，它将会从你函数的开头执行代码，一直到到达<code>yield</code>，然后它将会返回循环中的第一个值。然后，其他每次调用都会再一次执行你在函数中写的那段循环，并返回下一个值，直到没有值可以返回。</p>
</blockquote>
<p>生成器在函数执行了却没有到达<code>yield</code>的时候将被认为是空的，原因在于循环到达了终点，或者不再满足<code>if/else</code>条件。</p>
<h4 id="处理生成器耗尽"><a href="#处理生成器耗尽" class="headerlink" title="处理生成器耗尽"></a>处理生成器耗尽</h4><p>考虑以下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bank</span><span class="params">()</span>:</span> <span class="comment"># let's create a bank, building ATMs</span></div><div class="line"><span class="meta">... </span>   crisis = <span class="keyword">False</span></div><div class="line"><span class="meta">... </span>   <span class="function"><span class="keyword">def</span> <span class="title">create_atm</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>       <span class="keyword">while</span> <span class="keyword">not</span> self.crisis:</div><div class="line"><span class="meta">... </span>           <span class="keyword">yield</span> <span class="string">"$100"</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hsbc = Bank() <span class="comment"># when everything's ok the ATM gives you as much as you want</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>corner_street_atm = hsbc.create_atm()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(corner_street_atm.next())</div><div class="line">$<span class="number">100</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(corner_street_atm.next())</div><div class="line">$<span class="number">100</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print([corner_street_atm.next() <span class="keyword">for</span> cash <span class="keyword">in</span> range(<span class="number">5</span>)])</div><div class="line">[<span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>, <span class="string">'$100'</span>]</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hsbc.crisis = <span class="keyword">True</span> <span class="comment"># crisis is coming, no more money!</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(corner_street_atm.next())</div><div class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>wall_street_atm = hsbc.create_atm() <span class="comment"># it's even true for new ATMs</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(wall_street_atm.next())</div><div class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hsbc.crisis = <span class="keyword">False</span> <span class="comment"># trouble is, even post-crisis the ATM remains empty</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(corner_street_atm.next())</div><div class="line">&lt;type <span class="string">'exceptions.StopIteration'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>brand_new_atm = hsbc.create_atm() <span class="comment"># build a new one to get back in business</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> cash <span class="keyword">in</span> brand_new_atm:</div><div class="line"><span class="meta">... </span>   <span class="keyword">print</span> cash</div><div class="line">$<span class="number">100</span></div><div class="line">$<span class="number">100</span></div><div class="line">$<span class="number">100</span></div><div class="line">$<span class="number">100</span></div><div class="line">$<span class="number">100</span></div><div class="line">$<span class="number">100</span></div><div class="line">$<span class="number">100</span></div><div class="line">$<span class="number">100</span></div><div class="line">$<span class="number">100</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>首先看生成器的<code>next</code>方法，它用来执行代码并从生成器中获取下一个元素(在Python 3.x中生成器已经没有next方法，而是使用next(iterator)代替)。在<code>crisis</code>未被置为<code>True</code>的时候，<code>create_atm</code>函数中的<code>while</code>循环可以看做是无尽的，当<code>crisis</code>为<code>True</code>的时候，跳出了<code>while</code>循环，所有迭代器将会到达函数尾部，此时再次访问<code>next</code>将会抛出<code>StopIteration</code>异常，而此时就算将<code>crisis</code>设置为<code>False</code>，这些生成器仍然处在函数尾部，访问会继续抛出<code>StopIteration</code>异常。</p>
<p>将以上例子用来控制访问资源等用途的时候十分有用。</p>
<h4 id="itertools，你的好朋友"><a href="#itertools，你的好朋友" class="headerlink" title="itertools，你的好朋友"></a><code>itertools</code>，你的好朋友</h4><p><code>itertools</code>模块包含了许多用来操作可迭代对象的函数。想复制一个生成器？向连接两个生成器？想把多个值组合到一个嵌套列表里面？使用<code>map/zip</code>而不用重新创建一个列表？那么就:<code>import itertools</code>吧。</p>
<p>让我们来看看四匹马赛跑可能的到达结果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>horses = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>races = itertools.permutations(horses)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(races)</div><div class="line">&lt;itertools.permutations object at <span class="number">0xb754f1dc</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(itertools.permutations(horses)))</div><div class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),</div><div class="line"> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>),</div><div class="line"> (<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>),</div><div class="line"> (<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>),</div><div class="line"> (<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>),</div><div class="line"> (<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>),</div><div class="line"> (<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>),</div><div class="line"> (<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>),</div><div class="line"> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>),</div><div class="line"> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>),</div><div class="line"> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>),</div><div class="line"> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>),</div><div class="line"> (<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>),</div><div class="line"> (<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>),</div><div class="line"> (<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>),</div><div class="line"> (<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>),</div><div class="line"> (<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>),</div><div class="line"> (<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>),</div><div class="line"> (<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</div><div class="line"> (<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>),</div><div class="line"> (<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>),</div><div class="line"> (<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>),</div><div class="line"> (<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>),</div><div class="line"> (<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)]</div></pre></td></tr></table></figure>
<h4 id="迭代的内部机理"><a href="#迭代的内部机理" class="headerlink" title="迭代的内部机理"></a>迭代的内部机理</h4><p>迭代是一个依赖于可迭代对象(需要实现<code>__iter__()</code>方法)和迭代器(需要实现<code>__next__()</code>方法)的过程。</p>
<blockquote>
<p>可迭代对象是任意你可以从中得到一个迭代器的对象。</p>
<p>迭代器是让你可以对可迭代对象进行迭代的对象。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>yield</code>语句将你的函数转化成一个能够生成一种能够包装你原函数体的名叫<strong><em>生成器</em></strong>的特殊对象的工厂。当生成器被迭代，它将会起始位置开始执行函数一直到到达下一个<code>yield</code>，然后挂起执行，计算返回传递给<code>yield</code>的值，它将会在每次迭代的时候重复这个过程直到函数执行到达函数的尾部，举例来说:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_generator</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">yield</span> <span class="string">'one'</span></div><div class="line">    <span class="keyword">yield</span> <span class="string">'two'</span></div><div class="line">    <span class="keyword">yield</span> <span class="string">'three'</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> simple_generator():</div><div class="line">    <span class="keyword">print</span> i</div></pre></td></tr></table></figure>
<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">one</div><div class="line">two</div><div class="line">three</div></pre></td></tr></table></figure>
<p>这种效果的产生是由于在循环中使用了可以产生序列的生成器，生成器在每次循环时执行代码到下一个<code>yield</code>，并计算返回结果，这样生成器即时生成了一个列表，这对于特别是大型计算来说内存节省十分有效。</p>
<p>假设你想实现自己的可以产生一个可迭代一定范围数的<code>range</code>函数(特指Python 2.x中的<code>range</code>)，你可以这样做和使用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">myRangeNaive</span><span class="params">(i)</span>:</span></div><div class="line">    n = <span class="number">0</span></div><div class="line">    range = []</div><div class="line">    <span class="keyword">while</span> n &lt; i:</div><div class="line">        range.append(n)</div><div class="line">        n = n + <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> range</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> myRangeNaive(<span class="number">10</span>):</div><div class="line">    <span class="keyword">print</span> i</div></pre></td></tr></table></figure>
<p>但是这样并不高效，原因1：你创建了一个你只会使用一次的列表；原因2：这段代码实际上循环了两次。<br>由于Guido和他的团队很慷慨地开发了生成器因此我们可以这样做:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">myRangeSmart</span><span class="params">(i)</span>:</span></div><div class="line">    n = <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> n &lt; i:</div><div class="line">       <span class="keyword">yield</span> n</div><div class="line">       n = n + <span class="number">1</span></div><div class="line">    <span class="keyword">return</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> myRangeSmart(<span class="number">10</span>):</div><div class="line">    <span class="keyword">print</span> i</div></pre></td></tr></table></figure>
<p>现在，每次对生成器迭代将会调用<code>next()</code>来执行函数体直到到达<code>yield</code>语句，然后停止执行，并计算返回结果，或者是到达函数体尾部。在这种情况下，第一次的调用<code>next()</code>将会执行到<code>yield n</code>并返回<code>n</code>，下一次的<code>next()</code>将会执行自增操作，然后回到<code>while</code>的判断，如果满足条件，则再一次停止并返回<code>n</code>，它将会以这种方式执行一直到不满足<code>while</code>条件，使得生成器到达函数体尾部。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在&lt;a href=&quot;http://stackoverflow.com&quot;&gt;StackOverflow&lt;/a&gt;上看的问题回答比较多，今天这篇是关于介绍Python生成器的相关思想以及其中关键字&lt;code&gt;yield&lt;/code&gt;用法的翻译内容。&lt;/p&gt;
&lt;p&gt;为了搞清楚&lt;code&gt;yield&lt;/code&gt;是用来做什么的，你首先得知道Python中&lt;strong&gt;&lt;em&gt;生成器&lt;/em&gt;&lt;/strong&gt;的相关概念，而为了了解生成器的相关概念，你需要知道什么是&lt;strong&gt;&lt;em&gt;迭代器&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="生成器" scheme="http://youchen.me/tags/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
      <category term="迭代器" scheme="http://youchen.me/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python中的metaclass(元类)</title>
    <link href="http://youchen.me/2017/02/06/Python-metaclass/"/>
    <id>http://youchen.me/2017/02/06/Python-metaclass/</id>
    <published>2017-02-06T08:11:02.000Z</published>
    <updated>2017-02-07T09:17:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文根据对<a href="http://stackoverflow.com" target="_blank" rel="external">StackOverflow</a>上问题<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python?answertab=votes#tab-top" target="_blank" rel="external">What is a metaclass in Python?</a>的高票回答翻译结合实际例子，试图解释<strong>元类</strong>的意义与用途。</p>
<h4 id="类也是对象"><a href="#类也是对象" class="headerlink" title="类也是对象"></a>类也是对象</h4><p>在想了解什么是<strong>元类</strong>之前，需要读者掌握Python中类的基本概念。而恰巧Python对类的定义有着不同于其他语言的解释。在大多数编程语言中，类仅仅只是指示如何生成实例对象的一段代码，这一点在Python中也如此:</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>      <span class="keyword">pass</span></div><div class="line"><span class="meta">... </span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_object = ObjectCreator()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(my_object)</div><div class="line">&lt;__main__.ObjectCreator object at <span class="number">0x8974f2c</span>&gt;</div></pre></td></tr></table></figure>
<p>但是，Python中的类还远不止如此:</p>
<div class="tip"><br>类也是实例对象<br></div>

<p>当程序员使用了关键字<code>class</code>时，Python将会执行它并且创建一个对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>      <span class="keyword">pass</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>上述代码将会在内存中创建一个名叫”ObjectCreator”的对象。</p>
<div class="tip"><br>这个对象(类)自身拥有创建对象(实例)的能力，因此被称作类<br></div>

<p>即便如此，它仍然是一个对象，因此:</p>
<ul>
<li>你可以将它赋值给一个变量</li>
<li>你可以复制它</li>
<li>你可以为它添加属性</li>
<li>你可以将它作为函数参数传递</li>
</ul>
<p>例如,<br>使用<code>print</code>打印:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreator) <span class="comment"># you can print a class because it's an object</span></div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></div></pre></td></tr></table></figure>
<p>作为函数参数传递:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(o)</span>:</span></div><div class="line"><span class="meta">... </span>      print(o)</div><div class="line"><span class="meta">... </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>echo(ObjectCreator) <span class="comment"># you can pass a class as a parameter</span></div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></div></pre></td></tr></table></figure>
<p>添加属性:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(hasattr(ObjectCreator, <span class="string">'new_attribute'</span>))</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ObjectCreator.new_attribute = <span class="string">'foo'</span> <span class="comment"># you can add attributes to a class</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(hasattr(ObjectCreator, <span class="string">'new_attribute'</span>))</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreator.new_attribute)</div><div class="line">foo</div></pre></td></tr></table></figure>
<p>赋值给另一个变量:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>ObjectCreatorMirror = ObjectCreator <span class="comment"># you can assign a class to a variable</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreatorMirror.new_attribute)</div><div class="line">foo</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreatorMirror())</div><div class="line">&lt;__main__.ObjectCreator object at <span class="number">0x8997b4c</span>&gt;</div></pre></td></tr></table></figure>
<h4 id="动态地创建类"><a href="#动态地创建类" class="headerlink" title="动态地创建类"></a>动态地创建类</h4><p>既然类也是对象，那么你可以向创建对象一样快速地创建它们。<br>首先，你可以通过使用关键字<code>class</code>在函数中创建一个类:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">choose_class</span><span class="params">(name)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">if</span> name == <span class="string">'foo'</span>:</div><div class="line"><span class="meta">... </span>        <span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>            <span class="keyword">pass</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">return</span> Foo <span class="comment"># return the class, not an instance</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</div><div class="line"><span class="meta">... </span>        <span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>            <span class="keyword">pass</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">return</span> Bar</div><div class="line"><span class="meta">... </span>    </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>MyClass = choose_class(<span class="string">'foo'</span>) </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(MyClass, MyClass()) <span class="comment"># the function returns a class, not an instance</span></div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">choose_class</span>.&lt;<span class="title">locals</span>&gt;.<span class="title">Foo</span>'&gt; &lt;<span class="title">__main__</span>.<span class="title">choose_class</span>.&lt;<span class="title">locals</span>&gt;.<span class="title">Foo</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x10a7d06a0</span>&gt;</span></div></pre></td></tr></table></figure>
<p>但它并不是很动态，因为你仍然需要亲自编写整个类。由于类是对象，那么它们必然是被某些东西生成的。当你使用关键字<code>class</code>时，Python自动地创建了其对象的对象。但就跟Python中大多数东西一样，Python给了你手动操作它的方法。<br>还记得函数<code>type</code>吗？这个函数能够让你知道一个对象的类型:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(<span class="number">1</span>))</div><div class="line">&lt;type <span class="string">'int'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(<span class="string">"1"</span>))</div><div class="line">&lt;type <span class="string">'str'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(ObjectCreator))</div><div class="line">&lt;type <span class="string">'type'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(ObjectCreator()))</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></div></pre></td></tr></table></figure>
<p>其实<code>type</code>还有一个完全不同的能力，它能够快速地创建类。<code>type</code>可以以参数的方式接收对一个类的描述，然后返回一个类。(可能有的人认为同一个函数根据传递不同的参数拥有两种完全不同的用途是一件很傻的事，但这是由于Python的向后兼容留下的问题)</p>
<p>通过<code>type</code>创建类的参数描述如下:</p>
<pre><code>type(name of the class, tuple of the parent class (for inheritance, can be empty), dictionary containing attributes names and values)
</code></pre><p>例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyShinyClass</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>      <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>可以以如下方式手动创建:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>MyShinyClass = type(<span class="string">'MyShinyClass'</span>, (), &#123;&#125;) <span class="comment"># returns a class object</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(MyShinyClass, MyShinyClass())</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">MyShinyClass</span>'&gt; &lt;<span class="title">__main__</span>.<span class="title">MyShinyClass</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x10a7a5518</span>&gt;</span></div></pre></td></tr></table></figure>
<p>你可能注意到了我们使用了”MyShinyClass”作为类的名字同时也作为变量名来保持对类的引用。它们可以不同，但是没有理由使其复杂化。<br><code>type</code>接收一个字典来定义类的属性，因此:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line"><span class="meta">... </span>      bar = <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>可以被翻译成:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>Foo = type(<span class="string">'Foo'</span>, (), &#123;<span class="string">'bar'</span>: <span class="keyword">True</span>&#125;)</div></pre></td></tr></table></figure>
<p>这样定义的类也可以当做普通类使用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">print(Foo)  <span class="comment"># &lt;class '__main__.Foo'&gt;</span></div><div class="line">print(Foo.bar)  <span class="comment"># True</span></div><div class="line">f = Foo()</div><div class="line">print(f)  <span class="comment"># &lt;__main__.Foo object at 0x8a9b84c&gt;</span></div><div class="line">print(f.bar)  <span class="comment"># True</span></div></pre></td></tr></table></figure>
<p>当然，你也可以继承自它:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>  <span class="class"><span class="keyword">class</span> <span class="title">FooChild</span><span class="params">(Foo)</span>:</span></div><div class="line"><span class="meta">... </span>        <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>将会是:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = type(<span class="string">'FooChild'</span>, (Foo,), &#123;&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(FooChild, FooChild.bar)  <span class="comment"># bar is inherited from Foo</span></div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">FooChild</span>'&gt; <span class="title">True</span></span></div></pre></td></tr></table></figure>
<p>最终你会想为你的类添加一些方法。只需要使用正确的语法定义一个函数然后作为一个属性赋值给类:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo_bar</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>      print(self.bar)</div><div class="line"><span class="meta">... </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = type(<span class="string">'FooChild'</span>, (Foo,), &#123;<span class="string">'echo_bar'</span>: echo_bar&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(Foo, <span class="string">'echo_bar'</span>)</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(FooChild, <span class="string">'echo_bar'</span>)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_foo = FooChild()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_foo.echo_bar()</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>你甚至可以在动态生成了类之后添加更多的方法，就和向普通生成的类对象添加方法一样:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo_bar_more</span><span class="params">(self)</span>:</span></div><div class="line"><span class="meta">... </span>      print(<span class="string">'yet another method'</span>)</div><div class="line"><span class="meta">... </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild.echo_bar_more = echo_bar_more</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(FooChild, <span class="string">'echo_bar_more'</span>)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>如你所见:在Python中，类是对象，你可以快速动态地创建一个类。这便是当你使用关键字<code>class</code>时Python做的工作，它通过使用<strong>元类</strong>来完成这项工作。</p>
<h4 id="什么是元类-终于"><a href="#什么是元类-终于" class="headerlink" title="什么是元类(终于)"></a>什么是元类(终于)</h4><p><strong>元类</strong>是创建类的那些”东西”。你为了创建对象而定义了类，但是我们知道Python中的类也是对象，因此，元类是用来创建对象的。它们是<strong>类的类</strong>，你可以形象化地理解:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MyClass = MetaClass()</div><div class="line">MyObject = MyClass()</div></pre></td></tr></table></figure>
<p>你已经知道<code>type</code>可以这么用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MyClass = type(<span class="string">'MyClass'</span>, (), &#123;&#125;)</div></pre></td></tr></table></figure>
<p>这是因为函数<code>type</code>实际上是一个元类，而且是Python用来创建所有类的元类。</p>
<div class="tip"><br> 在Python中，所有东西都是对象<br></div>

<p>其中包括但不限于整型、字符串、函数和类。它们都是对象，而且它们都是被类创建的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>age = <span class="number">35</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__</div><div class="line">&lt;type <span class="string">'int'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'bob'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name.__class__</div><div class="line">&lt;type <span class="string">'str'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__class__</div><div class="line">&lt;type <span class="string">'function'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = Bar()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__</div><div class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Bar</span>'&gt;</span></div></pre></td></tr></table></figure>
<p>现在让我们看看<code>__class__</code>的<code>__class__</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__.__class__</div><div class="line">&lt;type <span class="string">'type'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name.__class__.__class__</div><div class="line">&lt;type <span class="string">'type'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__class__.__class__</div><div class="line">&lt;type <span class="string">'type'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__.__class__</div><div class="line">&lt;type <span class="string">'type'</span>&gt;</div></pre></td></tr></table></figure>
<p>由此可见，一个元类正是用来创建所有类的。你也可以称它为”类工厂”。<code>type</code>是Python使用的内置的元类，当然，你也可以创建你自己的元类。</p>
<h4 id="metaclass-属性"><a href="#metaclass-属性" class="headerlink" title="__metaclass__属性"></a><code>__metaclass__</code>属性</h4><p>你可以在编写一个类时为其指定<code>__metaclass__</code>属性:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></div><div class="line">    __metaclass__ = something...</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>需要注意的是，上述语法仅适用于Python 2.x版本，在Python 3.x版本中，由新语法替代:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object, metaclass=something)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>当你为类指定了元类以后，Python将会使用该元类来创建类<code>Foo</code>。<br>特别注意:</p>
<div class="tip"><br>类对象在Python调用<strong>metaclass</strong>来创建类之后才会存在。<br></div>

<p><strong> Python 2.x中的<strong>metaclass</strong> </strong><br>对Python 2.x来说，即当首先写下了<code>class Foo(object)</code>，但是类对象<code>Foo</code>还并没有在内存中被创建。Python将会在类定义中查找<code>__metaclass__</code>，如果找到了，则用其来创建对象类<code>Foo</code>，如果没有找到，Python将会使用<code>type</code>来创建该类。</p>
<p>当你这么写:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(Bar)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>Python将会这么做:</p>
<ol>
<li>类<code>Foo</code>有定义<code>__metaclass__</code>吗？如果有，则使用指定的<code>__metaclass__</code>来创建类对象<code>Foo</code>。</li>
<li>如果没有找到这个属性，它将会在父类<code>Bar</code>中找</li>
<li>这样一直向父类找，直到达到<code>module</code>级别才停止。</li>
<li>如果在任何父类都找不到，那就用<code>type</code>创建类对象<code>Foo</code></li>
</ol>
<p>这里面有几点需要注意:</p>
<ol>
<li>为子类指定的<code>__metaclass__</code>需要是其所有父类<code>__metaclass__</code>的子类。</li>
<li>在多继承的情况下，如果没有为该类指定<code>__metaclass__</code>，则该类将会由MRO中第一个父类的<code>__metaclass__</code>和所有父类<code>__metaclass__</code>中处于继承最底层的<code>__metaclass__</code>生成。</li>
</ol>
<p>Python 2.x中<code>__metaclass__</code>使用如以下代码所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python 2.x</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta0</span><span class="params">(type)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></div><div class="line">        cls = type.__new__(meta, name, bases, cls_dict)</div><div class="line">        print(meta, name, bases, cls_dict)</div><div class="line">        <span class="keyword">return</span> cls</div><div class="line"></div><div class="line">__metaclass__ = Meta0</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(type)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></div><div class="line">        print(meta, name, bases, cls_dict)</div><div class="line">        cls_dict[<span class="string">'meta'</span>] = <span class="keyword">True</span></div><div class="line">        cls = type.__new__(meta, name, bases, cls_dict)</div><div class="line">        <span class="keyword">return</span> cls</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta2</span><span class="params">(Meta)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></div><div class="line">        print(meta, name, bases, cls_dict)</div><div class="line">        cls_dict[<span class="string">'meta2'</span>] = <span class="keyword">True</span></div><div class="line">        cls = type.__new__(meta, name, bases, cls_dict)</div><div class="line">        <span class="keyword">return</span> cls</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta3</span><span class="params">(Meta2)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></div><div class="line">        print(meta, name, bases, cls_dict)</div><div class="line">        cls_dict[<span class="string">'meta3'</span>] = <span class="keyword">True</span></div><div class="line">        cls = type.__new__(meta, name, bases, cls_dict)</div><div class="line">        <span class="keyword">return</span> cls</div><div class="line"></div><div class="line">print(<span class="string">'C1'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(<span class="string">'C2'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span>:</span></div><div class="line">    __metaclass__ = Meta</div><div class="line"></div><div class="line">print(<span class="string">'C3'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C3</span><span class="params">(C2)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(<span class="string">'C4'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C4</span><span class="params">(C2)</span>:</span></div><div class="line">    __metaclass__ = Meta2</div><div class="line"></div><div class="line">print(<span class="string">'C5'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C5</span><span class="params">(C2)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(<span class="string">'C6'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C6</span><span class="params">(C2)</span>:</span></div><div class="line">    __metaclass__ = Meta3</div><div class="line"></div><div class="line">print(<span class="string">'C7'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C7</span><span class="params">(C4, C6, C5)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>结果为:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">C1</div><div class="line">(&lt;class '__main__.Meta0'&gt;, 'C1', (), &#123;'__module__': '__main__'&#125;)</div><div class="line">C2</div><div class="line">(&lt;class '__main__.Meta'&gt;, 'C2', (), &#123;'__module__': '__main__', '__metaclass__': &lt;class '__main__.Meta'&gt;&#125;)</div><div class="line">C3</div><div class="line">(&lt;class '__main__.Meta'&gt;, 'C3', (&lt;class '__main__.C2'&gt;,), &#123;'__module__': '__main__'&#125;)</div><div class="line">C4</div><div class="line">(&lt;class '__main__.Meta2'&gt;, 'C4', (&lt;class '__main__.C2'&gt;,), &#123;'__module__': '__main__', '__metaclass__': &lt;class '__main__.Meta2'&gt;&#125;)</div><div class="line">C5</div><div class="line">(&lt;class '__main__.Meta'&gt;, 'C5', (&lt;class '__main__.C2'&gt;,), &#123;'__module__': '__main__'&#125;)</div><div class="line">C6</div><div class="line">(&lt;class '__main__.Meta3'&gt;, 'C6', (&lt;class '__main__.C2'&gt;,), &#123;'__module__': '__main__', '__metaclass__': &lt;class '__main__.Meta3'&gt;&#125;)</div><div class="line">C7</div><div class="line">(&lt;class '__main__.Meta2'&gt;, 'C7', (&lt;class '__main__.C4'&gt;, &lt;class '__main__.C6'&gt;, &lt;class '__main__.C5'&gt;), &#123;'__module__': '__main__'&#125;)</div><div class="line">(&lt;class '__main__.Meta3'&gt;, 'C7', (&lt;class '__main__.C4'&gt;, &lt;class '__main__.C6'&gt;, &lt;class '__main__.C5'&gt;), &#123;'__module__': '__main__', 'meta2': True&#125;)</div></pre></td></tr></table></figure>
<p>注意到在类<code>C7</code>的生成过程中，分别调用了<code>Meta2</code>和<code>Meta3</code>，调用<code>Meta2</code>是由于在<code>C7</code>的继承中，类<code>C4</code>位于第一位，而<code>C4</code>的<code>__metaclass__</code>为<code>Meta2</code>，所以首先使用<code>Meta2</code>，而在<code>C4</code>、<code>C5</code>和<code>C6</code>的<code>__metaclass__</code>中，<code>Meta3</code>处于继承最底层，所以还会调用<code>Meta3</code>来生成类<code>C7</code>。(如果类<code>C6</code>位于最前面则只会调用<code>Meta3</code>)<br>这样的多继承以及多元类调用比较复杂，个人认为还是少用较好。</p>
<p><strong> Python 3.x中的metaclass </strong><br>在Python3.x中，需要通过关键字参数<code>metaclass</code>给类指定元类。如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span><span class="params">(metaclass=Meta)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>关于元类的寻找与Python 2.x类似:</p>
<ol>
<li>类<code>Foo</code>有定义关键字参数<code>metaclass</code>吗？如果有，则使用指定的<code>metaclass</code>来创建类对象<code>Foo</code>。</li>
<li>如果没有找到这个属性，它将会在父类<code>Bar</code>中找</li>
<li>如果在任何父类都找不到，那就用<code>type</code>创建类对象<code>Foo</code></li>
</ol>
<p>Python 3.x的metaclass使用注意仍然与Python 2.x类似:</p>
<ol>
<li>为子类指定的<code>metaclass</code>需要是其所有父类<code>metaclass</code>的子类。</li>
<li>在多继承的情况下，如果没有为该类指定<code>metaclass</code>，则该类将会由所有父类<code>metaclass</code>中处于继承最底层的<code>metaclass</code>生成。如果有指定，则选择前述的<code>metaclass</code>和该<code>metaclass</code>中继承层次更低的那个来生成。</li>
</ol>
<p>Python 3.x中<code>metaclass</code>使用如以下代码所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python 3.x</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(type)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></div><div class="line">        print(meta, name, bases, cls_dict)</div><div class="line">        <span class="keyword">return</span> type.__new__(meta, name, bases, cls_dict)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta2</span><span class="params">(Meta)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></div><div class="line">        print(meta, name, bases, cls_dict)</div><div class="line">        cls_dict[<span class="string">'hello'</span>] = <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> type.__new__(meta, name, bases, cls_dict)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta3</span><span class="params">(Meta2)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></div><div class="line">        print(meta, name, bases, cls_dict)</div><div class="line">        <span class="keyword">return</span> type.__new__(meta, name, bases, cls_dict)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta4</span><span class="params">(Meta3)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(meta, name, bases, cls_dict)</span>:</span></div><div class="line">        print(meta, name, bases, cls_dict)</div><div class="line">        <span class="keyword">return</span> type.__new__(meta, name, bases, cls_dict)</div><div class="line"></div><div class="line"></div><div class="line">print(<span class="string">'C1'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span><span class="params">(metaclass=Meta)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(<span class="string">'C2'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span><span class="params">(C1)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(<span class="string">'C3'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C3</span><span class="params">(C1, metaclass=Meta2)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(<span class="string">'C4'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C4</span><span class="params">(C1, metaclass=Meta3)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(<span class="string">'C5'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C5</span><span class="params">(C3, C4, C2)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">print(<span class="string">'C6'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C6</span><span class="params">(C3, C4, C2, metaclass=Meta4)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>结果为:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">C1</div><div class="line">&lt;class '__main__.Meta'&gt; C1 () &#123;'__module__': '__main__', '__qualname__': 'C1'&#125;</div><div class="line">C2</div><div class="line">&lt;class '__main__.Meta'&gt; C2 (&lt;class '__main__.C1'&gt;,) &#123;'__module__': '__main__', '__qualname__': 'C2'&#125;</div><div class="line">C3</div><div class="line">&lt;class '__main__.Meta2'&gt; C3 (&lt;class '__main__.C1'&gt;,) &#123;'__module__': '__main__', '__qualname__': 'C3'&#125;</div><div class="line">C4</div><div class="line">&lt;class '__main__.Meta3'&gt; C4 (&lt;class '__main__.C1'&gt;,) &#123;'__module__': '__main__', '__qualname__': 'C4'&#125;</div><div class="line">C5</div><div class="line">&lt;class '__main__.Meta3'&gt; C5 (&lt;class '__main__.C3'&gt;, &lt;class '__main__.C4'&gt;, &lt;class '__main__.C2'&gt;) &#123;'__module__': '__main__', '__qualname__': 'C5'&#125;</div><div class="line">C6</div><div class="line">&lt;class '__main__.Meta4'&gt; C6 (&lt;class '__main__.C3'&gt;, &lt;class '__main__.C4'&gt;, &lt;class '__main__.C2'&gt;) &#123;'__module__': '__main__', '__qualname__': 'C6'&#125;</div></pre></td></tr></table></figure>
<p>需要注意一点，为了输出内容的简洁，以上代码在方法<code>__new__</code>的最后都使用了<code>type.__new__</code>而不是<code>super().__new__</code>。改用<code>super().__new__</code>后执行仍相同，只是多了对父类的调用。</p>
<p>说了这么多，我们应该给<code>__metaclass__</code>赋值什么呢?答案当然是，一个可以创建类的东西。<br>那么，什么才能创建一个类呢？</p>
<h4 id="普通的元类"><a href="#普通的元类" class="headerlink" title="普通的元类"></a>普通的元类</h4><p>设计元类的一个很主要的原因就是为了在类被创建的时候进行自动修改，这经常用在API的设计上。<br>让我们举一个简单的例子，你决定让你的模块里所有类的属性都是大写形式。要完成这项工作有很多方法，其中一个便是在模块级别上定义<code>__metaclass__</code>。这样的话，该模块中所有的类都会通过该元类创建，我们只需要让这个元类完成将所有属性变成大写的工作。<br>幸运的是，<code>__metaclass__</code>可以是任何可调用(callable)对象，并不一定非要是一个正式的类。所以我们将从一个函数作为元类的例子说起:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python 2.x</span></div><div class="line"><span class="comment"># the metaclass will automatically get passed the same argument</span></div><div class="line"><span class="comment"># that you usually pass to `type`</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">upper_attr</span><span class="params">(future_class_name, future_class_parents, future_class_attr)</span>:</span></div><div class="line">  <span class="string">"""</span></div><div class="line">    Return a class object, with the list of its attribute turned </div><div class="line">    into uppercase.</div><div class="line">  """</div><div class="line"></div><div class="line">  <span class="comment"># pick up any attribute that doesn't start with '__' and uppercase it</span></div><div class="line">  uppercase_attr = &#123;&#125;</div><div class="line">  <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</div><div class="line">      <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</div><div class="line">          uppercase_attr[name.upper()] = val</div><div class="line">      <span class="keyword">else</span>:</div><div class="line">          uppercase_attr[name] = val</div><div class="line"></div><div class="line">  <span class="comment"># let `type` do the class creation</span></div><div class="line">  <span class="keyword">return</span> type(future_class_name, future_class_parents, uppercase_attr)</div><div class="line"></div><div class="line">__metaclass__ = upper_attr <span class="comment"># this will affect all classes in the module</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">()</span>:</span> <span class="comment"># global __metaclass__ won't work with "object" though</span></div><div class="line">  <span class="comment"># but we can define __metaclass__ here instead to affect only this class</span></div><div class="line">  <span class="comment"># and this will work with "object" children</span></div><div class="line">  bar = <span class="string">'bip'</span></div><div class="line"></div><div class="line">print(hasattr(Foo, <span class="string">'bar'</span>))</div><div class="line"><span class="comment"># Out: False</span></div><div class="line">print(hasattr(Foo, <span class="string">'BAR'</span>))</div><div class="line"><span class="comment"># Out: True</span></div><div class="line"></div><div class="line">f = Foo()</div><div class="line">print(f.BAR)</div><div class="line"><span class="comment"># Out: 'bip'</span></div></pre></td></tr></table></figure>
<p>现在，让我们完成同样的工作，但这次我们将会使用一个真正的类作为元类:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python 2.x</span></div><div class="line"><span class="comment"># remember that `type` is actually a class like `str` and `int`</span></div><div class="line"><span class="comment"># so you can inherit from it</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span> </div><div class="line">    <span class="comment"># __new__ is the method called before __init__</span></div><div class="line">    <span class="comment"># it's the method that creates the object and returns it</span></div><div class="line">    <span class="comment"># while __init__ just initializes the object passed as parameter</span></div><div class="line">    <span class="comment"># you rarely use __new__, except when you want to control how the object</span></div><div class="line">    <span class="comment"># is created.</span></div><div class="line">    <span class="comment"># here the created object is the class, and we want to customize it</span></div><div class="line">    <span class="comment"># so we override __new__</span></div><div class="line">    <span class="comment"># you can do some stuff in __init__ too if you wish</span></div><div class="line">    <span class="comment"># some advanced use involves overriding __call__ as well, but we won't</span></div><div class="line">    <span class="comment"># see this</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(upperattr_metaclass, future_class_name, </span></span></div><div class="line">                future_class_parents, future_class_attr):</div><div class="line"></div><div class="line">        uppercase_attr = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</div><div class="line">                uppercase_attr[name.upper()] = val</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                uppercase_attr[name] = val</div><div class="line"></div><div class="line">        <span class="keyword">return</span> type(future_class_name, future_class_parents, uppercase_attr)</div></pre></td></tr></table></figure>
<p>但是上面这种方法并不是很符合OOP，因为我们直接调用了<code>type</code>而且我们没有重写或者调用父类的<code>__new__</code>，让我们改为下面这样:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Python 2.x</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span> </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(upperattr_metaclass, future_class_name, </span></span></div><div class="line">                future_class_parents, future_class_attr):</div><div class="line"></div><div class="line">        uppercase_attr = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> future_class_attr.items():</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</div><div class="line">                uppercase_attr[name.upper()] = val</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                uppercase_attr[name] = val</div><div class="line"></div><div class="line">        <span class="comment"># reuse the type.__new__ method</span></div><div class="line">        <span class="comment"># this is basic OOP, nothing magic in there</span></div><div class="line">        <span class="keyword">return</span> type.__new__(upperattr_metaclass, future_class_name, </div><div class="line">                            future_class_parents, uppercase_attr)</div></pre></td></tr></table></figure>
<p>你可能注意到了一个额外的参数<code>upperattr_metaclass</code>，它其实并不特别:<code>__new__</code>总是将定义它的类作为第一个参数，就和实例方法中使用<code>self</code>或类方法中使用<code>cls</code>作为方法的第一个参数一样。当然，此处参数所使用的名字只是为了方便明确参数意义，但就跟<code>self</code>一样，所有参数都可以简写，因此实际使用中的一个元类可能看起来像这样:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span><span class="params">(type)</span>:</span> </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, clsname, bases, dct)</span>:</span></div><div class="line"></div><div class="line">        uppercase_attr = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> name, val <span class="keyword">in</span> dct.items():</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>):</div><div class="line">                uppercase_attr[name.upper()] = val</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                uppercase_attr[name] = val</div><div class="line"></div><div class="line">        <span class="keyword">return</span> type.__new__(cls, clsname, bases, uppercase_attr)</div></pre></td></tr></table></figure>
<p>是的，元类在完成一些”黑魔法”或者复杂事务的时候很有用，但是对于它们自身来说，其实很简单:</p>
<ol>
<li>拦截一个类的创建</li>
<li>修改这个类</li>
<li>返回修改后的类</li>
</ol>
<h4 id="你为什么要使用类而不是函数来作为元类？"><a href="#你为什么要使用类而不是函数来作为元类？" class="headerlink" title="你为什么要使用类而不是函数来作为元类？"></a>你为什么要使用类而不是函数来作为元类？</h4><p>由于<code>__metaclass__</code>可以接受任意可调用对象，那为什么你要使用一个明显更复杂的类呢？</p>
<p>有几个原因:</p>
<ul>
<li>意图明确。当你阅读到<code>UpperAttrMetaclass(type)</code>，你知道接下来会怎样</li>
<li>你可以使用OOP。元类可以继承，重写父类方法，甚至可以使用元类</li>
<li>你可以更好地组织里的代码。你不会在一些简单的工作中使用到元类，它通常是为了复杂工作准备的。编写多个方法并且将它们组织到一个类里将会对使代码清晰易读有巨大的帮助。</li>
<li>你可以拦截<code>__new__</code>、<code>__init__</code>和<code>__call__</code>等方法。这将允许你完成不同的工作。即使通常情况下你可以在<code>__new__</code>完成所有工作，但仍有许多人更偏爱在<code>__init__</code>中完成。</li>
<li>它们叫做metaclass，<code>class</code>!</li>
</ul>
<h4 id="为什么你要使用元类呢？"><a href="#为什么你要使用元类呢？" class="headerlink" title="为什么你要使用元类呢？"></a>为什么你要使用元类呢？</h4><p>现在到了最关键的问题，为什么你要使用一些既复杂又易错的功能呢？<br>实际上，通常情况下你不用:</p>
<blockquote>
<p>Metaclasses are deeper magic that 99% of users should never worry about. If you wonder whether you need them, you don’t (the people who actually need them know with certainty that they need them, and don’t need an explanation about why).      — Python Guru Tim Peters<br>译: 元类是较为高深的技术，99%的用户应该永远不用担心。如果你在犹豫你是否需要它们，那么你不需要(真正需要它们的人会清楚的知道需要它们，而且无须解释)</p>
</blockquote>
<p>元类主要的用途是创建一个API。一个典型的例子就是Django的ORM，它允许你这样定义:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></div><div class="line">  name = models.CharField(max_length=<span class="number">30</span>)</div><div class="line">  age = models.IntegerField()</div></pre></td></tr></table></figure>
<p>但是如果你这样做:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">guy = Person(name=<span class="string">'bob'</span>, age=<span class="string">'35'</span>)</div><div class="line">print(guy.age)</div></pre></td></tr></table></figure>
<p>它并不会返回一个<code>IntegerField</code>对象，而是返回一个<code>int</code>。这是因为<code>models.Model</code>定义了<code>__metaclass__</code>，而该元类将会完成一些工作使得你刚刚定义拥有一些简单语句的<code>Person</code>变成复杂的钩子(hook)与数据库字段相连。Django通过引入一个简单的API和使用元类来使一些复杂的事情看起来简单，根据该API重建代码完成实际工作都在幕后进行。</p>
<h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>首先，你知道了类也是对象，而且可以生成实例。当然，类也是元类的实例。<br>Python中的万物都是对象，它们要么是类的实例，要么是元类的实例。<code>type</code>除外:</p>
<div class="tip"><br><code>type</code>是它自己的元类<br></div>

<p>其次，元类十分复杂。对一个简单类的修改你可能并不会想使用它，而是使用另外两种不同的方式:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Monkey_patch" target="_blank" rel="external">Monkey patching</a></li>
<li>类装饰器</li>
</ul>
<p>在99%你需要修改类的情况下，你都最好使用以上两种方法。<br>但99%的时间里，你都不需要修改类。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文根据对&lt;a href=&quot;http://stackoverflow.com&quot;&gt;StackOverflow&lt;/a&gt;上问题&lt;a href=&quot;http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python?answertab=votes#tab-top&quot;&gt;What is a metaclass in Python?&lt;/a&gt;的高票回答翻译结合实际例子，试图解释&lt;strong&gt;元类&lt;/strong&gt;的意义与用途。&lt;/p&gt;
&lt;h4 id=&quot;类也是对象&quot;&gt;&lt;a href=&quot;#类也是对象&quot; class=&quot;headerlink&quot; title=&quot;类也是对象&quot;&gt;&lt;/a&gt;类也是对象&lt;/h4&gt;&lt;p&gt;在想了解什么是&lt;strong&gt;元类&lt;/strong&gt;之前，需要读者掌握Python中类的基本概念。而恰巧Python对类的定义有着不同于其他语言的解释。在大多数编程语言中，类仅仅只是指示如何生成实例对象的一段代码，这一点在Python中也如此:&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="类" scheme="http://youchen.me/tags/%E7%B1%BB/"/>
    
      <category term="OOP" scheme="http://youchen.me/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>Python属性访问</title>
    <link href="http://youchen.me/2017/02/04/Python-property%20access/"/>
    <id>http://youchen.me/2017/02/04/Python-property access/</id>
    <published>2017-02-04T08:26:07.000Z</published>
    <updated>2017-02-06T08:48:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇中讲到了描述器方法<code>__get__</code>、<code>__set__</code>和<code>__delete__</code>，同时也提到，一个对象具有任意一个方法的就会成为描述器，从而在被当作对象属性的时候会重写默认的查找行为。在本篇中，通过对<a href="https://docs.python.org/2/howto/descriptor.html" target="_blank" rel="external">Descriptor HowTo Guide</a>的节选翻译以及笔者的自身的一些实践，对描述器做一个更详细的说明。</p>
<p>如果一个对象同时定义了<code>__get__</code>和<code>__set__</code>方法，则称它为资料描述器(<em>data descriptor</em>)，而仅定义了<code>__get__</code>方法的描述器称为非资料描述器(<em>non-data descriptor</em>，常用于方法，其他用途也是可以的)。</p>
<p>资料描述器和非资料描述器的区别在于：<strong>相对于实例的字典的优先级</strong>。如果实例字典中有和描述器重名的属性，如果描述器是资料描述器，优先使用资料描述器，如果是非资料描述器，优先使用字典中的属性。这就是为何实例a的方法和属性重名时，比如都叫做<code>foo</code>，Python会在访问<code>a.foo</code>时优先访问实例字典中的属性，因为实例的方法是个非资料描述器。<br><a id="more"></a><br>要想制作一个只读的资料描述器需要同时定义<code>__set__</code>和<code>__get__</code>方法，由于是只读，所以只需要在<code>__set__</code>方法中抛出一个<code>AttributeError</code>异常即可。</p>
<p>在一般情况下，描述器在属性访问时被自动调用。举例来说，<code>obj.d</code>会在<code>obj</code>的字典里面查找<code>d</code>，如果<code>d</code>定义了<code>__get__</code>方法，那么<code>d.__get__(obj)</code>会依据下面的优先规则被调用。</p>
<p>调用的细节取决于<code>obj</code>是一个类还是一个实例，对于对象来讲，方法<code>object.__getattribute__</code>将属性访问<code>a.x</code>变成了<code>type(a).__dict__[&#39;x&#39;].__get__(a, type(a))</code>，具体实现依据这样的优先顺序:<strong>资料描述器</strong>优先于<strong>实例变量</strong>，<strong>实例变量</strong>优先于<strong>非资料描述器</strong>，<code>__getattr__()</code>方法具有最低优先级；对于类来讲，方法<code>type.__getattribute__</code>将<code>A.x</code>变成<code>A.__dict__[&#39;x&#39;].__get__(None, A)</code>。如以下代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">V</span>:</span></div><div class="line">    v = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>)</span>:</span></div><div class="line">        self.v = val</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, inst, owner)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.v</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, inst, value)</span>:</span></div><div class="line">        self.v = value</div><div class="line">        </div><div class="line">        </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line">    k1 = V(<span class="number">1</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">k</span><span class="params">(self)</span>:</span>  <span class="comment"># non-data descriptor</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">a = A()</div><div class="line">print(a.k)  <span class="comment"># &lt;bound method...&gt; *op1*</span></div><div class="line">a.k = <span class="number">6</span>  <span class="comment"># replace non-data descriptor with instance dict  *op2*</span></div><div class="line">print(a.k)  <span class="comment"># 6  *op3*</span></div><div class="line"></div><div class="line">print(a.k1)  <span class="comment"># 1</span></div><div class="line">a.__dict__[<span class="string">'k1'</span>] = V(<span class="number">2</span>)  <span class="comment"># *op4*</span></div><div class="line">print(a.k1)  <span class="comment"># 1</span></div></pre></td></tr></table></figure></p>
<p>这段代码展示了资料描述器、实例变量、非资料描述器在属性访问中的不同优先级，分析如下:类<code>A</code>中定义了方法<code>k</code>(非资料描述器)，第一次操作对<code>a.k</code>的访问将转变为<code>type(a).__dict__[&#39;k&#39;].__get__(a, type(a))</code>，<code>type(a)</code>即类<code>A</code>，<code>A.__dict__</code>中存储了方法<code>A.k</code>，由于方法<code>A.k</code>为非资料描述器，因此调用其定义的<code>__get__()</code>方法。第二次操作<code>a.k = 6</code>本质上是在字典<code>a.__dict__</code>中添加了<code>k</code>这一变量(注意<code>a.__dict__</code>和<code>A._dict__</code>的区别)，即新增了实例变量。第三次操作对<code>a.k</code>的访问由于<strong>实例变量</strong>优先级高于<strong>非资料描述器</strong>，因此将获得之前的赋值6而不是方法。在第四次操作前后分别访问了<code>a.k1</code>属性，由于<code>k1</code>是资料描述器，因此即使在<code>a.__dict__</code>中新增了实例变量<code>k1</code>，对<code>a.k1</code>仍然是访问了资料描述器而不是实例变量，与前述的优先级保持一致。</p>
<p><code>__getattr__</code>与<code>__getattribute__</code>区别:前者只会在待访问的属性缺失时触发，而后者则会在每次访问属性时触发。</p>
<p><strong>特别注意:</strong>如果要在<code>__getattribute__</code>和<code>__setattr__</code>方法中访问实例属性，那么应该直接通过<code>super()</code>来做，以避免无限递归。如以下代码就会抛出异常:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrokenAttribute</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></div><div class="line">        self._data = data</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, name)</span>:</span></div><div class="line">        print(<span class="string">'Called __getattribute__(&#123;0&#125;)'</span>.format(name))</div><div class="line">        <span class="keyword">return</span> self._data[name]</div><div class="line"></div><div class="line"></div><div class="line">data = BrokenAttribute(&#123;<span class="string">'foo'</span>: <span class="number">3</span>&#125;)</div><div class="line">print(data.foo)</div><div class="line">&gt;&gt;&gt;</div><div class="line">RecursionError: maximum recursion depth exceeded <span class="keyword">while</span> calling a Python object</div></pre></td></tr></table></figure></p>
<h4 id="属性Property"><a href="#属性Property" class="headerlink" title="属性Property"></a>属性Property</h4><p>调用<code>property()</code>是建立资料描述器的一种简洁方式，从而可以在访问属性时触发相应的方法调用。<code>property</code>函数原型:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute</div></pre></td></tr></table></figure></p>
<p>下面展示了一个典型应用，定义一个托管属性(managed attribute)x:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getx</span><span class="params">(self)</span>:</span> <span class="keyword">return</span> self.__x</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setx</span><span class="params">(self, value)</span>:</span> self.__x = value</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delx</span><span class="params">(self)</span>:</span> <span class="keyword">del</span> self.__x</div><div class="line">    x = property(getx, setx, delx, <span class="string">"I'm the 'x' property."</span>)</div></pre></td></tr></table></figure>
<p>其等价Python实现为:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Property</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"Emulate PyProperty_Type() in Objects/descrobject.c"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fget=None, fset=None, fdel=None, doc=None)</span>:</span></div><div class="line">        self.fget = fget</div><div class="line">        self.fset = fset</div><div class="line">        self.fdel = fdel</div><div class="line">        self.__doc__ = doc</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype=None)</span>:</span></div><div class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> self</div><div class="line">        <span class="keyword">if</span> self.fget <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">raise</span> AttributeError, <span class="string">"unreadable attribute"</span></div><div class="line">        <span class="keyword">return</span> self.fget(obj)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, obj, value)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.fset <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">raise</span> AttributeError, <span class="string">"can't set attribute"</span></div><div class="line">        self.fset(obj, value)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, obj)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.fdel <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">raise</span> AttributeError, <span class="string">"can't delete attribute"</span></div><div class="line">        self.fdel(obj)</div></pre></td></tr></table></figure>
<h4 id="静态方法与类方法"><a href="#静态方法与类方法" class="headerlink" title="静态方法与类方法"></a>静态方法与类方法</h4><p>非资料描述器为将函数绑定成方法这种常见模式提供了一个简单的实现机制。<br>简而言之，函数有个方法<code>__get__()</code>，当函数被当作属性访问时，它会把函数变成一个实例方法。非资料描述器把实例调用<code>obj.f(*args)</code>转换成<code>f(obj, *args)</code>(绑定方法)，把类调用<code>klass.f(*args)</code>转换成<code>f(klass, *args)</code>(非绑定方法)。<br>静态方法原样返回函数，调用 c.f 或者 C.f 分别等价于<code>object.__getattribute__(c, &quot;f&quot;)</code>或者<code>object.__getattribute__(C, &quot;f&quot;)</code>。也就是说，无论是从一个对象还是一个类中，这个函数都会同样地访问到。<br>利用非资料描述器，<code>staticmethod()</code>的等价实现看起来像这样:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">staticmethod</span><span class="params">(object)</span>:</span></div><div class="line"> <span class="string">"Emulate PyStaticMethod_Type() in Objects/funcobject.c"</span></div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, f)</span>:</span></div><div class="line">      self.f = f</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, objtype=None)</span>:</span></div><div class="line">      <span class="keyword">return</span> self.f</div></pre></td></tr></table></figure>
<p>同样的，<code>classmethod()</code>等价实现看起来像这样:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassMethod</span><span class="params">(object)</span>:</span></div><div class="line">     <span class="string">"Emulate PyClassMethod_Type() in Objects/funcobject.c"</span></div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, f)</span>:</span></div><div class="line">          self.f = f</div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, klass=None)</span>:</span></div><div class="line">          <span class="keyword">if</span> klass <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">               klass = type(obj)</div><div class="line">          <span class="function"><span class="keyword">def</span> <span class="title">newfunc</span><span class="params">(*args)</span>:</span></div><div class="line">               <span class="keyword">return</span> self.f(klass, *args)</div><div class="line">          <span class="keyword">return</span> newfunc</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇中讲到了描述器方法&lt;code&gt;__get__&lt;/code&gt;、&lt;code&gt;__set__&lt;/code&gt;和&lt;code&gt;__delete__&lt;/code&gt;，同时也提到，一个对象具有任意一个方法的就会成为描述器，从而在被当作对象属性的时候会重写默认的查找行为。在本篇中，通过对&lt;a href=&quot;https://docs.python.org/2/howto/descriptor.html&quot;&gt;Descriptor HowTo Guide&lt;/a&gt;的节选翻译以及笔者的自身的一些实践，对描述器做一个更详细的说明。&lt;/p&gt;
&lt;p&gt;如果一个对象同时定义了&lt;code&gt;__get__&lt;/code&gt;和&lt;code&gt;__set__&lt;/code&gt;方法，则称它为资料描述器(&lt;em&gt;data descriptor&lt;/em&gt;)，而仅定义了&lt;code&gt;__get__&lt;/code&gt;方法的描述器称为非资料描述器(&lt;em&gt;non-data descriptor&lt;/em&gt;，常用于方法，其他用途也是可以的)。&lt;/p&gt;
&lt;p&gt;资料描述器和非资料描述器的区别在于：&lt;strong&gt;相对于实例的字典的优先级&lt;/strong&gt;。如果实例字典中有和描述器重名的属性，如果描述器是资料描述器，优先使用资料描述器，如果是非资料描述器，优先使用字典中的属性。这就是为何实例a的方法和属性重名时，比如都叫做&lt;code&gt;foo&lt;/code&gt;，Python会在访问&lt;code&gt;a.foo&lt;/code&gt;时优先访问实例字典中的属性，因为实例的方法是个非资料描述器。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="描述器" scheme="http://youchen.me/tags/%E6%8F%8F%E8%BF%B0%E5%99%A8/"/>
    
      <category term="属性" scheme="http://youchen.me/tags/%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python属性与描述器</title>
    <link href="http://youchen.me/2017/01/24/Python-property%20and%20descriptor/"/>
    <id>http://youchen.me/2017/01/24/Python-property and descriptor/</id>
    <published>2017-01-24T09:03:27.000Z</published>
    <updated>2017-02-06T08:47:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="getter与setter"><a href="#getter与setter" class="headerlink" title="getter与setter"></a><code>getter</code>与<code>setter</code></h4><p>如果开发者之前有其他语言的开发经验，在转入Python之后，可能会在类中明确地实现类似<code>getter</code>和<code>setter</code>方法，如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OldResistor</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ohms)</span>:</span></div><div class="line">        self._ohms = ohms</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_ohms</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._homs</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_ohms</span><span class="params">(self, ohms)</span>:</span></div><div class="line">        self._ohms = ohms</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>然而这种方法却并不像Python的编程风格，特别是对于自增的代码来说更是如此:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">r = OldResistor(<span class="number">1e3</span>)</div><div class="line">r.set_ohms(r.get_ohms()+<span class="number">1e3</span>)</div></pre></td></tr></table></figure></p>
<p>对于Python语言来说，基本上不需要手工实现<code>getter</code>和<code>setter</code>方法，而是该先从简单的<code>public</code>属性写起:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewResistor</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ohms)</span>:</span></div><div class="line">        self.ohms = ohms</div><div class="line">        </div><div class="line">r = NewResistor(<span class="number">1e3</span>)</div><div class="line">r.ohms += <span class="number">1e3</span></div></pre></td></tr></table></figure></p>
<p>但是开发者可能需要在对某个属性操作的时候实现特殊行为，这时候可以改用<code>@property</code>修饰器和<code>setter</code>方法来做:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropResistor</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ohms)</span>:</span></div><div class="line">        self._ohms = ohms</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ohms</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># Do what you want when access ohms</span></div><div class="line">        <span class="keyword">return</span> self._ohms</div><div class="line">    </div><div class="line"><span class="meta">    @ohms.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ohms</span><span class="params">(self, ohms)</span>:</span></div><div class="line">        <span class="comment"># Do what you want when change ohms</span></div><div class="line">        self._ohms = ohms</div></pre></td></tr></table></figure></p>
<p>通过指定<code>setter</code>方法，我们可以在方法里面做类型验证以及数值验证。</p>
<p>但是,考虑下面一种情况:</p>
<blockquote>
<p>假设有一个考试成绩(<code>Exam</code>)类，由多个科目的小成绩组成，每一科需要单独计分，在进行分数录入的时候，要求对成绩进行验证，保证其在0~100之间</p>
</blockquote>
<p>如果使用属性<code>@property</code>实现，每添加一项科目，就要重复编写一次<code>@property</code>方法，而且还需要重复相关验证逻辑，如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">       self._chinese_grade = <span class="number">0</span></div><div class="line">       self._math_grade = <span class="number">0</span></div><div class="line">       </div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_check_grade</span><span class="params">(value)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>):</div><div class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'Grade must be between 0 and 100'</span>)</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">chinese_grade</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._chinese_grade</div><div class="line">    </div><div class="line"><span class="meta">    @chinese_grade.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">chinese_grade</span><span class="params">(self, grade)</span>:</span></div><div class="line">        self._check_grade(grade)</div><div class="line">        self._chinese_grade = grade</div><div class="line">        </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">math_grade</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._math_grade</div><div class="line">        </div><div class="line"><span class="meta">    @math_grade.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">math_grade</span><span class="params">(self, grade)</span>:</span></div><div class="line">        self._check_grade(grade)</div><div class="line">        self._math_grade = grade</div></pre></td></tr></table></figure></p>
<p>实际上，有另外一种更好的方式实现上述功能，那就是采用Python的描述器(<em>descriptor</em>)来做。</p>
<h4 id="描述器"><a href="#描述器" class="headerlink" title="描述器"></a>描述器</h4><blockquote>
<p>一般来说，一个描述器是一个有“绑定行为”的对象属性(object attribute)，它的访问控制被描述器协议方法重写。这些方法是 <code>__get__()</code>, <code>__set__()</code>, 和 <code>__delete__()</code> 。有这些方法的对象叫做描述器。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">descr.__get__(self, obj, type=None) --&gt; value</div><div class="line">descr.__set__(self, obj, value) --&gt; None</div><div class="line">descr.__delete__(self, obj) --&gt; None</div></pre></td></tr></table></figure>
<p>以上是所有描述器方法。一个对象具有其中任一个方法就会成为描述器，从而在被当作对象属性时重写默认的查找行为。来看一个例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._value = <span class="number">0</span></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, inst, owner)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._value</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, inst, value)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>):</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Grade must be between 0 and 100'</span>)</div><div class="line">        self._value = value</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam</span>:</span></div><div class="line">    math_grade = Grade()</div></pre></td></tr></table></figure></p>
<p>为属性赋值时:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">exam = Exam()</div><div class="line">exam.math_grade = <span class="number">50</span></div></pre></td></tr></table></figure></p>
<p>Python会对赋值操作进行转译，<code>exam.math_grade = 50</code>将会被转译成:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Exam.__dict__[<span class="string">'math_grade'</span>].__set__(exam, <span class="number">40</span>)</div></pre></td></tr></table></figure></p>
<p>同样，访问操作也会被转译，<code>print(exam.math_grade)</code>将会被转译成:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(Exam.__dict__[<span class="string">'math_grade'</span>].__get__(exam, Exam))</div></pre></td></tr></table></figure></p>
<p>但是，上面的代码存在一个问题，由于所有类<code>Exam</code>的实例都会共享同一份<code>math_grade</code>实例，即程序定义类<code>Exam</code>的时候，就会把类<code>Grade</code>的<code>math_grade</code>实例构建好，以后再创建类<code>Exam</code>的实例时，就不再构建Grade了，因此我们需要把每个<code>Exam</code>实例所对应的值记录到<code>Grade</code>中，因此可以采取字典保存:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._values = &#123;&#125;</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, inst, owner)</span>:</span></div><div class="line">        <span class="keyword">if</span> inst <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> self</div><div class="line">        <span class="keyword">return</span> self._values.get(inst, <span class="number">0</span>)</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, inst, value)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>):</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Grade must be between 0 and 100'</span>)</div><div class="line">        self._values[inst] = value</div></pre></td></tr></table></figure></p>
<p>这种方式实现简单，而且能够正常运作，但它仍然有一个问题，就是内存泄漏，在程序生命周期类，对于传给<code>__set__</code>方法的每个<code>Exam</code>实例来说，<code>_values</code>字典都会保存一份指向该实例的引用，这就导致该实例的引用计数无法降为0，从而使垃圾收集器无法将其回收，通过使用Python内置的<code>weakref</code>模块即可解决此问题。该模块提供了名为<code>WeakKeyDictionary</code>的特殊字典，该字典的引用为弱引用，系统能够正确的完成回收:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._values = WeakKeyDictionary()</div><div class="line">    <span class="comment"># ...</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;getter与setter&quot;&gt;&lt;a href=&quot;#getter与setter&quot; class=&quot;headerlink&quot; title=&quot;getter与setter&quot;&gt;&lt;/a&gt;&lt;code&gt;getter&lt;/code&gt;与&lt;code&gt;setter&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;如果开发者之前有其他语言的开发经验，在转入Python之后，可能会在类中明确地实现类似&lt;code&gt;getter&lt;/code&gt;和&lt;code&gt;setter&lt;/code&gt;方法，如:&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;OldResistor&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, ohms)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self._ohms = ohms&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get_ohms&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self._homs&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;set_ohms&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, ohms)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self._ohms = ohms&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="描述器" scheme="http://youchen.me/tags/%E6%8F%8F%E8%BF%B0%E5%99%A8/"/>
    
      <category term="属性" scheme="http://youchen.me/tags/%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python中的MRO</title>
    <link href="http://youchen.me/2017/01/22/Python-Method%20Resolution%20Order/"/>
    <id>http://youchen.me/2017/01/22/Python-Method Resolution Order/</id>
    <published>2017-01-22T07:23:00.000Z</published>
    <updated>2017-02-06T08:49:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天我想对Python中的方法解析顺序使用的C3算法进行一个梳理，文章内容主要基于对<a href="https://www.python.org/download/releases/2.3/mro/" target="_blank" rel="external">The Python 2.3 Method Resolution Order</a>一文的节选翻译。</p>
<p>首先，需要明白的是C3算法工作于Python 2.2引入的新式类(<em>new style classes</em>)，经典类(<em>classic classes</em>)中方法的解析仍然保持他们原有的顺序，即<code>深度优先，从左至右</code>，在此不进行深一步的讨论。</p>
<a id="more"></a>
<p>先来看一个例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>O = object</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">X</span><span class="params">(O)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Y</span><span class="params">(O)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(X, Y)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Y, X)</span>:</span> <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>继承顺序如图:<br><img src="/2017/01/22/Python-Method Resolution Order/python_inheritance.png" alt="Inheritance"></p>
<p>在这种情况下，通过A和B派生出一个新类C是有问题的，因为在A的继承中X先于Y,而在B中Y先于X，因此C中方法解析顺序会存在歧义。Python 2.3在这种情况下通过抛出异常<code>TypeError: MRO conflict among bases Y, X</code>来避免程序员创建有歧义的类。</p>
<h4 id="C3算法"><a href="#C3算法" class="headerlink" title="C3算法"></a>C3算法</h4><p>首先介绍一些简易记号来方便接下来的描述。</p>
<blockquote>
<p>$$C_1C_2…C_n$$</p>
</blockquote>
<p>表示一个类的列表<code>[C1, C2, ..., Cn]</code>。</p>
<p>列表的<code>head</code>为其第一个元素, <code>tail</code>为其余下元素:</p>
<blockquote>
<p>$$\begin{align}head &amp;= C_1\\tail &amp;= C_2…C_n\end{align}$$</p>
</blockquote>
<p>使用</p>
<blockquote>
<p>$$C+(C_1C_2…C_n) = CC_1C_2…C_n$$</p>
</blockquote>
<p>来表示<code>[C]+[C1, C2, ..., Cn]</code>。</p>
<p>线性化(<em>linearization</em>)定义:</p>
<blockquote>
<p>类C的线性化是指类C加上其父类的线性化以及其父类列表本身得到的和(列表)。</p>
</blockquote>
<p>用符号记号来描述:</p>
<blockquote>
<p>$$L[C(B_1…B_n)] = C + merge(L[B_1]…L[B_n], B_1…B_n)$$</p>
</blockquote>
<p>特别的，如果C是<code>object</code>类，即不存在父类，其线性化结果为:</p>
<blockquote>
<p>$$L[object] = object$$</p>
</blockquote>
<p>然而，要计算合并顺序需要遵循以下规则:</p>
<blockquote>
<p>取第一个列表的<code>head</code>，如$L[B_1][0]$；如果该<code>head</code>不在其余任一列表的尾部，将其加入类C的线性化结果列表中并将其从所有待合并列表中删除，否则从下一个列表中取出<code>head</code>并按上述规则处理。重复上述操作指导所有类都已经被删除或者无法再找到符合要求的<code>head</code>。在后者情况下，不可能完成merge操作，Python 2.3将会拒绝创建类C并抛出异常。</p>
</blockquote>
<p>下面举例说明，考虑如下继承:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>O = object</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">F</span><span class="params">(O)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(O)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(O)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(D, F)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(D, E)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(B, C)</span>:</span> <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<p>继承顺序如图:<br><img src="/2017/01/22/Python-Method Resolution Order/python_inheritance2.png" alt="Inheritance2"></p>
<p>B的线性化计算公式可以表示如下:</p>
<blockquote>
<p>$$L[B] = B + merge(DO, EO, DE)$$</p>
</blockquote>
<p>根据前述规则，我们首先取D作为<code>head</code>，待合并列表变成了$merge(O, EO, E)$，由于O不符合条件，我们跳过第一个列表在第二个列表中选择符合条件的E作为<code>head</code>，待合并列表变成了$merge(O, O)$，最后我们选择了O,因此:</p>
<blockquote>
<p>$$L[B] = B D E O$$</p>
</blockquote>
<p>同理可以得到C的线性化结果:</p>
<blockquote>
<p>$$\begin{align}L[C] &amp;= C + merge(DO, FO, DF)\\&amp;=C+D+merge(O, FO, F)\\&amp;=C+D+F+merge(O, O)\\&amp;=C\;D\;F\;O\end{align}$$</p>
</blockquote>
<p>最后来计算A的线性化结果:</p>
<blockquote>
<p>$$\begin{align}L[A] &amp;= A + merge(BDEO, CDFO, BC)\\&amp;=A+B+merge(DEO, CDFO, C)\\&amp;=A+B+C+merge(DEO, DFO)\\&amp;=A+B+C+D+merge(EO, FO)\\&amp;=A+B+C+D+E+merge(O, FO)\\&amp;=A+B+C+D+E+F+merge(O, O)\\&amp;=A\;B\;C\;D\;E\;F\;O\end{align}$$</p>
</blockquote>
<p>在Python 2.2以后，可以直接通过调用<code>.mro()</code>方法获得MRO:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; A.mro()</div><div class="line">[&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;,</div><div class="line">&lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.F'&gt;,</div><div class="line">&lt;type 'object'&gt;]</div></pre></td></tr></table></figure></p>
<p>最后，让我们回到最初的那个例子，其所有类的线性化结果计算如下:</p>
<blockquote>
<p>$$\begin{align}&amp;L[O] = O\\&amp;L[X] = X\;O\\&amp;L[Y] = Y\;O\\&amp;L[A] = A\;X\;Y\;O\\&amp;L[B] = B\;Y\;X\;O\end{align}$$</p>
</blockquote>
<p>然而，对于继承自类A和类B的类C来说是无法线性化的:</p>
<blockquote>
<p>$$\begin{align}L[C] &amp;= C + merge(AXYO, BYXO, AB)\\&amp;=C+A+merge(XYO, BYXO, B)\\&amp;=C+A+B+merge(XYO, YXO)\end{align}$$</p>
</blockquote>
<p>在此刻，我们无法完成对XYO和YXO的合并，因为X是YXO的尾，同时Y是XYO的尾，因此C3算法停止，Python 2.3将会抛出异常并拒绝创建类C。</p>
<h4 id="不好的MRO"><a href="#不好的MRO" class="headerlink" title="不好的MRO"></a>不好的MRO</h4><p>当一个MRO破坏了局部优先顺序和单调性等基础性质时称其为不好的MRO。<br>考虑如下例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>F=type(<span class="string">'Food'</span>,(),&#123;<span class="string">'remember2buy'</span>:<span class="string">'spam'</span>&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>E=type(<span class="string">'Eggs'</span>,(F,),&#123;<span class="string">'remember2buy'</span>:<span class="string">'eggs'</span>&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G=type(<span class="string">'GoodFood'</span>,(F,E),&#123;&#125;) <span class="comment"># under Python 2.3 this is an error!</span></div></pre></td></tr></table></figure></p>
<p>创建了F、E、G三个类，其中类E可表示为<code>class E(F)</code>，类G可表示为<code>class G(F, E)</code>，我们期望类G的<code>remember2buy</code>属性是继承自F而不是E的，然而在Python 2.2中我们会得到<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.remember2buy</div><div class="line"><span class="string">'eggs'</span></div></pre></td></tr></table></figure></p>
<p>这破坏了局部优先顺序,因为对于类G的继承顺序<code>(F, E)</code>,其局部优先顺序并没有在Python 2.2线性化结果中得到保留:</p>
<blockquote>
<p>$$L[G, P22] = G\;E\;F\;object$$</p>
</blockquote>
<p>有人可能会争辩说Python 2.2线性化结果中类F在类E之后的原因是因为类F没有类E更具体，因为类F是类E的父类；尽管如此打破了局部优先顺序会使得代码不直观且容易出错，一个有力的佐证就是其与经典类的不同:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">F</span>:</span> remember2buy=<span class="string">'spam'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(F)</span>:</span> remember2buy=<span class="string">'eggs'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">G</span><span class="params">(F,E)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.remember2buy</div><div class="line"><span class="string">'spam'</span></div></pre></td></tr></table></figure></p>
<p>回想之前谈到的，经典类的继承顺序为<code>深度优先，从左至右</code>，因此类G的MRO为GFEF，在这种情况下局部优先顺序得到了保留。<br>简而言之，像之前那种继承方式应该避免，Python 2.3开始通过抛出异常来避免了这种歧义，有力地阻止了程序员来创建有歧义的类继承(通过C3算法失败来完成)。</p>
<p>还有一点相关的，Python 2.3的算法足够智能来发现一些显而易见的错误，比如重复继承同一个父类:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class A(object): pass</div><div class="line">&gt;&gt;&gt; class C(A,A): pass # error</div><div class="line">Traceback (most recent call last):</div><div class="line">  File "&lt;stdin&gt;", line 1, in ?</div><div class="line">TypeError: duplicate base class A</div></pre></td></tr></table></figure></p>
<p>而这种情况在Python 2.2中(无论是经典类还是新式类)，都不会抛出异常。</p>
<p>最后，有一点十分重要的需要记住:</p>
<ul>
<li>MRO在决定方法解析顺序同时也决定了属性的解析顺序</li>
</ul>
<p>讨论完了局部优先顺序，下面再来看单调性问题。要证明经典类的MRO是非单调的很容易:<br><img src="/2017/01/22/Python-Method Resolution Order/python_inheritance3.png" alt="Inheritance3"></p>
<blockquote>
<p>$$\begin{align}&amp;L[B, P22] = B\;C\quad\#\;B在C之前：类B的方法优先\\&amp;L[D, P22] = D\;A\;C\;B\;C\quad\#\;B在C之后：类C的方法优先\end{align}$$</p>
</blockquote>
<p>另一方面，Python 2.2和Python 2.3的MRO中都不存在问题，都给出了:</p>
<blockquote>
<p>$$L[D] = D\;A\;B\;C$$</p>
</blockquote>
<p>Guido在他的<a href="https://www.python.org/download/releases/2.2.3/descrintro/#mro" target="_blank" rel="external">一篇文章</a>指出了经典类的MRO在实际使用中其实并不差，因为它可以使经典类避免钻石型结构。但由于所有新式类都继承自<code>object</code>，因此钻石型结果无法避免而且在所有的多继承图中前后矛盾都会出现。<br>Python 2.2的MRO使得破坏单调性十分困难，但并非不可能。接下来这个由<em>Samuele Pedroni</em>提供的例子，表明了Python 2.2新式类的MRO是非单调的:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(object)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">K1</span><span class="params">(A,B,C)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">K2</span><span class="params">(D,B,E)</span>:</span> <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">K3</span><span class="params">(D,A)</span>:</span>   <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Z</span><span class="params">(K1,K2,K3)</span>:</span> <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
<p><img src="/2017/01/22/Python-Method Resolution Order/python_inheritance4.png" alt="Inheritance4"></p>
<p>使用C3算法的线性化结果如下:</p>
<blockquote>
<p>$$\begin{align}&amp;L[A] = A\;O\\&amp;L[B] = B\;O\\&amp;L[C] = C\;O\\&amp;L[D] = D\;O\\&amp;L[E] = E\;O\\&amp;L[K1] = K1\;A\;B\;C\;O\\&amp;L[K2] = K2\;D\;B\;E\;O\\&amp;L[K3] = K3\;D\;A\;O\\&amp;L[Z] = Z\;K1\;K2\;K3\;D\;A\;B\;C\;E\;O\end{align}$$</p>
</blockquote>
<p>Python 2.2对于A、B、C、D、E、K1、K2、K3的线性化给出了相同结果，但是对于Z则不同:</p>
<blockquote>
<p>$$L[Z, P22] = Z\;K1\;K3\;A\;K2\;D\;B\;C\;E\;O$$ </p>
</blockquote>
<p>显然这个线性化结果是错的，因为类先于D出现了，而K3的线性化结果中D先于A出现。换句话说，在K3中，从类A继承的方法被从类D继承的方法覆盖了，但是在Z中，作为一个K3的子类，却使用了从类A继承的方法去覆盖从类D继承的方法！这违反了单调性。此外，Python 2.2中类Z的线性化结果与局部优先顺序也不一致，类Z的局部优先列表为<code>[K1, K2, K3]</code>(K2在K3之前)，而在线性化结果中K3在K2之前，这些问题解释了为什么2.2中的规则被弃用转投C3规则。</p>
<h4 id="super函数"><a href="#super函数" class="headerlink" title="super函数"></a>super函数</h4><p>最后再来看Python 2.2引入的<code>super</code>函数，它主要用于初始化父类，避免了直接调用父类的<code>__init__</code>函数，减少耦合性，来看以下代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        self.value = value</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimesFive</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super(TimesFive, self).__init__(value)</div><div class="line">        self.value *= <span class="number">5</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlusTwo</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super(PlusTwo, self).__init__(value)</div><div class="line">        self.value += <span class="number">2</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodWay</span><span class="params">(TimesFive, PlusTwo)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super(GoodWay, self).__init__(value)</div><div class="line"></div><div class="line">foo = GoodWay(<span class="number">5</span>)</div></pre></td></tr></table></figure></p>
<p>它的计算顺序为<code>5 * (5 + 2)</code>而不是<code>(5 * 5) + 2</code>，原因在于程序的运行顺序与类GoodWay的MRO保持了一致，通过查看<code>GoodWay.mro()</code>可以得到:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; GoodWay.mro()</div><div class="line">[&lt;class '__main__.GoodWay'&gt;, &lt;class '__main__.TimesFive'&gt;, &lt;class '__main__.PlusTwo'&gt;, &lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;]</div></pre></td></tr></table></figure></p>
<p>调用<code>GoodWay(5)</code>的时候，它会调用<code>TimesFive.__init__</code>，而<code>TimesFive.__init__</code>又会调用<code>PlusTwo.__init__</code>，而<code>PlusTwo.__init__</code>会调用<code>Base.__init__</code>，当到达了钻石体系的顶部之后，所有的初始化方法会按照与刚才那些<code>__init__</code>相反的顺序执行，因此<code>Base.__init__</code>将value设为5，<code>PlusTwo.__init__</code>在此基础上加2，value变为7，最后<code>TimesFive.__init__</code>将value乘以5，得到35。</p>
<h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h4><p>一看到<code>super</code>这个函数很多人第一想法就是父类，但其实<code>super</code>工作原理是这样的:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">super</span><span class="params">(cls, inst)</span>:</span></div><div class="line">    mro = inst.__class__.mro()</div><div class="line">    <span class="keyword">return</span> mro[mro.index(cls) + <span class="number">1</span>]</div></pre></td></tr></table></figure></p>
<p>根据实例inst获得其类的MRO列表，返回cls所在位置的下一个位置的类，其中<code>inst</code>永远是最开始那个实例。</p>
<p>Python 3提供了一种不带参数的<code>super</code>调用方式，例如:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Explicit</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super().__init__(value)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implicit</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super(__class__, self).__init__(value)</div><div class="line"></div><div class="line"><span class="keyword">assert</span> Explicit(<span class="number">10</span>).value == Implicit(<span class="number">10</span>).value</div></pre></td></tr></table></figure></p>
<p>由于Python 3程序可以在方法中通过<strong>class</strong>变量准确地引用当前类，所以上面的这种写法能够正常运作，而Python 2中则没有定义<strong>class</strong>，故而不能采用这种写法。可能有人试着用self.<strong>class</strong>做参数来调用<code>super</code>,但实际上这么做不行，因为Python 2是用<a href="http://stackoverflow.com/questions/18208683/when-calling-super-in-a-derived-class-can-i-pass-in-self-class" target="_blank" rel="external">特殊方式实现super</a>的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我想对Python中的方法解析顺序使用的C3算法进行一个梳理，文章内容主要基于对&lt;a href=&quot;https://www.python.org/download/releases/2.3/mro/&quot;&gt;The Python 2.3 Method Resolution Order&lt;/a&gt;一文的节选翻译。&lt;/p&gt;
&lt;p&gt;首先，需要明白的是C3算法工作于Python 2.2引入的新式类(&lt;em&gt;new style classes&lt;/em&gt;)，经典类(&lt;em&gt;classic classes&lt;/em&gt;)中方法的解析仍然保持他们原有的顺序，即&lt;code&gt;深度优先，从左至右&lt;/code&gt;，在此不进行深一步的讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="MRO" scheme="http://youchen.me/tags/MRO/"/>
    
      <category term="C3" scheme="http://youchen.me/tags/C3/"/>
    
  </entry>
  
  <entry>
    <title>multiprocessing中pool实现</title>
    <link href="http://youchen.me/2017/01/17/Python-multiprocessing%20pool/"/>
    <id>http://youchen.me/2017/01/17/Python-multiprocessing pool/</id>
    <published>2017-01-17T00:52:00.000Z</published>
    <updated>2017-01-17T02:10:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>终于有时间来整理整理之前自己的一些心得，今天想分享的是之前梳理的<code>Python</code>中<code>multiprocessing</code>模块的线程池与进程池实现。</p>
<a id="more"></a>
<p>multiprocessing.pool类包含taskqueue、inqueue、outqueue三个队列，其中：</p>
<ul>
<li>taskqueue采用<code>Queue.Queue</code>实现，通过apply、apply_async、map、map_async等函数向pool类提交任务。</li>
<li>inqueue、outqueue采用<code>SimpleQueue</code>实现，本质上是带锁的pipe</li>
<li>inqueue负责存放待完成任务，outqueue负责存放已完成任务</li>
</ul>
<p>multiprocessing.pool类包含worker_handler、task_handler、result_handler三个handler，均在threading.Thread上工作，均为<code>Daemon Thread</code>，其中：</p>
<ul>
<li><p>worker_handler负责回收已经完成任务的worker，同时根据回收数量使用process函数重新生成足够的worker，在生命周期中维护整个pool中worker的数量:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_maintain_pool</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""Clean up any exited workers and start replacements for them.</span></div><div class="line">    """</div><div class="line">    <span class="keyword">if</span> self._join_exited_workers():</div><div class="line">        self._repopulate_pool()</div><div class="line"></div><div class="line"><span class="meta">@staticmethod</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_handle_workers</span><span class="params">(pool)</span>:</span></div><div class="line">    thread = threading.current_thread()</div><div class="line"></div><div class="line">    <span class="comment"># Keep maintaining workers until the cache gets drained, unless the pool</span></div><div class="line">    <span class="comment"># is terminated.</span></div><div class="line">    <span class="keyword">while</span> thread._state == RUN <span class="keyword">or</span> (pool._cache <span class="keyword">and</span> thread._state != TERMINATE):</div><div class="line">        pool._maintain_pool()</div><div class="line">        time.sleep(<span class="number">0.1</span>)</div><div class="line">    <span class="comment"># send sentinel to stop workers</span></div><div class="line">    pool._taskqueue.put(<span class="keyword">None</span>)</div><div class="line">    util.debug(<span class="string">'worker handler exiting'</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>task_handler负责从taskqueue中按先后顺序阻塞获取待完成任务，更新pool的任务cache，并提交至inqueue中等待worker处理</p>
</li>
<li>result_handler负责从outqueue中按先后顺序阻塞获取已完成任务，更新pool的任务cache，如果存在回调函数则进行回调操作</li>
</ul>
<p>multiprocessing.pool类包含1个(未实现情况下)或多个(未提供数量，cpu_count()个)或指定数量的worker，其中：</p>
<ul>
<li>worker的维护由worker_handerler负责，在一个worker任务完成后由worker_handler负责回收并重新生成新的worker</li>
<li>worker包含对inqueue.get和outqueue.put的引用</li>
<li>worker从inqueue从获取待完成任务，并负责执行该任务，并将执行结果提交至outqueue中等待处理:<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(inqueue, outqueue, initializer=None, initargs=<span class="params">()</span>, maxtasks=None,</span></span></div><div class="line">           wrap_exception=False):</div><div class="line">    <span class="keyword">assert</span> maxtasks <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> (type(maxtasks) == int <span class="keyword">and</span> maxtasks &gt; <span class="number">0</span>)</div><div class="line">    put = outqueue.put</div><div class="line">    get = inqueue.get</div><div class="line">    <span class="keyword">if</span> hasattr(inqueue, <span class="string">'_writer'</span>):</div><div class="line">        inqueue._writer.close()</div><div class="line">        outqueue._reader.close()</div><div class="line"></div><div class="line">    <span class="keyword">if</span> initializer <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        initializer(*initargs)</div><div class="line"></div><div class="line">    completed = <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> maxtasks <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> (maxtasks <span class="keyword">and</span> completed &lt; maxtasks):</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            task = get()</div><div class="line">        <span class="keyword">except</span> (EOFError, OSError):</div><div class="line">            util.debug(<span class="string">'worker got EOFError or OSError -- exiting'</span>)</div><div class="line">            <span class="keyword">break</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> task <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            util.debug(<span class="string">'worker got sentinel -- exiting'</span>)</div><div class="line">            <span class="keyword">break</span></div><div class="line"></div><div class="line">        job, i, func, args, kwds = task</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            result = (<span class="keyword">True</span>, func(*args, **kwds))</div><div class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">            <span class="keyword">if</span> wrap_exception:</div><div class="line">                e = ExceptionWithTraceback(e, e.__traceback__)</div><div class="line">            result = (<span class="keyword">False</span>, e)</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            put((job, i, result))</div><div class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">            wrapped = MaybeEncodingError(e, result[<span class="number">1</span>])</div><div class="line">            util.debug(<span class="string">"Possible encoding error while sending result: %s"</span> % (</div><div class="line">                wrapped))</div><div class="line">            put((job, i, (<span class="keyword">False</span>, wrapped)))</div><div class="line">        completed += <span class="number">1</span></div><div class="line">    util.debug(<span class="string">'worker exiting after %d tasks'</span> % completed)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>PS：</p>
<blockquote>
<p>multiprocessing.ThreadPool是pool的thread-level级实现，以multiprocessing.dummy中的DummyProcess替换了pool的默认process，DummyProcess继承至threading.Thread，因此ThreadPool的实现是thread-level级的。</p>
</blockquote>
<p>实现用图来表示如下:</p>
<p><img src="/2017/01/17/Python-multiprocessing pool/python_multiprocessing_pool.png" alt="multiprocessing_pool"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于有时间来整理整理之前自己的一些心得，今天想分享的是之前梳理的&lt;code&gt;Python&lt;/code&gt;中&lt;code&gt;multiprocessing&lt;/code&gt;模块的线程池与进程池实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://youchen.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://youchen.me/tags/Python/"/>
    
      <category term="多进程" scheme="http://youchen.me/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="进程池" scheme="http://youchen.me/tags/%E8%BF%9B%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>欢迎</title>
    <link href="http://youchen.me/2017/01/05/welcome/"/>
    <id>http://youchen.me/2017/01/05/welcome/</id>
    <published>2017-01-05T03:58:00.000Z</published>
    <updated>2017-02-04T08:31:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到我的博客，这个博客使用了<a href="https://hexo.io" target="_blank" rel="external">Hexo</a>构建，托管在<a href="https://pages.github.com" target="_blank" rel="external">Github Pages</a>,主题使用了<a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank" rel="external">Apollo</a>。</p>
<p>因为整个博客是托管在Github上的静态页面，没有数据库的支持，因此使用了<a href="http://duoshuo.com" target="_blank" rel="external">多说</a>来为整个博客提供评论功能，同时我也通过JS给博客增加了搜索功能，通过点击右下角的搜索图标或者双击<code>Ctrl</code>键可以启动搜索，这样可以方便快速查找相关内容。</p>
<a id="more"></a>
<p>现在博客的功能还有限，在以后我会慢慢增加新的功能，同时也会不定期更新一些我学习过程中的心得，欢迎大家阅读！</p>
<p>谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎来到我的博客，这个博客使用了&lt;a href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;构建，托管在&lt;a href=&quot;https://pages.github.com&quot;&gt;Github Pages&lt;/a&gt;,主题使用了&lt;a href=&quot;https://github.com/pinggod/hexo-theme-apollo&quot;&gt;Apollo&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;因为整个博客是托管在Github上的静态页面，没有数据库的支持，因此使用了&lt;a href=&quot;http://duoshuo.com&quot;&gt;多说&lt;/a&gt;来为整个博客提供评论功能，同时我也通过JS给博客增加了搜索功能，通过点击右下角的搜索图标或者双击&lt;code&gt;Ctrl&lt;/code&gt;键可以启动搜索，这样可以方便快速查找相关内容。&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="http://youchen.me/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="欢迎" scheme="http://youchen.me/tags/%E6%AC%A2%E8%BF%8E/"/>
    
      <category term="第一篇" scheme="http://youchen.me/tags/%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    
      <category term="博客" scheme="http://youchen.me/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="新功能" scheme="http://youchen.me/tags/%E6%96%B0%E5%8A%9F%E8%83%BD/"/>
    
  </entry>
  
</feed>
