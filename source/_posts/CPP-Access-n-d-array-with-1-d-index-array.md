---
title: 使用一维索引数组访问高维数组元素
date: 2017-03-30 14:34:10
tags: [CPP,指针,数组]
categories: CPP
---

这是这两天看书偶然间突然间想到的一个问题，假设有一个高维数组，比如3维整型数组`int arr[10][10][10];`，用户每次输入对应维数个数(3)个参数，存入一个索引数组`int idx[3]`中，根据索引返回对应索引的元素值。在低维情况下，可以采取直接访问的方式，比如输入的索引值为`idx[0] = 1, idx[1] = 2, idx[2] = 3`，可以通过`arr[idx[0]][idx[1]][idx[2]]`访问，但是如果数组维度太高，这样的方式就不可行了，比如`arr[idx[0]][idx[1]]....[idx[n]]`。所以需要换种方式。

<!-- more -->

**指针**

我们知道，C/C++中数组的存放是采用连续内存单元的形式:

![c_1d_array](c_1d_array.png)

对一个长度为6的一维整型数组(`int a[6]`)，运行时将会分配一段连续的内存，我们可以通过`a[4]`来访问元素，其实这可以看做隐式的指针访问，即`*(a+4)`，该操作将会访问到第5个元素也就是`4`。

对`*(a+4)`的访问过程可以这么理解:

1. 得到数组a的基地址
2. 在基地址的基础上加上偏移量`4`
3. 获取该地址对应的整型值

下面来看二维的情况。

![c_2d_array](c_2d_array.png)

对一个维度为3\*3的二维整型数组(`int b[3][3]`)，运行时仍然会分配一段连续的内存，直接访问的方式和上面讲的一样，比如`b[1][2]`，同样，这可以看做`*(*(b+1)+2)`，该操作会访问到第二行第三列的元素也就是`5`，其中，`b+1`的操作对应于取第几行元素，`+2`的操作就对应于一维的偏移了，具体细节不再展开讨论。

因此对于一个高维数组，比如四维数组`int c[5][5][5][5]`，`c[0][1][2][3]`代表的意思即是取`c`数组中第一维维度为`0`、第二维维度为`1`、第三维维度为`2`、第四维维度为`3`的对应元素，有了这样的理解，再看`*(*(*(*(c+0)+1)+2)+3)`就清晰多了。

**问题**

那么对于一个高维数组(100维、1000维等等)，就没有办法用代码直接写`*(*(*(....*(d+k1)+k2)+...+kn)`了，所以需要换个思路。

既然内存单元存储的是实际值或者是地址，那么经过多次寻址，我们可以找到需要的实际值，那么怎么完成这个操作呢？

我们仍然使用四维数组为例，假设有:

```C
int arr[10][10][10][10] = {0};
arr[1][2][3][4] = 1;
```

同时，索引数组为:

```C
int idx[4] = {1, 2, 3, 4};
```

我们想要的结果是得到`1`，可以直接通过`arr[idx[0]][idx[1]][idx[2]][idx[3]]`访问，但之前也说过了，这样的代码无法适用于高维情况。

**`void *`(不那么好)**

最开始我想到的方式是使用`void *`指针，因为C中任意指针都可以赋值给`void *`指针，那么我们访问元素的思路可以这么理解:

1. 将数组`arr`的基地址赋值给`void *`指针
2. 根据每一维索引的偏移量以及`int`类型的大小计算`void *`指针的值
3. 将`void *`指针强制类型转换为`int *`指针并进行元素访问`*p`

需要注意的是第二步中，索引的偏移量代表的是`int`尺度的偏移，即对于`int a[2]`, `&a[0]`和`&a[1]`之间的偏移量，因此需要乘以`int`类型的大小。根据上面的描述，测试代码如下:

```C
#include <bits/stdc++.h>
using namespace std;

#define N 10

int main()
{
    int arr[N][N][N][N] = {0};
    int idx[4] = {1, 2, 3, 4};
    arr[1][2][3][4] = 1;
    cout<<"Expected: "<<arr[1][2][3][4]<<" at "<<&arr[1][2][3][4]<<endl;

    void *p = arr;
    for(int i = 0; i < 4; i++)
        p += idx[i] * int(pow(N, 3-i)) * sizeof(int);
    cout<<"Got with void *: ";
    cout<<*((int*)p)<<" at "<<p<<endl;

    return 0;
}
```

结果:

```
test.cpp: In function 'int main()':
test.cpp:21:53: warning: pointer of type 'void *' used in arithmetic [-Wpointer-arith]
         p += idx[i] * int(pow(10, 3-i)) * sizeof(int);
                                                     ^
Expected: 1 at 0x7fff5cb20f18
Got with void *: 1 at 0x7fff5cb20f18
```

程序正确地得到了我们想要的结果，但是编译器给出了警告，因为`void *`指针是未知类型指针，因此编译器并不知道相关计算，另外还有在计算偏移尺度的时候，使用了`pow`函数而且使用了强制类型转换将其转为`int`，这可能导致舍入误差。

**`int *`改进**

对于前述的方法，我们可以使用`int *`指针以及自己计算偏移尺度进行改进，通过将`arr`进行强制类型转换，赋值给整型指针`p`，在前面我们谈到数组的内存分配是连续的，因此我们只需要正确的计算出偏移量即可通过`p`指针得到所需要的值，此时因为使用的是整型指针`p`，因此不再需要乘以`sizeof(int)`，可以理解为`p+1`指向了下一个整型单元。

```C
#include <bits/stdc++.h>
using namespace std;

#define N 10

int main()
{
    int arr[N][N][N][N] = {0};
    int idx[4] = {1, 2, 3, 4};
    arr[1][2][3][4] = 1;
    cout<<"Expected: "<<arr[1][2][3][4]<<" at "<<&arr[1][2][3][4]<<endl;

    int *p = (int *)arr;
    int offset = 1e3;
    for(int i = 0; i < 4; i++)
    {
        p += idx[i] * offset;
        offset /= 10;
    }
    cout<<"Got with int *: ";
    cout<<*p<<" at "<<p<<endl;

    return 0;
}
```

结果:

```
Expected: 1 at 0x7fff51d37f08
Got with int *: 1 at 0x7fff51d37f08
```

**后话**

以上方法需要对指针以及指针的运算有一定的了解，当然，更多情况下，我们完全可以将高维数组展开成低维甚至一维数组，这样的访问将会很方便。或许处理这种问题还有其他更好的方式，有兴趣的读者可以自行研究。